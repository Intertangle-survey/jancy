----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_Alias.h
----------------------
[-] jnc_Alias_getTargetItem (jnc_Alias* alias);
[+] jnc_Alias_getTargetItem(jnc_Alias* alias);
[-] 	getTargetItem ()
[+] 	getTargetItem()
[-] 		return jnc_Alias_getTargetItem (this);
[+] 		return jnc_Alias_getTargetItem(this);
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_ArrayType.h
----------------------
[-] jnc_ArrayType_getElementType (jnc_ArrayType* type);
[+] jnc_ArrayType_getElementType(jnc_ArrayType* type);
[-] jnc_ArrayType_getElementCount (jnc_ArrayType* type);
[+] jnc_ArrayType_getElementCount(jnc_ArrayType* type);
[-] 	getElementType ()
[+] 	getElementType()
[-] 		return jnc_ArrayType_getElementType (this);
[+] 		return jnc_ArrayType_getElementType(this);
[-] 	getElementCount ()
[+] 	getElementCount()
[-] 		return jnc_ArrayType_getElementCount (this);
[+] 		return jnc_ArrayType_getElementCount(this);
[-] jnc_isAutoSizeArrayType (jnc_Type* type)
[+] jnc_isAutoSizeArrayType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Array &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Array &&
[-] 		(jnc_ModuleItem_getFlags ((jnc_ModuleItem*) type) & jnc_ArrayTypeFlag_AutoSize) != 0;
[+] 		(jnc_ModuleItem_getFlags((jnc_ModuleItem*)type) & jnc_ArrayTypeFlag_AutoSize) != 0;
[-] jnc_isCharArrayType (jnc_Type* type)
[+] jnc_isCharArrayType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Array &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Array &&
[-] 		jnc_Type_getTypeKind (jnc_ArrayType_getElementType ((jnc_ArrayType*) type)) == jnc_TypeKind_Char;
[+] 		jnc_Type_getTypeKind(jnc_ArrayType_getElementType((jnc_ArrayType*)type)) == jnc_TypeKind_Char;
[-] jnc_isCharArrayRefType (jnc_Type* type)
[+] jnc_isCharArrayRefType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_DataRef &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_DataRef &&
[-] 		jnc_isCharArrayType (jnc_DataPtrType_getTargetType ((jnc_DataPtrType*) type));
[+] 		jnc_isCharArrayType(jnc_DataPtrType_getTargetType((jnc_DataPtrType*)type));
[-] isAutoSizeArrayType (Type* type)
[+] isAutoSizeArrayType(Type* type)
[-] 	return jnc_isAutoSizeArrayType (type) != 0;
[+] 	return jnc_isAutoSizeArrayType(type) != 0;
[-] isCharArrayType (Type* type)
[+] isCharArrayType(Type* type)
[-] 	return jnc_isCharArrayType (type) != 0;
[+] 	return jnc_isCharArrayType(type) != 0;
[-] isCharArrayRefType (Type* type)
[+] isCharArrayRefType(Type* type)
[-] 	return jnc_isCharArrayRefType (type) != 0;
[+] 	return jnc_isCharArrayRefType(type) != 0;
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_AttributeBlock.h
----------------------
[-] jnc_AttributeBlock_getAttributeCount (jnc_AttributeBlock* block);
[+] jnc_AttributeBlock_getAttributeCount(jnc_AttributeBlock* block);
[-] jnc_AttributeBlock_getAttribute (
[+] jnc_AttributeBlock_getAttribute(
[-] jnc_AttributeBlock_findAttribute (
[+] jnc_AttributeBlock_findAttribute(
[-] 	getAttributeCount ()
[+] 	getAttributeCount()
[-] 		return jnc_AttributeBlock_getAttributeCount (this);
[+] 		return jnc_AttributeBlock_getAttributeCount(this);
[-] 	getAttribute (size_t index)
[+] 	getAttribute(size_t index)
[-] 		return jnc_AttributeBlock_getAttribute (this, index);
[+] 		return jnc_AttributeBlock_getAttribute(this, index);
[-] 	findAttribute (const char* name)
[+] 	findAttribute(const char* name)
[-] 		return jnc_AttributeBlock_findAttribute (this, name);
[+] 		return jnc_AttributeBlock_findAttribute(this, name);
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_BitFieldType.h
----------------------
[-] jnc_BitFieldType_getBaseType (jnc_BitFieldType* type);
[+] jnc_BitFieldType_getBaseType(jnc_BitFieldType* type);
[-] jnc_BitFieldType_getBitOffset (jnc_BitFieldType* type);
[+] jnc_BitFieldType_getBitOffset(jnc_BitFieldType* type);
[-] jnc_BitFieldType_getBitCount (jnc_BitFieldType* type);
[+] jnc_BitFieldType_getBitCount(jnc_BitFieldType* type);
[-] 	getBaseType ()
[+] 	getBaseType()
[-] 		return jnc_BitFieldType_getBaseType (this);
[+] 		return jnc_BitFieldType_getBaseType(this);
[-] 	getBitOffset ()
[+] 	getBitOffset()
[-] 		return jnc_BitFieldType_getBitOffset (this);
[+] 		return jnc_BitFieldType_getBitOffset(this);
[-] 	getBitCount ()
[+] 	getBitCount()
[-] 		return jnc_BitFieldType_getBitCount (this);
[+] 		return jnc_BitFieldType_getBitCount(this);
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_CallSite.h
----------------------
[-] 	JNC_ASSERT (runtime); \
[+] 	JNC_ASSERT(runtime); \
[-] 	jnc_Runtime_initializeCallSite (__jncRuntime, &__jncCallSite); \
[+] 	jnc_Runtime_initializeCallSite(__jncRuntime, &__jncCallSite); \
[-] 	__jncSjljPrevFrame = jnc_Runtime_setSjljFrame (__jncRuntime, &__jncSjljFrame); \
[+] 	__jncSjljPrevFrame = jnc_Runtime_setSjljFrame(__jncRuntime, &__jncSjljFrame); \
[-] 	__jncSjljBranch = setjmp (__jncSjljFrame.m_jmpBuf); \
[+] 	__jncSjljBranch = setjmp(__jncSjljFrame.m_jmpBuf); \
[-] 			jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame (__jncRuntime, __jncSjljPrevFrame); \
[+] 			jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame(__jncRuntime, __jncSjljPrevFrame); \
[-] 			JNC_ASSERT (prev == &__jncSjljFrame); \
[+] 			JNC_ASSERT(prev == &__jncSjljFrame); \
[-] 			jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame (__jncRuntime, __jncSjljPrevFrame); \
[+] 			jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame(__jncRuntime, __jncSjljPrevFrame); \
[-] 			JNC_ASSERT (prev == &__jncSjljFrame || prev == __jncSjljPrevFrame); \
[+] 			JNC_ASSERT(prev == &__jncSjljFrame || prev == __jncSjljPrevFrame); \
[-] 		jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame (__jncRuntime, __jncSjljPrevFrame); \
[+] 		jnc_SjljFrame* prev = jnc_Runtime_setSjljFrame(__jncRuntime, __jncSjljPrevFrame); \
[-] 		JNC_ASSERT (prev == &__jncSjljFrame || prev == __jncSjljPrevFrame); \
[+] 		JNC_ASSERT(prev == &__jncSjljFrame || prev == __jncSjljPrevFrame); \
[-] 	jnc_Runtime_uninitializeCallSite (__jncRuntime, &__jncCallSite);
[+] 	jnc_Runtime_uninitializeCallSite(__jncRuntime, &__jncCallSite);
[-] 	JNC_BEGIN_CALL_SITE_IMPL (runtime)
[+] 	JNC_BEGIN_CALL_SITE_IMPL(runtime)
[-] 	JNC_END_CALL_SITE_IMPL () \
[+] 	JNC_END_CALL_SITE_IMPL() \
[-] callFunctionImpl_u (void* p)
[+] callFunctionImpl_u(void* p)
[-] 	TargetFunc ();
[+] 	TargetFunc();
[-] 	return ((TargetFunc*) p) ();
[+] 	return ((TargetFunc*)p) ();
[-] callFunctionImpl_u (
[+] callFunctionImpl_u(
[-] 	TargetFunc (Arg);
[+] 	TargetFunc(Arg);
[-] 	return ((TargetFunc*) p) (arg);
[+] 	return ((TargetFunc*)p) (arg);
[-] callFunctionImpl_u (
[+] callFunctionImpl_u(
[-] 	TargetFunc (
[+] 	TargetFunc(
[-] 	return ((TargetFunc*) p)  (arg1, arg2);
[+] 	return ((TargetFunc*)p)  (arg1, arg2);
[-] callFunctionImpl_u (
[+] callFunctionImpl_u(
[-] 	TargetFunc (
[+] 	TargetFunc(
[-] 	return ((TargetFunc*) p) (arg1, arg2, arg3);
[+] 	return ((TargetFunc*)p) (arg1, arg2, arg3);
[-] callFunctionImpl_u (
[+] callFunctionImpl_u(
[-] 	TargetFunc (
[+] 	TargetFunc(
[-] 	return ((TargetFunc*) p) (arg1, arg2, arg3, arg4);
[+] 	return ((TargetFunc*)p) (arg1, arg2, arg3, arg4);
[-] callFunctionImpl_u (
[+] callFunctionImpl_u(
[-] 	TargetFunc (
[+] 	TargetFunc(
[-] 	return ((TargetFunc*) p) (arg1, arg2, arg3, arg4, arg5);
[+] 	return ((TargetFunc*)p) (arg1, arg2, arg3, arg4, arg5);
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p, arg);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p, arg);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p, arg1, arg2);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p, arg1, arg2);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p, arg1, arg2, arg3);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p, arg1, arg2, arg3);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p, arg1, arg2, arg3, arg4);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p, arg1, arg2, arg3, arg4);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunctionImpl_s (
[+] callFunctionImpl_s(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	*retVal = callFunctionImpl_u <RetVal> (p, arg1, arg2, arg3, arg4, arg5);
[+] 	*retVal = callFunctionImpl_u<RetVal> (p, arg1, arg2, arg3, arg4, arg5);
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, retVal);
[+] 	return callFunctionImpl_s(runtime, p, retVal);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, retVal, arg);
[+] 	return callFunctionImpl_s(runtime, p, retVal, arg);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, retVal, arg1, arg2);
[+] 	return callFunctionImpl_s(runtime, p, retVal, arg1, arg2);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, retVal, arg1, arg2, arg3);
[+] 	return callFunctionImpl_s(runtime, p, retVal, arg1, arg2, arg3);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, retVal, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_s(runtime, p, retVal, arg1, arg2, arg3, arg4);
[-] callFunction (Function* function)
[+] callFunction(Function* function)
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_u <RetVal> (p);
[+] 	return callFunctionImpl_u<RetVal> (p);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_u <RetVal> (p, arg);
[+] 	return callFunctionImpl_u<RetVal> (p, arg);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_u <RetVal> (p, arg1, arg2);
[+] 	return callFunctionImpl_u<RetVal> (p, arg1, arg2);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_u <RetVal> (p, arg1, arg2, arg3);
[+] 	return callFunctionImpl_u<RetVal> (p, arg1, arg2, arg3);
[-] callFunction (
[+] callFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_u <RetVal> (p, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_u<RetVal> (p, arg1, arg2, arg3, arg4);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, &retVal);
[+] 	return callFunctionImpl_s(runtime, p, &retVal);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, &retVal, arg);
[+] 	return callFunctionImpl_s(runtime, p, &retVal, arg);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, &retVal, arg1, arg2);
[+] 	return callFunctionImpl_s(runtime, p, &retVal, arg1, arg2);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, &retVal, arg1, arg2, arg3);
[+] 	return callFunctionImpl_s(runtime, p, &retVal, arg1, arg2, arg3);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	return callFunctionImpl_s (runtime, p, &retVal, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_s(runtime, p, &retVal, arg1, arg2, arg3, arg4);
[-] callVoidFunction (Function* function)
[+] callVoidFunction(Function* function)
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	callFunctionImpl_u <void> (p);
[+] 	callFunctionImpl_u<void> (p);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	callFunctionImpl_u <void> (p, arg);
[+] 	callFunctionImpl_u<void> (p, arg);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	callFunctionImpl_u <void> (p, arg1, arg2);
[+] 	callFunctionImpl_u<void> (p, arg1, arg2);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	callFunctionImpl_u <void> (p, arg1, arg2, arg3);
[+] 	callFunctionImpl_u<void> (p, arg1, arg2, arg3);
[-] callVoidFunction (
[+] callVoidFunction(
[-] 	void* p = function->getMachineCode ();
[+] 	void* p = function->getMachineCode();
[-] 	callFunctionImpl_u <void> (p, arg1, arg2, arg3, arg4);
[+] 	callFunctionImpl_u<void> (p, arg1, arg2, arg3, arg4);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, retVal, ptr.m_closure);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, retVal, ptr.m_closure);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, retVal, ptr.m_closure, arg);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, retVal, ptr.m_closure, arg);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2, arg3);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2, arg3);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, retVal, ptr.m_closure, arg1, arg2, arg3, arg4);
[-] callFunctionPtr (FunctionPtr ptr)
[+] callFunctionPtr(FunctionPtr ptr)
[-] 	return callFunctionImpl_u <RetVal> (ptr.m_p, ptr.m_closure);
[+] 	return callFunctionImpl_u<RetVal> (ptr.m_p, ptr.m_closure);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_u <RetVal> (ptr.m_p, ptr.m_closure, arg);
[+] 	return callFunctionImpl_u<RetVal> (ptr.m_p, ptr.m_closure, arg);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_u <RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2);
[+] 	return callFunctionImpl_u<RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_u <RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3);
[+] 	return callFunctionImpl_u<RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3);
[-] callFunctionPtr (
[+] callFunctionPtr(
[-] 	return callFunctionImpl_u <RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_u<RetVal> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3, arg4);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, &retVal, ptr.m_closure);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, &retVal, ptr.m_closure);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, &retVal, ptr.m_closure, arg);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, &retVal, ptr.m_closure, arg);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2, arg3);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2, arg3);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	return callFunctionImpl_s (runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2, arg3, arg4);
[+] 	return callFunctionImpl_s(runtime, ptr.m_p, &retVal, ptr.m_closure, arg1, arg2, arg3, arg4);
[-] callVoidFunctionPtr (FunctionPtr ptr)
[+] callVoidFunctionPtr(FunctionPtr ptr)
[-] 	callFunctionImpl_u <void> (ptr.m_p, ptr.m_closure);
[+] 	callFunctionImpl_u<void> (ptr.m_p, ptr.m_closure);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	callFunctionImpl_u <void> (ptr.m_p, ptr.m_closure, arg);
[+] 	callFunctionImpl_u<void> (ptr.m_p, ptr.m_closure, arg);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	callFunctionImpl_u <void> (ptr.m_p, ptr.m_closure, arg1, arg2);
[+] 	callFunctionImpl_u<void> (ptr.m_p, ptr.m_closure, arg1, arg2);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	callFunctionImpl_u <void> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3);
[+] 	callFunctionImpl_u<void> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3);
[-] callVoidFunctionPtr (
[+] callVoidFunctionPtr(
[-] 	callFunctionImpl_u <void> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3, arg4);
[+] 	callFunctionImpl_u<void> (ptr.m_p, ptr.m_closure, arg1, arg2, arg3, arg4);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	return callVoidFunctionPtr (runtime, ptr);
[+] 	return callVoidFunctionPtr(runtime, ptr);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	return callVoidFunctionPtr (runtime, ptr, arg);
[+] 	return callVoidFunctionPtr(runtime, ptr, arg);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	return callVoidFunctionPtr (runtime, ptr, arg1, arg2);
[+] 	return callVoidFunctionPtr(runtime, ptr, arg1, arg2);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	return callVoidFunctionPtr (runtime, ptr, arg1, arg2, arg3);
[+] 	return callVoidFunctionPtr(runtime, ptr, arg1, arg2, arg3);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	return callVoidFunctionPtr (runtime, ptr, arg1, arg2, arg3, arg4);
[+] 	return callVoidFunctionPtr(runtime, ptr, arg1, arg2, arg3, arg4);
[-] callMulticast (Multicast* multicast)
[+] callMulticast(Multicast* multicast)
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	callVoidFunctionPtr (ptr);
[+] 	callVoidFunctionPtr(ptr);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	callVoidFunctionPtr (ptr, arg);
[+] 	callVoidFunctionPtr(ptr, arg);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	callVoidFunctionPtr (ptr, arg1, arg2);
[+] 	callVoidFunctionPtr(ptr, arg1, arg2);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	callVoidFunctionPtr (ptr, arg1, arg2, arg3);
[+] 	callVoidFunctionPtr(ptr, arg1, arg2, arg3);
[-] callMulticast (
[+] callMulticast(
[-] 	void* p = getMulticastCallMethodMachineCode (multicast);
[+] 	void* p = getMulticastCallMethodMachineCode(multicast);
[-] 	callVoidFunctionPtr (ptr, arg1, arg2, arg3, arg4);
[+] 	callVoidFunctionPtr(ptr, arg1, arg2, arg3, arg4);
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_ClassType.h
----------------------
[-] jnc_getClassPtrTypeKindString (jnc_ClassPtrTypeKind ptrTypeKind);
[+] jnc_getClassPtrTypeKindString(jnc_ClassPtrTypeKind ptrTypeKind);
[-] jnc_ClassType_getClassTypeKind (jnc_ClassType* type);
[+] jnc_ClassType_getClassTypeKind(jnc_ClassType* type);
[-] jnc_ClassType_getIfaceStructType (jnc_ClassType* type);
[+] jnc_ClassType_getIfaceStructType(jnc_ClassType* type);
[-] jnc_ClassType_getClassPtrType (
[+] jnc_ClassType_getClassPtrType(
[-] 	getClassTypeKind ()
[+] 	getClassTypeKind()
[-] 		return jnc_ClassType_getClassTypeKind (this);
[+] 		return jnc_ClassType_getClassTypeKind(this);
[-] 	getIfaceStructType ()
[+] 	getIfaceStructType()
[-] 		return jnc_ClassType_getIfaceStructType (this);
[+] 		return jnc_ClassType_getIfaceStructType(this);
[-] 	getClassPtrType (
[+] 	getClassPtrType(
[-] 		return jnc_ClassType_getClassPtrType (this, ptrTypeKind, flags);
[+] 		return jnc_ClassType_getClassPtrType(this, ptrTypeKind, flags);
[-] jnc_MulticastClassType_getTargetType (jnc_MulticastClassType* type);
[+] jnc_MulticastClassType_getTargetType(jnc_MulticastClassType* type);
[-] jnc_MulticastClassType_getFunctionType (jnc_MulticastClassType* type)
[+] jnc_MulticastClassType_getFunctionType(jnc_MulticastClassType* type)
[-] 	return jnc_FunctionPtrType_getTargetType (jnc_MulticastClassType_getTargetType (type));
[+] 	return jnc_FunctionPtrType_getTargetType(jnc_MulticastClassType_getTargetType(type));
[-] jnc_MulticastClassType_getMethod (
[+] jnc_MulticastClassType_getMethod(
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 		return jnc_MulticastClassType_getTargetType (this);
[+] 		return jnc_MulticastClassType_getTargetType(this);
[-] 	getFunctionType ()
[+] 	getFunctionType()
[-] 		return jnc_MulticastClassType_getFunctionType (this);
[+] 		return jnc_MulticastClassType_getFunctionType(this);
[-] 	getMethod (jnc_MulticastMethodKind method)
[+] 	getMethod(jnc_MulticastMethodKind method)
[-] 		return jnc_MulticastClassType_getMethod (this, method);
[+] 		return jnc_MulticastClassType_getMethod(this, method);
[-] jnc_McSnapshotClassType_getTargetType (jnc_McSnapshotClassType* type);
[+] jnc_McSnapshotClassType_getTargetType(jnc_McSnapshotClassType* type);
[-] jnc_McSnapshotClassType_getFunctionType (jnc_McSnapshotClassType* type)
[+] jnc_McSnapshotClassType_getFunctionType(jnc_McSnapshotClassType* type)
[-] 	return jnc_FunctionPtrType_getTargetType (jnc_McSnapshotClassType_getTargetType (type));
[+] 	return jnc_FunctionPtrType_getTargetType(jnc_McSnapshotClassType_getTargetType(type));
[-] jnc_McSnapshotClassType_getMethod (
[+] jnc_McSnapshotClassType_getMethod(
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 		return jnc_McSnapshotClassType_getTargetType (this);
[+] 		return jnc_McSnapshotClassType_getTargetType(this);
[-] 	getFunctionType ()
[+] 	getFunctionType()
[-] 		return jnc_McSnapshotClassType_getFunctionType (this);
[+] 		return jnc_McSnapshotClassType_getFunctionType(this);
[-] 	getMethod (jnc_McSnapshotMethodKind method)
[+] 	getMethod(jnc_McSnapshotMethodKind method)
[-] 		return jnc_McSnapshotClassType_getMethod (this, method);
[+] 		return jnc_McSnapshotClassType_getMethod(this, method);
[-] jnc_isClassType (
[+] jnc_isClassType(
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Class &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Class &&
[-] 		jnc_ClassType_getClassTypeKind ((jnc_ClassType*) type) == classTypeKind;
[+] 		jnc_ClassType_getClassTypeKind((jnc_ClassType*)type) == classTypeKind;
[-] jnc_isOpaqueClassType (jnc_Type* type)
[+] jnc_isOpaqueClassType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Class &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Class &&
[-] 		(jnc_ModuleItem_getFlags ((jnc_ModuleItem*) type) & jnc_ClassTypeFlag_Opaque);
[+] 		(jnc_ModuleItem_getFlags((jnc_ModuleItem*)type) & jnc_ClassTypeFlag_Opaque);
[-] jnc_isClosureClassType (jnc_Type* type)
[+] jnc_isClosureClassType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Class &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Class &&
[-] 		(jnc_ModuleItem_getFlags ((jnc_ModuleItem*) type) & jnc_ClassTypeFlag_Closure);
[+] 		(jnc_ModuleItem_getFlags((jnc_ModuleItem*)type) & jnc_ClassTypeFlag_Closure);
[-] jnc_isDestructibleClassType (jnc_Type* type)
[+] jnc_isDestructibleClassType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_Class &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_Class &&
[-] 		jnc_DerivableType_getDestructor ((jnc_DerivableType*) type) != NULL;
[+] 		jnc_DerivableType_getDestructor((jnc_DerivableType*)type) != NULL;
[-] jnc_getMulticastCallMethodMachineCode (jnc_Multicast* multicast)
[+] jnc_getMulticastCallMethodMachineCode(jnc_Multicast* multicast)
[-] 	return jnc_Function_getMachineCode (jnc_MulticastClassType_getMethod (
[+] 	return jnc_Function_getMachineCode(jnc_MulticastClassType_getMethod(
[-] 		(jnc_MulticastClassType*) multicast->m_ifaceHdr.m_box->m_type,
[+] 		(jnc_MulticastClassType*)multicast->m_ifaceHdr.m_box->m_type,
[-] getClassPtrTypeKindString (ClassPtrTypeKind ptrTypeKind)
[+] getClassPtrTypeKindString(ClassPtrTypeKind ptrTypeKind)
[-] 	return jnc_getClassPtrTypeKindString (ptrTypeKind);
[+] 	return jnc_getClassPtrTypeKindString(ptrTypeKind);
[-] isClassType (
[+] isClassType(
[-] 	return jnc_isClassType (type, classTypeKind) != 0;
[+] 	return jnc_isClassType(type, classTypeKind) != 0;
[-] isOpaqueClassType (Type* type)
[+] isOpaqueClassType(Type* type)
[-] 	return jnc_isOpaqueClassType (type) != 0;
[+] 	return jnc_isOpaqueClassType(type) != 0;
[-] isClosureClassType (Type* type)
[+] isClosureClassType(Type* type)
[-] 	return jnc_isClosureClassType (type) != 0;
[+] 	return jnc_isClosureClassType(type) != 0;
[-] isDestructibleClassType (Type* type)
[+] isDestructibleClassType(Type* type)
[-] 	return jnc_isDestructibleClassType (type) != 0;
[+] 	return jnc_isDestructibleClassType(type) != 0;
[-] getMulticastCallMethodMachineCode (jnc_Multicast* multicast)
[+] getMulticastCallMethodMachineCode(jnc_Multicast* multicast)
[-] 	return jnc_getMulticastCallMethodMachineCode (multicast);
[+] 	return jnc_getMulticastCallMethodMachineCode(multicast);
----------------------
27/02/2019 18:01:59 - C:\Projects\repos\ioninja\jancy\include\jnc_Construct.h
----------------------
[-] construct (T* p)
[+] construct(T* p)
[-] 	new (p) T;
[+] 	new(p)T;
[-] construct (
[+] construct(
[-] 	new (p) T (arg);
[+] 	new(p)T(arg);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2);
[+] 	new(p)T(arg1, arg2);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2, arg3);
[+] 	new(p)T(arg1, arg2, arg3);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2, arg3, arg4);
[+] 	new(p)T(arg1, arg2, arg3, arg4);
[-] destruct (T* p)
[+] destruct(T* p)
[-] 	p->~T ();
[+] 	p->~T();
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Def.h
----------------------
[-] getTlsStringBuffer ();
[+] getTlsStringBuffer();
[-] 	Whenever something needs to be put on a Jancy list, it must be represented as a struct with ``jnc_ListLink`` memeber field in it. If a list contains entries of non-aggregate type (such as ``int``, or ``void*``), then we have to *box* entry in a struct as such:
[+] 	Whenever something needs to be put on a Jancy list, it must be represented as a struct with ``jnc_ListLink`` memeber field in it. If a list contains entries of non-aggregate type(such as ``int``, or ``void*``), then we have to *box* entry in a struct as such:
[-] 	\brief This struct describes a globally unique identifier (GUID).
[+] 	\brief This struct describes a globally unique identifier(GUID).
[-] 			uint8_t m_data4 [8];
[+] 			uint8_t m_data4[8];
[-] 		JNC_DEFINE_GUID (
[+] 		JNC_DEFINE_GUID(
[-] 			JNC_GUID_INITIALIZER (l, s1, s2, b1, b2,  b3,  b4,  b5,  b6,  b7,  b8)
[+] 			JNC_GUID_INITIALIZER(l, s1, s2, b1, b2,  b3,  b4,  b5,  b6,  b7,  b8)
[-] jnc_initialize (const char* tag);
[+] jnc_initialize(const char* tag);
[-] initialize (const char* tag = NULL)
[+] initialize(const char* tag = NULL)
[-] 	jnc_initialize (tag);
[+] 	jnc_initialize(tag);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_DerivableType.h
----------------------
[-] jnc_BaseTypeSlot_getType (jnc_BaseTypeSlot* baseType)
[+] jnc_BaseTypeSlot_getType(jnc_BaseTypeSlot* baseType)
[-] 	return (jnc_DerivableType*) jnc_ModuleItem_getType ((jnc_ModuleItem*) baseType);
[+] 	return (jnc_DerivableType*)jnc_ModuleItem_getType((jnc_ModuleItem*)baseType);
[-] jnc_BaseTypeSlot_getOffset (jnc_BaseTypeSlot* baseType);
[+] jnc_BaseTypeSlot_getOffset(jnc_BaseTypeSlot* baseType);
[-] jnc_BaseTypeSlot_getVTableIndex (jnc_BaseTypeSlot* baseType);
[+] jnc_BaseTypeSlot_getVTableIndex(jnc_BaseTypeSlot* baseType);
[-] 	getType ()
[+] 	getType()
[-] 		return jnc_BaseTypeSlot_getType (this);
[+] 		return jnc_BaseTypeSlot_getType(this);
[-] 	getOffset ()
[+] 	getOffset()
[-] 		return jnc_BaseTypeSlot_getOffset (this);
[+] 		return jnc_BaseTypeSlot_getOffset(this);
[-] 	getVTableIndex ()
[+] 	getVTableIndex()
[-] 		return jnc_BaseTypeSlot_getVTableIndex (this);
[+] 		return jnc_BaseTypeSlot_getVTableIndex(this);
[-] jnc_DerivableType_getStaticConstructor (jnc_DerivableType* type);
[+] jnc_DerivableType_getStaticConstructor(jnc_DerivableType* type);
[-] jnc_DerivableType_getStaticDestructor (jnc_DerivableType* type);
[+] jnc_DerivableType_getStaticDestructor(jnc_DerivableType* type);
[-] jnc_DerivableType_getPreConstructor (jnc_DerivableType* type);
[+] jnc_DerivableType_getPreConstructor(jnc_DerivableType* type);
[-] jnc_DerivableType_getConstructor (jnc_DerivableType* type);
[+] jnc_DerivableType_getConstructor(jnc_DerivableType* type);
[-] jnc_DerivableType_getDestructor (jnc_DerivableType* type);
[+] jnc_DerivableType_getDestructor(jnc_DerivableType* type);
[-] jnc_DerivableType_getUnaryOperator (
[+] jnc_DerivableType_getUnaryOperator(
[-] jnc_DerivableType_getBinaryOperator (
[+] jnc_DerivableType_getBinaryOperator(
[-] jnc_DerivableType_getCallOperator (jnc_DerivableType* type);
[+] jnc_DerivableType_getCallOperator(jnc_DerivableType* type);
[-] jnc_DerivableType_getCastOperator (
[+] jnc_DerivableType_getCastOperator(
[-] jnc_DerivableType_getBaseTypeCount (jnc_DerivableType* type);
[+] jnc_DerivableType_getBaseTypeCount(jnc_DerivableType* type);
[-] jnc_DerivableType_getBaseType (
[+] jnc_DerivableType_getBaseType(
[-] jnc_DerivableType_findBaseTypeOffset (
[+] jnc_DerivableType_findBaseTypeOffset(
[-] jnc_DerivableType_getMemberFieldCount (jnc_DerivableType* type);
[+] jnc_DerivableType_getMemberFieldCount(jnc_DerivableType* type);
[-] jnc_DerivableType_getMemberField (
[+] jnc_DerivableType_getMemberField(
[-] jnc_DerivableType_getMemberMethodCount (jnc_DerivableType* type);
[+] jnc_DerivableType_getMemberMethodCount(jnc_DerivableType* type);
[-] jnc_DerivableType_getMemberMethod (
[+] jnc_DerivableType_getMemberMethod(
[-] jnc_DerivableType_getMemberPropertyCount (jnc_DerivableType* type);
[+] jnc_DerivableType_getMemberPropertyCount(jnc_DerivableType* type);
[-] jnc_DerivableType_getMemberProperty (
[+] jnc_DerivableType_getMemberProperty(
[-] 	getStaticConstructor ()
[+] 	getStaticConstructor()
[-] 		return jnc_DerivableType_getStaticConstructor (this);
[+] 		return jnc_DerivableType_getStaticConstructor(this);
[-] 	getStaticDestructor ()
[+] 	getStaticDestructor()
[-] 		return jnc_DerivableType_getStaticDestructor (this);
[+] 		return jnc_DerivableType_getStaticDestructor(this);
[-] 	getPreConstructor ()
[+] 	getPreConstructor()
[-] 		return jnc_DerivableType_getPreConstructor (this);
[+] 		return jnc_DerivableType_getPreConstructor(this);
[-] 	getConstructor ()
[+] 	getConstructor()
[-] 		return jnc_DerivableType_getConstructor (this);
[+] 		return jnc_DerivableType_getConstructor(this);
[-] 	getDestructor ()
[+] 	getDestructor()
[-] 		return jnc_DerivableType_getDestructor (this);
[+] 		return jnc_DerivableType_getDestructor(this);
[-] 	getUnaryOperator (jnc_UnOpKind opKind)
[+] 	getUnaryOperator(jnc_UnOpKind opKind)
[-] 		return jnc_DerivableType_getUnaryOperator (this, opKind);
[+] 		return jnc_DerivableType_getUnaryOperator(this, opKind);
[-] 	getBinaryOperator (jnc_BinOpKind opKind)
[+] 	getBinaryOperator(jnc_BinOpKind opKind)
[-] 		return jnc_DerivableType_getBinaryOperator (this, opKind);
[+] 		return jnc_DerivableType_getBinaryOperator(this, opKind);
[-] 	getCallOperator ()
[+] 	getCallOperator()
[-] 		return jnc_DerivableType_getCallOperator (this);
[+] 		return jnc_DerivableType_getCallOperator(this);
[-] 	getCastOperator (size_t idx)
[+] 	getCastOperator(size_t idx)
[-] 		return jnc_DerivableType_getCastOperator (this, idx);
[+] 		return jnc_DerivableType_getCastOperator(this, idx);
[-] 	getBaseTypeCount ()
[+] 	getBaseTypeCount()
[-] 		return jnc_DerivableType_getBaseTypeCount (this);
[+] 		return jnc_DerivableType_getBaseTypeCount(this);
[-] 	getBaseType (size_t index)
[+] 	getBaseType(size_t index)
[-] 		return jnc_DerivableType_getBaseType (this, index);
[+] 		return jnc_DerivableType_getBaseType(this, index);
[-] 	findBaseTypeOffset (jnc_Type* baseType)
[+] 	findBaseTypeOffset(jnc_Type* baseType)
[-] 		return jnc_DerivableType_findBaseTypeOffset (this, baseType);
[+] 		return jnc_DerivableType_findBaseTypeOffset(this, baseType);
[-] 	getMemberFieldCount ()
[+] 	getMemberFieldCount()
[-] 		return jnc_DerivableType_getMemberFieldCount (this);
[+] 		return jnc_DerivableType_getMemberFieldCount(this);
[-] 	getMemberField (size_t index)
[+] 	getMemberField(size_t index)
[-] 		return jnc_DerivableType_getMemberField (this, index);
[+] 		return jnc_DerivableType_getMemberField(this, index);
[-] 	getMemberMethodCount ()
[+] 	getMemberMethodCount()
[-] 		return jnc_DerivableType_getMemberMethodCount (this);
[+] 		return jnc_DerivableType_getMemberMethodCount(this);
[-] 	getMemberMethod (size_t index)
[+] 	getMemberMethod(size_t index)
[-] 		return jnc_DerivableType_getMemberMethod (this, index);
[+] 		return jnc_DerivableType_getMemberMethod(this, index);
[-] 	getMemberPropertyCount ()
[+] 	getMemberPropertyCount()
[-] 		return jnc_DerivableType_getMemberPropertyCount (this);
[+] 		return jnc_DerivableType_getMemberPropertyCount(this);
[-] 	getMemberProperty (size_t index)
[+] 	getMemberProperty(size_t index)
[-] 		return jnc_DerivableType_getMemberProperty (this, index);
[+] 		return jnc_DerivableType_getMemberProperty(this, index);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_DynamicExtensionLibHost.h
----------------------
[-] jnc_GetLastErrorFunc ();
[+] jnc_GetLastErrorFunc();
[-] jnc_SetErrorFunc (const jnc_Error* error);
[+] jnc_SetErrorFunc(const jnc_Error* error);
[-] jnc_SetErrnoFunc (int code);
[+] jnc_SetErrnoFunc(int code);
[-] jnc_SetStringErrorFunc (const char* string);
[+] jnc_SetStringErrorFunc(const char* string);
[-] jnc_GetErrorDescriptionFunc (const jnc_Error* error);
[+] jnc_GetErrorDescriptionFunc(const jnc_Error* error);
[-] jnc_ModuleItemDecl_GetNameFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetNameFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetQualifiedNameFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetQualifiedNameFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetStorageKindFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetStorageKindFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetAccessKindFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetAccessKindFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetAttributeBlockFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetAttributeBlockFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetParentNamespaceFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetParentNamespaceFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetParentUnitFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetParentUnitFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetLineFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetLineFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetColFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetColFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_GetOffsetFunc (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_GetOffsetFunc(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItem_GetModuleFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetModuleFunc(jnc_ModuleItem* item);
[-] jnc_ModuleItem_GetItemKindFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetItemKindFunc(jnc_ModuleItem* item);
[-] jnc_ModuleItem_GetFlagsFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetFlagsFunc(jnc_ModuleItem* item);
[-] jnc_ModuleItem_GetDeclFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetDeclFunc(jnc_ModuleItem* item);
[-] jnc_ModuleItem_GetNamespaceFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetNamespaceFunc(jnc_ModuleItem* item);
[-] jnc_ModuleItem_GetTypeFunc (jnc_ModuleItem* item);
[+] jnc_ModuleItem_GetTypeFunc(jnc_ModuleItem* item);
[-] jnc_VerifyModuleItemIsDerivableTypeFunc (
[+] jnc_VerifyModuleItemIsDerivableTypeFunc(
[-] jnc_VerifyModuleItemIsClassTypeFunc (
[+] jnc_VerifyModuleItemIsClassTypeFunc(
[-] jnc_AttributeBlock_GetAttributeCountFunc (jnc_AttributeBlock* block);
[+] jnc_AttributeBlock_GetAttributeCountFunc(jnc_AttributeBlock* block);
[-] jnc_AttributeBlock_GetAttributeFunc (
[+] jnc_AttributeBlock_GetAttributeFunc(
[-] jnc_AttributeBlock_FindAttributeFunc (
[+] jnc_AttributeBlock_FindAttributeFunc(
[-] jnc_Namespace_GetItemCountFunc (jnc_Namespace* nspace);
[+] jnc_Namespace_GetItemCountFunc(jnc_Namespace* nspace);
[-] jnc_Namespace_GetItemFunc (
[+] jnc_Namespace_GetItemFunc(
[-] jnc_Namespace_FindVariableFunc (
[+] jnc_Namespace_FindVariableFunc(
[-] jnc_Namespace_FindFunctionFunc (
[+] jnc_Namespace_FindFunctionFunc(
[-] jnc_Namespace_FindPropertyFunc (
[+] jnc_Namespace_FindPropertyFunc(
[-] jnc_Namespace_FindClassTypeFunc (
[+] jnc_Namespace_FindClassTypeFunc(
[-] jnc_Function_GetFunctionKindFunc (jnc_Function* function);
[+] jnc_Function_GetFunctionKindFunc(jnc_Function* function);
[-] jnc_Function_IsMemberFunc (jnc_Function* function);
[+] jnc_Function_IsMemberFunc(jnc_Function* function);
[-] jnc_Function_IsOverloadedFunc (jnc_Function* function);
[+] jnc_Function_IsOverloadedFunc(jnc_Function* function);
[-] jnc_Function_GetOverloadCountFunc (jnc_Function* function);
[+] jnc_Function_GetOverloadCountFunc(jnc_Function* function);
[-] jnc_Function_GetOverloadFunc (
[+] jnc_Function_GetOverloadFunc(
[-] jnc_Function_GetMachineCodeFunc (jnc_Function* function);
[+] jnc_Function_GetMachineCodeFunc(jnc_Function* function);
[-] jnc_Property_GetGetterFunc (jnc_Property* prop);
[+] jnc_Property_GetGetterFunc(jnc_Property* prop);
[-] jnc_Property_GetSetterFunc (jnc_Property* prop);
[+] jnc_Property_GetSetterFunc(jnc_Property* prop);
[-] jnc_Type_GetTypeKindFunc (jnc_Type* type);
[+] jnc_Type_GetTypeKindFunc(jnc_Type* type);
[-] jnc_Type_GetSizeFunc (jnc_Type* type);
[+] jnc_Type_GetSizeFunc(jnc_Type* type);
[-] jnc_Type_GetTypeStringFunc (jnc_Type* type);
[+] jnc_Type_GetTypeStringFunc(jnc_Type* type);
[-] jnc_Type_CmpFunc (
[+] jnc_Type_CmpFunc(
[-] jnc_Type_GetDataPtrTypeFunc (
[+] jnc_Type_GetDataPtrTypeFunc(
[-] jnc_Type_MarkGcRootsFunc (
[+] jnc_Type_MarkGcRootsFunc(
[-] jnc_BaseTypeSlot_GetOffsetFunc (jnc_BaseTypeSlot* baseType);
[+] jnc_BaseTypeSlot_GetOffsetFunc(jnc_BaseTypeSlot* baseType);
[-] jnc_BaseTypeSlot_GetVTableIndexFunc (jnc_BaseTypeSlot* baseType);
[+] jnc_BaseTypeSlot_GetVTableIndexFunc(jnc_BaseTypeSlot* baseType);
[-] jnc_DerivableType_GetMemberMethodFunc (jnc_DerivableType* type);
[+] jnc_DerivableType_GetMemberMethodFunc(jnc_DerivableType* type);
[-] jnc_DerivableType_GetUnaryOperatorFunc (
[+] jnc_DerivableType_GetUnaryOperatorFunc(
[-] jnc_DerivableType_GetBinaryOperatorFunc (
[+] jnc_DerivableType_GetBinaryOperatorFunc(
[-] jnc_DerivableType_GetCastOperatorFunc (
[+] jnc_DerivableType_GetCastOperatorFunc(
[-] jnc_ArrayType_GetElementTypeFunc (jnc_ArrayType* type);
[+] jnc_ArrayType_GetElementTypeFunc(jnc_ArrayType* type);
[-] jnc_ArrayType_GetElementCountFunc (jnc_ArrayType* type);
[+] jnc_ArrayType_GetElementCountFunc(jnc_ArrayType* type);
[-] jnc_BitFieldType_GetBaseTypeFunc (jnc_BitFieldType* type);
[+] jnc_BitFieldType_GetBaseTypeFunc(jnc_BitFieldType* type);
[-] jnc_BitFieldType_GetBitOffsetFunc (jnc_BitFieldType* type);
[+] jnc_BitFieldType_GetBitOffsetFunc(jnc_BitFieldType* type);
[-] jnc_BitFieldType_GetBitCountFunc (jnc_BitFieldType* type);
[+] jnc_BitFieldType_GetBitCountFunc(jnc_BitFieldType* type);
[-] jnc_FunctionType_GetReturnTypeFunc (jnc_FunctionType* type);
[+] jnc_FunctionType_GetReturnTypeFunc(jnc_FunctionType* type);
[-] jnc_FunctionType_GetArgCountFunc (jnc_FunctionType* type);
[+] jnc_FunctionType_GetArgCountFunc(jnc_FunctionType* type);
[-] jnc_FunctionType_GetArgFunc (
[+] jnc_FunctionType_GetArgFunc(
[-] jnc_FunctionType_GetFunctionPtrTypeFunc (
[+] jnc_FunctionType_GetFunctionPtrTypeFunc(
[-] jnc_FunctionType_GetShortTypeFunc (jnc_FunctionType* type);
[+] jnc_FunctionType_GetShortTypeFunc(jnc_FunctionType* type);
[-] jnc_EnumConst_GetValueFunc (jnc_EnumConst* enumConst);
[+] jnc_EnumConst_GetValueFunc(jnc_EnumConst* enumConst);
[-] jnc_EnumType_GetBaseTypeFunc (jnc_EnumType* type);
[+] jnc_EnumType_GetBaseTypeFunc(jnc_EnumType* type);
[-] jnc_EnumType_GetConstCountFunc (jnc_EnumType* type);
[+] jnc_EnumType_GetConstCountFunc(jnc_EnumType* type);
[-] jnc_EnumType_GetConstFunc (
[+] jnc_EnumType_GetConstFunc(
[-] jnc_StructField_GetOffsetFunc (jnc_StructField* field);
[+] jnc_StructField_GetOffsetFunc(jnc_StructField* field);
[-] jnc_ClassType_GetClassTypeKindFunc (jnc_ClassType* type);
[+] jnc_ClassType_GetClassTypeKindFunc(jnc_ClassType* type);
[-] jnc_ClassType_GetIfaceStructTypeFunc (jnc_ClassType* type);
[+] jnc_ClassType_GetIfaceStructTypeFunc(jnc_ClassType* type);
[-] jnc_ClassType_GetClassPtrTypeFunc (
[+] jnc_ClassType_GetClassPtrTypeFunc(
[-] jnc_MulticastClassType_GetTargetTypeFunc (jnc_MulticastClassType* type);
[+] jnc_MulticastClassType_GetTargetTypeFunc(jnc_MulticastClassType* type);
[-] jnc_MulticastClassType_GetMethodFunc (
[+] jnc_MulticastClassType_GetMethodFunc(
[-] jnc_McSnapshotClassType_GetTargetTypeFunc (jnc_McSnapshotClassType* type);
[+] jnc_McSnapshotClassType_GetTargetTypeFunc(jnc_McSnapshotClassType* type);
[-] jnc_McSnapshotClassType_GetMethodFunc (
[+] jnc_McSnapshotClassType_GetMethodFunc(
[-] jnc_DataPtrType_GetPtrTypeKindFunc (jnc_DataPtrType* type);
[+] jnc_DataPtrType_GetPtrTypeKindFunc(jnc_DataPtrType* type);
[-] jnc_DataPtrType_GetTargetTypeFunc (jnc_DataPtrType* type);
[+] jnc_DataPtrType_GetTargetTypeFunc(jnc_DataPtrType* type);
[-] jnc_FunctionPtrType_GetPtrTypeKindFunc (jnc_FunctionPtrType* type);
[+] jnc_FunctionPtrType_GetPtrTypeKindFunc(jnc_FunctionPtrType* type);
[-] jnc_FunctionPtrType_GetTargetTypeFunc (jnc_FunctionPtrType* type);
[+] jnc_FunctionPtrType_GetTargetTypeFunc(jnc_FunctionPtrType* type);
[-] jnc_Variant_CastFunc (
[+] jnc_Variant_CastFunc(
[-] jnc_Variant_UnaryOperatorFunc (
[+] jnc_Variant_UnaryOperatorFunc(
[-] jnc_Variant_BinaryOperatorFunc (
[+] jnc_Variant_BinaryOperatorFunc(
[-] jnc_Variant_RelationalOperatorFunc (
[+] jnc_Variant_RelationalOperatorFunc(
[-] jnc_Variant_GetMemberFunc (
[+] jnc_Variant_GetMemberFunc(
[-] jnc_Variant_SetMemberFunc (
[+] jnc_Variant_SetMemberFunc(
[-] jnc_Variant_GetElementFunc (
[+] jnc_Variant_GetElementFunc(
[-] jnc_Variant_SetElementFunc (
[+] jnc_Variant_SetElementFunc(
[-] jnc_Variant_HashFunc (const jnc_Variant* variant);
[+] jnc_Variant_HashFunc(const jnc_Variant* variant);
[-] jnc_Module_CreateFunc ();
[+] jnc_Module_CreateFunc();
[-] jnc_Module_DestroyFunc (jnc_Module* module);
[+] jnc_Module_DestroyFunc(jnc_Module* module);
[-] jnc_Module_ClearFunc (jnc_Module* module);
[+] jnc_Module_ClearFunc(jnc_Module* module);
[-] jnc_Module_InitializeFunc (
[+] jnc_Module_InitializeFunc(
[-] jnc_Module_GetGlobalNamespaceFunc (jnc_Module* module);
[+] jnc_Module_GetGlobalNamespaceFunc(jnc_Module* module);
[-] jnc_Module_GetPrimitiveTypeFunc (
[+] jnc_Module_GetPrimitiveTypeFunc(
[-] jnc_Module_FindItemFunc (
[+] jnc_Module_FindItemFunc(
[-] jnc_Module_MapVariableFunc (
[+] jnc_Module_MapVariableFunc(
[-] jnc_Module_MapFunctionFunc (
[+] jnc_Module_MapFunctionFunc(
[-] jnc_Module_AddSourceFunc (
[+] jnc_Module_AddSourceFunc(
[-] jnc_Module_AddImportDirFunc (
[+] jnc_Module_AddImportDirFunc(
[-] jnc_Module_AddImportFunc (
[+] jnc_Module_AddImportFunc(
[-] jnc_Module_AddOpaqueClassTypeInfoFunc (
[+] jnc_Module_AddOpaqueClassTypeInfoFunc(
[-] jnc_Module_AddStaticLibFunc (
[+] jnc_Module_AddStaticLibFunc(
[-] jnc_Module_ParseFunc (
[+] jnc_Module_ParseFunc(
[-] jnc_Module_ParseFileFunc (
[+] jnc_Module_ParseFileFunc(
[-] jnc_Module_ParseImportsFunc (jnc_Module* module);
[+] jnc_Module_ParseImportsFunc(jnc_Module* module);
[-] jnc_Module_CalcLayoutFunc (jnc_Module* module);
[+] jnc_Module_CalcLayoutFunc(jnc_Module* module);
[-] jnc_Module_CompileFunc (jnc_Module* module);
[+] jnc_Module_CompileFunc(jnc_Module* module);
[-] jnc_Module_JitFunc (jnc_Module* module);
[+] jnc_Module_JitFunc(jnc_Module* module);
[-] jnc_Module_getLlvmIrStringFunc (jnc_Module* module);
[+] jnc_Module_getLlvmIrStringFunc(jnc_Module* module);
[-] jnc_Runtime_CreateFunc ();
[+] jnc_Runtime_CreateFunc();
[-] jnc_Runtime_DestroyFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_DestroyFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_GetModuleFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_GetModuleFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_GetGcHeapFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_GetGcHeapFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_IsAbortedFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_IsAbortedFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_GetStackSizeLimitFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_GetStackSizeLimitFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_SetStackSizeLimitFunc (
[+] jnc_Runtime_SetStackSizeLimitFunc(
[-] jnc_Runtime_StartupFunc (
[+] jnc_Runtime_StartupFunc(
[-] jnc_Runtime_ShutdownFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_ShutdownFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_AbortFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_AbortFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_InitializeCallSiteFunc (
[+] jnc_Runtime_InitializeCallSiteFunc(
[-] jnc_Runtime_UninitializeCallSiteFunc (
[+] jnc_Runtime_UninitializeCallSiteFunc(
[-] jnc_Runtime_SetSjljFrameFunc (
[+] jnc_Runtime_SetSjljFrameFunc(
[-] jnc_Runtime_GetUserDataFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_GetUserDataFunc(jnc_Runtime* runtime);
[-] jnc_Runtime_SetUserDataFunc (
[+] jnc_Runtime_SetUserDataFunc(
[-] jnc_Runtime_CheckStackOverflowFunc (jnc_Runtime* runtime);
[+] jnc_Runtime_CheckStackOverflowFunc(jnc_Runtime* runtime);
[-] jnc_GetCurrentThreadRuntimeFunc ();
[+] jnc_GetCurrentThreadRuntimeFunc();
[-] jnc_GetCurrentThreadTlsFunc ();
[+] jnc_GetCurrentThreadTlsFunc();
[-] jnc_DynamicThrowFunc ();
[+] jnc_DynamicThrowFunc();
[-] jnc_PrimeClassFunc (
[+] jnc_PrimeClassFunc(
[-] jnc_StrLenFunc (jnc_DataPtr ptr);
[+] jnc_StrLenFunc(jnc_DataPtr ptr);
[-] jnc_StrDupFunc (
[+] jnc_StrDupFunc(
[-] jnc_MemDupFunc (
[+] jnc_MemDupFunc(
[-] jnc_GcHeap_GetRuntimeFunc (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_GetRuntimeFunc(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_GetStatsFunc (
[+] jnc_GcHeap_GetStatsFunc(
[-] jnc_GcHeap_GetSizeTriggersFunc (
[+] jnc_GcHeap_GetSizeTriggersFunc(
[-] jnc_GcHeap_SetSizeTriggersFunc (
[+] jnc_GcHeap_SetSizeTriggersFunc(
[-] jnc_GcHeap_CollectFunc (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_CollectFunc(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_EnterNoCollectRegionFunc (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_EnterNoCollectRegionFunc(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_LeaveNoCollectRegionFunc (
[+] jnc_GcHeap_LeaveNoCollectRegionFunc(
[-] jnc_GcHeap_EnterWaitRegionFunc (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_EnterWaitRegionFunc(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_LeaveWaitRegionFunc (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_LeaveWaitRegionFunc(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_AllocateClassFunc (
[+] jnc_GcHeap_AllocateClassFunc(
[-] jnc_GcHeap_AllocateDataFunc (
[+] jnc_GcHeap_AllocateDataFunc(
[-] jnc_GcHeap_AllocateArrayFunc (
[+] jnc_GcHeap_AllocateArrayFunc(
[-] jnc_GcHeap_AllocateBufferFunc (
[+] jnc_GcHeap_AllocateBufferFunc(
[-] jnc_GcHeap_CreateDataPtrValidatorFunc (
[+] jnc_GcHeap_CreateDataPtrValidatorFunc(
[-] jnc_GcHeap_GetDynamicLayoutFunc (
[+] jnc_GcHeap_GetDynamicLayoutFunc(
[-] jnc_GcHeap_ResetDynamicLayoutFunc (
[+] jnc_GcHeap_ResetDynamicLayoutFunc(
[-] jnc_GcHeap_WeakMarkFunc (
[+] jnc_GcHeap_WeakMarkFunc(
[-] jnc_GcHeap_MarkDataFunc (
[+] jnc_GcHeap_MarkDataFunc(
[-] jnc_GcHeap_MarkClassFunc (
[+] jnc_GcHeap_MarkClassFunc(
[-] jnc_GcHeap_AddBoxToCallSiteFunc (jnc_Box* box);
[+] jnc_GcHeap_AddBoxToCallSiteFunc(jnc_Box* box);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_EnumType.h
----------------------
[-] jnc_EnumConst_getValue (jnc_EnumConst* enumConst);
[+] jnc_EnumConst_getValue(jnc_EnumConst* enumConst);
[-] 	getValue ()
[+] 	getValue()
[-] 		return jnc_EnumConst_getValue (this);
[+] 		return jnc_EnumConst_getValue(this);
[-] jnc_EnumType_getBaseType (jnc_EnumType* type);
[+] jnc_EnumType_getBaseType(jnc_EnumType* type);
[-] jnc_EnumType_getConstCount (jnc_EnumType* type);
[+] jnc_EnumType_getConstCount(jnc_EnumType* type);
[-] jnc_EnumType_getConst (
[+] jnc_EnumType_getConst(
[-] 	getBaseType ()
[+] 	getBaseType()
[-] 		return jnc_EnumType_getBaseType (this);
[+] 		return jnc_EnumType_getBaseType(this);
[-] 	getConstCount ()
[+] 	getConstCount()
[-] 		return jnc_EnumType_getConstCount (this);
[+] 		return jnc_EnumType_getConstCount(this);
[-] 	getConst (size_t index)
[+] 	getConst(size_t index)
[-] 		return jnc_EnumType_getConst (this, index);
[+] 		return jnc_EnumType_getConst(this, index);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Error.h
----------------------
[-] jnc_setErrorRouter (jnc_ErrorRouter* router);
[+] jnc_setErrorRouter(jnc_ErrorRouter* router);
[-] jnc_getLastError ();
[+] jnc_getLastError();
[-] jnc_setError (const jnc_Error* error);
[+] jnc_setError(const jnc_Error* error);
[-] jnc_setErrno (int code);
[+] jnc_setErrno(int code);
[-] jnc_setStringError (const char* string);
[+] jnc_setStringError(const char* string);
[-] 		jnc_getErrorDescription_v (jnc_getLastError ())
[+] 		jnc_getErrorDescription_v(jnc_getLastError())
[-] 		printf ("error: %s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("error: %s\n", jnc_getLastErrorDescription_v ());
[-] jnc_getErrorDescription_v (const jnc_Error* error);
[+] jnc_getErrorDescription_v(const jnc_Error* error);
[-] jnc_getLastErrorDescription_v ()
[+] jnc_getLastErrorDescription_v()
[-] 	return jnc_getErrorDescription_v (jnc_getLastError ());
[+] 	return jnc_getErrorDescription_v(jnc_getLastError());
[-] setErrorRouter (jnc_ErrorRouter* router)
[+] setErrorRouter(jnc_ErrorRouter* router)
[-] 	jnc_setErrorRouter (router);
[+] 	jnc_setErrorRouter(router);
[-] getLastError ()
[+] getLastError()
[-] 	return jnc_getLastError ();
[+] 	return jnc_getLastError();
[-] setError (const jnc_Error* error)
[+] setError(const jnc_Error* error)
[-] 	jnc_setError (error);
[+] 	jnc_setError(error);
[-] setErrno (int code)
[+] setErrno(int code)
[-] 	jnc_setErrno (code);
[+] 	jnc_setErrno(code);
[-] setStringError (const char* string)
[+] setStringError(const char* string)
[-] 	jnc_setStringError (string);
[+] 	jnc_setStringError(string);
[-] getErrorDescription_v (const jnc_Error* error)
[+] getErrorDescription_v(const jnc_Error* error)
[-] 	return jnc_getErrorDescription_v (error);
[+] 	return jnc_getErrorDescription_v(error);
[-] getLastErrorDescription_v ()
[+] getLastErrorDescription_v()
[-] 	return jnc_getLastErrorDescription_v ();
[+] 	return jnc_getLastErrorDescription_v();
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_ExtensionLib.h
----------------------
[-] 	Indirectly provides access to runtime and module of the Jancy host (on behalf of which this dynamic extension library is being loaded).
[+] 	Indirectly provides access to runtime and module of the Jancy host(on behalf of which this dynamic extension library is being loaded).
[-] jnc_ExtensionLib_AddSourcesFunc (jnc_Module* module);
[+] jnc_ExtensionLib_AddSourcesFunc(jnc_Module* module);
[-] jnc_ExtensionLib_AddOpaqueClassTypeInfosFunc (jnc_Module* module);
[+] jnc_ExtensionLib_AddOpaqueClassTypeInfosFunc(jnc_Module* module);
[-] jnc_ExtensionLib_MapAddressesFunc (jnc_Module* module);
[+] jnc_ExtensionLib_MapAddressesFunc(jnc_Module* module);
[-] jnc_DynamicExtensionLibMainFunc (jnc_DynamicExtensionLibHost* host);
[+] jnc_DynamicExtensionLibMainFunc(jnc_DynamicExtensionLibHost* host);
[-] jnc_DynamicExtensionLibUnloadFunc ();
[+] jnc_DynamicExtensionLibUnloadFunc();
[-] jnc_g_dynamicExtensionLibMainFuncName [] = "jncDynamicExtensionLibMain";
[+] jnc_g_dynamicExtensionLibMainFuncName[] = "jncDynamicExtensionLibMain";
[-] jnc_g_dynamicExtensionLibUnloadFuncName [] = "jncDynamicExtensionLibUnload";
[+] jnc_g_dynamicExtensionLibUnloadFuncName[] = "jncDynamicExtensionLibUnload";
[-] 	LibPrefix##_getLib ();
[+] 	LibPrefix##_getLib();
[-] 	LibPrefix##_addSources (jnc_Module* module); \
[+] 	LibPrefix##_addSources(jnc_Module* module); \
[-] 	LibPrefix##_addOpaqueClassTypeInfos (jnc_Module* module); \
[+] 	LibPrefix##_addOpaqueClassTypeInfos(jnc_Module* module); \
[-] 	LibPrefix##_mapAddresses (jnc_Module* module); \
[+] 	LibPrefix##_mapAddresses(jnc_Module* module); \
[-] 	LibPrefix##_getLib () \
[+] 	LibPrefix##_getLib() \
[-] 	LibPrefix##_addSources (jnc_Module* module) \
[+] 	LibPrefix##_addSources(jnc_Module* module) \
[-] 		jnc_ExtensionLib* lib = LibPrefix##_getLib ();
[+] 		jnc_ExtensionLib* lib = LibPrefix##_getLib();
[-] 		jnc_Module_addSource (module, lib, fileName, sourceVar, sizeof (sourceVar) - 1);
[+] 		jnc_Module_addSource(module, lib, fileName, sourceVar, sizeof(sourceVar) - 1);
[-] 		jnc_Module_addImport (module, fileName);
[+] 		jnc_Module_addImport(module, fileName);
[-] 	LibPrefix##_addOpaqueClassTypeInfos (jnc_Module* module) \
[+] 	LibPrefix##_addOpaqueClassTypeInfos(jnc_Module* module) \
[-] 			TypePrefix##_getQualifiedName (), \
[+] 			TypePrefix##_getQualifiedName(), \
[-] 			TypePrefix##_getOpaqueClassTypeInfo () \
[+] 			TypePrefix##_getOpaqueClassTypeInfo() \
[-] 	LibPrefix##_mapAddresses (jnc_Module* module) \
[+] 	LibPrefix##_mapAddresses(jnc_Module* module) \
[-] 		jnc_GlobalNamespace* global = jnc_Module_getGlobalNamespace (module); \
[+] 		jnc_GlobalNamespace* global = jnc_Module_getGlobalNamespace(module); \
[-] 		jnc_Namespace* nspace = jnc_ModuleItem_getNamespace ((jnc_ModuleItem*) global); \
[+] 		jnc_Namespace* nspace = jnc_ModuleItem_getNamespace((jnc_ModuleItem*)global); \
[-] 	TypePrefix##_getQualifiedName (); \
[+] 	TypePrefix##_getQualifiedName(); \
[-] 	TypePrefix##_getType (jnc_Module* module); \
[+] 	TypePrefix##_getType(jnc_Module* module); \
[-] 	TypePrefix##_getVTable ();
[+] 	TypePrefix##_getVTable();
[-] 	JNC_DECLARE_CLASS_TYPE (TypePrefix) \
[+] 	JNC_DECLARE_CLASS_TYPE(TypePrefix) \
[-] 	TypePrefix##_getOpaqueClassTypeInfo ();
[+] 	TypePrefix##_getOpaqueClassTypeInfo();
[-] 	TypePrefix##_getQualifiedName () \
[+] 	TypePrefix##_getQualifiedName() \
[-] 	TypePrefix##_getType (jnc_Module* module) \
[+] 	TypePrefix##_getType(jnc_Module* module) \
[-] 		jnc_ModuleItem* item = jnc_Module_findItem (module, qualifiedName, &(libGuid), cacheSlot); \
[+] 		jnc_ModuleItem* item = jnc_Module_findItem(module, qualifiedName, &(libGuid), cacheSlot); \
[-] 		return item ? verify (item, qualifiedName) : NULL; \
[+] 		return item ? verify(item, qualifiedName) : NULL; \
[-] 	JNC_DEFINE_CLASS_TYPE (TypePrefix, qualifiedName, libGuid, cacheSlot) \
[+] 	JNC_DEFINE_CLASS_TYPE(TypePrefix, qualifiedName, libGuid, cacheSlot) \
[-] 	TypePrefix##_getOpaqueClassTypeInfo () \
[+] 	TypePrefix##_getOpaqueClassTypeInfo() \
[-] 			sizeof (Type), \
[+] 			sizeof(Type), \
[-] 			(jnc_MarkOpaqueGcRootsFunc*) jnc_pvoid_cast (markOpaqueGcRootsFunc), \
[+] 			(jnc_MarkOpaqueGcRootsFunc*)jnc_pvoid_cast(markOpaqueGcRootsFunc), \
[-] 	JNC_DEFINE_OPAQUE_CLASS_TYPE_EX (TypePrefix, qualifiedName, libGuid, cacheSlot, Type, markOpaqueGcRootsFunc, 0)
[+] 	JNC_DEFINE_OPAQUE_CLASS_TYPE_EX(TypePrefix, qualifiedName, libGuid, cacheSlot, Type, markOpaqueGcRootsFunc, 0)
[-] 	JNC_DEFINE_OPAQUE_CLASS_TYPE_EX (TypePrefix, qualifiedName, libGuid, cacheSlot, Type, markOpaqueGcRootsFunc, 1)
[+] 	JNC_DEFINE_OPAQUE_CLASS_TYPE_EX(TypePrefix, qualifiedName, libGuid, cacheSlot, Type, markOpaqueGcRootsFunc, 1)
[-] 	getQualifiedName () \
[+] 	getQualifiedName() \
[-] 		return TypePrefix##_getQualifiedName (); \
[+] 		return TypePrefix##_getQualifiedName(); \
[-] 	getType (jnc::Module* module) \
[+] 	getType(jnc::Module* module) \
[-] 		return TypePrefix##_getType (module); \
[+] 		return TypePrefix##_getType(module); \
[-] 		return TypePrefix##_mapAddresses (module, isRequired) != 0; \
[+] 		return TypePrefix##_mapAddresses(module, isRequired) != 0; \
[-] 	getVTable () \
[+] 	getVTable() \
[-] 		return TypePrefix##_getVTable (); \
[+] 		return TypePrefix##_getVTable(); \
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (TypePrefix) \
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(TypePrefix) \
[-] 	getOpaqueClassTypeInfo () \
[+] 	getOpaqueClassTypeInfo() \
[-] 		return TypePrefix##_getOpaqueClassTypeInfo (); \
[+] 		return TypePrefix##_getOpaqueClassTypeInfo(); \
[-] 	TypePrefix##_getVTable () \
[+] 	TypePrefix##_getVTable() \
[-] 		static const void* const vtable [] = \
[+] 		static const void* const vtable[] = \
[-] 			jnc_pvoid_cast (function),
[+] 			jnc_pvoid_cast(function),
[-] 		jnc_DerivableType* type = (jnc_DerivableType*) TypePrefix##_getType (module); \
[+] 		jnc_DerivableType* type = (jnc_DerivableType*)TypePrefix##_getType(module); \
[-] 		nspace = jnc_ModuleItem_getNamespace ((jnc_ModuleItem*) type);
[+] 		nspace = jnc_ModuleItem_getNamespace((jnc_ModuleItem*)type);
[-] 	result = TypePrefix##_mapAddresses (module, isRequired); \
[+] 	result = TypePrefix##_mapAddresses(module, isRequired); \
[-] 	result = jnc_Module_mapFunction (module, function, jnc_pvoid_cast (p)); \
[+] 	result = jnc_Module_mapFunction(module, function, jnc_pvoid_cast(p)); \
[-] 		jnc_Function* overload = jnc_Function_getOverload (function, ++overloadIdx); \
[+] 		jnc_Function* overload = jnc_Function_getOverload(function, ++overloadIdx); \
[-] 		JNC_MAP_FUNCTION_IMPL (overload, p) \
[+] 		JNC_MAP_FUNCTION_IMPL(overload, p) \
[-] 	function = jnc_DerivableType_getPreconstructor (type); \
[+] 	function = jnc_DerivableType_getPreconstructor(type); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getConstructor (type); \
[+] 	function = jnc_DerivableType_getConstructor(type); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getDestructor (type); \
[+] 	function = jnc_DerivableType_getDestructor(type); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getUnaryOperator (type, opKind); \
[+] 	function = jnc_DerivableType_getUnaryOperator(type, opKind); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getBinaryOperator (type, opKind); \
[+] 	function = jnc_DerivableType_getBinaryOperator(type, opKind); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getCallOperator (); \
[+] 	function = jnc_DerivableType_getCallOperator(); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_DerivableType_getCastOperator (i); \
[+] 	function = jnc_DerivableType_getCastOperator(i); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p)
[+] 	JNC_MAP_FUNCTION_IMPL(function, p)
[-] 	function = jnc_Namespace_findFunction (nspace, name, 1); \
[+] 	function = jnc_Namespace_findFunction(nspace, name, 1); \
[-] 		JNC_MAP_FUNCTION_IMPL (function, p) \
[+] 		JNC_MAP_FUNCTION_IMPL(function, p) \
[-] 	function = jnc_Property_getGetter (prop); \
[+] 	function = jnc_Property_getGetter(prop); \
[-] 	JNC_ASSERT (function); \
[+] 	JNC_ASSERT(function); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p);
[+] 	JNC_MAP_FUNCTION_IMPL(function, p);
[-] 	function = jnc_Property_getSetter (prop); \
[+] 	function = jnc_Property_getSetter(prop); \
[-] 	JNC_MAP_FUNCTION_IMPL (function, p);
[+] 	JNC_MAP_FUNCTION_IMPL(function, p);
[-] 	prop = jnc_Namespace_findProperty (nspace, name, 1); \
[+] 	prop = jnc_Namespace_findProperty(nspace, name, 1); \
[-] 	JNC_MAP_PROPERTY_GETTER (prop, getter); \
[+] 	JNC_MAP_PROPERTY_GETTER(prop, getter); \
[-] 	JNC_MAP_PROPERTY_SETTER (prop, setter);
[+] 	JNC_MAP_PROPERTY_SETTER(prop, setter);
[-] 	prop = jnc_Namespace_findProperty (nspace, name, 1); \
[+] 	prop = jnc_Namespace_findProperty(nspace, name, 1); \
[-] 	JNC_MAP_PROPERTY_GETTER (prop, getter);
[+] 	JNC_MAP_PROPERTY_GETTER(prop, getter);
[-] 	prop = jnc_Namespace_findProperty (nspace, name, 1); \
[+] 	prop = jnc_Namespace_findProperty(nspace, name, 1); \
[-] 	JNC_MAP_PROPERTY_SETTER (prop, setter);
[+] 	JNC_MAP_PROPERTY_SETTER(prop, setter);
[-] 	variable = jnc_Namespace_findVariable (nspace, name, 1); \
[+] 	variable = jnc_Namespace_findVariable(nspace, name, 1); \
[-] 	result = jnc_Module_mapVariable (module, variable, p); \
[+] 	result = jnc_Module_mapVariable(module, variable, p); \
[-] JNC_DECLARE_LIB (jnc_CoreLib)
[+] JNC_DECLARE_LIB(jnc_CoreLib)
[-] JNC_DECLARE_LIB (jnc_StdLib)
[+] JNC_DECLARE_LIB(jnc_StdLib)
[-] JNC_DECLARE_LIB (jnc_SysLib)
[+] JNC_DECLARE_LIB(jnc_SysLib)
[-] jnc_StdLib_StdInputFunc (
[+] jnc_StdLib_StdInputFunc(
[-] jnc_StdLib_StdOutputFunc (
[+] jnc_StdLib_StdOutputFunc(
[-] jnc_StdLib_setStdIo (
[+] jnc_StdLib_setStdIo(
[-] jnc_pvoid_cast (T x)
[+] jnc_pvoid_cast(T x)
[-] 	JNC_ASSERT (sizeof (x) == sizeof (void*) || sizeof (x) == sizeof (void*) * 2);
[+] 	JNC_ASSERT(sizeof(x) == sizeof(void*) || sizeof(x) == sizeof(void*)* 2);
[-] jnc_pvoid_cast (int x)
[+] jnc_pvoid_cast(int x)
[-] 	return (void*) (intptr_t) x;
[+] 	return (void*)(intptr_t)x;
[-] 	char m_tailPadding [sizeof (T) - offsetof (TailPaddingCheck, m_field)];
[+] 	char m_tailPadding[sizeof(T) - offsetof(TailPaddingCheck, m_field)];
[-] StdLib_getLib ()
[+] StdLib_getLib()
[-] 	return jnc_StdLib_getLib ();
[+] 	return jnc_StdLib_getLib();
[-] SysLib_getLib ()
[+] SysLib_getLib()
[-] 	return jnc_SysLib_getLib ();
[+] 	return jnc_SysLib_getLib();
[-] StdLib_setStdIo (
[+] StdLib_setStdIo(
[-] 	jnc_StdLib_setStdIo (getsFunc, printOutFunc, printErrFunc);
[+] 	jnc_StdLib_setStdIo(getsFunc, printOutFunc, printErrFunc);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Function.h
----------------------
[-] 	Use functions from the :ref:`Function <cid-function>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Function<cid-function>` to access and manage the contents of this structure.
[-] jnc_getFunctionKindString (jnc_FunctionKind functionKind);
[+] jnc_getFunctionKindString(jnc_FunctionKind functionKind);
[-] jnc_getFunctionKindFlags (jnc_FunctionKind functionKind);
[+] jnc_getFunctionKindFlags(jnc_FunctionKind functionKind);
[-] jnc_Function_getFunctionKind (jnc_Function* function);
[+] jnc_Function_getFunctionKind(jnc_Function* function);
[-] jnc_Function_getType (jnc_Function* function)
[+] jnc_Function_getType(jnc_Function* function)
[-] 	return (jnc_FunctionType*) jnc_ModuleItem_getType ((jnc_ModuleItem*) function);
[+] 	return (jnc_FunctionType*)jnc_ModuleItem_getType((jnc_ModuleItem*)function);
[-] jnc_Function_isMember (jnc_Function* function);
[+] jnc_Function_isMember(jnc_Function* function);
[-] jnc_Function_isOverloaded (jnc_Function* function);
[+] jnc_Function_isOverloaded(jnc_Function* function);
[-] jnc_Function_getOverloadCount (jnc_Function* function);
[+] jnc_Function_getOverloadCount(jnc_Function* function);
[-] jnc_Function_getOverload (
[+] jnc_Function_getOverload(
[-] jnc_Function_getMachineCode (jnc_Function* function);
[+] jnc_Function_getMachineCode(jnc_Function* function);
[-] 	getFunctionKind ()
[+] 	getFunctionKind()
[-] 		return jnc_Function_getFunctionKind (this);
[+] 		return jnc_Function_getFunctionKind(this);
[-] 	getType ()
[+] 	getType()
[-] 		return jnc_Function_getType (this);
[+] 		return jnc_Function_getType(this);
[-] 	isMember ()
[+] 	isMember()
[-] 		return jnc_Function_isMember (this) != 0;
[+] 		return jnc_Function_isMember(this) != 0;
[-] 	isOverloaded ()
[+] 	isOverloaded()
[-] 		return jnc_Function_isOverloaded (this) != 0;
[+] 		return jnc_Function_isOverloaded(this) != 0;
[-] 	getOverloadCount ()
[+] 	getOverloadCount()
[-] 		return jnc_Function_getOverloadCount (this);
[+] 		return jnc_Function_getOverloadCount(this);
[-] 	getOverload (size_t index)
[+] 	getOverload(size_t index)
[-] 		return jnc_Function_getOverload (this, index);
[+] 		return jnc_Function_getOverload(this, index);
[-] 	getMachineCode ()
[+] 	getMachineCode()
[-] 		return jnc_Function_getMachineCode (this);
[+] 		return jnc_Function_getMachineCode(this);
[-] getFunctionKindString (FunctionKind functionKind)
[+] getFunctionKindString(FunctionKind functionKind)
[-] 	return jnc_getFunctionKindString (functionKind);
[+] 	return jnc_getFunctionKindString(functionKind);
[-] getFunctionKindFlags (FunctionKind functionKind)
[+] getFunctionKindFlags(FunctionKind functionKind)
[-] 	return jnc_getFunctionKindFlags (functionKind);
[+] 	return jnc_getFunctionKindFlags(functionKind);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_FunctionType.h
----------------------
[-] jnc_getFunctionTypeFlagString (jnc_FunctionTypeFlag flag);
[+] jnc_getFunctionTypeFlagString(jnc_FunctionTypeFlag flag);
[-] jnc_getFunctionPtrTypeKindString (jnc_FunctionPtrTypeKind ptrTypeKind);
[+] jnc_getFunctionPtrTypeKindString(jnc_FunctionPtrTypeKind ptrTypeKind);
[-] jnc_FunctionArg_hasDefaultValue (jnc_FunctionArg* arg);
[+] jnc_FunctionArg_hasDefaultValue(jnc_FunctionArg* arg);
[-] jnc_FunctionArg_getDefaultValueString_v (jnc_FunctionArg* arg);
[+] jnc_FunctionArg_getDefaultValueString_v(jnc_FunctionArg* arg);
[-] 	hasDefaultValue ()
[+] 	hasDefaultValue()
[-] 		return jnc_FunctionArg_hasDefaultValue (this) != 0;
[+] 		return jnc_FunctionArg_hasDefaultValue(this) != 0;
[-] 	getDefaultValueString ()
[+] 	getDefaultValueString()
[-] 		return jnc_FunctionArg_getDefaultValueString_v (this);
[+] 		return jnc_FunctionArg_getDefaultValueString_v(this);
[-] jnc_FunctionType_getReturnType (jnc_FunctionType* type);
[+] jnc_FunctionType_getReturnType(jnc_FunctionType* type);
[-] jnc_FunctionType_getArgCount (jnc_FunctionType* type);
[+] jnc_FunctionType_getArgCount(jnc_FunctionType* type);
[-] jnc_FunctionType_getArg (
[+] jnc_FunctionType_getArg(
[-] jnc_FunctionType_getFunctionPtrType (
[+] jnc_FunctionType_getFunctionPtrType(
[-] jnc_FunctionType_getShortType (jnc_FunctionType* type);
[+] jnc_FunctionType_getShortType(jnc_FunctionType* type);
[-] 	getReturnType ()
[+] 	getReturnType()
[-] 		return jnc_FunctionType_getReturnType (this);
[+] 		return jnc_FunctionType_getReturnType(this);
[-] 	getArgCount ()
[+] 	getArgCount()
[-] 		return jnc_FunctionType_getArgCount (this);
[+] 		return jnc_FunctionType_getArgCount(this);
[-] 	getArg (size_t index)
[+] 	getArg(size_t index)
[-] 		return jnc_FunctionType_getArg (this, index);
[+] 		return jnc_FunctionType_getArg(this, index);
[-] 	getFunctionPtrType (
[+] 	getFunctionPtrType(
[-] 		return jnc_FunctionType_getFunctionPtrType (this, ptrTypeKind, flags);
[+] 		return jnc_FunctionType_getFunctionPtrType(this, ptrTypeKind, flags);
[-] 	getShortType ()
[+] 	getShortType()
[-] 		return jnc_FunctionType_getShortType (this);
[+] 		return jnc_FunctionType_getShortType(this);
[-] jnc_FunctionPtrType_getPtrTypeKind (jnc_FunctionPtrType* type);
[+] jnc_FunctionPtrType_getPtrTypeKind(jnc_FunctionPtrType* type);
[-] jnc_FunctionPtrType_getTargetType (jnc_FunctionPtrType* type);
[+] jnc_FunctionPtrType_getTargetType(jnc_FunctionPtrType* type);
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 		return jnc_FunctionPtrType_getPtrTypeKind (this);
[+] 		return jnc_FunctionPtrType_getPtrTypeKind(this);
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 		return jnc_FunctionPtrType_getTargetType (this);
[+] 		return jnc_FunctionPtrType_getTargetType(this);
[-] getFunctionTypeFlagString (jnc_FunctionTypeFlag flag)
[+] getFunctionTypeFlagString(jnc_FunctionTypeFlag flag)
[-] 	return jnc_getFunctionTypeFlagString (flag);
[+] 	return jnc_getFunctionTypeFlagString(flag);
[-] getFunctionPtrTypeKindString (jnc_FunctionPtrTypeKind ptrTypeKind)
[+] getFunctionPtrTypeKindString(jnc_FunctionPtrTypeKind ptrTypeKind)
[-] 	return jnc_getFunctionPtrTypeKindString (ptrTypeKind);
[+] 	return jnc_getFunctionPtrTypeKindString(ptrTypeKind);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_GcHeap.h
----------------------
[-] 	Use functions from the :ref:`Garbage-Collected Heap <cid-gc-heap>` group to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Garbage-Collected Heap<cid-gc-heap>` group to access and manage the contents of this structure.
[-] jnc_GcHeap_getRuntime (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_getRuntime(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_getStats (
[+] jnc_GcHeap_getStats(
[-] jnc_GcHeap_getSizeTriggers (
[+] jnc_GcHeap_getSizeTriggers(
[-] jnc_GcHeap_setSizeTriggers (
[+] jnc_GcHeap_setSizeTriggers(
[-] jnc_GcHeap_getStats (
[+] jnc_GcHeap_getStats(
[-] jnc_GcHeap_collect (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_collect(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_enterNoCollectRegion (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_enterNoCollectRegion(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_leaveNoCollectRegion (
[+] jnc_GcHeap_leaveNoCollectRegion(
[-] jnc_GcHeap_enterWaitRegion (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_enterWaitRegion(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_leaveWaitRegion (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_leaveWaitRegion(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_safePoint (jnc_GcHeap* gcHeap);
[+] jnc_GcHeap_safePoint(jnc_GcHeap* gcHeap);
[-] jnc_GcHeap_setFrameMap (
[+] jnc_GcHeap_setFrameMap(
[-] jnc_GcHeap_addStaticDestructor (
[+] jnc_GcHeap_addStaticDestructor(
[-] jnc_GcHeap_addStaticClassDestructor (
[+] jnc_GcHeap_addStaticClassDestructor(
[-] jnc_GcHeap_addStaticRoot (
[+] jnc_GcHeap_addStaticRoot(
[-] jnc_GcHeap_allocateClass (
[+] jnc_GcHeap_allocateClass(
[-] jnc_GcHeap_tryAllocateClass (
[+] jnc_GcHeap_tryAllocateClass(
[-] jnc_GcHeap_allocateData (
[+] jnc_GcHeap_allocateData(
[-] jnc_GcHeap_tryAllocateData (
[+] jnc_GcHeap_tryAllocateData(
[-] jnc_GcHeap_allocateArray (
[+] jnc_GcHeap_allocateArray(
[-] jnc_GcHeap_tryAllocateArray (
[+] jnc_GcHeap_tryAllocateArray(
[-] jnc_GcHeap_allocateBuffer (
[+] jnc_GcHeap_allocateBuffer(
[-] jnc_GcHeap_tryAllocateBuffer (
[+] jnc_GcHeap_tryAllocateBuffer(
[-] jnc_GcHeap_createDataPtrValidator (
[+] jnc_GcHeap_createDataPtrValidator(
[-] jnc_GcHeap_getDynamicLayout (
[+] jnc_GcHeap_getDynamicLayout(
[-] jnc_GcHeap_resetDynamicLayout (
[+] jnc_GcHeap_resetDynamicLayout(
[-] jnc_GcHeap_weakMark (
[+] jnc_GcHeap_weakMark(
[-] jnc_GcHeap_markData (
[+] jnc_GcHeap_markData(
[-] jnc_GcHeap_markClass (
[+] jnc_GcHeap_markClass(
[-] jnc_GcHeap_addRoot (
[+] jnc_GcHeap_addRoot(
[-] jnc_GcHeap_addBoxToCallSite (jnc_Box* box);
[+] jnc_GcHeap_addBoxToCallSite(jnc_Box* box);
[-] 	getRuntime ()
[+] 	getRuntime()
[-] 		return jnc_GcHeap_getRuntime (this);
[+] 		return jnc_GcHeap_getRuntime(this);
[-] 	getSizeTriggers (jnc_GcSizeTriggers* triggers)
[+] 	getSizeTriggers(jnc_GcSizeTriggers* triggers)
[-] 		jnc_GcHeap_getSizeTriggers (this, triggers);
[+] 		jnc_GcHeap_getSizeTriggers(this, triggers);
[-] 	setSizeTriggers (const jnc_GcSizeTriggers* triggers)
[+] 	setSizeTriggers(const jnc_GcSizeTriggers* triggers)
[-] 		jnc_GcHeap_setSizeTriggers (this, triggers);
[+] 		jnc_GcHeap_setSizeTriggers(this, triggers);
[-] 	getStats (jnc_GcStats* stats)
[+] 	getStats(jnc_GcStats* stats)
[-] 		jnc_GcHeap_getStats (this, stats);
[+] 		jnc_GcHeap_getStats(this, stats);
[-] 	collect ()
[+] 	collect()
[-] 		jnc_GcHeap_collect (this);
[+] 		jnc_GcHeap_collect(this);
[-] 	enterNoCollectRegion ()
[+] 	enterNoCollectRegion()
[-] 		jnc_GcHeap_enterNoCollectRegion (this);
[+] 		jnc_GcHeap_enterNoCollectRegion(this);
[-] 	leaveNoCollectRegion (bool canCollectNow = true)
[+] 	leaveNoCollectRegion(bool canCollectNow = true)
[-] 		jnc_GcHeap_leaveNoCollectRegion (this, canCollectNow);
[+] 		jnc_GcHeap_leaveNoCollectRegion(this, canCollectNow);
[-] 	enterWaitRegion ()
[+] 	enterWaitRegion()
[-] 		jnc_GcHeap_enterWaitRegion (this);
[+] 		jnc_GcHeap_enterWaitRegion(this);
[-] 	leaveWaitRegion ()
[+] 	leaveWaitRegion()
[-] 		jnc_GcHeap_leaveWaitRegion (this);
[+] 		jnc_GcHeap_leaveWaitRegion(this);
[-] 	safePoint ()
[+] 	safePoint()
[-] 		jnc_GcHeap_safePoint (this);
[+] 		jnc_GcHeap_safePoint(this);
[-] 	setFrameMap (
[+] 	setFrameMap(
[-] 		jnc_GcHeap_setFrameMap (this, frame, map, op);
[+] 		jnc_GcHeap_setFrameMap(this, frame, map, op);
[-] 	addStaticDestructor (jnc_StaticDestructFunc* destructFunc)
[+] 	addStaticDestructor(jnc_StaticDestructFunc* destructFunc)
[-] 		jnc_GcHeap_addStaticDestructor (this, destructFunc);
[+] 		jnc_GcHeap_addStaticDestructor(this, destructFunc);
[-] 	addStaticClassDestructor (
[+] 	addStaticClassDestructor(
[-] 		jnc_GcHeap_addStaticClassDestructor (this, destructFunc, iface);
[+] 		jnc_GcHeap_addStaticClassDestructor(this, destructFunc, iface);
[-] 	addStaticRoot (
[+] 	addStaticRoot(
[-] 		jnc_GcHeap_addStaticRoot (this, p, type);
[+] 		jnc_GcHeap_addStaticRoot(this, p, type);
[-] 	allocateClass (jnc_ClassType* type)
[+] 	allocateClass(jnc_ClassType* type)
[-] 		return jnc_GcHeap_allocateClass (this, type);
[+] 		return jnc_GcHeap_allocateClass(this, type);
[-] 	tryAllocateClass (jnc_ClassType* type)
[+] 	tryAllocateClass(jnc_ClassType* type)
[-] 		return jnc_GcHeap_tryAllocateClass (this, type);
[+] 		return jnc_GcHeap_tryAllocateClass(this, type);
[-] 	allocateData (jnc_Type* type)
[+] 	allocateData(jnc_Type* type)
[-] 		return jnc_GcHeap_allocateData (this, type);
[+] 		return jnc_GcHeap_allocateData(this, type);
[-] 	tryAllocateData (jnc_Type* type)
[+] 	tryAllocateData(jnc_Type* type)
[-] 		return jnc_GcHeap_tryAllocateData (this, type);
[+] 		return jnc_GcHeap_tryAllocateData(this, type);
[-] 	allocateArray (
[+] 	allocateArray(
[-] 		return jnc_GcHeap_allocateArray (this, type, count);
[+] 		return jnc_GcHeap_allocateArray(this, type, count);
[-] 	tryAllocateArray (
[+] 	tryAllocateArray(
[-] 		return jnc_GcHeap_tryAllocateArray (this, type, count);
[+] 		return jnc_GcHeap_tryAllocateArray(this, type, count);
[-] 	allocateBuffer (size_t size)
[+] 	allocateBuffer(size_t size)
[-] 		return jnc_GcHeap_allocateBuffer (this, size);
[+] 		return jnc_GcHeap_allocateBuffer(this, size);
[-] 	tryAllocateBuffer (size_t size)
[+] 	tryAllocateBuffer(size_t size)
[-] 		return jnc_GcHeap_tryAllocateBuffer (this, size);
[+] 		return jnc_GcHeap_tryAllocateBuffer(this, size);
[-] 	createDataPtrValidator (
[+] 	createDataPtrValidator(
[-] 		return jnc_GcHeap_createDataPtrValidator (this, box, rangeBegin, rangeLength);
[+] 		return jnc_GcHeap_createDataPtrValidator(this, box, rangeBegin, rangeLength);
[-] 	getDynamicLayout (jnc_Box* box)
[+] 	getDynamicLayout(jnc_Box* box)
[-] 		return jnc_GcHeap_getDynamicLayout (this, box);
[+] 		return jnc_GcHeap_getDynamicLayout(this, box);
[-] 	resetDynamicLayout (jnc_Box* box)
[+] 	resetDynamicLayout(jnc_Box* box)
[-] 		jnc_GcHeap_resetDynamicLayout (this, box);
[+] 		jnc_GcHeap_resetDynamicLayout(this, box);
[-] 	weakMark (jnc_Box* box)
[+] 	weakMark(jnc_Box* box)
[-] 		jnc_GcHeap_weakMark (this, box);
[+] 		jnc_GcHeap_weakMark(this, box);
[-] 	markData (jnc_Box* box)
[+] 	markData(jnc_Box* box)
[-] 		jnc_GcHeap_markData (this, box);
[+] 		jnc_GcHeap_markData(this, box);
[-] 	markClass (jnc_Box* box)
[+] 	markClass(jnc_Box* box)
[-] 		jnc_GcHeap_markClass (this, box);
[+] 		jnc_GcHeap_markClass(this, box);
[-] 	addRoot (
[+] 	addRoot(
[-] 		jnc_GcHeap_addRoot (this, p, type);
[+] 		jnc_GcHeap_addRoot(this, p, type);
[-] 	addBoxToCallSite (jnc_Box* box)
[+] 	addBoxToCallSite(jnc_Box* box)
[-] 		jnc_GcHeap_addBoxToCallSite (box);
[+] 		jnc_GcHeap_addBoxToCallSite(box);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Module.h
----------------------
[-] 	Use functions from the :ref:`Module <cid-module>` group to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Module<cid-module>` group to access and manage the contents of this structure.
[-] jnc_Module_create ();
[+] jnc_Module_create();
[-] jnc_Module_destroy (jnc_Module* module);
[+] jnc_Module_destroy(jnc_Module* module);
[-] jnc_Module_clear (jnc_Module* module);
[+] jnc_Module_clear(jnc_Module* module);
[-] jnc_Module_initialize (
[+] jnc_Module_initialize(
[-] jnc_Module_getCompileFlags (jnc_Module* module);
[+] jnc_Module_getCompileFlags(jnc_Module* module);
[-] jnc_Module_getCompileState (jnc_Module* module);
[+] jnc_Module_getCompileState(jnc_Module* module);
[-] jnc_Module_getGlobalNamespace (jnc_Module* module);
[+] jnc_Module_getGlobalNamespace(jnc_Module* module);
[-] jnc_Module_getPrimitiveType (
[+] jnc_Module_getPrimitiveType(
[-] jnc_Module_getStdType (
[+] jnc_Module_getStdType(
[-] jnc_Module_findItem (
[+] jnc_Module_findItem(
[-] jnc_Module_mapVariable (
[+] jnc_Module_mapVariable(
[-] jnc_Module_mapFunction (
[+] jnc_Module_mapFunction(
[-] jnc_Module_addSource (
[+] jnc_Module_addSource(
[-] jnc_Module_addImportDir (
[+] jnc_Module_addImportDir(
[-] jnc_Module_addImport (
[+] jnc_Module_addImport(
[-] jnc_Module_addIgnoredImport (
[+] jnc_Module_addIgnoredImport(
[-] jnc_Module_addOpaqueClassTypeInfo (
[+] jnc_Module_addOpaqueClassTypeInfo(
[-] jnc_Module_addStaticLib (
[+] jnc_Module_addStaticLib(
[-] jnc_Module_parse (
[+] jnc_Module_parse(
[-] jnc_Module_parseFile (
[+] jnc_Module_parseFile(
[-] jnc_Module_parseImports (jnc_Module* module);
[+] jnc_Module_parseImports(jnc_Module* module);
[-] jnc_Module_link (jnc_Module* module);
[+] jnc_Module_link(jnc_Module* module);
[-] jnc_Module_calcLayout (jnc_Module* module);
[+] jnc_Module_calcLayout(jnc_Module* module);
[-] jnc_Module_compile (jnc_Module* module);
[+] jnc_Module_compile(jnc_Module* module);
[-] jnc_Module_jit (jnc_Module* module);
[+] jnc_Module_jit(jnc_Module* module);
[-] jnc_Module_generateDocumentation (
[+] jnc_Module_generateDocumentation(
[-] jnc_Module_getLlvmIrString_v (jnc_Module* module);
[+] jnc_Module_getLlvmIrString_v(jnc_Module* module);
[-] 	create ()
[+] 	create()
[-] 		return jnc_Module_create ();
[+] 		return jnc_Module_create();
[-] 	destroy ()
[+] 	destroy()
[-] 		jnc_Module_destroy (this);
[+] 		jnc_Module_destroy(this);
[-] 	clear ()
[+] 	clear()
[-] 		jnc_Module_clear (this);
[+] 		jnc_Module_clear(this);
[-] 	initialize (
[+] 	initialize(
[-] 		jnc_Module_initialize (this, tag, compileFlags);
[+] 		jnc_Module_initialize(this, tag, compileFlags);
[-] 	getCompileFlags ()
[+] 	getCompileFlags()
[-] 		return jnc_Module_getCompileFlags (this);
[+] 		return jnc_Module_getCompileFlags(this);
[-] 	getCompileState ()
[+] 	getCompileState()
[-] 		return jnc_Module_getCompileState (this);
[+] 		return jnc_Module_getCompileState(this);
[-] 	getGlobalNamespace ()
[+] 	getGlobalNamespace()
[-] 		return jnc_Module_getGlobalNamespace (this);
[+] 		return jnc_Module_getGlobalNamespace(this);
[-] 	getPrimitiveType (jnc_TypeKind typeKind)
[+] 	getPrimitiveType(jnc_TypeKind typeKind)
[-] 		return jnc_Module_getPrimitiveType (this, typeKind);
[+] 		return jnc_Module_getPrimitiveType(this, typeKind);
[-] 	getStdType (jnc_StdType stdType)
[+] 	getStdType(jnc_StdType stdType)
[-] 		return jnc_Module_getStdType (this, stdType);
[+] 		return jnc_Module_getStdType(this, stdType);
[-] 	findItem (
[+] 	findItem(
[-] 		return jnc_Module_findItem (this, name, libGuid, itemCacheSlot);
[+] 		return jnc_Module_findItem(this, name, libGuid, itemCacheSlot);
[-] 	mapVariable (
[+] 	mapVariable(
[-] 		return jnc_Module_mapVariable (this, variable, p) != 0;
[+] 		return jnc_Module_mapVariable(this, variable, p) != 0;
[-] 	mapFunction (
[+] 	mapFunction(
[-] 		return jnc_Module_mapFunction (this, function, p) != 0;
[+] 		return jnc_Module_mapFunction(this, function, p) != 0;
[-] 	addSource (
[+] 	addSource(
[-] 		jnc_Module_addSource (this, lib, fileName, source, length);
[+] 		jnc_Module_addSource(this, lib, fileName, source, length);
[-] 	addImportDir (const char* dir)
[+] 	addImportDir(const char* dir)
[-] 		jnc_Module_addImportDir (this, dir);
[+] 		jnc_Module_addImportDir(this, dir);
[-] 	addImport (const char* fileName)
[+] 	addImport(const char* fileName)
[-] 		jnc_Module_addImport (this, fileName);
[+] 		jnc_Module_addImport(this, fileName);
[-] 	addIgnoredImport (const char* fileName)
[+] 	addIgnoredImport(const char* fileName)
[-] 		jnc_Module_addIgnoredImport (this, fileName);
[+] 		jnc_Module_addIgnoredImport(this, fileName);
[-] 	addOpaqueClassTypeInfo (
[+] 	addOpaqueClassTypeInfo(
[-] 		jnc_Module_addOpaqueClassTypeInfo (this, qualifiedName, info);
[+] 		jnc_Module_addOpaqueClassTypeInfo(this, qualifiedName, info);
[-] 	addStaticLib (jnc_ExtensionLib* lib)
[+] 	addStaticLib(jnc_ExtensionLib* lib)
[-] 		jnc_Module_addStaticLib (this, lib);
[+] 		jnc_Module_addStaticLib(this, lib);
[-] 	parse (
[+] 	parse(
[-] 		return jnc_Module_parse (this, lib, fileName, source, length) != 0;
[+] 		return jnc_Module_parse(this, lib, fileName, source, length) != 0;
[-] 	parse (
[+] 	parse(
[-] 		return jnc_Module_parse (this, NULL, fileName, source, length) != 0;
[+] 		return jnc_Module_parse(this, NULL, fileName, source, length) != 0;
[-] 	parseFile (const char* fileName)
[+] 	parseFile(const char* fileName)
[-] 		return jnc_Module_parseFile (this, fileName) != 0;
[+] 		return jnc_Module_parseFile(this, fileName) != 0;
[-] 	parseImports ()
[+] 	parseImports()
[-] 		return jnc_Module_parseImports (this) != 0;
[+] 		return jnc_Module_parseImports(this) != 0;
[-] 	link ()
[+] 	link()
[-] 		return jnc_Module_link (this) != 0;
[+] 		return jnc_Module_link(this) != 0;
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 		return jnc_Module_calcLayout (this) != 0;
[+] 		return jnc_Module_calcLayout(this) != 0;
[-] 	compile ()
[+] 	compile()
[-] 		return jnc_Module_compile (this) != 0;
[+] 		return jnc_Module_compile(this) != 0;
[-] 	jit ()
[+] 	jit()
[-] 		return jnc_Module_jit (this) != 0;
[+] 		return jnc_Module_jit(this) != 0;
[-] 	getLlvmIrString_v ()
[+] 	getLlvmIrString_v()
[-] 		return jnc_Module_getLlvmIrString_v (this);
[+] 		return jnc_Module_getLlvmIrString_v(this);
[-] 	generateDocumentation (const char* outputDir)
[+] 	generateDocumentation(const char* outputDir)
[-] 		return jnc_Module_generateDocumentation (this, outputDir) != 0;
[+] 		return jnc_Module_generateDocumentation(this, outputDir) != 0;
[-] 	AutoModule ()
[+] 	AutoModule()
[-] 		m_module = jnc_Module_create ();
[+] 		m_module = jnc_Module_create();
[-] 	~AutoModule ()
[+] 	~AutoModule()
[-] 			jnc_Module_destroy (m_module);
[+] 			jnc_Module_destroy(m_module);
[-] 	p () const
[+] 	p() const
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_ModuleItem.h
----------------------
[-] 	Use functions from the :ref:`Module Item Declaration <cid-module-item-decl>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Module Item Declaration<cid-module-item-decl>` to access and manage the contents of this structure.
[-] jnc_getModuleItemKindString (jnc_ModuleItemKind itemKind);
[+] jnc_getModuleItemKindString(jnc_ModuleItemKind itemKind);
[-] jnc_getStorageKindString (jnc_StorageKind storageKind);
[+] jnc_getStorageKindString(jnc_StorageKind storageKind);
[-] jnc_getAccessKindString (jnc_AccessKind accessKind);
[+] jnc_getAccessKindString(jnc_AccessKind accessKind);
[-] jnc_ModuleItemDecl_getName (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getName(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getQualifiedName (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getQualifiedName(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getStorageKind (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getStorageKind(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getAccessKind (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getAccessKind(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getAttributeBlock (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getAttributeBlock(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getParentNamespace (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getParentNamespace(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getParentUnit (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getParentUnit(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getLine (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getLine(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getCol (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getCol(jnc_ModuleItemDecl* decl);
[-] jnc_ModuleItemDecl_getOffset (jnc_ModuleItemDecl* decl);
[+] jnc_ModuleItemDecl_getOffset(jnc_ModuleItemDecl* decl);
[-] 	getName ()
[+] 	getName()
[-] 		return jnc_ModuleItemDecl_getName (this);
[+] 		return jnc_ModuleItemDecl_getName(this);
[-] 	getQualifiedName ()
[+] 	getQualifiedName()
[-] 		return jnc_ModuleItemDecl_getQualifiedName (this);
[+] 		return jnc_ModuleItemDecl_getQualifiedName(this);
[-] 	getStorageKind (jnc_ModuleItemDecl* decl)
[+] 	getStorageKind(jnc_ModuleItemDecl* decl)
[-] 		return jnc_ModuleItemDecl_getStorageKind (this);
[+] 		return jnc_ModuleItemDecl_getStorageKind(this);
[-] 	getAccessKind ()
[+] 	getAccessKind()
[-] 		return jnc_ModuleItemDecl_getAccessKind (this);
[+] 		return jnc_ModuleItemDecl_getAccessKind(this);
[-] 	getAttributeBlock ()
[+] 	getAttributeBlock()
[-] 		return jnc_ModuleItemDecl_getAttributeBlock (this);
[+] 		return jnc_ModuleItemDecl_getAttributeBlock(this);
[-] 	getParentNamespace ()
[+] 	getParentNamespace()
[-] 		return jnc_ModuleItemDecl_getParentNamespace (this);
[+] 		return jnc_ModuleItemDecl_getParentNamespace(this);
[-] 	getParentUnit ()
[+] 	getParentUnit()
[-] 		return jnc_ModuleItemDecl_getParentUnit (this);
[+] 		return jnc_ModuleItemDecl_getParentUnit(this);
[-] 	getLine ()
[+] 	getLine()
[-] 		return jnc_ModuleItemDecl_getLine (this);
[+] 		return jnc_ModuleItemDecl_getLine(this);
[-] 	getCol ()
[+] 	getCol()
[-] 		return jnc_ModuleItemDecl_getCol (this);
[+] 		return jnc_ModuleItemDecl_getCol(this);
[-] 	getOffset ()
[+] 	getOffset()
[-] 		return jnc_ModuleItemDecl_getOffset (this);
[+] 		return jnc_ModuleItemDecl_getOffset(this);
[-] jnc_ModuleItem_getModule (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getModule(jnc_ModuleItem* item);
[-] jnc_ModuleItem_getItemKind (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getItemKind(jnc_ModuleItem* item);
[-] jnc_ModuleItem_getFlags (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getFlags(jnc_ModuleItem* item);
[-] jnc_ModuleItem_getDecl (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getDecl(jnc_ModuleItem* item);
[-] jnc_ModuleItem_getNamespace (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getNamespace(jnc_ModuleItem* item);
[-] jnc_ModuleItem_getType (jnc_ModuleItem* item);
[+] jnc_ModuleItem_getType(jnc_ModuleItem* item);
[-] 	getModule ()
[+] 	getModule()
[-] 		return jnc_ModuleItem_getModule (this);
[+] 		return jnc_ModuleItem_getModule(this);
[-] 	getItemKind ()
[+] 	getItemKind()
[-] 		return jnc_ModuleItem_getItemKind (this);
[+] 		return jnc_ModuleItem_getItemKind(this);
[-] 	getFlags ()
[+] 	getFlags()
[-] 		return jnc_ModuleItem_getFlags (this);
[+] 		return jnc_ModuleItem_getFlags(this);
[-] 	getDecl ()
[+] 	getDecl()
[-] 		return jnc_ModuleItem_getDecl (this);
[+] 		return jnc_ModuleItem_getDecl(this);
[-] 	getNamespace ()
[+] 	getNamespace()
[-] 		return jnc_ModuleItem_getNamespace (this);
[+] 		return jnc_ModuleItem_getNamespace(this);
[-] 	getType ()
[+] 	getType()
[-] 		return jnc_ModuleItem_getType (this);
[+] 		return jnc_ModuleItem_getType(this);
[-] jnc_verifyModuleItemIsDerivableType (
[+] jnc_verifyModuleItemIsDerivableType(
[-] jnc_verifyModuleItemIsClassType (
[+] jnc_verifyModuleItemIsClassType(
[-] getModuleItemKindString (ModuleItemKind itemKind)
[+] getModuleItemKindString(ModuleItemKind itemKind)
[-] 	return jnc_getModuleItemKindString (itemKind);
[+] 	return jnc_getModuleItemKindString(itemKind);
[-] getStorageKindString (StorageKind storageKind)
[+] getStorageKindString(StorageKind storageKind)
[-] 	return jnc_getStorageKindString (storageKind);
[+] 	return jnc_getStorageKindString(storageKind);
[-] getAccessKindString (AccessKind accessKind)
[+] getAccessKindString(AccessKind accessKind)
[-] 	return jnc_getAccessKindString (accessKind);
[+] 	return jnc_getAccessKindString(accessKind);
[-] verifyModuleItemIsDerivableType (
[+] verifyModuleItemIsDerivableType(
[-] 	return jnc_verifyModuleItemIsDerivableType (item, name);
[+] 	return jnc_verifyModuleItemIsDerivableType(item, name);
[-] verifyModuleItemIsClassType (
[+] verifyModuleItemIsClassType(
[-] 	return jnc_verifyModuleItemIsClassType (item, name);
[+] 	return jnc_verifyModuleItemIsClassType(item, name);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Namespace.h
----------------------
[-] 	Use functions from the :ref:`Namespace <cid-namespace>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Namespace<cid-namespace>` to access and manage the contents of this structure.
[-] jnc_getNamespaceKindString (jnc_NamespaceKind namespaceKind);
[+] jnc_getNamespaceKindString(jnc_NamespaceKind namespaceKind);
[-] jnc_Namespace_getItemCount (jnc_Namespace* nspace);
[+] jnc_Namespace_getItemCount(jnc_Namespace* nspace);
[-] jnc_Namespace_getItem (
[+] jnc_Namespace_getItem(
[-] jnc_Namespace_findVariable (
[+] jnc_Namespace_findVariable(
[-] jnc_Namespace_findFunction (
[+] jnc_Namespace_findFunction(
[-] jnc_Namespace_findProperty (
[+] jnc_Namespace_findProperty(
[-] jnc_Namespace_findClassType (
[+] jnc_Namespace_findClassType(
[-] 	getItemCount ()
[+] 	getItemCount()
[-] 		return jnc_Namespace_getItemCount (this);
[+] 		return jnc_Namespace_getItemCount(this);
[-] 	getItem (size_t index)
[+] 	getItem(size_t index)
[-] 		return jnc_Namespace_getItem (this, index);
[+] 		return jnc_Namespace_getItem(this, index);
[-] 	findVariable (
[+] 	findVariable(
[-] 		return jnc_Namespace_findVariable (this, name, isRequired);
[+] 		return jnc_Namespace_findVariable(this, name, isRequired);
[-] 	findFunction (
[+] 	findFunction(
[-] 		return jnc_Namespace_findFunction (this, name, isRequired);
[+] 		return jnc_Namespace_findFunction(this, name, isRequired);
[-] 	findProperty (
[+] 	findProperty(
[-] 		return jnc_Namespace_findProperty (this, name, isRequired);
[+] 		return jnc_Namespace_findProperty(this, name, isRequired);
[-] 	findClassType (
[+] 	findClassType(
[-] 		return jnc_Namespace_findClassType (this, name, isRequired);
[+] 		return jnc_Namespace_findClassType(this, name, isRequired);
[-] getNamespaceKindString (NamespaceKind namespaceKind)
[+] getNamespaceKindString(NamespaceKind namespaceKind)
[-] 	return jnc_getNamespaceKindString (namespaceKind);
[+] 	return jnc_getNamespaceKindString(namespaceKind);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_OpKind.h
----------------------
[-] jnc_getUnOpKindString (jnc_UnOpKind opKind);
[+] jnc_getUnOpKindString(jnc_UnOpKind opKind);
[-] jnc_getBinOpKindString (jnc_BinOpKind opKind);
[+] jnc_getBinOpKindString(jnc_BinOpKind opKind);
[-] getUnOpKindString (UnOpKind opKind)
[+] getUnOpKindString(UnOpKind opKind)
[-] 	return jnc_getUnOpKindString (opKind);
[+] 	return jnc_getUnOpKindString(opKind);
[-] getBinOpKindString (BinOpKind opKind)
[+] getBinOpKindString(BinOpKind opKind)
[-] 	return jnc_getBinOpKindString (opKind);
[+] 	return jnc_getBinOpKindString(opKind);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Pch.h
----------------------
[-] #	define JNC_SELECT_ANY  __declspec (selectany)
[+] #	define JNC_SELECT_ANY  __declspec(selectany)
[-] #	define JNC_EXPORT      __declspec (dllexport)
[+] #	define JNC_EXPORT      __declspec(dllexport)
[-] #		define JNC_CDECL   __attribute__ ((cdecl))
[+] #		define JNC_CDECL   __attribute__((cdecl))
[-] #		define JNC_STDCALL __attribute__ ((stdcall))
[+] #		define JNC_STDCALL __attribute__((stdcall))
[-] #	define JNC_SELECT_ANY  __attribute__ ((weak))
[+] #	define JNC_SELECT_ANY  __attribute__((weak))
[-] #	define JNC_EXPORT      __attribute__ ((visibility ("default")))
[+] #	define JNC_EXPORT      __attribute__((visibility("default")))
[-] #	define JNC_GCC_ALIGN(n) __attribute__((aligned (n)))
[+] #	define JNC_GCC_ALIGN(n) __attribute__((aligned(n)))
[-] #		if (__has_attribute (ms_struct))
[+] #		if (__has_attribute(ms_struct))
[-] #		if (__has_feature (address_sanitizer))
[+] #		if (__has_feature(address_sanitizer))
[-] #	elif (defined (__SANITIZE_ADDRESS__))
[+] #	elif (defined(__SANITIZE_ADDRESS__))
[-] 	On ``Release`` builds, this macro does nothing (expands to an empty sequence).
[+] 	On ``Release`` builds, this macro does nothing(expands to an empty sequence).
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Property.h
----------------------
[-] 	Use functions from the :ref:`Property <cid-property>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Property<cid-property>` to access and manage the contents of this structure.
[-] jnc_Property_getType (jnc_Property* prop)
[+] jnc_Property_getType(jnc_Property* prop)
[-] 	return (jnc_PropertyType*) jnc_ModuleItem_getType ((jnc_ModuleItem*) prop);
[+] 	return (jnc_PropertyType*)jnc_ModuleItem_getType((jnc_ModuleItem*)prop);
[-] jnc_Property_getGetter (jnc_Property* prop);
[+] jnc_Property_getGetter(jnc_Property* prop);
[-] jnc_Property_getSetter (jnc_Property* prop);
[+] jnc_Property_getSetter(jnc_Property* prop);
[-] 	getType ()
[+] 	getType()
[-] 		return jnc_Property_getType (this);
[+] 		return jnc_Property_getType(this);
[-] 	getGetter ()
[+] 	getGetter()
[-] 		return jnc_Property_getGetter (this);
[+] 		return jnc_Property_getGetter(this);
[-] 	getSetter ()
[+] 	getSetter()
[-] 		return jnc_Property_getSetter (this);
[+] 		return jnc_Property_getSetter(this);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_PropertyType.h
----------------------
[-] Each property in Jancy has one getter and zero or more setters. Property type has information about function type for each and every accessor (getter or setter) a property of this type provides.
[+] Each property in Jancy has one getter and zero or more setters. Property type has information about function type for each and every accessor(getter or setter) a property of this type provides.
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Runtime.h
----------------------
[-] 	Use functions from the :ref:`Runtime <cid-runtime>` group to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Runtime<cid-runtime>` group to access and manage the contents of this structure.
[-] jnc_Runtime_create ();
[+] jnc_Runtime_create();
[-] jnc_Runtime_destroy (jnc_Runtime* runtime);
[+] jnc_Runtime_destroy(jnc_Runtime* runtime);
[-] jnc_Runtime_getModule (jnc_Runtime* runtime);
[+] jnc_Runtime_getModule(jnc_Runtime* runtime);
[-] jnc_Runtime_getGcHeap (jnc_Runtime* runtime);
[+] jnc_Runtime_getGcHeap(jnc_Runtime* runtime);
[-] jnc_Runtime_isAborted (jnc_Runtime* runtime);
[+] jnc_Runtime_isAborted(jnc_Runtime* runtime);
[-] jnc_Runtime_getStackSizeLimit (jnc_Runtime* runtime);
[+] jnc_Runtime_getStackSizeLimit(jnc_Runtime* runtime);
[-] jnc_Runtime_setStackSizeLimit (
[+] jnc_Runtime_setStackSizeLimit(
[-] jnc_Runtime_startup (
[+] jnc_Runtime_startup(
[-] jnc_Runtime_shutdown (jnc_Runtime* runtime);
[+] jnc_Runtime_shutdown(jnc_Runtime* runtime);
[-] jnc_Runtime_abort (jnc_Runtime* runtime);
[+] jnc_Runtime_abort(jnc_Runtime* runtime);
[-] jnc_Runtime_initializeCallSite (
[+] jnc_Runtime_initializeCallSite(
[-] jnc_Runtime_uninitializeCallSite (
[+] jnc_Runtime_uninitializeCallSite(
[-] jnc_Runtime_setSjljFrame (
[+] jnc_Runtime_setSjljFrame(
[-] jnc_Runtime_getUserData (jnc_Runtime* runtime);
[+] jnc_Runtime_getUserData(jnc_Runtime* runtime);
[-] jnc_Runtime_setUserData (
[+] jnc_Runtime_setUserData(
[-] jnc_Runtime_checkStackOverflow (jnc_Runtime* runtime);
[+] jnc_Runtime_checkStackOverflow(jnc_Runtime* runtime);
[-] 	create ()
[+] 	create()
[-] 		return jnc_Runtime_create ();
[+] 		return jnc_Runtime_create();
[-] 	destroy ()
[+] 	destroy()
[-] 		jnc_Runtime_destroy (this);
[+] 		jnc_Runtime_destroy(this);
[-] 	getModule ()
[+] 	getModule()
[-] 		return jnc_Runtime_getModule (this);
[+] 		return jnc_Runtime_getModule(this);
[-] 	getGcHeap ()
[+] 	getGcHeap()
[-] 		return jnc_Runtime_getGcHeap (this);
[+] 		return jnc_Runtime_getGcHeap(this);
[-] 	isAborted ()
[+] 	isAborted()
[-] 		return jnc_Runtime_isAborted (this) != 0;
[+] 		return jnc_Runtime_isAborted(this) != 0;
[-] 	getStackSizeLimit ()
[+] 	getStackSizeLimit()
[-] 		return jnc_Runtime_getStackSizeLimit (this);
[+] 		return jnc_Runtime_getStackSizeLimit(this);
[-] 	setStackSizeLimit (size_t sizeLimit)
[+] 	setStackSizeLimit(size_t sizeLimit)
[-] 		return jnc_Runtime_setStackSizeLimit (this, sizeLimit) != 0;
[+] 		return jnc_Runtime_setStackSizeLimit(this, sizeLimit) != 0;
[-] 	startup (jnc_Module* module)
[+] 	startup(jnc_Module* module)
[-] 		return jnc_Runtime_startup (this, module) != 0;
[+] 		return jnc_Runtime_startup(this, module) != 0;
[-] 	shutdown ()
[+] 	shutdown()
[-] 		jnc_Runtime_shutdown (this);
[+] 		jnc_Runtime_shutdown(this);
[-] 	abort ()
[+] 	abort()
[-] 		jnc_Runtime_abort (this);
[+] 		jnc_Runtime_abort(this);
[-] 	initializeCallSite (jnc_CallSite* callSite)
[+] 	initializeCallSite(jnc_CallSite* callSite)
[-] 		jnc_Runtime_initializeCallSite (this, callSite);
[+] 		jnc_Runtime_initializeCallSite(this, callSite);
[-] 	uninitializeCallSite (jnc_CallSite* callSite)
[+] 	uninitializeCallSite(jnc_CallSite* callSite)
[-] 		jnc_Runtime_uninitializeCallSite (this, callSite);
[+] 		jnc_Runtime_uninitializeCallSite(this, callSite);
[-] 	getUserData ()
[+] 	getUserData()
[-] 		return jnc_Runtime_getUserData (this);
[+] 		return jnc_Runtime_getUserData(this);
[-] 	setUserData (void* data)
[+] 	setUserData(void* data)
[-] 		return jnc_Runtime_setUserData (this, data);
[+] 		return jnc_Runtime_setUserData(this, data);
[-] 	checkStackOverflow ()
[+] 	checkStackOverflow()
[-] 		jnc_Runtime_checkStackOverflow (this);
[+] 		jnc_Runtime_checkStackOverflow(this);
[-] jnc_getCurrentThreadRuntime ();
[+] jnc_getCurrentThreadRuntime();
[-] jnc_getCurrentThreadGcHeap ()
[+] jnc_getCurrentThreadGcHeap()
[-] 	jnc_Runtime* runtime = jnc_getCurrentThreadRuntime ();
[+] 	jnc_Runtime* runtime = jnc_getCurrentThreadRuntime();
[-] 	return runtime ? jnc_Runtime_getGcHeap (runtime) : NULL;
[+] 	return runtime ? jnc_Runtime_getGcHeap(runtime) : NULL;
[-] jnc_getCurrentThreadTls ();
[+] jnc_getCurrentThreadTls();
[-] jnc_dynamicThrow ();
[+] jnc_dynamicThrow();
[-] jnc_primeClass (
[+] jnc_primeClass(
[-] jnc_strengthenClassPtr (jnc_IfaceHdr* iface);
[+] jnc_strengthenClassPtr(jnc_IfaceHdr* iface);
[-] jnc_strLen (jnc_DataPtr ptr);
[+] jnc_strLen(jnc_DataPtr ptr);
[-] jnc_strDup (
[+] jnc_strDup(
[-] jnc_memDup (
[+] jnc_memDup(
[-] getCurrentThreadRuntime ()
[+] getCurrentThreadRuntime()
[-] 	return jnc_getCurrentThreadRuntime ();
[+] 	return jnc_getCurrentThreadRuntime();
[-] getCurrentThreadGcHeap ()
[+] getCurrentThreadGcHeap()
[-] 	return jnc_getCurrentThreadGcHeap ();
[+] 	return jnc_getCurrentThreadGcHeap();
[-] getCurrentThreadTls ()
[+] getCurrentThreadTls()
[-] 	return jnc_getCurrentThreadTls ();
[+] 	return jnc_getCurrentThreadTls();
[-] dynamicThrow ()
[+] dynamicThrow()
[-] 	return jnc_dynamicThrow ();
[+] 	return jnc_dynamicThrow();
[-] primeClass (
[+] primeClass(
[-] 	jnc_primeClass (box, root, type, vtable);
[+] 	jnc_primeClass(box, root, type, vtable);
[-] primeClass (
[+] primeClass(
[-] 	jnc_primeClass (box, box, type, vtable);
[+] 	jnc_primeClass(box, box, type, vtable);
[-] primeClass (
[+] primeClass(
[-] 	ClassBoxBase <T>* p,
[+] 	ClassBoxBase<T>* p,
[-] 	jnc_primeClass (p, root, T::getType (module), T::getVTable ());
[+] 	jnc_primeClass(p, root, T::getType(module), T::getVTable());
[-] primeClass (
[+] primeClass(
[-] 	ClassBoxBase <T>* p
[+] 	ClassBoxBase<T>* p
[-] 	primeClass (p, p, T::getType (module), T::getVTable ());
[+] 	primeClass(p, p, T::getType(module), T::getVTable());
[-] strengthenClassPtr (IfaceHdr* iface)
[+] strengthenClassPtr(IfaceHdr* iface)
[-] 	return jnc_strengthenClassPtr (iface);
[+] 	return jnc_strengthenClassPtr(iface);
[-] createClass (Runtime* runtime)
[+] createClass(Runtime* runtime)
[-] 	ClassType* type = T::getType (runtime->getModule ());
[+] 	ClassType* type = T::getType(runtime->getModule());
[-] 	T* p = (T*) runtime->getGcHeap ()->allocateClass (type);
[+] 	T* p = (T*)runtime->getGcHeap()->allocateClass(type);
[-] 	construct (p);
[+] 	construct(p);
[-] createClass (
[+] createClass(
[-] 	ClassType* type = T::getType (runtime->getModule ());
[+] 	ClassType* type = T::getType(runtime->getModule());
[-] 	T* p = (T*) runtime->getGcHeap ()->allocateClass (type);
[+] 	T* p = (T*)runtime->getGcHeap()->allocateClass(type);
[-] 	construct (p, arg);
[+] 	construct(p, arg);
[-] createClass (
[+] createClass(
[-] 	ClassType* type = T::getType (runtime->getModule ());
[+] 	ClassType* type = T::getType(runtime->getModule());
[-] 	T* p = (T*) runtime->getGcHeap ()->allocateClass (type);
[+] 	T* p = (T*)runtime->getGcHeap()->allocateClass(type);
[-] 	construct (p, arg1, arg2);
[+] 	construct(p, arg1, arg2);
[-] createClass (
[+] createClass(
[-] 	ClassType* type = T::getType (runtime->getModule ());
[+] 	ClassType* type = T::getType(runtime->getModule());
[-] 	T* p = (T*) runtime->getGcHeap ()->allocateClass (type);
[+] 	T* p = (T*)runtime->getGcHeap()->allocateClass(type);
[-] 	construct (p, arg1, arg2, arg3);
[+] 	construct(p, arg1, arg2, arg3);
[-] createClass (
[+] createClass(
[-] 	ClassType* type = T::getType (runtime->getModule ());
[+] 	ClassType* type = T::getType(runtime->getModule());
[-] 	T* p = (T*) runtime->getGcHeap ()->allocateClass (type);
[+] 	T* p = (T*)runtime->getGcHeap()->allocateClass(type);
[-] 	construct (p, arg1, arg2, arg3, arg4);
[+] 	construct(p, arg1, arg2, arg3, arg4);
[-] createData (Runtime* runtime)
[+] createData(Runtime* runtime)
[-] 	Type* type = T::getType (runtime->getModule ());
[+] 	Type* type = T::getType(runtime->getModule());
[-] 	DataPtr ptr = runtime->getGcHeap ()->allocateData (type);
[+] 	DataPtr ptr = runtime->getGcHeap()->allocateData(type);
[-] 	construct ((T*) ptr.m_p);
[+] 	construct((T*)ptr.m_p);
[-] createData (
[+] createData(
[-] 	Type* type = T::getType (runtime->getModule ());
[+] 	Type* type = T::getType(runtime->getModule());
[-] 	DataPtr ptr = runtime->getGcHeap ()->allocateData (type);
[+] 	DataPtr ptr = runtime->getGcHeap()->allocateData(type);
[-] 	construct ((T*) ptr.m_p, arg);
[+] 	construct((T*)ptr.m_p, arg);
[-] createData (
[+] createData(
[-] 	Type* type = T::getType (runtime->getModule ());
[+] 	Type* type = T::getType(runtime->getModule());
[-] 	DataPtr ptr = runtime->getGcHeap ()->allocateData (type);
[+] 	DataPtr ptr = runtime->getGcHeap()->allocateData(type);
[-] 	construct ((T*) ptr.m_p, arg1, arg2);
[+] 	construct((T*)ptr.m_p, arg1, arg2);
[-] createData (
[+] createData(
[-] 	Type* type = T::getType (runtime->getModule ());
[+] 	Type* type = T::getType(runtime->getModule());
[-] 	DataPtr ptr = runtime->getGcHeap ()->allocateData (type);
[+] 	DataPtr ptr = runtime->getGcHeap()->allocateData(type);
[-] 	construct ((T*) ptr.m_p, arg1, arg2, arg3);
[+] 	construct((T*)ptr.m_p, arg1, arg2, arg3);
[-] createData (
[+] createData(
[-] 	Type* type = T::getType (runtime->getModule ());
[+] 	Type* type = T::getType(runtime->getModule());
[-] 	DataPtr ptr = runtime->getGcHeap ()->allocateData (type);
[+] 	DataPtr ptr = runtime->getGcHeap()->allocateData(type);
[-] 	construct ((T*) ptr.m_p, arg1, arg2, arg3, arg4);
[+] 	construct((T*)ptr.m_p, arg1, arg2, arg3, arg4);
[-] strLen (DataPtr ptr)
[+] strLen(DataPtr ptr)
[-] 	return jnc_strLen (ptr);
[+] 	return jnc_strLen(ptr);
[-] strDup (
[+] strDup(
[-] 	return jnc_strDup (p, length);
[+] 	return jnc_strDup(p, length);
[-] strDup (const axl::sl::StringRef& string)
[+] strDup(const axl::sl::StringRef& string)
[-] 	return jnc_strDup (string.cp (), string.getLength ());
[+] 	return jnc_strDup(string.cp(), string.getLength());
[-] memDup (
[+] memDup(
[-] 	return jnc_memDup (p, size);
[+] 	return jnc_memDup(p, size);
[-] 	AutoRuntime ()
[+] 	AutoRuntime()
[-] 		m_runtime = jnc_Runtime_create ();
[+] 		m_runtime = jnc_Runtime_create();
[-] 	~AutoRuntime ()
[+] 	~AutoRuntime()
[-] 			jnc_Runtime_destroy (m_runtime);
[+] 			jnc_Runtime_destroy(m_runtime);
[-] 	p () const
[+] 	p() const
[-] 	ScopedNoCollectRegion (
[+] 	ScopedNoCollectRegion(
[-] 		init (gcHeap, canCollectOnLeave);
[+] 		init(gcHeap, canCollectOnLeave);
[-] 	ScopedNoCollectRegion (
[+] 	ScopedNoCollectRegion(
[-] 		init (jnc_Runtime_getGcHeap (runtime), canCollectOnLeave);
[+] 		init(jnc_Runtime_getGcHeap(runtime), canCollectOnLeave);
[-] 	ScopedNoCollectRegion (bool canCollectOnLeave)
[+] 	ScopedNoCollectRegion(bool canCollectOnLeave)
[-] 		GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 		GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 		JNC_ASSERT (gcHeap);
[+] 		JNC_ASSERT(gcHeap);
[-] 		init (gcHeap, canCollectOnLeave);
[+] 		init(gcHeap, canCollectOnLeave);
[-] 	~ScopedNoCollectRegion ()
[+] 	~ScopedNoCollectRegion()
[-] 		jnc_GcHeap_leaveNoCollectRegion (m_gcHeap, m_canCollectOnLeave);
[+] 		jnc_GcHeap_leaveNoCollectRegion(m_gcHeap, m_canCollectOnLeave);
[-] 	init (
[+] 	init(
[-] 		jnc_GcHeap_enterNoCollectRegion (m_gcHeap);
[+] 		jnc_GcHeap_enterNoCollectRegion(m_gcHeap);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_RuntimeStructs.h
----------------------
[-] 	intptr_t m_gcRootArray [3];
[+] 	intptr_t m_gcRootArray[3];
[-] 	intptr_t m_gcRootTypeArray [3];
[+] 	intptr_t m_gcRootTypeArray[3];
[-] jnc_MarkOpaqueGcRootsFunc (
[+] jnc_MarkOpaqueGcRootsFunc(
[-] jnc_StaticConstructFunc ();
[+] jnc_StaticConstructFunc();
[-] jnc_StaticDestructFunc ();
[+] jnc_StaticDestructFunc();
[-] jnc_DestructFunc (jnc_IfaceHdr* iface);
[+] jnc_DestructFunc(jnc_IfaceHdr* iface);
[-] 	T* p ()
[+] 	T* p()
[-] 		return (T*) (this + 1);
[+] 		return (T*)(this + 1);
[-] 		return p ();
[+] 		return p();
[-] 		return p ();
[+] 		return p();
[-] #pragma pack (push, 1)
[+] #pragma pack(push, 1)
[-] class ClassBox_align1: public ClassBoxBase <T>
[+] class ClassBox_align1: public ClassBoxBase<T>
[-] 	char m_buffer [sizeof (T)];
[+] 	char m_buffer[sizeof(T)];
[-] #pragma pack (2)
[+] #pragma pack(2)
[-] class ClassBox_align2: public ClassBoxBase <T>
[+] class ClassBox_align2: public ClassBoxBase<T>
[-] 	char m_buffer [sizeof (T)];
[+] 	char m_buffer[sizeof(T)];
[-] #pragma pack (4)
[+] #pragma pack(4)
[-] class ClassBox_align4: public ClassBoxBase <T>
[+] class ClassBox_align4: public ClassBoxBase<T>
[-] 	char m_buffer [sizeof (T)];
[+] 	char m_buffer[sizeof(T)];
[-] #pragma pack (8)
[+] #pragma pack(8)
[-] class ClassBox_align8: public ClassBoxBase <T>
[+] class ClassBox_align8: public ClassBoxBase<T>
[-] 	char m_buffer [sizeof (T)];
[+] 	char m_buffer[sizeof(T)];
[-] 		char m_buffer [sizeof (T)];
[+] 		char m_buffer[sizeof(T)];
[-] #pragma pack (pop)
[+] #pragma pack(pop)
[-] class ClassBox: public ClassBoxBase <T>
[+] class ClassBox: public ClassBoxBase<T>
[-] 	char m_buffer [sizeof (T)];
[+] 	char m_buffer[sizeof(T)];
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_StructType.h
----------------------
[-] jnc_StructField_getOffset (jnc_StructField* field);
[+] jnc_StructField_getOffset(jnc_StructField* field);
[-] 	getOffset ()
[+] 	getOffset()
[-] 		return jnc_StructField_getOffset (this);
[+] 		return jnc_StructField_getOffset(this);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Type.h
----------------------
[-] 	Use functions from the :ref:`Type <cid-type>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Type<cid-type>` to access and manage the contents of this structure.
[-] jnc_getTypeKindFlags (jnc_TypeKind typeKind);
[+] jnc_getTypeKindFlags(jnc_TypeKind typeKind);
[-] jnc_getDataPtrTypeKindString (jnc_DataPtrTypeKind ptrTypeKind);
[+] jnc_getDataPtrTypeKindString(jnc_DataPtrTypeKind ptrTypeKind);
[-] jnc_Type_getTypeKind (jnc_Type* type);
[+] jnc_Type_getTypeKind(jnc_Type* type);
[-] jnc_Type_getTypeKindFlags (jnc_Type* type)
[+] jnc_Type_getTypeKindFlags(jnc_Type* type)
[-] 	jnc_TypeKind typeKind = jnc_Type_getTypeKind (type);
[+] 	jnc_TypeKind typeKind = jnc_Type_getTypeKind(type);
[-] 	return jnc_getTypeKindFlags (typeKind);
[+] 	return jnc_getTypeKindFlags(typeKind);
[-] jnc_Type_getSize (jnc_Type* type);
[+] jnc_Type_getSize(jnc_Type* type);
[-] jnc_Type_getTypeString (jnc_Type* type);
[+] jnc_Type_getTypeString(jnc_Type* type);
[-] jnc_Type_getTypeStringPrefix (jnc_Type* type);
[+] jnc_Type_getTypeStringPrefix(jnc_Type* type);
[-] jnc_Type_getTypeStringSuffix (jnc_Type* type);
[+] jnc_Type_getTypeStringSuffix(jnc_Type* type);
[-] jnc_Type_cmp (
[+] jnc_Type_cmp(
[-] jnc_Type_getDataPtrType (
[+] jnc_Type_getDataPtrType(
[-] jnc_Type_markGcRoots (
[+] jnc_Type_markGcRoots(
[-] 	getTypeKind ()
[+] 	getTypeKind()
[-] 		return jnc_Type_getTypeKind (this);
[+] 		return jnc_Type_getTypeKind(this);
[-] 	getTypeKindFlags ()
[+] 	getTypeKindFlags()
[-] 		return jnc_Type_getTypeKindFlags (this);
[+] 		return jnc_Type_getTypeKindFlags(this);
[-] 	getSize ()
[+] 	getSize()
[-] 		return jnc_Type_getSize (this);
[+] 		return jnc_Type_getSize(this);
[-] 	getTypeString ()
[+] 	getTypeString()
[-] 		return jnc_Type_getTypeString (this);
[+] 		return jnc_Type_getTypeString(this);
[-] 	getTypeStringPrefix ()
[+] 	getTypeStringPrefix()
[-] 		return jnc_Type_getTypeStringPrefix (this);
[+] 		return jnc_Type_getTypeStringPrefix(this);
[-] 	getTypeStringSuffix ()
[+] 	getTypeStringSuffix()
[-] 		return jnc_Type_getTypeStringSuffix (this);
[+] 		return jnc_Type_getTypeStringSuffix(this);
[-] 	cmp (jnc_Type* type)
[+] 	cmp(jnc_Type* type)
[-] 		return jnc_Type_cmp (this, type);
[+] 		return jnc_Type_cmp(this, type);
[-] 	getDataPtrType (
[+] 	getDataPtrType(
[-] 		return jnc_Type_getDataPtrType (this, ptrTypeKind, flags);
[+] 		return jnc_Type_getDataPtrType(this, ptrTypeKind, flags);
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 		jnc_Type_markGcRoots (this, p, gcHeap);
[+] 		jnc_Type_markGcRoots(this, p, gcHeap);
[-] jnc_DataPtrType_getPtrTypeKind (jnc_DataPtrType* type);
[+] jnc_DataPtrType_getPtrTypeKind(jnc_DataPtrType* type);
[-] jnc_DataPtrType_getTargetType (jnc_DataPtrType* type);
[+] jnc_DataPtrType_getTargetType(jnc_DataPtrType* type);
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 		return jnc_DataPtrType_getPtrTypeKind (this);
[+] 		return jnc_DataPtrType_getPtrTypeKind(this);
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 		return jnc_DataPtrType_getTargetType (this);
[+] 		return jnc_DataPtrType_getTargetType(this);
[-] jnc_isCharPtrType (jnc_Type* type)
[+] jnc_isCharPtrType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_DataPtr &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_DataPtr &&
[-] 		jnc_Type_getTypeKind (jnc_DataPtrType_getTargetType ((jnc_DataPtrType*) type)) == jnc_TypeKind_Char;
[+] 		jnc_Type_getTypeKind(jnc_DataPtrType_getTargetType((jnc_DataPtrType*)type)) == jnc_TypeKind_Char;
[-] jnc_isArrayRefType (jnc_Type* type)
[+] jnc_isArrayRefType(jnc_Type* type)
[-] 		jnc_Type_getTypeKind (type) == jnc_TypeKind_DataRef &&
[+] 		jnc_Type_getTypeKind(type) == jnc_TypeKind_DataRef &&
[-] 		jnc_Type_getTypeKind (jnc_DataPtrType_getTargetType ((jnc_DataPtrType*) type)) == jnc_TypeKind_Array;
[+] 		jnc_Type_getTypeKind(jnc_DataPtrType_getTargetType((jnc_DataPtrType*)type)) == jnc_TypeKind_Array;
[-] jnc_isDataPtrType (
[+] jnc_isDataPtrType(
[-] 		(jnc_Type_getTypeKindFlags (type) & jnc_TypeKindFlag_DataPtr) &&
[+] 		(jnc_Type_getTypeKindFlags(type) & jnc_TypeKindFlag_DataPtr) &&
[-] 		jnc_DataPtrType_getPtrTypeKind (((jnc_DataPtrType*) type)) == kind;
[+] 		jnc_DataPtrType_getPtrTypeKind(((jnc_DataPtrType*)type)) == kind;
[-] getTypeKindFlags (TypeKind typeKind)
[+] getTypeKindFlags(TypeKind typeKind)
[-] 	return jnc_getTypeKindFlags (typeKind);
[+] 	return jnc_getTypeKindFlags(typeKind);
[-] getDataPtrTypeKindString (DataPtrTypeKind ptrTypeKind)
[+] getDataPtrTypeKindString(DataPtrTypeKind ptrTypeKind)
[-] 	return jnc_getDataPtrTypeKindString (ptrTypeKind);
[+] 	return jnc_getDataPtrTypeKindString(ptrTypeKind);
[-] isCharPtrType (Type* type)
[+] isCharPtrType(Type* type)
[-] 	return jnc_isCharPtrType (type) != 0;
[+] 	return jnc_isCharPtrType(type) != 0;
[-] isArrayRefType (Type* type)
[+] isArrayRefType(Type* type)
[-] 	return jnc_isArrayRefType (type) != 0;
[+] 	return jnc_isArrayRefType(type) != 0;
[-] isDataPtrType (
[+] isDataPtrType(
[-] 	return jnc_isDataPtrType (type, kind) != 0;
[+] 	return jnc_isDataPtrType(type, kind) != 0;
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Unit.h
----------------------
[-] jnc_Unit_getLib (jnc_Unit* unit);
[+] jnc_Unit_getLib(jnc_Unit* unit);
[-] 	getLib ()
[+] 	getLib()
[-] 		return jnc_Unit_getLib (this);
[+] 		return jnc_Unit_getLib(this);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Variable.h
----------------------
[-] 	Use functions from the :ref:`Variable <cid-variable>` to access and manage the contents of this structure.
[+] 	Use functions from the :ref:`Variable<cid-variable>` to access and manage the contents of this structure.
[-] jnc_Variable_hasInitializer (jnc_Variable* variable);
[+] jnc_Variable_hasInitializer(jnc_Variable* variable);
[-] jnc_Variable_getInitializerString_v (jnc_Variable* variable);
[+] jnc_Variable_getInitializerString_v(jnc_Variable* variable);
[-] 	hasInitializer ()
[+] 	hasInitializer()
[-] 		return jnc_Variable_hasInitializer (this) != 0;
[+] 		return jnc_Variable_hasInitializer(this) != 0;
[-] 	getInitializerString_v ()
[+] 	getInitializerString_v()
[-] 		return jnc_Variable_getInitializerString_v (this);
[+] 		return jnc_Variable_getInitializerString_v(this);
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_Variant.h
----------------------
[-] jnc_Variant_cast (
[+] jnc_Variant_cast(
[-] jnc_Variant_unaryOperator (
[+] jnc_Variant_unaryOperator(
[-] jnc_Variant_binaryOperator (
[+] jnc_Variant_binaryOperator(
[-] jnc_Variant_relationalOperator (
[+] jnc_Variant_relationalOperator(
[-] jnc_Variant_getMember (
[+] jnc_Variant_getMember(
[-] jnc_Variant_setMember (
[+] jnc_Variant_setMember(
[-] jnc_Variant_getElement (
[+] jnc_Variant_getElement(
[-] jnc_Variant_setElement (
[+] jnc_Variant_setElement(
[-] jnc_Variant_isNull (const jnc_Variant* variant);
[+] jnc_Variant_isNull(const jnc_Variant* variant);
[-] jnc_Variant_isEqual (
[+] jnc_Variant_isEqual(
[-] 	return jnc_Variant_relationalOperator (variant, variant2, jnc_BinOpKind_Eq, &result) && result;
[+] 	return jnc_Variant_relationalOperator(variant, variant2, jnc_BinOpKind_Eq, &result) && result;
[-] jnc_Variant_hash (const jnc_Variant* variant);
[+] jnc_Variant_hash(const jnc_Variant* variant);
[-] 	char m_padding [4]; // ensure the same layout regardless of pack factor
[+] 	char m_padding[4]; // ensure the same layout regardless of pack factor
[-] 	isNull () const
[+] 	isNull() const
[-] 		return jnc_Variant_isNull (this) != 0;
[+] 		return jnc_Variant_isNull(this) != 0;
[-] 	cast (
[+] 	cast(
[-] 		return jnc_Variant_cast (this, type, buffer) != 0;
[+] 		return jnc_Variant_cast(this, type, buffer) != 0;
[-] 	unaryOperator (
[+] 	unaryOperator(
[-] 		return jnc_Variant_unaryOperator (this, opKind, result) != 0;
[+] 		return jnc_Variant_unaryOperator(this, opKind, result) != 0;
[-] 	unaryOperator (jnc_UnOpKind opKind)
[+] 	unaryOperator(jnc_UnOpKind opKind)
[-] 		return jnc_Variant_unaryOperator (this, opKind, this) != 0;
[+] 		return jnc_Variant_unaryOperator(this, opKind, this) != 0;
[-] 	binaryOperator (
[+] 	binaryOperator(
[-] 		return jnc_Variant_binaryOperator (this, variant2, opKind, result) != 0;
[+] 		return jnc_Variant_binaryOperator(this, variant2, opKind, result) != 0;
[-] 	binaryOperator (
[+] 	binaryOperator(
[-] 		return jnc_Variant_binaryOperator (this, variant2, opKind, this) != 0;
[+] 		return jnc_Variant_binaryOperator(this, variant2, opKind, this) != 0;
[-] 	relationalOperator (
[+] 	relationalOperator(
[-] 	getMember (
[+] 	getMember(
[-] 		return jnc_Variant_getMember (this, name, result) != 0;
[+] 		return jnc_Variant_getMember(this, name, result) != 0;
[-] 	setMember (
[+] 	setMember(
[-] 		return jnc_Variant_setMember (this, name, value) != 0;
[+] 		return jnc_Variant_setMember(this, name, value) != 0;
[-] 	getElement (
[+] 	getElement(
[-] 		return jnc_Variant_getElement (this, index, result) != 0;
[+] 		return jnc_Variant_getElement(this, index, result) != 0;
[-] 	setElement (
[+] 	setElement(
[-] 		return jnc_Variant_setElement (this, index, value) != 0;
[+] 		return jnc_Variant_setElement(this, index, value) != 0;
[-] 	isEqual (const jnc_Variant* variant2) const
[+] 	isEqual(const jnc_Variant* variant2) const
[-] 		return jnc_Variant_isEqual (this, variant2) != 0;
[+] 		return jnc_Variant_isEqual(this, variant2) != 0;
[-] 	isEqual (const jnc_Variant& variant2) const
[+] 	isEqual(const jnc_Variant& variant2) const
[-] 		return jnc_Variant_isEqual (this, &variant2) != 0;
[+] 		return jnc_Variant_isEqual(this, &variant2) != 0;
[-] 	hash () const
[+] 	hash() const
[-] 		return jnc_Variant_hash (this);
[+] 		return jnc_Variant_hash(this);
[-] jnc_Variant_isNull (const jnc_Variant* variant)
[+] jnc_Variant_isNull(const jnc_Variant* variant)
----------------------
27/02/2019 18:02:00 - C:\Projects\repos\ioninja\jancy\include\jnc_WarningSuppression.h
----------------------
[-] #	pragma warning (disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[+] #	pragma warning(disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[-] #	pragma warning (disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[+] #	pragma warning(disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[-] #	pragma warning (disable: 4355) // warning C4355: 'this' : used in base member initializer list
[+] #	pragma warning(disable: 4355) // warning C4355: 'this' : used in base member initializer list
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\main.c
----------------------
[-] convertToUtf8 (
[+] convertToUtf8(
[-] 	requiredLength = WideCharToMultiByte (CP_UTF8, 0, string, (int) length, NULL, 0, NULL, NULL);
[+] 	requiredLength = WideCharToMultiByte(CP_UTF8, 0, string, (int)length, NULL, 0, NULL, NULL);
[-] 	p = malloc (requiredLength + 1);
[+] 	p = malloc(requiredLength + 1);
[-] 	p [requiredLength] = 0; // ensure zero-termination
[+] 	p[requiredLength] = 0; // ensure zero-termination
[-] 	WideCharToMultiByte (CP_UTF8, 0, string, (int) length, p, requiredLength, NULL, NULL);
[+] 	WideCharToMultiByte(CP_UTF8, 0, string, (int)length, p, requiredLength, NULL, NULL);
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	MainFunc ();
[+] 	MainFunc();
[-] 	printf ("Initializing...\n");
[+] 	printf("Initializing...\n");
[-] 		printf ("usage: jnc_sample_01_embed_c <script.jnc>\n");
[+] 		printf("usage: jnc_sample_01_embed_c <script.jnc>\n");
[-] 	jnc_initialize ("jnc_sample_01_embed_c");
[+] 	jnc_initialize("jnc_sample_01_embed_c");
[-] 	fileName = convertToUtf8 (argv [1], -1);
[+] 	fileName = convertToUtf8(argv[1], -1);
[-] 	fileName = argv [1];
[+] 	fileName = argv[1];
[-] 	module = jnc_Module_create ();
[+] 	module = jnc_Module_create();
[-] 	jnc_Module_initialize (module, fileName, jnc_ModuleCompileFlag_StdFlags);
[+] 	jnc_Module_initialize(module, fileName, jnc_ModuleCompileFlag_StdFlags);
[-] 	jnc_Module_addStaticLib (module, jnc_StdLib_getLib ());
[+] 	jnc_Module_addStaticLib(module, jnc_StdLib_getLib());
[-] 	jnc_Module_addStaticLib (module, MyLib_getLib ());
[+] 	jnc_Module_addStaticLib(module, MyLib_getLib());
[-] 	printf ("Parsing '%s'...\n", fileName);
[+] 	printf("Parsing '%s'...\n", fileName);
[-] 		jnc_Module_parseFile (module, fileName) &&
[+] 		jnc_Module_parseFile(module, fileName) &&
[-] 		jnc_Module_parseImports (module);
[+] 		jnc_Module_parseImports(module);
[-] 		printf ("%s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc_getLastErrorDescription_v ());
[-] 	printf ("Compiling...\n");
[+] 	printf("Compiling...\n");
[-] 	result = jnc_Module_compile (module);
[+] 	result = jnc_Module_compile(module);
[-] 		printf ("%s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc_getLastErrorDescription_v ());
[-] 	printf ("JITting...\n");
[+] 	printf("JITting...\n");
[-] 	result = jnc_Module_jit (module);
[+] 	result = jnc_Module_jit(module);
[-] 		printf ("%s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc_getLastErrorDescription_v ());
[-] 	nspace = jnc_ModuleItem_getNamespace ((jnc_ModuleItem*) jnc_Module_getGlobalNamespace (module));
[+] 	nspace = jnc_ModuleItem_getNamespace((jnc_ModuleItem*)jnc_Module_getGlobalNamespace(module));
[-] 	function = jnc_Namespace_findFunction (nspace, "main", 1);
[+] 	function = jnc_Namespace_findFunction(nspace, "main", 1);
[-] 		printf ("%s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc_getLastErrorDescription_v ());
[-] 	printf ("Running...\n");
[+] 	printf("Running...\n");
[-] 	runtime = jnc_Runtime_create ();
[+] 	runtime = jnc_Runtime_create();
[-] 	result = jnc_Runtime_startup (runtime, module);
[+] 	result = jnc_Runtime_startup(runtime, module);
[-] 		printf ("%s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc_getLastErrorDescription_v ());
[-] 	mc = jnc_Function_getMachineCode (function);
[+] 	mc = jnc_Function_getMachineCode(function);
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	returnValue = mc ();
[+] 	returnValue = mc();
[-] 	JNC_END_CALL_SITE_EX (&result)
[+] 	JNC_END_CALL_SITE_EX(&result)
[-] 		printf ("Runtime error: %s\n", jnc_getLastErrorDescription_v ());
[+] 		printf("Runtime error: %s\n", jnc_getLastErrorDescription_v ());
[-] 	printf ("Shutting down...\n");
[+] 	printf("Shutting down...\n");
[-] 	jnc_Runtime_shutdown (runtime);
[+] 	jnc_Runtime_shutdown(runtime);
[-] 	printf ("Done.\n");
[+] 	printf("Done.\n");
[-] 		jnc_Runtime_destroy (runtime);
[+] 		jnc_Runtime_destroy(runtime);
[-] 		jnc_Module_destroy (module);
[+] 		jnc_Module_destroy(module);
[-] 		free ((void*) fileName);
[+] 		free((void*)fileName);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\MyLib.c
----------------------
[-] foo_0 (int x)
[+] foo_0(int x)
[-] 	printf ("  foo_0 (%d)\n", x);
[+] 	printf("  foo_0 (%d)\n", x);
[-] foo_1 (double x)
[+] foo_1(double x)
[-] 	printf ("  foo_1 (%f)\n", x);
[+] 	printf("  foo_1 (%f)\n", x);
[-] foo_2 (jnc_DataPtr ptr)
[+] foo_2(jnc_DataPtr ptr)
[-] 	printf ("  foo_2 (%s)\n", ptr.m_p);
[+] 	printf("  foo_2 (%s)\n", ptr.m_p);
[-] getSimpleProp ()
[+] getSimpleProp()
[-] 	printf ("  getSimpleProp () => %d\n", g_simplePropValue);
[+] 	printf("  getSimpleProp () => %d\n", g_simplePropValue);
[-] setSimpleProp (int x)
[+] setSimpleProp(int x)
[-] 	printf ("  setSimpleProp (%d)\n", x);
[+] 	printf("  setSimpleProp (%d)\n", x);
[-] getProp ()
[+] getProp()
[-] 	printf ("  getProp () => %s\n", g_propValue.m_p);
[+] 	printf("  getProp () => %s\n", g_propValue.m_p);
[-] setProp_0 (int x)
[+] setProp_0(int x)
[-] 	char buffer [32];
[+] 	char buffer[32];
[-] 	printf ("  setProp_0 (%d)\n", x);
[+] 	printf("  setProp_0 (%d)\n", x);
[-] 	length = sprintf (buffer, "%d", x);
[+] 	length = sprintf(buffer, "%d", x);
[-] 	g_propValue = jnc_strDup (buffer, length);
[+] 	g_propValue = jnc_strDup(buffer, length);
[-] setProp_1 (double x)
[+] setProp_1(double x)
[-] 	char buffer [32];
[+] 	char buffer[32];
[-] 	printf ("  setProp_1 (%f)\n", x);
[+] 	printf("  setProp_1 (%f)\n", x);
[-] 	length = sprintf (buffer, "%f", x);
[+] 	length = sprintf(buffer, "%f", x);
[-] 	g_propValue = jnc_strDup (buffer, length);
[+] 	g_propValue = jnc_strDup(buffer, length);
[-] setProp_2 (jnc_DataPtr ptr)
[+] setProp_2(jnc_DataPtr ptr)
[-] 	printf ("  setProp_2 (%s)\n", ptr.m_p);
[+] 	printf("  setProp_2 (%s)\n", ptr.m_p);
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (MyLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(MyLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (MyLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(MyLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (TestClass)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(TestClass)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (MyLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(MyLib)
[-] 	JNC_MAP_FUNCTION ("foo",    &foo_0)
[+] 	JNC_MAP_FUNCTION("foo",    &foo_0)
[-] 	JNC_MAP_OVERLOAD (&foo_1)
[+] 	JNC_MAP_OVERLOAD(&foo_1)
[-] 	JNC_MAP_OVERLOAD (&foo_2)
[+] 	JNC_MAP_OVERLOAD(&foo_2)
[-] 	JNC_MAP_PROPERTY ("g_simpleProp",  &getSimpleProp, &setSimpleProp)
[+] 	JNC_MAP_PROPERTY("g_simpleProp",  &getSimpleProp, &setSimpleProp)
[-] 	JNC_MAP_PROPERTY ("g_prop",  &getProp, &setProp_0)
[+] 	JNC_MAP_PROPERTY("g_prop",  &getProp, &setProp_0)
[-] 	JNC_MAP_OVERLOAD (&setProp_1)
[+] 	JNC_MAP_OVERLOAD(&setProp_1)
[-] 	JNC_MAP_OVERLOAD (&setProp_2)
[+] 	JNC_MAP_OVERLOAD(&setProp_2)
[-] 	JNC_MAP_TYPE (TestStruct)
[+] 	JNC_MAP_TYPE(TestStruct)
[-] 	JNC_MAP_TYPE (TestClass)
[+] 	JNC_MAP_TYPE(TestClass)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\TestClass.c
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestClass)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestClass)
[-] 	JNC_MAP_CONSTRUCTOR (TestClass_construct)
[+] 	JNC_MAP_CONSTRUCTOR(TestClass_construct)
[-] 	JNC_MAP_DESTRUCTOR (TestClass_destruct)
[+] 	JNC_MAP_DESTRUCTOR(TestClass_destruct)
[-] 	JNC_MAP_BINARY_OPERATOR (jnc_BinOpKind_AddAssign, TestClass_addAssign)
[+] 	JNC_MAP_BINARY_OPERATOR(jnc_BinOpKind_AddAssign, TestClass_addAssign)
[-] 	JNC_MAP_BINARY_OPERATOR (jnc_BinOpKind_SubAssign, TestClass_subAssign)
[+] 	JNC_MAP_BINARY_OPERATOR(jnc_BinOpKind_SubAssign, TestClass_subAssign)
[-] 	JNC_MAP_FUNCTION ("foo", TestClass_foo_0)
[+] 	JNC_MAP_FUNCTION("foo", TestClass_foo_0)
[-] 	JNC_MAP_OVERLOAD (TestClass_foo_1)
[+] 	JNC_MAP_OVERLOAD(TestClass_foo_1)
[-] 	JNC_MAP_OVERLOAD (TestClass_foo_2)
[+] 	JNC_MAP_OVERLOAD(TestClass_foo_2)
[-] 	JNC_MAP_PROPERTY ("m_prop", TestClass_setProp, TestClass_setProp)
[+] 	JNC_MAP_PROPERTY("m_prop", TestClass_setProp, TestClass_setProp)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] TestClass_construct (
[+] TestClass_construct(
[-] 	printf ("  TestClass_construct (%d)\n", value);
[+] 	printf("  TestClass_construct (%d)\n", value);
[-] 	sprintf (self->m_internalData, "TestClass (%p)", self);
[+] 	sprintf(self->m_internalData, "TestClass (%p)", self);
[-] TestClass_destruct (TestClass* self)
[+] TestClass_destruct(TestClass* self)
[-] 	printf ("  TestClass_destruct ()\n");
[+] 	printf("  TestClass_destruct ()\n");
[-] TestClass_markOpaqueGcRoots (
[+] TestClass_markOpaqueGcRoots(
[-] 		jnc_GcHeap_markClass (gcHeap, self->m_internalObject->m_box);
[+] 		jnc_GcHeap_markClass(gcHeap, self->m_internalObject->m_box);
[-] TestClass_setInternalValue (
[+] TestClass_setInternalValue(
[-] 		OnNegativeEventFunc* mc = jnc_getMulticastCallMethodMachineCode (&self->m_onNegative.m_multicast);
[+] 		OnNegativeEventFunc* mc = jnc_getMulticastCallMethodMachineCode(&self->m_onNegative.m_multicast);
[-] 		mc (&self->m_onNegative.m_multicast);
[+] 		mc(&self->m_onNegative.m_multicast);
[-] TestClass_addAssign (
[+] TestClass_addAssign(
[-] 	printf ("  TestClass_addAssign (%d)\n", delta);
[+] 	printf("  TestClass_addAssign (%d)\n", delta);
[-] 	return TestClass_setInternalValue (self, self->m_internalValue + delta);
[+] 	return TestClass_setInternalValue(self, self->m_internalValue + delta);
[-] TestClass_subAssign (
[+] TestClass_subAssign(
[-] 	printf ("  TestClass_subAssign (%d)\n", delta);
[+] 	printf("  TestClass_subAssign (%d)\n", delta);
[-] 	return TestClass_setInternalValue (self, self->m_internalValue - delta);
[+] 	return TestClass_setInternalValue(self, self->m_internalValue - delta);
[-] TestClass_foo_0 (TestClass* self)
[+] TestClass_foo_0(TestClass* self)
[-] 	printf ("  TestClass_foo_0 ()\n");
[+] 	printf("  TestClass_foo_0 ()\n");
[-] TestClass_foo_1 (
[+] TestClass_foo_1(
[-] 	printf ("  TestClass_foo_1 (%d)\n", value);
[+] 	printf("  TestClass_foo_1 (%d)\n", value);
[-] 	return TestClass_setInternalValue (self, value);
[+] 	return TestClass_setInternalValue(self, value);
[-] TestClass_foo_2 (
[+] TestClass_foo_2(
[-] 	printf ("  TestClass_foo_2 ()\n");
[+] 	printf("  TestClass_foo_2 ()\n");
[-] 	return TestClass_setInternalValue (self, src->m_internalValue);
[+] 	return TestClass_setInternalValue(self, src->m_internalValue);
[-] TestClass_setProp (
[+] TestClass_setProp(
[-] 	printf ("  TestClass_setProp (%s)\n", ptr.m_p);
[+] 	printf("  TestClass_setProp (%s)\n", ptr.m_p);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\TestStruct.c
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestStruct)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestStruct)
[-] 	JNC_MAP_CONSTRUCTOR (TestStruct_construct_0)
[+] 	JNC_MAP_CONSTRUCTOR(TestStruct_construct_0)
[-] 	JNC_MAP_OVERLOAD (TestStruct_construct_1)
[+] 	JNC_MAP_OVERLOAD(TestStruct_construct_1)
[-] 	JNC_MAP_FUNCTION ("foo", TestStruct_foo_0)
[+] 	JNC_MAP_FUNCTION("foo", TestStruct_foo_0)
[-] 	JNC_MAP_OVERLOAD (TestStruct_foo_1)
[+] 	JNC_MAP_OVERLOAD(TestStruct_foo_1)
[-] 	JNC_MAP_OVERLOAD (TestStruct_foo_2)
[+] 	JNC_MAP_OVERLOAD(TestStruct_foo_2)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] TestStruct_construct_0 (jnc_DataPtr selfPtr)
[+] TestStruct_construct_0(jnc_DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct_construct_0 ()\n");
[+] 	printf("  TestStruct_construct_0 ()\n");
[-] TestStruct_construct_1 (
[+] TestStruct_construct_1(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct_construct_1 (%d, %d)\n", x, y);
[+] 	printf("  TestStruct_construct_1 (%d, %d)\n", x, y);
[-] TestStruct_foo_0 (jnc_DataPtr selfPtr)
[+] TestStruct_foo_0(jnc_DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct_foo_0 ()\n");
[+] 	printf("  TestStruct_foo_0 ()\n");
[-] TestStruct_foo_1 (
[+] TestStruct_foo_1(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct_foo_1 (%d, %d)\n", x, y);
[+] 	printf("  TestStruct_foo_1 (%d, %d)\n", x, y);
[-] TestStruct_foo_2 (
[+] TestStruct_foo_2(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	TestStruct* src = (TestStruct*) srcPtr.m_p;
[+] 	TestStruct* src = (TestStruct*)srcPtr.m_p;
[-] 	printf ("  TestStruct_foo_2 ( { %d, %d } )\n", src->m_x, src->m_y);
[+] 	printf("  TestStruct_foo_2 ( { %d, %d } )\n", src->m_x, src->m_y);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\MyLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
[-] JNC_DECLARE_LIB (MyLib)
[+] JNC_DECLARE_LIB(MyLib)
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\pch.h
----------------------
[-] #pragma warning (disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
[+] #pragma warning(disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\TestClass.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (TestClass)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(TestClass)
[-] OnNegativeEventFunc (jnc_Multicast* multicast);
[+] OnNegativeEventFunc(jnc_Multicast* multicast);
[-] 	char m_internalData [256];
[+] 	char m_internalData[256];
[-] TestClass_construct (
[+] TestClass_construct(
[-] TestClass_destruct (TestClass* self);
[+] TestClass_destruct(TestClass* self);
[-] TestClass_markOpaqueGcRoots (
[+] TestClass_markOpaqueGcRoots(
[-] TestClass_addAssign (
[+] TestClass_addAssign(
[-] TestClass_subAssign (
[+] TestClass_subAssign(
[-] TestClass_foo_0 (TestClass* self);
[+] TestClass_foo_0(TestClass* self);
[-] TestClass_foo_1 (
[+] TestClass_foo_1(
[-] TestClass_foo_2 (
[+] TestClass_foo_2(
[-] TestClass_setProp (
[+] TestClass_setProp(
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\TestStruct.h
----------------------
[-] JNC_DECLARE_TYPE (TestStruct)
[+] JNC_DECLARE_TYPE(TestStruct)
[-] TestStruct_construct_0 (jnc_DataPtr selfPtr);
[+] TestStruct_construct_0(jnc_DataPtr selfPtr);
[-] TestStruct_construct_1 (
[+] TestStruct_construct_1(
[-] TestStruct_foo_0 (jnc_DataPtr selfPtr);
[+] TestStruct_foo_0(jnc_DataPtr selfPtr);
[-] TestStruct_foo_1 (
[+] TestStruct_foo_1(
[-] TestStruct_foo_2 (
[+] TestStruct_foo_2(
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\main.cpp
----------------------
[-] std::auto_ptr <char>
[+] std::auto_ptr<char>
[-] convertToUtf8 (
[+] convertToUtf8(
[-] 	int requiredLength = ::WideCharToMultiByte (CP_UTF8, 0, string, (int) length, NULL, 0, NULL, NULL);
[+] 	int requiredLength = ::WideCharToMultiByte(CP_UTF8, 0, string, (int)length, NULL, 0, NULL, NULL);
[-] 		return std::auto_ptr <char> ();
[+] 		return std::auto_ptr<char> ();
[-] 	char* p = new char [requiredLength + 1];
[+] 	char* p = new char[requiredLength + 1];
[-] 	p [requiredLength] = 0; // ensure zero-termination
[+] 	p[requiredLength] = 0; // ensure zero-termination
[-] 	::WideCharToMultiByte (CP_UTF8, 0, string, (int) length, p, requiredLength, NULL, NULL);
[+] 	::WideCharToMultiByte(CP_UTF8, 0, string, (int)length, p, requiredLength, NULL, NULL);
[-] 	return std::auto_ptr <char> (p);
[+] 	return std::auto_ptr<char> (p);
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	printf ("Initializing...\n");
[+] 	printf("Initializing...\n");
[-] 		printf ("usage: jnc_sample_02_embed_cpp <script.jnc>\n");
[+] 		printf("usage: jnc_sample_02_embed_cpp <script.jnc>\n");
[-] 	jnc::initialize ("jnc_sample_02_embed_cpp");
[+] 	jnc::initialize("jnc_sample_02_embed_cpp");
[-] 	std::auto_ptr <char> fileName_utf8 = convertToUtf8 (argv [1]);
[+] 	std::auto_ptr<char> fileName_utf8 = convertToUtf8(argv[1]);
[-] 	const char* fileName = fileName_utf8.get ();
[+] 	const char* fileName = fileName_utf8.get();
[-] 	const char* fileName = argv [1];
[+] 	const char* fileName = argv[1];
[-] 	module->initialize (fileName);
[+] 	module->initialize(fileName);
[-] 	module->addStaticLib (jnc::StdLib_getLib ());
[+] 	module->addStaticLib(jnc::StdLib_getLib());
[-] 	module->addStaticLib (MyLib_getLib ());
[+] 	module->addStaticLib(MyLib_getLib());
[-] 	printf ("Parsing '%s'...\n", fileName);
[+] 	printf("Parsing '%s'...\n", fileName);
[-] 		module->parseFile (fileName) &&
[+] 		module->parseFile(fileName) &&
[-] 		module->parseImports ();
[+] 		module->parseImports();
[-] 		printf ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc::getLastErrorDescription_v ());
[-] 	printf ("Compiling...\n");
[+] 	printf("Compiling...\n");
[-] 	result = module->compile ();
[+] 	result = module->compile();
[-] 		printf ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc::getLastErrorDescription_v ());
[-] 	printf ("JITting...\n");
[+] 	printf("JITting...\n");
[-] 	result = module->jit ();
[+] 	result = module->jit();
[-] 		printf ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc::getLastErrorDescription_v ());
[-] 	jnc::Namespace* nspace = module->getGlobalNamespace ()->getNamespace ();
[+] 	jnc::Namespace* nspace = module->getGlobalNamespace()->getNamespace();
[-] 	jnc::Function* mainFunction = nspace->findFunction ("main", true);
[+] 	jnc::Function* mainFunction = nspace->findFunction("main", true);
[-] 		printf ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc::getLastErrorDescription_v ());
[-] 	printf ("Running...\n");
[+] 	printf("Running...\n");
[-] 	result = runtime->startup (module);
[+] 	result = runtime->startup(module);
[-] 		printf ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("%s\n", jnc::getLastErrorDescription_v ());
[-] 	result = jnc::callFunction (runtime, mainFunction, &returnValue);
[+] 	result = jnc::callFunction(runtime, mainFunction, &returnValue);
[-] 		printf ("Runtime error: %s\n", jnc::getLastErrorDescription_v ());
[+] 		printf("Runtime error: %s\n", jnc::getLastErrorDescription_v ());
[-] 	printf ("Shutting down...\n");
[+] 	printf("Shutting down...\n");
[-] 	runtime->shutdown ();
[+] 	runtime->shutdown();
[-] 	printf ("Done.\n");
[+] 	printf("Done.\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\MyLib.cpp
----------------------
[-] foo_0 (int x)
[+] foo_0(int x)
[-] 	printf ("  foo_0 (%d)\n", x);
[+] 	printf("  foo_0 (%d)\n", x);
[-] foo_1 (double x)
[+] foo_1(double x)
[-] 	printf ("  foo_1 (%f)\n", x);
[+] 	printf("  foo_1 (%f)\n", x);
[-] foo_2 (jnc::DataPtr ptr)
[+] foo_2(jnc::DataPtr ptr)
[-] 	printf ("  foo_2 (%s)\n", ptr.m_p);
[+] 	printf("  foo_2 (%s)\n", ptr.m_p);
[-] getSimpleProp ()
[+] getSimpleProp()
[-] 	printf ("  getSimpleProp () => %d\n", g_simplePropValue);
[+] 	printf("  getSimpleProp () => %d\n", g_simplePropValue);
[-] setSimpleProp (int x)
[+] setSimpleProp(int x)
[-] 	printf ("  setSimpleProp (%d)\n", x);
[+] 	printf("  setSimpleProp (%d)\n", x);
[-] getProp ()
[+] getProp()
[-] 	printf ("  getProp () => %s\n", g_propValue.m_p);
[+] 	printf("  getProp () => %s\n", g_propValue.m_p);
[-] setProp_0 (int x)
[+] setProp_0(int x)
[-] 	printf ("  setProp_0 (%d)\n", x);
[+] 	printf("  setProp_0 (%d)\n", x);
[-] 	char buffer [32];
[+] 	char buffer[32];
[-] 	int length = sprintf (buffer, "%d", x);
[+] 	int length = sprintf(buffer, "%d", x);
[-] 	g_propValue = jnc::strDup (buffer, length);
[+] 	g_propValue = jnc::strDup(buffer, length);
[-] setProp_1 (double x)
[+] setProp_1(double x)
[-] 	printf ("  setProp_1 (%f)\n", x);
[+] 	printf("  setProp_1 (%f)\n", x);
[-] 	char buffer [32];
[+] 	char buffer[32];
[-] 	int length = sprintf (buffer, "%f", x);
[+] 	int length = sprintf(buffer, "%f", x);
[-] 	g_propValue = jnc::strDup (buffer, length);
[+] 	g_propValue = jnc::strDup(buffer, length);
[-] setProp_2 (jnc::DataPtr ptr)
[+] setProp_2(jnc::DataPtr ptr)
[-] 	printf ("  setProp_2 (%s)\n", ptr.m_p);
[+] 	printf("  setProp_2 (%s)\n", ptr.m_p);
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (MyLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(MyLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (MyLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(MyLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (TestClass)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(TestClass)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (MyLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(MyLib)
[-] 	JNC_MAP_FUNCTION ("foo",    &foo_0)
[+] 	JNC_MAP_FUNCTION("foo",    &foo_0)
[-] 	JNC_MAP_OVERLOAD (&foo_1)
[+] 	JNC_MAP_OVERLOAD(&foo_1)
[-] 	JNC_MAP_OVERLOAD (&foo_2)
[+] 	JNC_MAP_OVERLOAD(&foo_2)
[-] 	JNC_MAP_PROPERTY ("g_simpleProp",  &getSimpleProp, &setSimpleProp)
[+] 	JNC_MAP_PROPERTY("g_simpleProp",  &getSimpleProp, &setSimpleProp)
[-] 	JNC_MAP_PROPERTY ("g_prop",  &getProp, &setProp_0)
[+] 	JNC_MAP_PROPERTY("g_prop",  &getProp, &setProp_0)
[-] 	JNC_MAP_OVERLOAD (&setProp_1)
[+] 	JNC_MAP_OVERLOAD(&setProp_1)
[-] 	JNC_MAP_OVERLOAD (&setProp_2)
[+] 	JNC_MAP_OVERLOAD(&setProp_2)
[-] 	JNC_MAP_TYPE (TestStruct)
[+] 	JNC_MAP_TYPE(TestStruct)
[-] 	JNC_MAP_TYPE (TestClass)
[+] 	JNC_MAP_TYPE(TestClass)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\TestClass.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestClass)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestClass)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <TestClass, int>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<TestClass, int>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <TestClass>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<TestClass>)
[-] 	JNC_MAP_BINARY_OPERATOR (jnc::BinOpKind_AddAssign, &TestClass::addAssign)
[+] 	JNC_MAP_BINARY_OPERATOR(jnc::BinOpKind_AddAssign, &TestClass::addAssign)
[-] 	JNC_MAP_BINARY_OPERATOR (jnc::BinOpKind_SubAssign, &TestClass::subAssign)
[+] 	JNC_MAP_BINARY_OPERATOR(jnc::BinOpKind_SubAssign, &TestClass::subAssign)
[-] 	JNC_MAP_FUNCTION ("foo", &TestClass::foo_0)
[+] 	JNC_MAP_FUNCTION("foo", &TestClass::foo_0)
[-] 	JNC_MAP_OVERLOAD (&TestClass::foo_1)
[+] 	JNC_MAP_OVERLOAD(&TestClass::foo_1)
[-] 	JNC_MAP_OVERLOAD (&TestClass::foo_2)
[+] 	JNC_MAP_OVERLOAD(&TestClass::foo_2)
[-] 	JNC_MAP_PROPERTY ("m_prop", &TestClass::setProp, &TestClass::setProp)
[+] 	JNC_MAP_PROPERTY("m_prop", &TestClass::setProp, &TestClass::setProp)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] TestClass::TestClass (int value)
[+] TestClass::TestClass(int value)
[-] 	printf ("  TestClass::TestClass (%d)\n", value);
[+] 	printf("  TestClass::TestClass (%d)\n", value);
[-] 	sprintf (m_internalData, "TestClass (%p)", this);
[+] 	sprintf(m_internalData, "TestClass (%p)", this);
[-] TestClass::~TestClass ()
[+] TestClass::~TestClass()
[-] 	printf ("  TestClass::~TestClass ()\n");
[+] 	printf("  TestClass::~TestClass ()\n");
[-] TestClass::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] TestClass::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		gcHeap->markClass (m_internalObject->m_box);
[+] 		gcHeap->markClass(m_internalObject->m_box);
[-] TestClass::addAssign (int delta)
[+] TestClass::addAssign(int delta)
[-] 	printf ("  TestClass::addAssign (%d)\n", delta);
[+] 	printf("  TestClass::addAssign (%d)\n", delta);
[-] 	return setInternalValue (m_internalValue + delta);
[+] 	return setInternalValue(m_internalValue + delta);
[-] TestClass::subAssign (int delta)
[+] TestClass::subAssign(int delta)
[-] 	printf ("  TestClass::subAssign (%d)\n", delta);
[+] 	printf("  TestClass::subAssign (%d)\n", delta);
[-] 	return setInternalValue (m_internalValue - delta);
[+] 	return setInternalValue(m_internalValue - delta);
[-] TestClass::foo_0 ()
[+] TestClass::foo_0()
[-] 	printf ("  TestClass::foo_0 ()\n");
[+] 	printf("  TestClass::foo_0 ()\n");
[-] TestClass::foo_1 (int value)
[+] TestClass::foo_1(int value)
[-] 	printf ("  TestClass::foo_1 (%d)\n", value);
[+] 	printf("  TestClass::foo_1 (%d)\n", value);
[-] 	return setInternalValue (value);
[+] 	return setInternalValue(value);
[-] TestClass::foo_2 (TestClass* src)
[+] TestClass::foo_2(TestClass* src)
[-] 	printf ("  TestClass::foo_2 ()\n");
[+] 	printf("  TestClass::foo_2 ()\n");
[-] 	return setInternalValue (src->m_internalValue);
[+] 	return setInternalValue(src->m_internalValue);
[-] TestClass::setProp (jnc::DataPtr ptr)
[+] TestClass::setProp(jnc::DataPtr ptr)
[-] 	printf ("  TestClass::setProp (%s)\n", ptr.m_p);
[+] 	printf("  TestClass::setProp (%s)\n", ptr.m_p);
[-] TestClass::setInternalValue (int value)
[+] TestClass::setInternalValue(int value)
[-] 		callMulticast (jnc::getCurrentThreadRuntime (), m_onNegative);
[+] 		callMulticast(jnc::getCurrentThreadRuntime(), m_onNegative);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\TestStruct.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestStruct)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestStruct)
[-] 	JNC_MAP_CONSTRUCTOR (&TestStruct::construct_0)
[+] 	JNC_MAP_CONSTRUCTOR(&TestStruct::construct_0)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::construct_1)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::construct_1)
[-] 	JNC_MAP_FUNCTION ("foo", &TestStruct::foo_0)
[+] 	JNC_MAP_FUNCTION("foo", &TestStruct::foo_0)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::foo_1)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::foo_1)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::foo_2)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::foo_2)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] TestStruct::construct_0 (jnc::DataPtr selfPtr)
[+] TestStruct::construct_0(jnc::DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct::construct_0 ()\n");
[+] 	printf("  TestStruct::construct_0 ()\n");
[-] TestStruct::construct_1 (
[+] TestStruct::construct_1(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct::construct_1 (%d, %d)\n", x, y);
[+] 	printf("  TestStruct::construct_1 (%d, %d)\n", x, y);
[-] TestStruct::foo_0 (jnc::DataPtr selfPtr)
[+] TestStruct::foo_0(jnc::DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct::foo_0 ()\n");
[+] 	printf("  TestStruct::foo_0 ()\n");
[-] TestStruct::foo_1 (
[+] TestStruct::foo_1(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("  TestStruct::foo_1 (%d, %d)\n", x, y);
[+] 	printf("  TestStruct::foo_1 (%d, %d)\n", x, y);
[-] TestStruct::foo_2 (
[+] TestStruct::foo_2(
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	TestStruct* src = (TestStruct*) srcPtr.m_p;
[+] 	TestStruct* src = (TestStruct*)srcPtr.m_p;
[-] 	printf ("  TestStruct::foo_2 ( { %d, %d } )\n", src->m_x, src->m_y);
[+] 	printf("  TestStruct::foo_2 ( { %d, %d } )\n", src->m_x, src->m_y);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\MyLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
[-] JNC_DECLARE_LIB (MyLib)
[+] JNC_DECLARE_LIB(MyLib)
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\pch.h
----------------------
[-] #pragma warning (disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
[+] #pragma warning(disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\TestClass.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (TestClass)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(TestClass)
[-] 	jnc::ClassBox <jnc::Multicast> m_onNegative;
[+] 	jnc::ClassBox<jnc::Multicast> m_onNegative;
[-] 	char m_internalData [256];
[+] 	char m_internalData[256];
[-] 	TestClass (int value);
[+] 	TestClass(int value);
[-] 	~TestClass ();
[+] 	~TestClass();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	addAssign (int delta);
[+] 	addAssign(int delta);
[-] 	subAssign (int delta);
[+] 	subAssign(int delta);
[-] 	foo_0 ();
[+] 	foo_0();
[-] 	foo_1 (int value);
[+] 	foo_1(int value);
[-] 	foo_2 (TestClass* src);
[+] 	foo_2(TestClass* src);
[-] 	setProp (jnc::DataPtr ptr);
[+] 	setProp(jnc::DataPtr ptr);
[-] 	setInternalValue (int value);
[+] 	setInternalValue(int value);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\TestStruct.h
----------------------
[-] JNC_DECLARE_TYPE (TestStruct)
[+] JNC_DECLARE_TYPE(TestStruct)
[-] 	construct_0 (jnc::DataPtr selfPtr);
[+] 	construct_0(jnc::DataPtr selfPtr);
[-] 	construct_1 (
[+] 	construct_1(
[-] 	foo_0 (jnc::DataPtr selfPtr);
[+] 	foo_0(jnc::DataPtr selfPtr);
[-] 	foo_1 (
[+] 	foo_1(
[-] 	foo_2 (
[+] 	foo_2(
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\main.cpp
----------------------
[-] #	pragma comment (linker, "/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup")
[+] #	pragma comment(linker, "/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup")
[-] int main (int argc, char* argv [])
[+] int main(int argc, char* argv[])
[-] 	jnc::initialize ("jnc_sample_03_dialog");
[+] 	jnc::initialize("jnc_sample_03_dialog");
[-] 		const char* arg = argv [i];
[+] 		const char* arg = argv[i];
[-] 		if (arg [0] != '-')
[+] 		if (arg[0] != '-')
[-] 		else if (strcmp (arg, "--test") == 0)
[+] 		else if (strcmp(arg, "--test") == 0)
[-] 	QApplication app (argc, argv);
[+] 	QApplication app(argc, argv);
[-] 	QCoreApplication::setOrganizationName ("Tibbo");
[+] 	QCoreApplication::setOrganizationName("Tibbo");
[-] 	QCoreApplication::setOrganizationDomain ("tibbo.com");
[+] 	QCoreApplication::setOrganizationDomain("tibbo.com");
[-] 	QCoreApplication::setApplicationName ("JancyDialog");
[+] 	QCoreApplication::setApplicationName("JancyDialog");
[-] 	mainWindow.show ();
[+] 	mainWindow.show();
[-] 	bool result = mainWindow.runScript (fileName);
[+] 	bool result = mainWindow.runScript(fileName);
[-] 		printf ("%s\n", mainWindow.readOutput ().toUtf8 ().constData ());
[+] 		printf("%s\n", mainWindow.readOutput ().toUtf8 ().constData ());
[-] 	return app.exec ();
[+] 	return app.exec();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MainWindow.cpp
----------------------
[-] MainWindow* getMainWindow ()
[+] MainWindow* getMainWindow()
[-] size_t printToMainWindow (const void* p, size_t size)
[+] size_t printToMainWindow(const void* p, size_t size)
[-] 	return getMainWindow ()->outputDirect (QString::fromUtf8 ((const char*) p, size));
[+] 	return getMainWindow()->outputDirect(QString::fromUtf8((const char*) p, size));
[-] MainWindow::MainWindow (
[+] MainWindow::MainWindow(
[-] 	QMainWindow (parent, flags)
[+] 	QMainWindow(parent, flags)
[-] 	Q_ASSERT (!g_mainWindow);
[+] 	Q_ASSERT(!g_mainWindow);
[-] 	m_body = new QWidget (this);
[+] 	m_body = new QWidget(this);
[-] 	m_body->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);
[+] 	m_body->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
[-] 	setCentralWidget (m_body);
[+] 	setCentralWidget(m_body);
[-] 	QFont font ("Monospace", 9);
[+] 	QFont font("Monospace", 9);
[-] 	font.setStyleHint (QFont::TypeWriter);
[+] 	font.setStyleHint(QFont::TypeWriter);
[-] 	m_output = new QPlainTextEdit (this);
[+] 	m_output = new QPlainTextEdit(this);
[-] 	m_output->setTextInteractionFlags (Qt::TextSelectableByMouse | Qt::TextSelectableByKeyboard);
[+] 	m_output->setTextInteractionFlags(Qt::TextSelectableByMouse | Qt::TextSelectableByKeyboard);
[-] 	m_output->setLineWrapMode (QPlainTextEdit::NoWrap);
[+] 	m_output->setLineWrapMode(QPlainTextEdit::NoWrap);
[-] 	m_output->setFont (font);
[+] 	m_output->setFont(font);
[-] 	QDockWidget* dockWidget = new QDockWidget ("Output", this);
[+] 	QDockWidget* dockWidget = new QDockWidget("Output", this);
[-] 	dockWidget->setWidget (m_output);
[+] 	dockWidget->setWidget(m_output);
[-] 	addDockWidget (Qt::BottomDockWidgetArea, dockWidget);
[+] 	addDockWidget(Qt::BottomDockWidgetArea, dockWidget);
[-] 	jnc::StdLib_setStdIo (NULL, printToMainWindow, printToMainWindow);
[+] 	jnc::StdLib_setStdIo(NULL, printToMainWindow, printToMainWindow);
[-] int MainWindow::outputDirect (const QString& string)
[+] int MainWindow::outputDirect(const QString& string)
[-] 	m_output->moveCursor (QTextCursor::End);
[+] 	m_output->moveCursor(QTextCursor::End);
[-] 	m_output->insertPlainText (string);
[+] 	m_output->insertPlainText(string);
[-] 	return string.length ();
[+] 	return string.length();
[-] int MainWindow::output_va (const char* format, va_list va)
[+] int MainWindow::output_va(const char* format, va_list va)
[-] 	string.vsprintf (format, va);
[+] 	string.vsprintf(format, va);
[-] 	return outputDirect (string);
[+] 	return outputDirect(string);
[-] int MainWindow::output (const char* format, ...)
[+] int MainWindow::output(const char* format, ...)
[-] 	va_start (va, format);
[+] 	va_start(va, format);
[-] 	return output_va (format, va);
[+] 	return output_va(format, va);
[-] bool MainWindow::runScript (const QString& fileName)
[+] bool MainWindow::runScript(const QString& fileName)
[-] 	if (fileName.isEmpty ())
[+] 	if (fileName.isEmpty())
[-] 		output ("usage: 02_dialog <script.jnc>\n");
[+] 		output("usage: 02_dialog <script.jnc>\n");
[-] 	QByteArray fileName_utf8 = fileName.toUtf8 ();
[+] 	QByteArray fileName_utf8 = fileName.toUtf8();
[-] 	output ("Parsing...\n");
[+] 	output("Parsing...\n");
[-] 	m_module->initialize (fileName_utf8.constBegin ());
[+] 	m_module->initialize(fileName_utf8.constBegin());
[-] 	m_module->addStaticLib (jnc::StdLib_getLib ());
[+] 	m_module->addStaticLib(jnc::StdLib_getLib());
[-] 	m_module->addStaticLib (MyLib_getLib ());
[+] 	m_module->addStaticLib(MyLib_getLib());
[-] 		m_module->parseFile (fileName_utf8.constBegin ()) &&
[+] 		m_module->parseFile(fileName_utf8.constBegin()) &&
[-] 		m_module->parseImports ();
[+] 		m_module->parseImports();
[-] 		output ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		output("%s\n", jnc::getLastErrorDescription_v ());
[-] 	output ("Compiling...\n");
[+] 	output("Compiling...\n");
[-] 	result = m_module->compile ();
[+] 	result = m_module->compile();
[-] 		output ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		output("%s\n", jnc::getLastErrorDescription_v ());
[-] 	output ("JITting...\n");
[+] 	output("JITting...\n");
[-] 	result = m_module->jit ();
[+] 	result = m_module->jit();
[-] 		output ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		output("%s\n", jnc::getLastErrorDescription_v ());
[-] 	jnc::Namespace* nspace = m_module->getGlobalNamespace ()->getNamespace ();
[+] 	jnc::Namespace* nspace = m_module->getGlobalNamespace()->getNamespace();
[-] 	jnc::Function* mainFunction = nspace->findFunction ("main");
[+] 	jnc::Function* mainFunction = nspace->findFunction("main");
[-] 		output ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		output("%s\n", jnc::getLastErrorDescription_v ());
[-] 	output ("Running...\n");
[+] 	output("Running...\n");
[-] 	result = m_runtime->startup (m_module);
[+] 	result = m_runtime->startup(m_module);
[-] 		output ("%s\n", jnc::getLastErrorDescription_v ());
[+] 		output("%s\n", jnc::getLastErrorDescription_v ());
[-] 	createLayout ();
[+] 	createLayout();
[-] 	result = jnc::callFunction (m_runtime, mainFunction, &returnValue, m_layout);
[+] 	result = jnc::callFunction(m_runtime, mainFunction, &returnValue, m_layout);
[-] 		output ("Runtime error: %s\n", jnc::getLastErrorDescription_v ());
[+] 		output("Runtime error: %s\n", jnc::getLastErrorDescription_v ());
[-] 	output ("Done.\n");
[+] 	output("Done.\n");
[-] void MainWindow::createLayout ()
[+] void MainWindow::createLayout()
[-] 	m_runtime->getGcHeap ()->addStaticRoot (&m_layout, m_module->getStdType (jnc::StdType_AbstractClassPtr));
[+] 	m_runtime->getGcHeap()->addStaticRoot(&m_layout, m_module->getStdType(jnc::StdType_AbstractClassPtr));
[-] 	JNC_BEGIN_CALL_SITE (m_runtime)
[+] 	JNC_BEGIN_CALL_SITE(m_runtime)
[-] 	m_layout = jnc::createClass <MyLayout> (m_runtime, QBoxLayout::TopToBottom);
[+] 	m_layout = jnc::createClass<MyLayout> (m_runtime, QBoxLayout::TopToBottom);
[-] 	m_body->setLayout (m_layout->m_qtLayout);
[+] 	m_body->setLayout(m_layout->m_qtLayout);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] void MainWindow::closeEvent (QCloseEvent* e)
[+] void MainWindow::closeEvent(QCloseEvent* e)
[-] 	output ("Shutting down...\n");
[+] 	output("Shutting down...\n");
[-] 	m_runtime->shutdown ();
[+] 	m_runtime->shutdown();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyButton.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyButton)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyButton)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <MyButton, jnc::DataPtr>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<MyButton, jnc::DataPtr>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MyButton>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MyButton>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_text", &MyButton::setText)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_text", &MyButton::setText)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyButton::MyButton (jnc::DataPtr textPtr):
[+] MyButton::MyButton(jnc::DataPtr textPtr):
[-] 	MyWidget (new QPushButton)
[+] 	MyWidget(new QPushButton)
[-] 	m_qtButton = (QPushButton*) m_handle;
[+] 	m_qtButton = (QPushButton*)m_handle;
[-] 	setText (textPtr);
[+] 	setText(textPtr);
[-] 	m_onClickedBridge->connect (m_qtButton, SIGNAL (clicked ()), m_onClicked);
[+] 	m_onClickedBridge->connect(m_qtButton, SIGNAL(clicked()), m_onClicked);
[-] MyButton::~MyButton ()
[+] MyButton::~MyButton()
[-] 	if (!m_qtButton->parent ())
[+] 	if (!m_qtButton->parent())
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyCheckBox.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyCheckBox)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyCheckBox)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <MyCheckBox, jnc::DataPtr>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<MyCheckBox, jnc::DataPtr>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MyCheckBox>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MyCheckBox>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_text", &MyCheckBox::setText)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_text", &MyCheckBox::setText)
[-] 	JNC_MAP_PROPERTY ("m_isChecked", &MyCheckBox::isChecked, &MyCheckBox::setChecked)
[+] 	JNC_MAP_PROPERTY("m_isChecked", &MyCheckBox::isChecked, &MyCheckBox::setChecked)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyCheckBox::MyCheckBox (jnc::DataPtr textPtr):
[+] MyCheckBox::MyCheckBox(jnc::DataPtr textPtr):
[-] 	MyWidget (new QCheckBox)
[+] 	MyWidget(new QCheckBox)
[-] 	m_qtCheckBox = (QCheckBox*) m_handle;
[+] 	m_qtCheckBox = (QCheckBox*)m_handle;
[-] 	setText (textPtr);
[+] 	setText(textPtr);
[-] 	m_onIsCheckedChangedBridge->connect (m_qtCheckBox, SIGNAL (stateChanged (int)), m_onIsCheckedChanged);
[+] 	m_onIsCheckedChangedBridge->connect(m_qtCheckBox, SIGNAL(stateChanged(int)), m_onIsCheckedChanged);
[-] MyCheckBox::~MyCheckBox ()
[+] MyCheckBox::~MyCheckBox()
[-] 	if (!m_qtCheckBox->parent ())
[+] 	if (!m_qtCheckBox->parent())
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLabel.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyLabel)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyLabel)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <MyLabel, jnc::DataPtr>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<MyLabel, jnc::DataPtr>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MyLabel>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MyLabel>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_text", &MyLabel::setText)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_text", &MyLabel::setText)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_color", &MyLabel::setColor)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_color", &MyLabel::setColor)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_backColor", &MyLabel::setBackColor)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_backColor", &MyLabel::setBackColor)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_alignment", &MyLabel::setAlignment)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_alignment", &MyLabel::setAlignment)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyLabel::MyLabel (jnc::DataPtr textPtr):
[+] MyLabel::MyLabel(jnc::DataPtr textPtr):
[-] 	MyWidget (new QLabel)
[+] 	MyWidget(new QLabel)
[-] 	m_qtLabel = (QLabel*) m_handle;
[+] 	m_qtLabel = (QLabel*)m_handle;
[-] 	m_alignment = m_qtLabel->alignment ();
[+] 	m_alignment = m_qtLabel->alignment();
[-] 	setText (textPtr);
[+] 	setText(textPtr);
[-] MyLabel::~MyLabel ()
[+] MyLabel::~MyLabel()
[-] 	if (!m_qtLabel->parent ())
[+] 	if (!m_qtLabel->parent())
[-] MyLabel::updateStyleSheet ()
[+] MyLabel::updateStyleSheet()
[-] 		styleSheet += QString ("color: #%1; ").arg (m_color, 6, 16, (QChar) '0');
[+] 		styleSheet += QString("color: #%1; ").arg (m_color, 6, 16, (QChar) '0');
[-] 		styleSheet += QString ("background-color: #%1; ").arg (m_backColor, 6, 16, (QChar) '0');
[+] 		styleSheet += QString("background-color: #%1; ").arg (m_backColor, 6, 16, (QChar) '0');
[-] 	m_qtLabel->setStyleSheet (styleSheet);
[+] 	m_qtLabel->setStyleSheet(styleSheet);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLayout.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyLayout)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyLayout)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <MyLayout, QBoxLayout::Direction>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<MyLayout, QBoxLayout::Direction>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MyLayout>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MyLayout>)
[-] 	JNC_MAP_FUNCTION ("addWidget", &MyLayout::addWidget)
[+] 	JNC_MAP_FUNCTION("addWidget", &MyLayout::addWidget)
[-] 	JNC_MAP_FUNCTION ("addLayout", &MyLayout::addLayout)
[+] 	JNC_MAP_FUNCTION("addLayout", &MyLayout::addLayout)
[-] 	JNC_MAP_FUNCTION ("addSpacer", &MyLayout::addSpacer)
[+] 	JNC_MAP_FUNCTION("addSpacer", &MyLayout::addSpacer)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyLayout::MyLayout (QBoxLayout::Direction direction)
[+] MyLayout::MyLayout(QBoxLayout::Direction direction)
[-] 	m_qtLayout = new QBoxLayout (direction);
[+] 	m_qtLayout = new QBoxLayout(direction);
[-] MyLayout::~MyLayout ()
[+] MyLayout::~MyLayout()
[-] 	if (!m_qtLayout->parent ())
[+] 	if (!m_qtLayout->parent())
[-] MyLayout::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] MyLayout::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 	int count = m_childWidgetList.count ();
[+] 	int count = m_childWidgetList.count();
[-] 		MyWidget* widget = m_childWidgetList [i];
[+] 		MyWidget* widget = m_childWidgetList[i];
[-] 		gcHeap->markClass (widget->m_box);
[+] 		gcHeap->markClass(widget->m_box);
[-] 	count = m_childLayoutList.count ();
[+] 	count = m_childLayoutList.count();
[-] 		MyLayout* layout = m_childLayoutList [i];
[+] 		MyLayout* layout = m_childLayoutList[i];
[-] 		gcHeap->markClass (layout->m_box);
[+] 		gcHeap->markClass(layout->m_box);
[-] MyLayout::addWidget (MyWidget* widget)
[+] MyLayout::addWidget(MyWidget* widget)
[-] 	m_childWidgetList.append (widget);
[+] 	m_childWidgetList.append(widget);
[-] 	m_qtLayout->addWidget (widget->m_handle);
[+] 	m_qtLayout->addWidget(widget->m_handle);
[-] MyLayout::addLayout (MyLayout* layout)
[+] MyLayout::addLayout(MyLayout* layout)
[-] 	m_childLayoutList.append (layout);
[+] 	m_childLayoutList.append(layout);
[-] 	m_qtLayout->addLayout (layout->m_qtLayout);
[+] 	m_qtLayout->addLayout(layout->m_qtLayout);
[-] MyLayout::addSpacer ()
[+] MyLayout::addSpacer()
[-] 	switch (m_direction)
[+] 	switch(m_direction)
[-] 	QSpacerItem* item = new QSpacerItem (0, 0, hpolicy, vpolicy);
[+] 	QSpacerItem* item = new QSpacerItem(0, 0, hpolicy, vpolicy);
[-] 	m_qtLayout->addSpacerItem (item);
[+] 	m_qtLayout->addSpacerItem(item);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLib.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (MyLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(MyLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MyLayout)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MyLayout)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MyLabel)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MyLabel)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MyButton)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MyButton)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MyCheckBox)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MyCheckBox)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MyTextEdit)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MyTextEdit)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MySlider)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MySlider)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (MyLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(MyLib)
[-] 	JNC_MAP_TYPE (MyWidget)
[+] 	JNC_MAP_TYPE(MyWidget)
[-] 	JNC_MAP_TYPE (MyLayout)
[+] 	JNC_MAP_TYPE(MyLayout)
[-] 	JNC_MAP_TYPE (MyLabel)
[+] 	JNC_MAP_TYPE(MyLabel)
[-] 	JNC_MAP_TYPE (MyButton)
[+] 	JNC_MAP_TYPE(MyButton)
[-] 	JNC_MAP_TYPE (MyCheckBox)
[+] 	JNC_MAP_TYPE(MyCheckBox)
[-] 	JNC_MAP_TYPE (MyTextEdit)
[+] 	JNC_MAP_TYPE(MyTextEdit)
[-] 	JNC_MAP_TYPE (MySlider)
[+] 	JNC_MAP_TYPE(MySlider)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MySlider.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MySlider)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MySlider)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <MySlider, int, int>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<MySlider, int, int>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MySlider>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MySlider>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_minimum", &MySlider::setMinimum)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_minimum", &MySlider::setMinimum)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_maximum", &MySlider::setMaximum)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_maximum", &MySlider::setMaximum)
[-] 	JNC_MAP_PROPERTY ("m_value", &MySlider::getValue, &MySlider::setValue)
[+] 	JNC_MAP_PROPERTY("m_value", &MySlider::getValue, &MySlider::setValue)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MySlider::MySlider (
[+] MySlider::MySlider(
[-] 	MyWidget (new QSlider)
[+] 	MyWidget(new QSlider)
[-] 	m_qtSlider = (QSlider*) m_handle;
[+] 	m_qtSlider = (QSlider*)m_handle;
[-] 	m_qtSlider->setOrientation (Qt::Horizontal);
[+] 	m_qtSlider->setOrientation(Qt::Horizontal);
[-] 	setMinimum (minimum);
[+] 	setMinimum(minimum);
[-] 	setMaximum (maximum);
[+] 	setMaximum(maximum);
[-] 	m_onValueChangedBridge->connect (m_qtSlider, SIGNAL (valueChanged (int)), m_onValueChanged);
[+] 	m_onValueChangedBridge->connect(m_qtSlider, SIGNAL(valueChanged(int)), m_onValueChanged);
[-] MySlider::~MySlider ()
[+] MySlider::~MySlider()
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyTextEdit.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyTextEdit)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyTextEdit)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <MyTextEdit>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<MyTextEdit>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MyTextEdit>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MyTextEdit>)
[-] 	JNC_MAP_PROPERTY ("m_text", &MyTextEdit::getText, &MyTextEdit::setText)
[+] 	JNC_MAP_PROPERTY("m_text", &MyTextEdit::getText, &MyTextEdit::setText)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyTextEdit::MyTextEdit ():
[+] MyTextEdit::MyTextEdit():
[-] 	MyWidget (new QLineEdit)
[+] 	MyWidget(new QLineEdit)
[-] 	m_qtLineEdit = (QLineEdit*) m_handle;
[+] 	m_qtLineEdit = (QLineEdit*)m_handle;
[-] MyTextEdit::~MyTextEdit ()
[+] MyTextEdit::~MyTextEdit()
[-] 	if (!m_qtLineEdit->parent ())
[+] 	if (!m_qtLineEdit->parent())
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyWidget.cpp
----------------------
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MyWidget)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MyWidget)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_isVisible", &MyWidget::setVisible)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_isVisible", &MyWidget::setVisible)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_isEnabled", &MyWidget::setEnabled)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_isEnabled", &MyWidget::setEnabled)
[-] 	JNC_MAP_FUNCTION ("setSizePolicy", &MyWidget::setSizePolicy)
[+] 	JNC_MAP_FUNCTION("setSizePolicy", &MyWidget::setSizePolicy)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MyWidget::MyWidget (QWidget* widget)
[+] MyWidget::MyWidget(QWidget* widget)
[-] 	QSizePolicy sizePolicy = widget->sizePolicy ();
[+] 	QSizePolicy sizePolicy = widget->sizePolicy();
[-] 	m_hpolicy = sizePolicy.horizontalPolicy ();
[+] 	m_hpolicy = sizePolicy.horizontalPolicy();
[-] 	m_vpolicy = sizePolicy.verticalPolicy ();
[+] 	m_vpolicy = sizePolicy.verticalPolicy();
[-] 	m_isVisible = widget->isVisible ();
[+] 	m_isVisible = widget->isVisible();
[-] 	m_isEnabled = widget->isEnabled ();
[+] 	m_isEnabled = widget->isEnabled();
[-] MyWidget::setSizePolicy (
[+] MyWidget::setSizePolicy(
[-] 	m_handle->setSizePolicy (hpolicy, vpolicy);
[+] 	m_handle->setSizePolicy(hpolicy, vpolicy);
[-] MyWidget::setVisible (bool value)
[+] MyWidget::setVisible(bool value)
[-] 	m_handle->setVisible (value);
[+] 	m_handle->setVisible(value);
[-] MyWidget::setEnabled (bool value)
[+] MyWidget::setEnabled(bool value)
[-] 	m_handle->setEnabled (value);
[+] 	m_handle->setEnabled(value);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\QtSignalBridge.cpp
----------------------
[-] QtSignalBridge::QtSignalBridge (QObject* parent):
[+] QtSignalBridge::QtSignalBridge(QObject* parent):
[-] 	QObject (parent)
[+] 	QObject(parent)
[-] 	m_runtime = jnc::getCurrentThreadRuntime ();
[+] 	m_runtime = jnc::getCurrentThreadRuntime();
[-] 	Q_ASSERT (m_runtime);
[+] 	Q_ASSERT(m_runtime);
[-] QtSignalBridge::onQtSignal ()
[+] QtSignalBridge::onQtSignal()
[-] 	jnc::callMulticast (m_runtime, m_jncEvent);
[+] 	jnc::callMulticast(m_runtime, m_jncEvent);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MainWindow.h
----------------------
[-] 	MainWindow (QWidget* parent = NULL, Qt::WindowFlags flags = 0);
[+] 	MainWindow(QWidget* parent = NULL, Qt::WindowFlags flags = 0);
[-] 	bool runScript (const QString& fileName);
[+] 	bool runScript(const QString& fileName);
[-] 	int outputDirect (const QString& string);
[+] 	int outputDirect(const QString& string);
[-] 	int output_va (const char* format, va_list va);
[+] 	int output_va(const char* format, va_list va);
[-] 	int output (const char* format, ...);
[+] 	int output(const char* format, ...);
[-] 	QString readOutput ()
[+] 	QString readOutput()
[-] 		return m_output->toPlainText ();
[+] 		return m_output->toPlainText();
[-] 	virtual void closeEvent (QCloseEvent* e);
[+] 	virtual void closeEvent(QCloseEvent* e);
[-] 	void createLayout ();
[+] 	void createLayout();
[-] MainWindow* getMainWindow ();
[+] MainWindow* getMainWindow();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyButton.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MyButton)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MyButton)
[-] 	jnc::ClassBox <jnc::Multicast> m_onClicked;
[+] 	jnc::ClassBox<jnc::Multicast> m_onClicked;
[-] 	MyButton (jnc::DataPtr textPtr);
[+] 	MyButton(jnc::DataPtr textPtr);
[-] 	~MyButton ();
[+] 	~MyButton();
[-] 	setText (jnc::DataPtr textPtr)
[+] 	setText(jnc::DataPtr textPtr)
[-] 		m_qtButton->setText ((const char*) textPtr.m_p);
[+] 		m_qtButton->setText((const char*) textPtr.m_p);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyCheckBox.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MyCheckBox)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MyCheckBox)
[-] 	jnc::ClassBox <jnc::Multicast> m_onIsCheckedChanged;
[+] 	jnc::ClassBox<jnc::Multicast> m_onIsCheckedChanged;
[-] 	MyCheckBox (jnc::DataPtr textPtr);
[+] 	MyCheckBox(jnc::DataPtr textPtr);
[-] 	~MyCheckBox ();
[+] 	~MyCheckBox();
[-] 	setText (jnc::DataPtr textPtr)
[+] 	setText(jnc::DataPtr textPtr)
[-] 		m_qtCheckBox->setText ((const char*) textPtr.m_p);
[+] 		m_qtCheckBox->setText((const char*) textPtr.m_p);
[-] 	isChecked ()
[+] 	isChecked()
[-] 		return m_qtCheckBox->isChecked ();
[+] 		return m_qtCheckBox->isChecked();
[-] 	setChecked (bool value)
[+] 	setChecked(bool value)
[-] 		m_qtCheckBox->setChecked (value);
[+] 		m_qtCheckBox->setChecked(value);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLabel.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MyLabel)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MyLabel)
[-] 	MyLabel (jnc::DataPtr textPtr);
[+] 	MyLabel(jnc::DataPtr textPtr);
[-] 	~MyLabel ();
[+] 	~MyLabel();
[-] 	setText (jnc::DataPtr textPtr)
[+] 	setText(jnc::DataPtr textPtr)
[-] 		m_qtLabel->setText ((const char*) textPtr.m_p);
[+] 		m_qtLabel->setText((const char*) textPtr.m_p);
[-] 	setColor (int color)
[+] 	setColor(int color)
[-] 		updateStyleSheet ();
[+] 		updateStyleSheet();
[-] 	setBackColor (int color)
[+] 	setBackColor(int color)
[-] 		updateStyleSheet ();
[+] 		updateStyleSheet();
[-] 	setAlignment (Qt::Alignment alignment)
[+] 	setAlignment(Qt::Alignment alignment)
[-] 		m_qtLabel->setAlignment (alignment);
[+] 		m_qtLabel->setAlignment(alignment);
[-] 	updateStyleSheet ();
[+] 	updateStyleSheet();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLayout.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MyLayout)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MyLayout)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (MyLayout)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(MyLayout)
[-] 	QList <MyWidget*> m_childWidgetList;
[+] 	QList<MyWidget*> m_childWidgetList;
[-] 	QList <MyLayout*> m_childLayoutList;
[+] 	QList<MyLayout*> m_childLayoutList;
[-] 	MyLayout (QBoxLayout::Direction direction);
[+] 	MyLayout(QBoxLayout::Direction direction);
[-] 	~MyLayout ();
[+] 	~MyLayout();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	addWidget (MyWidget* widget);
[+] 	addWidget(MyWidget* widget);
[-] 	addLayout (MyLayout* layout);
[+] 	addLayout(MyLayout* layout);
[-] 	addSpacer ();
[+] 	addSpacer();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
[-] JNC_DECLARE_LIB (MyLib)
[+] JNC_DECLARE_LIB(MyLib)
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MySlider.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MySlider)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MySlider)
[-] 	jnc::ClassBox <jnc::Multicast> m_onValueChanged;
[+] 	jnc::ClassBox<jnc::Multicast> m_onValueChanged;
[-] 	MySlider (
[+] 	MySlider(
[-] 	~MySlider ();
[+] 	~MySlider();
[-] 	setMinimum (int minimum)
[+] 	setMinimum(int minimum)
[-] 		m_qtSlider->setMinimum (minimum);
[+] 		m_qtSlider->setMinimum(minimum);
[-] 	setMaximum (int maximum)
[+] 	setMaximum(int maximum)
[-] 		m_qtSlider->setMaximum (maximum);
[+] 		m_qtSlider->setMaximum(maximum);
[-] 	getValue ()
[+] 	getValue()
[-] 		return m_qtSlider->value ();
[+] 		return m_qtSlider->value();
[-] 	setValue (int value)
[+] 	setValue(int value)
[-] 		m_qtSlider->setValue (value);
[+] 		m_qtSlider->setValue(value);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyTextEdit.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MyTextEdit)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MyTextEdit)
[-] 	MyTextEdit ();
[+] 	MyTextEdit();
[-] 	~MyTextEdit ();
[+] 	~MyTextEdit();
[-] 	getText (MyTextEdit* self)
[+] 	getText(MyTextEdit* self)
[-] 		QByteArray text = self->m_qtLineEdit->text ().toUtf8 ();
[+] 		QByteArray text = self->m_qtLineEdit->text().toUtf8();
[-] 		return jnc::strDup (text, text.length ());
[+] 		return jnc::strDup(text, text.length());
[-] 	setText (jnc::DataPtr textPtr)
[+] 	setText(jnc::DataPtr textPtr)
[-] 		m_qtLineEdit->setText ((const char*) textPtr.m_p);
[+] 		m_qtLineEdit->setText((const char*) textPtr.m_p);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\MyWidget.h
----------------------
[-] JNC_DECLARE_CLASS_TYPE (MyWidget)
[+] JNC_DECLARE_CLASS_TYPE(MyWidget)
[-] 	MyWidget (QWidget* widget);
[+] 	MyWidget(QWidget* widget);
[-] 	setSizePolicy (
[+] 	setSizePolicy(
[-] 	setVisible (bool value);
[+] 	setVisible(bool value);
[-] 	setEnabled (bool value);
[+] 	setEnabled(bool value);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\pch.h
----------------------
[-] #			define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
[+] #			define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__)
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\QtSignalBridge.h
----------------------
[-] 	QtSignalBridge (QObject* parent = NULL);
[+] 	QtSignalBridge(QObject* parent = NULL);
[-] 	QtSignalBridge (
[+] 	QtSignalBridge(
[-] 		QObject (parent)
[+] 		QObject(parent)
[-] 		connect (sender, signal, jncEvent);
[+] 		connect(sender, signal, jncEvent);
[-] 	connect (
[+] 	connect(
[-] 		QObject::connect (sender, signal, this, SLOT (onQtSignal ()));
[+] 		QObject::connect(sender, signal, this, SLOT(onQtSignal()));
[-] 	onQtSignal ();
[+] 	onQtSignal();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Alias.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Alias_getTargetItem (jnc_Alias* alias)
[+] jnc_Alias_getTargetItem(jnc_Alias* alias)
[-] 	return alias->getTargetItem ();
[+] 	return alias->getTargetItem();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_ArrayType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_ArrayType_getElementType (jnc_ArrayType* type)
[+] jnc_ArrayType_getElementType(jnc_ArrayType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_arrayTypeFuncTable->m_getElementTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_arrayTypeFuncTable->m_getElementTypeFunc(type);
[-] jnc_ArrayType_getElementCount (jnc_ArrayType* type)
[+] jnc_ArrayType_getElementCount(jnc_ArrayType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_arrayTypeFuncTable->m_GetElementCountFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_arrayTypeFuncTable->m_GetElementCountFunc(type);
[-] jnc_ArrayType_getElementType (jnc_ArrayType* type)
[+] jnc_ArrayType_getElementType(jnc_ArrayType* type)
[-] 	return type->getElementType ();
[+] 	return type->getElementType();
[-] jnc_ArrayType_getElementCount (jnc_ArrayType* type)
[+] jnc_ArrayType_getElementCount(jnc_ArrayType* type)
[-] 	return type->getElementCount ();
[+] 	return type->getElementCount();
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_AttributeBlock.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_AttributeBlock_getAttributeCount (jnc_AttributeBlock* block)
[+] jnc_AttributeBlock_getAttributeCount(jnc_AttributeBlock* block)
[-] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_getAttributeCountFunc (block);
[+] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_getAttributeCountFunc(block);
[-] jnc_AttributeBlock_getAttribute (
[+] jnc_AttributeBlock_getAttribute(
[-] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_getAttributeFunc (block, index);
[+] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_getAttributeFunc(block, index);
[-] jnc_AttributeBlock_findAttribute (
[+] jnc_AttributeBlock_findAttribute(
[-] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_findAttributeFunc (block, name);
[+] 	return jnc_g_dynamicExtensionLibHost->m_attributeBlockFuncTable->m_findAttributeFunc(block, name);
[-] jnc_AttributeBlock_getAttributeCount (jnc_AttributeBlock* block)
[+] jnc_AttributeBlock_getAttributeCount(jnc_AttributeBlock* block)
[-] 	return block->getAttributeArray ().getCount ();
[+] 	return block->getAttributeArray().getCount();
[-] jnc_AttributeBlock_getAttribute (
[+] jnc_AttributeBlock_getAttribute(
[-] 	return block->getAttributeArray () [index];
[+] 	return block->getAttributeArray() [index];
[-] jnc_AttributeBlock_findAttribute (
[+] jnc_AttributeBlock_findAttribute(
[-] 	return block->findAttribute (name);
[+] 	return block->findAttribute(name);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_BitFieldType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_BitFieldType_getBaseType (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBaseType(jnc_BitFieldType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBaseTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBaseTypeFunc(type);
[-] jnc_BitFieldType_getBitOffset (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBitOffset(jnc_BitFieldType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBitOffsetFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBitOffsetFunc(type);
[-] jnc_BitFieldType_getBitCount (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBitCount(jnc_BitFieldType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBitCountFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_bitFieldTypeFuncTable->m_getBitCountFunc(type);
[-] jnc_BitFieldType_getBaseType (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBaseType(jnc_BitFieldType* type)
[-] 	return type->getBaseType ();
[+] 	return type->getBaseType();
[-] jnc_BitFieldType_getBitOffset (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBitOffset(jnc_BitFieldType* type)
[-] 	return type->getBitOffset ();
[+] 	return type->getBitOffset();
[-] jnc_BitFieldType_getBitCount (jnc_BitFieldType* type)
[+] jnc_BitFieldType_getBitCount(jnc_BitFieldType* type)
[-] 	return type->getBitCount ();
[+] 	return type->getBitCount();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_ClassType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getClassPtrTypeKindString (jnc_ClassPtrTypeKind ptrTypeKind)
[+] jnc_getClassPtrTypeKindString(jnc_ClassPtrTypeKind ptrTypeKind)
[-] 	static const char* stringTable [jnc_ClassPtrTypeKind__Count] =
[+] 	static const char* stringTable[jnc_ClassPtrTypeKind__Count] =
[-] 	return (size_t) ptrTypeKind < jnc_ClassPtrTypeKind__Count ?
[+] 	return (size_t)ptrTypeKind < jnc_ClassPtrTypeKind__Count ?
[-] 		stringTable [ptrTypeKind] :
[+] 		stringTable[ptrTypeKind] :
[-] jnc_ClassType_getClassTypeKind (jnc_ClassType* type)
[+] jnc_ClassType_getClassTypeKind(jnc_ClassType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getClassTypeKindFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getClassTypeKindFunc(type);
[-] jnc_ClassType_getIfaceStructType (jnc_ClassType* type)
[+] jnc_ClassType_getIfaceStructType(jnc_ClassType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getIfaceStructTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getIfaceStructTypeFunc(type);
[-] jnc_ClassType_getClassPtrType (
[+] jnc_ClassType_getClassPtrType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getClassPtrTypeFunc (type, ptrTypeKind, flags);
[+] 	return jnc_g_dynamicExtensionLibHost->m_classTypeFuncTable->m_getClassPtrTypeFunc(type, ptrTypeKind, flags);
[-] jnc_MulticastClassType_getTargetType (jnc_MulticastClassType* type)
[+] jnc_MulticastClassType_getTargetType(jnc_MulticastClassType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_multicastClassTypeFuncTable->m_getTargetTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_multicastClassTypeFuncTable->m_getTargetTypeFunc(type);
[-] jnc_MulticastClassType_getMethod (
[+] jnc_MulticastClassType_getMethod(
[-] 	return jnc_g_dynamicExtensionLibHost->m_multicastClassTypeFuncTable->m_getMethodFunc (type, method);
[+] 	return jnc_g_dynamicExtensionLibHost->m_multicastClassTypeFuncTable->m_getMethodFunc(type, method);
[-] jnc_McSnapshotClassType_getTargetType (jnc_McSnapshotClassType* type)
[+] jnc_McSnapshotClassType_getTargetType(jnc_McSnapshotClassType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_mcSnapshotClassTypeFuncTable->m_getTargetTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_mcSnapshotClassTypeFuncTable->m_getTargetTypeFunc(type);
[-] jnc_McSnapshotClassType_getMethod (
[+] jnc_McSnapshotClassType_getMethod(
[-] 	return jnc_g_dynamicExtensionLibHost->m_mcSnapshotClassTypeFuncTable->m_getMethodFunc (type, method);
[+] 	return jnc_g_dynamicExtensionLibHost->m_mcSnapshotClassTypeFuncTable->m_getMethodFunc(type, method);
[-] jnc_ClassType_getClassTypeKind (jnc_ClassType* type)
[+] jnc_ClassType_getClassTypeKind(jnc_ClassType* type)
[-] 	return type->getClassTypeKind ();
[+] 	return type->getClassTypeKind();
[-] jnc_ClassType_getIfaceStructType (jnc_ClassType* type)
[+] jnc_ClassType_getIfaceStructType(jnc_ClassType* type)
[-] 	return type->getIfaceStructType ();
[+] 	return type->getIfaceStructType();
[-] jnc_ClassType_getClassPtrType (
[+] jnc_ClassType_getClassPtrType(
[-] 	return type->getClassPtrType (ptrTypeKind, flags);
[+] 	return type->getClassPtrType(ptrTypeKind, flags);
[-] jnc_MulticastClassType_getTargetType (jnc_MulticastClassType* type)
[+] jnc_MulticastClassType_getTargetType(jnc_MulticastClassType* type)
[-] 	return type->getTargetType ();
[+] 	return type->getTargetType();
[-] jnc_MulticastClassType_getMethod (
[+] jnc_MulticastClassType_getMethod(
[-] 	return type->getMethod (method);
[+] 	return type->getMethod(method);
[-] jnc_McSnapshotClassType_getTargetType (jnc_McSnapshotClassType* type)
[+] jnc_McSnapshotClassType_getTargetType(jnc_McSnapshotClassType* type)
[-] 	return type->getTargetType ();
[+] 	return type->getTargetType();
[-] jnc_McSnapshotClassType_getMethod (
[+] jnc_McSnapshotClassType_getMethod(
[-] 	return type->getMethod (method);
[+] 	return type->getMethod(method);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_DerivableType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_BaseTypeSlot_getOffset (jnc_BaseTypeSlot* baseType)
[+] jnc_BaseTypeSlot_getOffset(jnc_BaseTypeSlot* baseType)
[-] 	return jnc_g_dynamicExtensionLibHost->m_baseTypeSlotFuncTable->m_getOffsetFunc (baseType);
[+] 	return jnc_g_dynamicExtensionLibHost->m_baseTypeSlotFuncTable->m_getOffsetFunc(baseType);
[-] jnc_BaseTypeSlot_getVTableIndex (jnc_BaseTypeSlot* baseType)
[+] jnc_BaseTypeSlot_getVTableIndex(jnc_BaseTypeSlot* baseType)
[-] 	return jnc_g_dynamicExtensionLibHost->m_baseTypeSlotFuncTable->m_getVTableIndexFunc (baseType);
[+] 	return jnc_g_dynamicExtensionLibHost->m_baseTypeSlotFuncTable->m_getVTableIndexFunc(baseType);
[-] jnc_DerivableType_getStaticConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getStaticConstructor(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getStaticConstructorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getStaticConstructorFunc(type);
[-] jnc_DerivableType_getStaticDestructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getStaticDestructor(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getStaticDestructorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getStaticDestructorFunc(type);
[-] jnc_DerivableType_getPreConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getPreConstructor(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getPreConstructorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getPreConstructorFunc(type);
[-] jnc_DerivableType_getConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getConstructor(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getConstructorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getConstructorFunc(type);
[-] jnc_DerivableType_getDestructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getDestructor(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getDestructorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getDestructorFunc(type);
[-] jnc_DerivableType_getUnaryOperator (
[+] jnc_DerivableType_getUnaryOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getUnaryOperatorFunc (type, opKind);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getUnaryOperatorFunc(type, opKind);
[-] jnc_DerivableType_getBinaryOperator (
[+] jnc_DerivableType_getBinaryOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getBinaryOperatorFunc (type, opKind);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getBinaryOperatorFunc(type, opKind);
[-] jnc_DerivableType_getCallOperator (jnc_DerivableType* type)
[+] jnc_DerivableType_getCallOperator(jnc_DerivableType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getCallOperatorFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getCallOperatorFunc(type);
[-] jnc_DerivableType_getCastOperator (
[+] jnc_DerivableType_getCastOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getCastOperatorFunc (type, idx);
[+] 	return jnc_g_dynamicExtensionLibHost->m_derivableTypeFuncTable->m_getCastOperatorFunc(type, idx);
[-] jnc_BaseTypeSlot_getOffset (jnc_BaseTypeSlot* baseType)
[+] jnc_BaseTypeSlot_getOffset(jnc_BaseTypeSlot* baseType)
[-] 	return baseType->getOffset ();
[+] 	return baseType->getOffset();
[-] jnc_BaseTypeSlot_getVTableIndex (jnc_BaseTypeSlot* baseType)
[+] jnc_BaseTypeSlot_getVTableIndex(jnc_BaseTypeSlot* baseType)
[-] 	return baseType->getVTableIndex ();
[+] 	return baseType->getVTableIndex();
[-] jnc_DerivableType_getStaticConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getStaticConstructor(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getStaticConstructor ();
[+] 	jnc_Function* function = type->getStaticConstructor();
[-] 		err::setFormatStringError ("'%s' has no static constructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no static constructor", type->getTypeString ().sz ());
[-] jnc_DerivableType_getStaticDestructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getStaticDestructor(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getStaticDestructor ();
[+] 	jnc_Function* function = type->getStaticDestructor();
[-] 		err::setFormatStringError ("'%s' has no static destructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no static destructor", type->getTypeString ().sz ());
[-] jnc_DerivableType_getPreConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getPreConstructor(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getPreConstructor ();
[+] 	jnc_Function* function = type->getPreConstructor();
[-] 		err::setFormatStringError ("'%s' has no preconstructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no preconstructor", type->getTypeString ().sz ());
[-] jnc_DerivableType_getConstructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getConstructor(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getConstructor ();
[+] 	jnc_Function* function = type->getConstructor();
[-] 		err::setFormatStringError ("'%s' has no constructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no constructor", type->getTypeString ().sz ());
[-] jnc_DerivableType_getDestructor (jnc_DerivableType* type)
[+] jnc_DerivableType_getDestructor(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getDestructor ();
[+] 	jnc_Function* function = type->getDestructor();
[-] 		err::setFormatStringError ("'%s' has no destructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no destructor", type->getTypeString ().sz ());
[-] jnc_DerivableType_getUnaryOperator (
[+] jnc_DerivableType_getUnaryOperator(
[-] 	jnc_Function* function = type->getUnaryOperator ((jnc::UnOpKind) opKind);
[+] 	jnc_Function* function = type->getUnaryOperator((jnc::UnOpKind)opKind);
[-] 		err::setFormatStringError ("'%s' has no operator %s", type->getTypeString ().sz (), jnc_getUnOpKindString (opKind));
[+] 		err::setFormatStringError("'%s' has no operator %s", type->getTypeString ().sz (), jnc_getUnOpKindString (opKind));
[-] jnc_DerivableType_getBinaryOperator (
[+] jnc_DerivableType_getBinaryOperator(
[-] 	jnc_Function* function = type->getBinaryOperator ((jnc::BinOpKind) opKind);
[+] 	jnc_Function* function = type->getBinaryOperator((jnc::BinOpKind)opKind);
[-] 		err::setFormatStringError ("'%s' has no operator %s", type->getTypeString ().sz (), jnc_getBinOpKindString (opKind));
[+] 		err::setFormatStringError("'%s' has no operator %s", type->getTypeString ().sz (), jnc_getBinOpKindString (opKind));
[-] jnc_DerivableType_getCallOperator (jnc_DerivableType* type)
[+] jnc_DerivableType_getCallOperator(jnc_DerivableType* type)
[-] 	jnc_Function* function = type->getCallOperator ();
[+] 	jnc_Function* function = type->getCallOperator();
[-] 		err::setFormatStringError ("'%s' has no operator ()", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no operator ()", type->getTypeString ().sz ());
[-] jnc_DerivableType_getCastOperator (
[+] jnc_DerivableType_getCastOperator(
[-] 	jnc_Function* function = type->getCastOperator (idx);
[+] 	jnc_Function* function = type->getCastOperator(idx);
[-] 		err::setFormatStringError ("'%s' has no cast operator #%d", type->getTypeString ().sz (), idx);
[+] 		err::setFormatStringError("'%s' has no cast operator #%d", type->getTypeString ().sz (), idx);
[-] jnc_DerivableType_getBaseTypeCount (jnc_DerivableType* type)
[+] jnc_DerivableType_getBaseTypeCount(jnc_DerivableType* type)
[-] 	return type->getBaseTypeArray ().getCount ();
[+] 	return type->getBaseTypeArray().getCount();
[-] jnc_DerivableType_getBaseType (
[+] jnc_DerivableType_getBaseType(
[-] 	return type->getBaseTypeArray () [index];
[+] 	return type->getBaseTypeArray() [index];
[-] jnc_DerivableType_findBaseTypeOffset (
[+] jnc_DerivableType_findBaseTypeOffset(
[-] 	return type->findBaseTypeOffset (baseType);
[+] 	return type->findBaseTypeOffset(baseType);
[-] jnc_DerivableType_getMemberFieldCount (jnc_DerivableType* type)
[+] jnc_DerivableType_getMemberFieldCount(jnc_DerivableType* type)
[-] 	return type->getMemberFieldArray ().getCount ();
[+] 	return type->getMemberFieldArray().getCount();
[-] jnc_DerivableType_getMemberField (
[+] jnc_DerivableType_getMemberField(
[-] 	return type->getMemberFieldArray () [index];
[+] 	return type->getMemberFieldArray() [index];
[-] jnc_DerivableType_getMemberMethodCount (jnc_DerivableType* type)
[+] jnc_DerivableType_getMemberMethodCount(jnc_DerivableType* type)
[-] 	return type->getMemberMethodArray ().getCount ();
[+] 	return type->getMemberMethodArray().getCount();
[-] jnc_DerivableType_getMemberMethod (
[+] jnc_DerivableType_getMemberMethod(
[-] 	return type->getMemberMethodArray () [index];
[+] 	return type->getMemberMethodArray() [index];
[-] jnc_DerivableType_getMemberPropertyCount (jnc_DerivableType* type)
[+] jnc_DerivableType_getMemberPropertyCount(jnc_DerivableType* type)
[-] 	return type->getMemberPropertyArray ().getCount ();
[+] 	return type->getMemberPropertyArray().getCount();
[-] jnc_DerivableType_getMemberProperty (
[+] jnc_DerivableType_getMemberProperty(
[-] 	return type->getMemberPropertyArray () [index];
[+] 	return type->getMemberPropertyArray() [index];
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_DynamicExtensionLibHost.cpp
----------------------
[-] 	sizeof (jnc_ErrorFuncTable),
[+] 	sizeof(jnc_ErrorFuncTable),
[-] 	sizeof (jnc_ModuleItemDeclFuncTable),
[+] 	sizeof(jnc_ModuleItemDeclFuncTable),
[-] 	sizeof (jnc_ModuleItemFuncTable),
[+] 	sizeof(jnc_ModuleItemFuncTable),
[-] 	sizeof (jnc_AttributeFuncTable),
[+] 	sizeof(jnc_AttributeFuncTable),
[-] 	sizeof (jnc_AttributeBlockFuncTable),
[+] 	sizeof(jnc_AttributeBlockFuncTable),
[-] 	sizeof (jnc_NamespaceFuncTable),
[+] 	sizeof(jnc_NamespaceFuncTable),
[-] 	sizeof (jnc_GlobalNamespaceFuncTable),
[+] 	sizeof(jnc_GlobalNamespaceFuncTable),
[-] 	sizeof (jnc_VariableFuncTable),
[+] 	sizeof(jnc_VariableFuncTable),
[-] 	sizeof (jnc_FunctionFuncTable),
[+] 	sizeof(jnc_FunctionFuncTable),
[-] 	sizeof (jnc_PropertyFuncTable),
[+] 	sizeof(jnc_PropertyFuncTable),
[-] 	sizeof (jnc_TypedefFuncTable),
[+] 	sizeof(jnc_TypedefFuncTable),
[-] 	sizeof (jnc_TypeFuncTable),
[+] 	sizeof(jnc_TypeFuncTable),
[-] 	sizeof (jnc_NamedTypeFuncTable),
[+] 	sizeof(jnc_NamedTypeFuncTable),
[-] 	sizeof (jnc_BaseTypeSlotFuncTable),
[+] 	sizeof(jnc_BaseTypeSlotFuncTable),
[-] 	sizeof (jnc_DerivableTypeFuncTable),
[+] 	sizeof(jnc_DerivableTypeFuncTable),
[-] 	sizeof (jnc_ArrayTypeFuncTable),
[+] 	sizeof(jnc_ArrayTypeFuncTable),
[-] 	sizeof (jnc_BitFieldTypeFuncTable),
[+] 	sizeof(jnc_BitFieldTypeFuncTable),
[-] 	sizeof (jnc_FunctionArgFuncTable),
[+] 	sizeof(jnc_FunctionArgFuncTable),
[-] 	sizeof (jnc_FunctionTypeFuncTable),
[+] 	sizeof(jnc_FunctionTypeFuncTable),
[-] 	sizeof (jnc_PropertyTypeFuncTable),
[+] 	sizeof(jnc_PropertyTypeFuncTable),
[-] 	sizeof (jnc_EnumConstFuncTable),
[+] 	sizeof(jnc_EnumConstFuncTable),
[-] 	sizeof (jnc_EnumTypeFuncTable),
[+] 	sizeof(jnc_EnumTypeFuncTable),
[-] 	sizeof (jnc_StructFieldFuncTable),
[+] 	sizeof(jnc_StructFieldFuncTable),
[-] 	sizeof (jnc_StructTypeFuncTable),
[+] 	sizeof(jnc_StructTypeFuncTable),
[-] 	sizeof (jnc_UnionTypeFuncTable),
[+] 	sizeof(jnc_UnionTypeFuncTable),
[-] 	sizeof (jnc_ClassTypeFuncTable),
[+] 	sizeof(jnc_ClassTypeFuncTable),
[-] 	sizeof (jnc_MulticastClassTypeFuncTable),
[+] 	sizeof(jnc_MulticastClassTypeFuncTable),
[-] 	sizeof (jnc_McSnapshotClassTypeFuncTable),
[+] 	sizeof(jnc_McSnapshotClassTypeFuncTable),
[-] 	sizeof (jnc_DataPtrTypeFuncTable),
[+] 	sizeof(jnc_DataPtrTypeFuncTable),
[-] 	sizeof (jnc_ClassPtrTypeFuncTable),
[+] 	sizeof(jnc_ClassPtrTypeFuncTable),
[-] 	sizeof (jnc_FunctionPtrTypeFuncTable),
[+] 	sizeof(jnc_FunctionPtrTypeFuncTable),
[-] 	sizeof (jnc_PropertyPtrTypeFuncTable),
[+] 	sizeof(jnc_PropertyPtrTypeFuncTable),
[-] 	sizeof (jnc_VariantFuncTable),
[+] 	sizeof(jnc_VariantFuncTable),
[-] 	sizeof (jnc_UnitFuncTable),
[+] 	sizeof(jnc_UnitFuncTable),
[-] 	sizeof (jnc_ModuleFuncTable),
[+] 	sizeof(jnc_ModuleFuncTable),
[-] 	sizeof (jnc_RuntimeFuncTable),
[+] 	sizeof(jnc_RuntimeFuncTable),
[-] 	sizeof (jnc_GcHeapFuncTable),
[+] 	sizeof(jnc_GcHeapFuncTable),
[-] 	sizeof (jnc_DynamicExtensionLibHost),
[+] 	sizeof(jnc_DynamicExtensionLibHost),
[-] 	err::getErrorMgr (),
[+] 	err::getErrorMgr(),
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_EnumType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_EnumConst_getValue (jnc_EnumConst* enumConst)
[+] jnc_EnumConst_getValue(jnc_EnumConst* enumConst)
[-] 	return jnc_g_dynamicExtensionLibHost->m_enumConstFuncTable->m_getValueFunc (enumConst);
[+] 	return jnc_g_dynamicExtensionLibHost->m_enumConstFuncTable->m_getValueFunc(enumConst);
[-] jnc_EnumType_getBaseType (jnc_EnumType* type)
[+] jnc_EnumType_getBaseType(jnc_EnumType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getBaseTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getBaseTypeFunc(type);
[-] jnc_EnumType_getConstCount (jnc_EnumType* type)
[+] jnc_EnumType_getConstCount(jnc_EnumType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getConstCountFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getConstCountFunc(type);
[-] jnc_EnumType_getConst (
[+] jnc_EnumType_getConst(
[-] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getConstFunc (type, index);
[+] 	return jnc_g_dynamicExtensionLibHost->m_enumTypeFuncTable->m_getConstFunc(type, index);
[-] jnc_EnumConst_getValue (jnc_EnumConst* enumConst)
[+] jnc_EnumConst_getValue(jnc_EnumConst* enumConst)
[-] 	return enumConst->getValue ();
[+] 	return enumConst->getValue();
[-] jnc_EnumType_getBaseType (jnc_EnumType* type)
[+] jnc_EnumType_getBaseType(jnc_EnumType* type)
[-] 	return type->getBaseType ();
[+] 	return type->getBaseType();
[-] jnc_EnumType_getConstCount (jnc_EnumType* type)
[+] jnc_EnumType_getConstCount(jnc_EnumType* type)
[-] 	return type->getConstArray ().getCount ();
[+] 	return type->getConstArray().getCount();
[-] jnc_EnumType_getConst (
[+] jnc_EnumType_getConst(
[-] 	return type->getConstArray () [index];
[+] 	return type->getConstArray() [index];
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Error.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getLastError ()
[+] jnc_getLastError()
[-] 	return jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_getLastErrorFunc ();
[+] 	return jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_getLastErrorFunc();
[-] jnc_setError (const jnc_Error* error)
[+] jnc_setError(const jnc_Error* error)
[-] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setErrorFunc (error);
[+] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setErrorFunc(error);
[-] jnc_setErrno (int code)
[+] jnc_setErrno(int code)
[-] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setErrnoFunc (code);
[+] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setErrnoFunc(code);
[-] jnc_setStringError (const char* string)
[+] jnc_setStringError(const char* string)
[-] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setStringErrorFunc (string);
[+] 	jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_setStringErrorFunc(string);
[-] jnc_getErrorDescription_v (const jnc_Error* error)
[+] jnc_getErrorDescription_v(const jnc_Error* error)
[-] 	return jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_getErrorDescriptionFunc (error);
[+] 	return jnc_g_dynamicExtensionLibHost->m_errorFuncTable->m_getErrorDescriptionFunc(error);
[-] jnc_getLastError ()
[+] jnc_getLastError()
[-] 	return err::getLastError ();
[+] 	return err::getLastError();
[-] jnc_setError (const jnc_Error* error)
[+] jnc_setError(const jnc_Error* error)
[-] 	err::setError (error);
[+] 	err::setError(error);
[-] jnc_setErrno (int code)
[+] jnc_setErrno(int code)
[-] 	err::setErrno (code);
[+] 	err::setErrno(code);
[-] jnc_setStringError (const char* string)
[+] jnc_setStringError(const char* string)
[-] 	err::setError (string);
[+] 	err::setError(string);
[-] jnc_getErrorDescription_v (const jnc_Error* error)
[+] jnc_getErrorDescription_v(const jnc_Error* error)
[-] 	return *jnc::getTlsStringBuffer () = error->getDescription ();
[+] 	return *jnc::getTlsStringBuffer() = error->getDescription();
[-] jnc_setErrorRouter (jnc_ErrorRouter* router)
[+] jnc_setErrorRouter(jnc_ErrorRouter* router)
[-] 	err::ErrorMgr* errorMgr = err::getErrorMgr ();
[+] 	err::ErrorMgr* errorMgr = err::getErrorMgr();
[-] 		errorMgr->setForwardRouter (router);
[+] 		errorMgr->setForwardRouter(router);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Function.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getFunctionKindString (jnc_FunctionKind functionKind)
[+] jnc_getFunctionKindString(jnc_FunctionKind functionKind)
[-] 	static const char* stringTable [jnc_FunctionKind__Count] =
[+] 	static const char* stringTable[jnc_FunctionKind__Count] =
[-] 	return (size_t) functionKind < jnc_FunctionKind__Count ?
[+] 	return (size_t)functionKind < jnc_FunctionKind__Count ?
[-] 		stringTable [functionKind] :
[+] 		stringTable[functionKind] :
[-] 		stringTable [jnc_FunctionKind_Undefined];
[+] 		stringTable[jnc_FunctionKind_Undefined];
[-] jnc_getFunctionKindFlags (jnc_FunctionKind functionKind)
[+] jnc_getFunctionKindFlags(jnc_FunctionKind functionKind)
[-] 	static int flagTable [jnc_FunctionKind__Count] =
[+] 	static int flagTable[jnc_FunctionKind__Count] =
[-] 	return (size_t) functionKind < jnc_FunctionKind__Count ? flagTable [functionKind] : 0;
[+] 	return (size_t)functionKind < jnc_FunctionKind__Count ? flagTable[functionKind] : 0;
[-] jnc_Function_getFunctionKind (jnc_Function* function)
[+] jnc_Function_getFunctionKind(jnc_Function* function)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getFunctionKindFunc (function);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getFunctionKindFunc(function);
[-] jnc_Function_isMember (jnc_Function* function)
[+] jnc_Function_isMember(jnc_Function* function)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_isMemberFunc (function);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_isMemberFunc(function);
[-] jnc_Function_isOverloaded (jnc_Function* function)
[+] jnc_Function_isOverloaded(jnc_Function* function)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_isOverloadedFunc (function);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_isOverloadedFunc(function);
[-] jnc_Function_getOverloadCount (jnc_Function* function)
[+] jnc_Function_getOverloadCount(jnc_Function* function)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getOverloadCountFunc (function);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getOverloadCountFunc(function);
[-] jnc_Function_getOverload (
[+] jnc_Function_getOverload(
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getOverloadFunc (function, overloadIdx);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getOverloadFunc(function, overloadIdx);
[-] jnc_Function_getMachineCode (jnc_Function* function)
[+] jnc_Function_getMachineCode(jnc_Function* function)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getMachineCodeFunc (function);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionFuncTable->m_getMachineCodeFunc(function);
[-] jnc_Function_getFunctionKind (jnc_Function* function)
[+] jnc_Function_getFunctionKind(jnc_Function* function)
[-] 	return function->getFunctionKind ();
[+] 	return function->getFunctionKind();
[-] jnc_Function_isMember (jnc_Function* function)
[+] jnc_Function_isMember(jnc_Function* function)
[-] 	return function->isMember ();
[+] 	return function->isMember();
[-] jnc_Function_isOverloaded (jnc_Function* function)
[+] jnc_Function_isOverloaded(jnc_Function* function)
[-] 	return function->isOverloaded ();
[+] 	return function->isOverloaded();
[-] jnc_Function_getOverloadCount (jnc_Function* function)
[+] jnc_Function_getOverloadCount(jnc_Function* function)
[-] 	return function->getOverloadCount ();
[+] 	return function->getOverloadCount();
[-] jnc_Function_getOverload (
[+] jnc_Function_getOverload(
[-] 	jnc_Function* overload = function->getOverload (index);
[+] 	jnc_Function* overload = function->getOverload(index);
[-] 		err::setFormatStringError ("'%s' has no overload #%d", function->getQualifiedName ().sz (), index);
[+] 		err::setFormatStringError("'%s' has no overload #%d", function->getQualifiedName ().sz (), index);
[-] jnc_Function_getMachineCode (jnc_Function* function)
[+] jnc_Function_getMachineCode(jnc_Function* function)
[-] 	return function->getMachineCode ();
[+] 	return function->getMachineCode();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_FunctionType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getFunctionTypeFlagString (jnc_FunctionTypeFlag flag)
[+] jnc_getFunctionTypeFlagString(jnc_FunctionTypeFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = axl::sl::getLoBitIdx32 (flag >> 16);
[+] 	size_t i = axl::sl::getLoBitIdx32(flag >> 16);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] jnc_FunctionType_getReturnType (jnc_FunctionType* type)
[+] jnc_FunctionType_getReturnType(jnc_FunctionType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getReturnTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getReturnTypeFunc(type);
[-] jnc_FunctionType_getArgCount (jnc_FunctionType* type)
[+] jnc_FunctionType_getArgCount(jnc_FunctionType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getArgCountFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getArgCountFunc(type);
[-] jnc_FunctionType_getArg (
[+] jnc_FunctionType_getArg(
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getArgFunc (type, index);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getArgFunc(type, index);
[-] jnc_FunctionType_getFunctionPtrType (
[+] jnc_FunctionType_getFunctionPtrType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getFunctionPtrTypeFunc (type, ptrTypeKind, flags);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getFunctionPtrTypeFunc(type, ptrTypeKind, flags);
[-] jnc_FunctionType_getShortType (jnc_FunctionType* type)
[+] jnc_FunctionType_getShortType(jnc_FunctionType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getShortTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionTypeFuncTable->m_getShortTypeFunc(type);
[-] jnc_FunctionPtrType_getPtrTypeKind (jnc_FunctionPtrType* type)
[+] jnc_FunctionPtrType_getPtrTypeKind(jnc_FunctionPtrType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionPtrTypeFuncTable->m_getPtrTypeKindFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionPtrTypeFuncTable->m_getPtrTypeKindFunc(type);
[-] jnc_FunctionPtrType_getTargetType (jnc_FunctionPtrType* type)
[+] jnc_FunctionPtrType_getTargetType(jnc_FunctionPtrType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_functionPtrTypeFuncTable->m_getTargetTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_functionPtrTypeFuncTable->m_getTargetTypeFunc(type);
[-] jnc_FunctionArg_hasDefaultValue (jnc_FunctionArg* arg)
[+] jnc_FunctionArg_hasDefaultValue(jnc_FunctionArg* arg)
[-] 	return !arg->getInitializer ().isEmpty ();
[+] 	return !arg->getInitializer().isEmpty();
[-] jnc_FunctionArg_getDefaultValueString_v (jnc_FunctionArg* arg)
[+] jnc_FunctionArg_getDefaultValueString_v(jnc_FunctionArg* arg)
[-] 	return *jnc::getTlsStringBuffer () = arg->getInitializerString ();
[+] 	return *jnc::getTlsStringBuffer() = arg->getInitializerString();
[-] jnc_FunctionType_getReturnType (jnc_FunctionType* type)
[+] jnc_FunctionType_getReturnType(jnc_FunctionType* type)
[-] 	return type->getReturnType ();
[+] 	return type->getReturnType();
[-] jnc_FunctionType_getArgCount (jnc_FunctionType* type)
[+] jnc_FunctionType_getArgCount(jnc_FunctionType* type)
[-] 	return type->getArgArray ().getCount ();
[+] 	return type->getArgArray().getCount();
[-] jnc_FunctionType_getArg (
[+] jnc_FunctionType_getArg(
[-] 	return type->getArgArray () [index];
[+] 	return type->getArgArray() [index];
[-] jnc_FunctionPtrType_getPtrTypeKind (jnc_FunctionPtrType* type)
[+] jnc_FunctionPtrType_getPtrTypeKind(jnc_FunctionPtrType* type)
[-] 	return type->getPtrTypeKind ();
[+] 	return type->getPtrTypeKind();
[-] jnc_FunctionPtrType_getTargetType (jnc_FunctionPtrType* type)
[+] jnc_FunctionPtrType_getTargetType(jnc_FunctionPtrType* type)
[-] 	return type->getTargetType ();
[+] 	return type->getTargetType();
[-] jnc_FunctionType_getFunctionPtrType (
[+] jnc_FunctionType_getFunctionPtrType(
[-] 	return type->getFunctionPtrType (ptrTypeKind, flags);
[+] 	return type->getFunctionPtrType(ptrTypeKind, flags);
[-] jnc_FunctionType_getShortType (jnc_FunctionType* type)
[+] jnc_FunctionType_getShortType(jnc_FunctionType* type)
[-] 	return type->getShortType ();
[+] 	return type->getShortType();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_GcHeap.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_GcHeap_getRuntime (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_getRuntime(jnc_GcHeap* gcHeap)
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getRuntimeFunc (gcHeap);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getRuntimeFunc(gcHeap);
[-] jnc_GcHeap_getStats (
[+] jnc_GcHeap_getStats(
[-] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getStatsFunc (gcHeap, stats);
[+] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getStatsFunc(gcHeap, stats);
[-] jnc_GcHeap_getSizeTriggers (
[+] jnc_GcHeap_getSizeTriggers(
[-] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getSizeTriggersFunc (gcHeap, triggers);
[+] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getSizeTriggersFunc(gcHeap, triggers);
[-] jnc_GcHeap_setSizeTriggers (
[+] jnc_GcHeap_setSizeTriggers(
[-] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_setSizeTriggersFunc (gcHeap, triggers);
[+] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_setSizeTriggersFunc(gcHeap, triggers);
[-] jnc_GcHeap_collect (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_collect(jnc_GcHeap* gcHeap)
[-] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_collectFunc (gcHeap);
[+] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_collectFunc(gcHeap);
[-] jnc_GcHeap_enterNoCollectRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_enterNoCollectRegion(jnc_GcHeap* gcHeap)
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_enterNoCollectRegionFunc (gcHeap);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_enterNoCollectRegionFunc(gcHeap);
[-] jnc_GcHeap_leaveNoCollectRegion (
[+] jnc_GcHeap_leaveNoCollectRegion(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_leaveNoCollectRegionFunc (gcHeap, canCollectNow);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_leaveNoCollectRegionFunc(gcHeap, canCollectNow);
[-] jnc_GcHeap_enterWaitRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_enterWaitRegion(jnc_GcHeap* gcHeap)
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_enterWaitRegionFunc (gcHeap);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_enterWaitRegionFunc(gcHeap);
[-] jnc_GcHeap_leaveWaitRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_leaveWaitRegion(jnc_GcHeap* gcHeap)
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_leaveWaitRegionFunc (gcHeap);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_leaveWaitRegionFunc(gcHeap);
[-] jnc_GcHeap_allocateClass (
[+] jnc_GcHeap_allocateClass(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateClassFunc (gcHeap, type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateClassFunc(gcHeap, type);
[-] jnc_GcHeap_tryAllocateClass (
[+] jnc_GcHeap_tryAllocateClass(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateClassFunc (gcHeap, type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateClassFunc(gcHeap, type);
[-] jnc_GcHeap_allocateData (
[+] jnc_GcHeap_allocateData(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateDataFunc (gcHeap, type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateDataFunc(gcHeap, type);
[-] jnc_GcHeap_tryAllocateData (
[+] jnc_GcHeap_tryAllocateData(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateDataFunc (gcHeap, type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateDataFunc(gcHeap, type);
[-] jnc_GcHeap_allocateArray (
[+] jnc_GcHeap_allocateArray(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateArrayFunc (gcHeap, type, count);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateArrayFunc(gcHeap, type, count);
[-] jnc_GcHeap_tryAllocateArray (
[+] jnc_GcHeap_tryAllocateArray(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateArrayFunc (gcHeap, type, count);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateArrayFunc(gcHeap, type, count);
[-] jnc_GcHeap_allocateBuffer (
[+] jnc_GcHeap_allocateBuffer(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateBufferFunc (gcHeap, size);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_allocateBufferFunc(gcHeap, size);
[-] jnc_GcHeap_tryAllocateBuffer (
[+] jnc_GcHeap_tryAllocateBuffer(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateBufferFunc (gcHeap, size);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_tryAllocateBufferFunc(gcHeap, size);
[-] jnc_GcHeap_createDataPtrValidator (
[+] jnc_GcHeap_createDataPtrValidator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_createDataPtrValidatorFunc (gcHeap, box, rangeBegin, rangeLength);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_createDataPtrValidatorFunc(gcHeap, box, rangeBegin, rangeLength);
[-] jnc_GcHeap_getDynamicLayout (
[+] jnc_GcHeap_getDynamicLayout(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getDynamicLayoutFunc (gcHeap, box);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_getDynamicLayoutFunc(gcHeap, box);
[-] jnc_GcHeap_resetDynamicLayout (
[+] jnc_GcHeap_resetDynamicLayout(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_resetDynamicLayoutFunc (gcHeap, box);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_resetDynamicLayoutFunc(gcHeap, box);
[-] jnc_GcHeap_weakMark (
[+] jnc_GcHeap_weakMark(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_weakMarkFunc (gcHeap, box);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_weakMarkFunc(gcHeap, box);
[-] jnc_GcHeap_markData (
[+] jnc_GcHeap_markData(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_markDataFunc (gcHeap, box);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_markDataFunc(gcHeap, box);
[-] jnc_GcHeap_markClass (
[+] jnc_GcHeap_markClass(
[-] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_markClassFunc (gcHeap, box);
[+] 	return jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_markClassFunc(gcHeap, box);
[-] jnc_GcHeap_addBoxToCallSite (jnc_Box* box)
[+] jnc_GcHeap_addBoxToCallSite(jnc_Box* box)
[-] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_addBoxToCallSiteFunc (box);
[+] 	jnc_g_dynamicExtensionLibHost->m_gcHeapFuncTable->m_addBoxToCallSiteFunc(box);
[-] jnc_GcHeap_getRuntime (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_getRuntime(jnc_GcHeap* gcHeap)
[-] 	return gcHeap->getRuntime ();
[+] 	return gcHeap->getRuntime();
[-] jnc_GcHeap_getStats (
[+] jnc_GcHeap_getStats(
[-] 	gcHeap->getStats (stats);
[+] 	gcHeap->getStats(stats);
[-] jnc_GcHeap_getSizeTriggers (
[+] jnc_GcHeap_getSizeTriggers(
[-] 	gcHeap->getSizeTriggers (triggers);
[+] 	gcHeap->getSizeTriggers(triggers);
[-] jnc_GcHeap_setSizeTriggers (
[+] jnc_GcHeap_setSizeTriggers(
[-] 	gcHeap->setSizeTriggers (*triggers);
[+] 	gcHeap->setSizeTriggers(*triggers);
[-] jnc_GcHeap_collect (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_collect(jnc_GcHeap* gcHeap)
[-] 	gcHeap->collect ();
[+] 	gcHeap->collect();
[-] jnc_GcHeap_enterNoCollectRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_enterNoCollectRegion(jnc_GcHeap* gcHeap)
[-] 	gcHeap->enterNoCollectRegion ();
[+] 	gcHeap->enterNoCollectRegion();
[-] jnc_GcHeap_leaveNoCollectRegion (
[+] jnc_GcHeap_leaveNoCollectRegion(
[-] 	gcHeap->leaveNoCollectRegion (canCollectNow != 0);
[+] 	gcHeap->leaveNoCollectRegion(canCollectNow != 0);
[-] jnc_GcHeap_enterWaitRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_enterWaitRegion(jnc_GcHeap* gcHeap)
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] jnc_GcHeap_leaveWaitRegion (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_leaveWaitRegion(jnc_GcHeap* gcHeap)
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] jnc_GcHeap_safePoint (jnc_GcHeap* gcHeap)
[+] jnc_GcHeap_safePoint(jnc_GcHeap* gcHeap)
[-] 	gcHeap->safePoint ();
[+] 	gcHeap->safePoint();
[-] jnc_GcHeap_setFrameMap (
[+] jnc_GcHeap_setFrameMap(
[-] 	gcHeap->setFrameMap (frame, map, op);
[+] 	gcHeap->setFrameMap(frame, map, op);
[-] jnc_GcHeap_addStaticDestructor (
[+] jnc_GcHeap_addStaticDestructor(
[-] 	gcHeap->addStaticDestructor (destructFunc);
[+] 	gcHeap->addStaticDestructor(destructFunc);
[-] jnc_GcHeap_addStaticClassDestructor (
[+] jnc_GcHeap_addStaticClassDestructor(
[-] 	gcHeap->addStaticClassDestructor (destructFunc, iface);
[+] 	gcHeap->addStaticClassDestructor(destructFunc, iface);
[-] jnc_GcHeap_addStaticRoot (
[+] jnc_GcHeap_addStaticRoot(
[-] 	gcHeap->addStaticRoot (p, type);
[+] 	gcHeap->addStaticRoot(p, type);
[-] jnc_GcHeap_allocateClass (
[+] jnc_GcHeap_allocateClass(
[-] 	return gcHeap->allocateClass (type);
[+] 	return gcHeap->allocateClass(type);
[-] jnc_GcHeap_tryAllocateClass (
[+] jnc_GcHeap_tryAllocateClass(
[-] 	return gcHeap->tryAllocateClass (type);
[+] 	return gcHeap->tryAllocateClass(type);
[-] jnc_GcHeap_allocateData (
[+] jnc_GcHeap_allocateData(
[-] 	return gcHeap->allocateData (type);
[+] 	return gcHeap->allocateData(type);
[-] jnc_GcHeap_tryAllocateData (
[+] jnc_GcHeap_tryAllocateData(
[-] 	return gcHeap->tryAllocateData (type);
[+] 	return gcHeap->tryAllocateData(type);
[-] jnc_GcHeap_allocateArray (
[+] jnc_GcHeap_allocateArray(
[-] 	return gcHeap->allocateArray (type, count);
[+] 	return gcHeap->allocateArray(type, count);
[-] jnc_GcHeap_tryAllocateArray (
[+] jnc_GcHeap_tryAllocateArray(
[-] 	return gcHeap->tryAllocateArray (type, count);
[+] 	return gcHeap->tryAllocateArray(type, count);
[-] jnc_GcHeap_allocateBuffer (
[+] jnc_GcHeap_allocateBuffer(
[-] 	return gcHeap->allocateBuffer (size);
[+] 	return gcHeap->allocateBuffer(size);
[-] jnc_GcHeap_tryAllocateBuffer (
[+] jnc_GcHeap_tryAllocateBuffer(
[-] 	return gcHeap->tryAllocateBuffer (size);
[+] 	return gcHeap->tryAllocateBuffer(size);
[-] jnc_GcHeap_createDataPtrValidator (
[+] jnc_GcHeap_createDataPtrValidator(
[-] 	return gcHeap->createDataPtrValidator (box, rangeBegin, rangeLength);
[+] 	return gcHeap->createDataPtrValidator(box, rangeBegin, rangeLength);
[-] jnc_GcHeap_getDynamicLayout (
[+] jnc_GcHeap_getDynamicLayout(
[-] 	return gcHeap->getDynamicLayout (box);
[+] 	return gcHeap->getDynamicLayout(box);
[-] jnc_GcHeap_resetDynamicLayout (
[+] jnc_GcHeap_resetDynamicLayout(
[-] 	return gcHeap->resetDynamicLayout (box);
[+] 	return gcHeap->resetDynamicLayout(box);
[-] jnc_GcHeap_weakMark (
[+] jnc_GcHeap_weakMark(
[-] 	gcHeap->weakMark (box);
[+] 	gcHeap->weakMark(box);
[-] jnc_GcHeap_markData (
[+] jnc_GcHeap_markData(
[-] 	gcHeap->markData (box);
[+] 	gcHeap->markData(box);
[-] jnc_GcHeap_markClass (
[+] jnc_GcHeap_markClass(
[-] 	gcHeap->markClass (box);
[+] 	gcHeap->markClass(box);
[-] jnc_GcHeap_addRoot (
[+] jnc_GcHeap_addRoot(
[-] 	gcHeap->addRoot (p, type);
[+] 	gcHeap->addRoot(p, type);
[-] jnc_GcHeap_addBoxToCallSite (jnc_Box* box)
[+] jnc_GcHeap_addBoxToCallSite(jnc_Box* box)
[-] 	bool result = jnc::rt::GcHeap::addBoxIfDynamicFrame (box);
[+] 	bool result = jnc::rt::GcHeap::addBoxIfDynamicFrame(box);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Module.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Module_getGlobalNamespace (jnc_Module* module)
[+] jnc_Module_getGlobalNamespace(jnc_Module* module)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_getGlobalNamespaceFunc (module);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_getGlobalNamespaceFunc(module);
[-] jnc_Module_getPrimitiveType (
[+] jnc_Module_getPrimitiveType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_getPrimitiveTypeFunc (module, typeKind);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_getPrimitiveTypeFunc(module, typeKind);
[-] jnc_Module_findItem (
[+] jnc_Module_findItem(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_findItemFunc (module, name, libGuid, itemCacheSlot);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_findItemFunc(module, name, libGuid, itemCacheSlot);
[-] jnc_Module_mapVariable (
[+] jnc_Module_mapVariable(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_mapVariableFunc (module, variable, p);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_mapVariableFunc(module, variable, p);
[-] jnc_Module_mapFunction (
[+] jnc_Module_mapFunction(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_mapFunctionFunc (module, function, p);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_mapFunctionFunc(module, function, p);
[-] jnc_Module_addSource (
[+] jnc_Module_addSource(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addSourceFunc (module, lib, fileName, source, size);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addSourceFunc(module, lib, fileName, source, size);
[-] jnc_Module_addImport (
[+] jnc_Module_addImport(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addImportFunc (module, fileName);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addImportFunc(module, fileName);
[-] jnc_Module_addOpaqueClassTypeInfo (
[+] jnc_Module_addOpaqueClassTypeInfo(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addOpaqueClassTypeInfoFunc (module, qualifiedName, info);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleFuncTable->m_addOpaqueClassTypeInfoFunc(module, qualifiedName, info);
[-] jnc_Module_create ()
[+] jnc_Module_create()
[-] 	return AXL_MEM_NEW (jnc_Module);
[+] 	return AXL_MEM_NEW(jnc_Module);
[-] jnc_Module_destroy (jnc_Module* module)
[+] jnc_Module_destroy(jnc_Module* module)
[-] 	AXL_MEM_DELETE (module);
[+] 	AXL_MEM_DELETE(module);
[-] jnc_Module_clear (jnc_Module* module)
[+] jnc_Module_clear(jnc_Module* module)
[-] 	module->clear ();
[+] 	module->clear();
[-] jnc_Module_initialize (
[+] jnc_Module_initialize(
[-] 	module->initialize (tag, compileFlags);
[+] 	module->initialize(tag, compileFlags);
[-] jnc_Module_getCompileFlags (jnc_Module* module)
[+] jnc_Module_getCompileFlags(jnc_Module* module)
[-] 	return module->getCompileFlags ();
[+] 	return module->getCompileFlags();
[-] jnc_Module_getCompileState (jnc_Module* module)
[+] jnc_Module_getCompileState(jnc_Module* module)
[-] 	return module->getCompileState ();
[+] 	return module->getCompileState();
[-] jnc_Module_getGlobalNamespace (jnc_Module* module)
[+] jnc_Module_getGlobalNamespace(jnc_Module* module)
[-] 	return module->m_namespaceMgr.getGlobalNamespace ();
[+] 	return module->m_namespaceMgr.getGlobalNamespace();
[-] jnc_Module_getPrimitiveType (
[+] jnc_Module_getPrimitiveType(
[-] 	return module->m_typeMgr.getPrimitiveType (typeKind);
[+] 	return module->m_typeMgr.getPrimitiveType(typeKind);
[-] jnc_Module_getStdType (
[+] jnc_Module_getStdType(
[-] 	return module->m_typeMgr.getStdType (stdType);
[+] 	return module->m_typeMgr.getStdType(stdType);
[-] jnc_Module_findItem (
[+] jnc_Module_findItem(
[-] 	return module->m_extensionLibMgr.findItem (name, *libGuid, itemCacheSlot);
[+] 	return module->m_extensionLibMgr.findItem(name, *libGuid, itemCacheSlot);
[-] jnc_Module_mapVariable (
[+] jnc_Module_mapVariable(
[-] 	return module->mapVariable (variable, p);
[+] 	return module->mapVariable(variable, p);
[-] jnc_Module_mapFunction (
[+] jnc_Module_mapFunction(
[-] 	return module->mapFunction (function, p);
[+] 	return module->mapFunction(function, p);
[-] jnc_Module_addSource (
[+] jnc_Module_addSource(
[-] 	module->m_extensionLibMgr.addSource (lib, fileName, axl::sl::StringRef (source, length));
[+] 	module->m_extensionLibMgr.addSource(lib, fileName, axl::sl::StringRef(source, length));
[-] jnc_Module_addImportDir (
[+] jnc_Module_addImportDir(
[-] 	module->m_importMgr.m_importDirList.insertTail (dir);
[+] 	module->m_importMgr.m_importDirList.insertTail(dir);
[-] jnc_Module_addImport (
[+] jnc_Module_addImport(
[-] 	module->m_importMgr.addImport (fileName);
[+] 	module->m_importMgr.addImport(fileName);
[-] jnc_Module_addIgnoredImport (
[+] jnc_Module_addIgnoredImport(
[-] 	module->m_importMgr.addIgnoredImport (fileName);
[+] 	module->m_importMgr.addIgnoredImport(fileName);
[-] jnc_Module_addOpaqueClassTypeInfo (
[+] jnc_Module_addOpaqueClassTypeInfo(
[-] 	module->m_extensionLibMgr.addOpaqueClassTypeInfo (qualifiedName, info);
[+] 	module->m_extensionLibMgr.addOpaqueClassTypeInfo(qualifiedName, info);
[-] jnc_Module_addStaticLib (
[+] jnc_Module_addStaticLib(
[-] 	module->m_extensionLibMgr.addStaticLib (lib);
[+] 	module->m_extensionLibMgr.addStaticLib(lib);
[-] jnc_Module_parse (
[+] jnc_Module_parse(
[-] 	return module->parse (lib, fileName, sl::StringRef (source, length));
[+] 	return module->parse(lib, fileName, sl::StringRef(source, length));
[-] jnc_Module_parseFile (
[+] jnc_Module_parseFile(
[-] 	return module->parseFile (fileName);
[+] 	return module->parseFile(fileName);
[-] jnc_Module_parseImports (jnc_Module* module)
[+] jnc_Module_parseImports(jnc_Module* module)
[-] 	return module->parseImports ();
[+] 	return module->parseImports();
[-] jnc_Module_link (jnc_Module* module)
[+] jnc_Module_link(jnc_Module* module)
[-] 	return module->link ();
[+] 	return module->link();
[-] jnc_Module_calcLayout (jnc_Module* module)
[+] jnc_Module_calcLayout(jnc_Module* module)
[-] 	return module->calcLayout ();
[+] 	return module->calcLayout();
[-] jnc_Module_compile (jnc_Module* module)
[+] jnc_Module_compile(jnc_Module* module)
[-] 	return module->compile ();
[+] 	return module->compile();
[-] jnc_Module_jit (jnc_Module* module)
[+] jnc_Module_jit(jnc_Module* module)
[-] 	return module->jit ();
[+] 	return module->jit();
[-] jnc_Module_getLlvmIrString_v (jnc_Module* module)
[+] jnc_Module_getLlvmIrString_v(jnc_Module* module)
[-] 	return *jnc::getTlsStringBuffer () = module->getLlvmIrString ();
[+] 	return *jnc::getTlsStringBuffer() = module->getLlvmIrString();
[-] jnc_Module_generateDocumentation (
[+] jnc_Module_generateDocumentation(
[-] 	static char indexFileHdr [] =
[+] 	static char indexFileHdr[] =
[-] 	static char indexFileTerm [] = "</doxygenindex>\n";
[+] 	static char indexFileTerm[] = "</doxygenindex>\n";
[-] 	static char compoundFileHdr [] =
[+] 	static char compoundFileHdr[] =
[-] 	static char compoundFileTerm [] = "</doxygen>\n";
[+] 	static char compoundFileTerm[] = "</doxygen>\n";
[-] 		module->link () &&
[+] 		module->link() &&
[-] 		io::ensureDirExists (outputDir);
[+] 		io::ensureDirExists(outputDir);
[-] 	result = module->m_doxyMgr.resolveBlockTargets ();
[+] 	result = module->m_doxyMgr.resolveBlockTargets();
[-] 	jnc::GlobalNamespace* nspace = module->m_namespaceMgr.getGlobalNamespace ();
[+] 	jnc::GlobalNamespace* nspace = module->m_namespaceMgr.getGlobalNamespace();
[-] 	result = nspace->generateDocumentation (outputDir, &nspaceXml, &indexXml);
[+] 	result = nspace->generateDocumentation(outputDir, &nspaceXml, &indexXml);
[-] 	if (nspaceXml.isEmpty ())
[+] 	if (nspaceXml.isEmpty())
[-] 		err::setError ("module does not contain any documentable items");
[+] 		err::setError("module does not contain any documentable items");
[-] 	module->m_doxyMgr.deleteEmptyGroups ();
[+] 	module->m_doxyMgr.deleteEmptyGroups();
[-] 	result = module->m_doxyMgr.generateGroupDocumentation (outputDir, &indexXml);
[+] 	result = module->m_doxyMgr.generateGroupDocumentation(outputDir, &indexXml);
[-] 	sl::String refId = nspace->getDoxyBlock ()->getRefId ();
[+] 	sl::String refId = nspace->getDoxyBlock()->getRefId();
[-] 	sl::String nspaceFileName = sl::String (outputDir) + "/" + refId + ".xml";
[+] 	sl::String nspaceFileName = sl::String(outputDir) + "/" + refId + ".xml";
[-] 	sl::String indexFileName = sl::String (outputDir) + "/index.xml";
[+] 	sl::String indexFileName = sl::String(outputDir) + "/index.xml";
[-] 		file.open (nspaceFileName, io::FileFlag_Clear) &&
[+] 		file.open(nspaceFileName, io::FileFlag_Clear) &&
[-] 		file.write (compoundFileHdr, lengthof (compoundFileHdr)) != -1 &&
[+] 		file.write(compoundFileHdr, lengthof(compoundFileHdr)) != -1 &&
[-] 		file.write (nspaceXml, nspaceXml.getLength ()) != -1 &&
[+] 		file.write(nspaceXml, nspaceXml.getLength()) != -1 &&
[-] 		file.write (compoundFileTerm, lengthof (compoundFileTerm)) != -1 &&
[+] 		file.write(compoundFileTerm, lengthof(compoundFileTerm)) != -1 &&
[-] 		file.open (indexFileName, io::FileFlag_Clear) &&
[+] 		file.open(indexFileName, io::FileFlag_Clear) &&
[-] 		file.write (indexFileHdr, lengthof (indexFileHdr)) != -1 &&
[+] 		file.write(indexFileHdr, lengthof(indexFileHdr)) != -1 &&
[-] 		file.write (indexXml, indexXml.getLength ()) != -1 &&
[+] 		file.write(indexXml, indexXml.getLength()) != -1 &&
[-] 		file.write (indexFileTerm, lengthof (indexFileTerm)) != -1;
[+] 		file.write(indexFileTerm, lengthof(indexFileTerm)) != -1;
[-] jnc_initialize (const char* tag)
[+] jnc_initialize(const char* tag)
[-] 	atexit (llvm::llvm_shutdown);
[+] 	atexit(llvm::llvm_shutdown);
[-] 	llvm::InitializeNativeTarget ();
[+] 	llvm::InitializeNativeTarget();
[-] 	llvm::InitializeNativeTargetAsmParser ();
[+] 	llvm::InitializeNativeTargetAsmParser();
[-] 	llvm::InitializeNativeTargetAsmPrinter ();
[+] 	llvm::InitializeNativeTargetAsmPrinter();
[-] 	llvm::InitializeNativeTargetDisassembler ();
[+] 	llvm::InitializeNativeTargetDisassembler();
[-] 		g::getModule ()->setTag (tag);
[+] 		g::getModule()->setTag(tag);
[-] 	sl::getSimpleSingleton <jnc::rt::ExceptionMgr> ()->install ();
[+] 	sl::getSimpleSingleton<jnc::rt::ExceptionMgr> ()->install();
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	io::registerUsbErrorProvider ();
[+] 	io::registerUsbErrorProvider();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_ModuleItem.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getModuleItemKindString (jnc_ModuleItemKind itemKind)
[+] jnc_getModuleItemKindString(jnc_ModuleItemKind itemKind)
[-] 	static const char* stringTable [jnc_ModuleItemKind__Count] =
[+] 	static const char* stringTable[jnc_ModuleItemKind__Count] =
[-] 	return (size_t) itemKind < jnc_ModuleItemKind__Count ?
[+] 	return (size_t)itemKind < jnc_ModuleItemKind__Count ?
[-] 		stringTable [itemKind] :
[+] 		stringTable[itemKind] :
[-] 		stringTable [jnc_ModuleItemKind_Undefined];
[+] 		stringTable[jnc_ModuleItemKind_Undefined];
[-] jnc_getStorageKindString (jnc_StorageKind storageKind)
[+] jnc_getStorageKindString(jnc_StorageKind storageKind)
[-] 	static const char* stringTable [jnc_StorageKind__Count] =
[+] 	static const char* stringTable[jnc_StorageKind__Count] =
[-] 	return (size_t) storageKind < jnc_StorageKind__Count ?
[+] 	return (size_t)storageKind < jnc_StorageKind__Count ?
[-] 		stringTable [storageKind] :
[+] 		stringTable[storageKind] :
[-] 		stringTable [jnc_StorageKind_Undefined];
[+] 		stringTable[jnc_StorageKind_Undefined];
[-] jnc_getAccessKindString (jnc_AccessKind accessKind)
[+] jnc_getAccessKindString(jnc_AccessKind accessKind)
[-] 	static const char* stringTable [jnc_AccessKind__Count] =
[+] 	static const char* stringTable[jnc_AccessKind__Count] =
[-] 	return (size_t) accessKind < jnc_AccessKind__Count ?
[+] 	return (size_t)accessKind < jnc_AccessKind__Count ?
[-] 		stringTable [accessKind] :
[+] 		stringTable[accessKind] :
[-] 		stringTable [jnc_AccessKind_Undefined];
[+] 		stringTable[jnc_AccessKind_Undefined];
[-] jnc_ModuleItemDecl_getName (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getName(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getNameFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getNameFunc(decl);
[-] jnc_ModuleItemDecl_getQualifiedName (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getQualifiedName(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getQualifiedNameFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getQualifiedNameFunc(decl);
[-] jnc_ModuleItemDecl_getStorageKind (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getStorageKind(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getStorageKindFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getStorageKindFunc(decl);
[-] jnc_ModuleItemDecl_getAccessKind (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getAccessKind(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getAccessKindFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getAccessKindFunc(decl);
[-] jnc_ModuleItemDecl_getAttributeBlock (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getAttributeBlock(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getAttributeBlockFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getAttributeBlockFunc(decl);
[-] jnc_ModuleItemDecl_getParentNamespace (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getParentNamespace(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getParentNamespaceFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getParentNamespaceFunc(decl);
[-] jnc_ModuleItemDecl_getParentUnit (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getParentUnit(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getParentUnitFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getParentUnitFunc(decl);
[-] jnc_ModuleItemDecl_getLine (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getLine(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getLineFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getLineFunc(decl);
[-] jnc_ModuleItemDecl_getCol (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getCol(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getColFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getColFunc(decl);
[-] jnc_ModuleItemDecl_getOffset (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getOffset(jnc_ModuleItemDecl* decl)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getOffsetFunc (decl);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemDeclFuncTable->m_getOffsetFunc(decl);
[-] jnc_ModuleItem_getModule (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getModule(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getModuleFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getModuleFunc(item);
[-] jnc_ModuleItem_getItemKind (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getItemKind(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getItemKindFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getItemKindFunc(item);
[-] jnc_ModuleItem_getFlags (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getFlags(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getFlagsFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getFlagsFunc(item);
[-] jnc_ModuleItem_getDecl (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getDecl(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getDeclFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getDeclFunc(item);
[-] jnc_ModuleItem_getNamespace (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getNamespace(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getNamespaceFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getNamespaceFunc(item);
[-] jnc_ModuleItem_getType (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getType(jnc_ModuleItem* item)
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getTypeFunc (item);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_getTypeFunc(item);
[-] jnc_verifyModuleItemIsDerivableType (
[+] jnc_verifyModuleItemIsDerivableType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_verifyModuleItemIsDerivableTypeFunc (item, name);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_verifyModuleItemIsDerivableTypeFunc(item, name);
[-] jnc_verifyModuleItemIsClassType (
[+] jnc_verifyModuleItemIsClassType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_verifyModuleItemIsClassTypeFunc (item, name);
[+] 	return jnc_g_dynamicExtensionLibHost->m_moduleItemFuncTable->m_verifyModuleItemIsClassTypeFunc(item, name);
[-] jnc_ModuleItemDecl_getName (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getName(jnc_ModuleItemDecl* decl)
[-] 	return decl->getName ();
[+] 	return decl->getName();
[-] jnc_ModuleItemDecl_getQualifiedName (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getQualifiedName(jnc_ModuleItemDecl* decl)
[-] 	return decl->getQualifiedName ();
[+] 	return decl->getQualifiedName();
[-] jnc_ModuleItemDecl_getStorageKind (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getStorageKind(jnc_ModuleItemDecl* decl)
[-] 	return decl->getStorageKind ();
[+] 	return decl->getStorageKind();
[-] jnc_ModuleItemDecl_getAccessKind (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getAccessKind(jnc_ModuleItemDecl* decl)
[-] 	return decl->getAccessKind ();
[+] 	return decl->getAccessKind();
[-] jnc_ModuleItemDecl_getAttributeBlock (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getAttributeBlock(jnc_ModuleItemDecl* decl)
[-] 	return decl->getAttributeBlock ();
[+] 	return decl->getAttributeBlock();
[-] jnc_ModuleItemDecl_getParentNamespace (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getParentNamespace(jnc_ModuleItemDecl* decl)
[-] 	return decl->getParentNamespace ();
[+] 	return decl->getParentNamespace();
[-] jnc_ModuleItemDecl_getParentUnit (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getParentUnit(jnc_ModuleItemDecl* decl)
[-] 	return decl->getParentUnit ();
[+] 	return decl->getParentUnit();
[-] jnc_ModuleItemDecl_getLine (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getLine(jnc_ModuleItemDecl* decl)
[-] 	return decl->getPos ()->m_line;
[+] 	return decl->getPos()->m_line;
[-] jnc_ModuleItemDecl_getCol (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getCol(jnc_ModuleItemDecl* decl)
[-] 	return decl->getPos ()->m_col;
[+] 	return decl->getPos()->m_col;
[-] jnc_ModuleItemDecl_getOffset (jnc_ModuleItemDecl* decl)
[+] jnc_ModuleItemDecl_getOffset(jnc_ModuleItemDecl* decl)
[-] 	return decl->getPos ()->m_offset;
[+] 	return decl->getPos()->m_offset;
[-] jnc_ModuleItem_getModule (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getModule(jnc_ModuleItem* item)
[-] 	return item->getModule ();
[+] 	return item->getModule();
[-] jnc_ModuleItem_getItemKind (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getItemKind(jnc_ModuleItem* item)
[-] 	return item->getItemKind ();
[+] 	return item->getItemKind();
[-] jnc_ModuleItem_getFlags (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getFlags(jnc_ModuleItem* item)
[-] 	return item->getFlags ();
[+] 	return item->getFlags();
[-] jnc_ModuleItem_getDecl (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getDecl(jnc_ModuleItem* item)
[-] 	return item->getDecl ();
[+] 	return item->getDecl();
[-] jnc_ModuleItem_getNamespace (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getNamespace(jnc_ModuleItem* item)
[-] 	return item->getNamespace ();
[+] 	return item->getNamespace();
[-] jnc_ModuleItem_getType (jnc_ModuleItem* item)
[+] jnc_ModuleItem_getType(jnc_ModuleItem* item)
[-] 	return item->getType ();
[+] 	return item->getType();
[-] jnc_verifyModuleItemIsDerivableType (
[+] jnc_verifyModuleItemIsDerivableType(
[-] 	return jnc::ct::verifyModuleItemIsDerivableType (item, name);
[+] 	return jnc::ct::verifyModuleItemIsDerivableType(item, name);
[-] jnc_verifyModuleItemIsClassType (
[+] jnc_verifyModuleItemIsClassType(
[-] 	return jnc::ct::verifyModuleItemIsClassType (item, name);
[+] 	return jnc::ct::verifyModuleItemIsClassType(item, name);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Namespace.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getNamespaceKindString (jnc_NamespaceKind namespaceKind)
[+] jnc_getNamespaceKindString(jnc_NamespaceKind namespaceKind)
[-] 	static const char* stringTable [jnc_NamespaceKind__Count] =
[+] 	static const char* stringTable[jnc_NamespaceKind__Count] =
[-] 	return (size_t) namespaceKind < jnc_NamespaceKind__Count ?
[+] 	return (size_t)namespaceKind < jnc_NamespaceKind__Count ?
[-] 		stringTable [namespaceKind] :
[+] 		stringTable[namespaceKind] :
[-] 		stringTable [jnc_NamespaceKind_Undefined];
[+] 		stringTable[jnc_NamespaceKind_Undefined];
[-] jnc_Namespace_getItemCount (jnc_Namespace* nspace)
[+] jnc_Namespace_getItemCount(jnc_Namespace* nspace)
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_getItemCountFunc (nspace);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_getItemCountFunc(nspace);
[-] jnc_Namespace_getItem (
[+] jnc_Namespace_getItem(
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_getItemFunc (nspace, index);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_getItemFunc(nspace, index);
[-] jnc_Namespace_findVariable (
[+] jnc_Namespace_findVariable(
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findVariableFunc (nspace, name, isRequired);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findVariableFunc(nspace, name, isRequired);
[-] jnc_Namespace_findFunction (
[+] jnc_Namespace_findFunction(
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findFunctionFunc (nspace, name, isRequired);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findFunctionFunc(nspace, name, isRequired);
[-] jnc_Namespace_findProperty (
[+] jnc_Namespace_findProperty(
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findPropertyFunc (nspace, name, isRequired);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findPropertyFunc(nspace, name, isRequired);
[-] jnc_Namespace_findClassType (
[+] jnc_Namespace_findClassType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findClassTypeFunc (nspace, name, isRequired);
[+] 	return jnc_g_dynamicExtensionLibHost->m_namespaceFuncTable->m_findClassTypeFunc(nspace, name, isRequired);
[-] jnc_Namespace_getItemCount (jnc_Namespace* nspace)
[+] jnc_Namespace_getItemCount(jnc_Namespace* nspace)
[-] 	return nspace->getItemCount ();
[+] 	return nspace->getItemCount();
[-] jnc_Namespace_getItem (
[+] jnc_Namespace_getItem(
[-] 	return nspace->getItem (index);
[+] 	return nspace->getItem(index);
[-] jnc_Namespace_findVariable (
[+] jnc_Namespace_findVariable(
[-] 		nspace->getVariableByName (name) :
[+] 		nspace->getVariableByName(name) :
[-] 		nspace->findVariableByName (name);
[+] 		nspace->findVariableByName(name);
[-] jnc_Namespace_findFunction (
[+] jnc_Namespace_findFunction(
[-] 		nspace->getFunctionByName (name) :
[+] 		nspace->getFunctionByName(name) :
[-] 		nspace->findFunctionByName (name);
[+] 		nspace->findFunctionByName(name);
[-] jnc_Namespace_findProperty (
[+] jnc_Namespace_findProperty(
[-] 		nspace->getPropertyByName (name) :
[+] 		nspace->getPropertyByName(name) :
[-] 		nspace->findPropertyByName (name);
[+] 		nspace->findPropertyByName(name);
[-] jnc_Namespace_findClassType (
[+] jnc_Namespace_findClassType(
[-] 		nspace->getClassTypeByName (name) :
[+] 		nspace->getClassTypeByName(name) :
[-] 		nspace->findClassTypeByName (name);
[+] 		nspace->findClassTypeByName(name);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_OpKind.cpp
----------------------
[-] jnc_getUnOpKindString (jnc_UnOpKind opKind)
[+] jnc_getUnOpKindString(jnc_UnOpKind opKind)
[-] 	static const char* stringTable [jnc_UnOpKind__Count] =
[+] 	static const char* stringTable[jnc_UnOpKind__Count] =
[-] 	return (size_t) opKind < jnc_UnOpKind__Count ?
[+] 	return (size_t)opKind < jnc_UnOpKind__Count ?
[-] 		stringTable [opKind] :
[+] 		stringTable[opKind] :
[-] 		stringTable [jnc_UnOpKind_Undefined];
[+] 		stringTable[jnc_UnOpKind_Undefined];
[-] jnc_getBinOpKindString (jnc_BinOpKind opKind)
[+] jnc_getBinOpKindString(jnc_BinOpKind opKind)
[-] 	static const char* stringTable [jnc_BinOpKind__Count] =
[+] 	static const char* stringTable[jnc_BinOpKind__Count] =
[-] 	return (size_t) opKind < jnc_BinOpKind__Count ?
[+] 	return (size_t)opKind < jnc_BinOpKind__Count ?
[-] 		stringTable [opKind] :
[+] 		stringTable[opKind] :
[-] 		stringTable [jnc_BinOpKind_Undefined];
[+] 		stringTable[jnc_BinOpKind_Undefined];
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Property.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Property_getGetter (jnc_Property* prop)
[+] jnc_Property_getGetter(jnc_Property* prop)
[-] 	return jnc_g_dynamicExtensionLibHost->m_propertyFuncTable->m_getGetterFunc (prop);
[+] 	return jnc_g_dynamicExtensionLibHost->m_propertyFuncTable->m_getGetterFunc(prop);
[-] jnc_Property_getSetter (jnc_Property* prop)
[+] jnc_Property_getSetter(jnc_Property* prop)
[-] 	return jnc_g_dynamicExtensionLibHost->m_propertyFuncTable->m_getSetterFunc (prop);
[+] 	return jnc_g_dynamicExtensionLibHost->m_propertyFuncTable->m_getSetterFunc(prop);
[-] jnc_Property_getGetter (jnc_Property* prop)
[+] jnc_Property_getGetter(jnc_Property* prop)
[-] 	return prop->getGetter ();
[+] 	return prop->getGetter();
[-] jnc_Property_getSetter (jnc_Property* prop)
[+] jnc_Property_getSetter(jnc_Property* prop)
[-] 	jnc_Function* function = prop->getSetter ();
[+] 	jnc_Function* function = prop->getSetter();
[-] 		err::setFormatStringError ("'%s' has no setter", prop->m_tag.sz ());
[+] 		err::setFormatStringError("'%s' has no setter", prop->m_tag.sz ());
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_PropertyType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Runtime.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Runtime_create ()
[+] jnc_Runtime_create()
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_createFunc ();
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_createFunc();
[-] jnc_Runtime_destroy (jnc_Runtime* runtime)
[+] jnc_Runtime_destroy(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_destroyFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_destroyFunc(runtime);
[-] jnc_Runtime_getModule (jnc_Runtime* runtime)
[+] jnc_Runtime_getModule(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getModuleFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getModuleFunc(runtime);
[-] jnc_Runtime_getGcHeap (jnc_Runtime* runtime)
[+] jnc_Runtime_getGcHeap(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getGcHeapFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getGcHeapFunc(runtime);
[-] jnc_Runtime_isAborted (jnc_Runtime* runtime)
[+] jnc_Runtime_isAborted(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_isAbortedFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_isAbortedFunc(runtime);
[-] jnc_Runtime_getStackSizeLimit (jnc_Runtime* runtime)
[+] jnc_Runtime_getStackSizeLimit(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getStackSizeLimitFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getStackSizeLimitFunc(runtime);
[-] jnc_Runtime_setStackSizeLimit (
[+] jnc_Runtime_setStackSizeLimit(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setStackSizeLimitFunc (runtime, sizeLimit);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setStackSizeLimitFunc(runtime, sizeLimit);
[-] jnc_Runtime_startup (
[+] jnc_Runtime_startup(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_startupFunc (runtime, module);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_startupFunc(runtime, module);
[-] jnc_Runtime_shutdown (jnc_Runtime* runtime)
[+] jnc_Runtime_shutdown(jnc_Runtime* runtime)
[-] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_shutdownFunc (runtime);
[+] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_shutdownFunc(runtime);
[-] jnc_Runtime_abort (jnc_Runtime* runtime)
[+] jnc_Runtime_abort(jnc_Runtime* runtime)
[-] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_abortFunc (runtime);
[+] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_abortFunc(runtime);
[-] jnc_Runtime_initializeCallSite (
[+] jnc_Runtime_initializeCallSite(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_initializeCallSiteFunc (runtime, callSite);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_initializeCallSiteFunc(runtime, callSite);
[-] jnc_Runtime_uninitializeCallSite (
[+] jnc_Runtime_uninitializeCallSite(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_uninitializeCallSiteFunc (runtime, callSite);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_uninitializeCallSiteFunc(runtime, callSite);
[-] jnc_Runtime_setSjljFrame (
[+] jnc_Runtime_setSjljFrame(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setSjljFrameFunc (runtime, frame);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setSjljFrameFunc(runtime, frame);
[-] jnc_Runtime_getUserData (jnc_Runtime* runtime)
[+] jnc_Runtime_getUserData(jnc_Runtime* runtime)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getUserDataFunc (runtime);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getUserDataFunc(runtime);
[-] jnc_Runtime_setUserData (
[+] jnc_Runtime_setUserData(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setUserDataFunc (runtime, data);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_setUserDataFunc(runtime, data);
[-] jnc_Runtime_checkStackOverflow (jnc_Runtime* runtime)
[+] jnc_Runtime_checkStackOverflow(jnc_Runtime* runtime)
[-] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_checkStackOverflowFunc (runtime);
[+] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_checkStackOverflowFunc(runtime);
[-] jnc_getCurrentThreadRuntime ()
[+] jnc_getCurrentThreadRuntime()
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getCurrentThreadRuntimeFunc ();
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getCurrentThreadRuntimeFunc();
[-] jnc_getCurrentThreadTls ()
[+] jnc_getCurrentThreadTls()
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getCurrentThreadTlsFunc ();
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_getCurrentThreadTlsFunc();
[-] jnc_dynamicThrow ()
[+] jnc_dynamicThrow()
[-] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_dynamicThrowFunc ();
[+] 	jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_dynamicThrowFunc();
[-] jnc_primeClass (
[+] jnc_primeClass(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_primeClassFunc (box, root, type, vtable);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_primeClassFunc(box, root, type, vtable);
[-] jnc_strLen (jnc_DataPtr ptr)
[+] jnc_strLen(jnc_DataPtr ptr)
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_strLenFunc (ptr);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_strLenFunc(ptr);
[-] jnc_strDup (
[+] jnc_strDup(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_strDupFunc (p, length);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_strDupFunc(p, length);
[-] jnc_memDup (
[+] jnc_memDup(
[-] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_memDupFunc (p, size);
[+] 	return jnc_g_dynamicExtensionLibHost->m_runtimeFuncTable->m_memDupFunc(p, size);
[-] jnc_Runtime_create ()
[+] jnc_Runtime_create()
[-] 	return AXL_MEM_NEW (jnc_Runtime);
[+] 	return AXL_MEM_NEW(jnc_Runtime);
[-] jnc_Runtime_destroy (jnc_Runtime* runtime)
[+] jnc_Runtime_destroy(jnc_Runtime* runtime)
[-] 	return AXL_MEM_DELETE (runtime);
[+] 	return AXL_MEM_DELETE(runtime);
[-] jnc_Runtime_getModule (jnc_Runtime* runtime)
[+] jnc_Runtime_getModule(jnc_Runtime* runtime)
[-] 	return runtime->getModule ();
[+] 	return runtime->getModule();
[-] jnc_Runtime_getGcHeap (jnc_Runtime* runtime)
[+] jnc_Runtime_getGcHeap(jnc_Runtime* runtime)
[-] 	return runtime->getGcHeap ();
[+] 	return runtime->getGcHeap();
[-] jnc_Runtime_isAborted (jnc_Runtime* runtime)
[+] jnc_Runtime_isAborted(jnc_Runtime* runtime)
[-] 	return runtime->isAborted ();
[+] 	return runtime->isAborted();
[-] jnc_Runtime_getStackSizeLimit (jnc_Runtime* runtime)
[+] jnc_Runtime_getStackSizeLimit(jnc_Runtime* runtime)
[-] 	return runtime->getStackSizeLimit ();
[+] 	return runtime->getStackSizeLimit();
[-] jnc_Runtime_setStackSizeLimit (
[+] jnc_Runtime_setStackSizeLimit(
[-] 	return runtime->setStackSizeLimit (sizeLimit);
[+] 	return runtime->setStackSizeLimit(sizeLimit);
[-] jnc_Runtime_startup (
[+] jnc_Runtime_startup(
[-] 	return runtime->startup (module);
[+] 	return runtime->startup(module);
[-] jnc_Runtime_shutdown (jnc_Runtime* runtime)
[+] jnc_Runtime_shutdown(jnc_Runtime* runtime)
[-] 	return runtime->shutdown ();
[+] 	return runtime->shutdown();
[-] jnc_Runtime_abort (jnc_Runtime* runtime)
[+] jnc_Runtime_abort(jnc_Runtime* runtime)
[-] 	return runtime->abort ();
[+] 	return runtime->abort();
[-] jnc_Runtime_initializeCallSite (
[+] jnc_Runtime_initializeCallSite(
[-] 	runtime->initializeCallSite (callSite);
[+] 	runtime->initializeCallSite(callSite);
[-] jnc_Runtime_uninitializeCallSite (
[+] jnc_Runtime_uninitializeCallSite(
[-] 	runtime->uninitializeCallSite (callSite);
[+] 	runtime->uninitializeCallSite(callSite);
[-] jnc_Runtime_setSjljFrame (
[+] jnc_Runtime_setSjljFrame(
[-] 	return runtime->setSjljFrame (frame);
[+] 	return runtime->setSjljFrame(frame);
[-] jnc_Runtime_getUserData (jnc_Runtime* runtime)
[+] jnc_Runtime_getUserData(jnc_Runtime* runtime)
[-] jnc_Runtime_setUserData (
[+] jnc_Runtime_setUserData(
[-] 	return (void*) sys::atomicXchg ((size_t volatile*) &runtime->m_userData, (size_t) data);
[+] 	return (void*)sys::atomicXchg((size_t volatile*) &runtime->m_userData, (size_t)data);
[-] jnc_Runtime_checkStackOverflow (jnc_Runtime* runtime)
[+] jnc_Runtime_checkStackOverflow(jnc_Runtime* runtime)
[-] 	return runtime->checkStackOverflow ();
[+] 	return runtime->checkStackOverflow();
[-] jnc_getCurrentThreadRuntime ()
[+] jnc_getCurrentThreadRuntime()
[-] 	return jnc::rt::getCurrentThreadRuntime ();
[+] 	return jnc::rt::getCurrentThreadRuntime();
[-] jnc_getCurrentThreadTls ()
[+] jnc_getCurrentThreadTls()
[-] 	return jnc::rt::getCurrentThreadTls ();
[+] 	return jnc::rt::getCurrentThreadTls();
[-] jnc_dynamicThrow ()
[+] jnc_dynamicThrow()
[-] 	jnc::rt::Runtime::dynamicThrow ();
[+] 	jnc::rt::Runtime::dynamicThrow();
[-] primeIface (
[+] primeIface(
[-] 	sl::Array <ct::BaseTypeSlot*> baseTypePrimeArray = type->getBaseTypePrimeArray ();
[+] 	sl::Array<ct::BaseTypeSlot*> baseTypePrimeArray = type->getBaseTypePrimeArray();
[-] 	size_t count = baseTypePrimeArray.getCount ();
[+] 	size_t count = baseTypePrimeArray.getCount();
[-] 		ct::BaseTypeSlot* slot = baseTypePrimeArray [i];
[+] 		ct::BaseTypeSlot* slot = baseTypePrimeArray[i];
[-] 		ASSERT (slot->getType ()->getTypeKind () == TypeKind_Class);
[+] 		ASSERT(slot->getType()->getTypeKind() == TypeKind_Class);
[-] 		primeIface (
[+] 		primeIface(
[-] 			(IfaceHdr*) ((char*) iface + slot->getOffset ()),
[+] 			(IfaceHdr*)((char*)iface + slot->getOffset()),
[-] 			(ct::ClassType*) slot->getType (),
[+] 			(ct::ClassType*)slot->getType(),
[-] 			(void**) vtable + slot->getVTableIndex ()
[+] 			(void**) vtable + slot->getVTableIndex()
[-] 	sl::Array <ct::StructField*> fieldPrimeArray = type->getClassMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> fieldPrimeArray = type->getClassMemberFieldArray();
[-] 	count = fieldPrimeArray.getCount ();
[+] 	count = fieldPrimeArray.getCount();
[-] 		ct::StructField* field = fieldPrimeArray [i];
[+] 		ct::StructField* field = fieldPrimeArray[i];
[-] 		ASSERT (field->getType ()->getTypeKind () == TypeKind_Class);
[+] 		ASSERT(field->getType()->getTypeKind() == TypeKind_Class);
[-] 		ct::ClassType* fieldType = (ct::ClassType*) field->getType ();
[+] 		ct::ClassType* fieldType = (ct::ClassType*)field->getType();
[-] 		Box* fieldBox = (Box*) ((char*) iface + field->getOffset ());
[+] 		Box* fieldBox = (Box*)((char*)iface + field->getOffset());
[-] 		primeClass (
[+] 		primeClass(
[-] jnc_primeClass (
[+] jnc_primeClass(
[-] 	ASSERT (root <= box);
[+] 	ASSERT(root <= box);
[-] 		jnc_Variable* vtableVariable = type->getVTableVariable ();
[+] 		jnc_Variable* vtableVariable = type->getVTableVariable();
[-] 			vtable = vtableVariable->getStaticData ();
[+] 			vtable = vtableVariable->getStaticData();
[-] 	memset (box, 0, type->getSize ());
[+] 	memset(box, 0, type->getSize());
[-] 	box->m_rootOffset = (char*) box - (char*) root;
[+] 	box->m_rootOffset = (char*)box - (char*)root;
[-] 	primeIface (box, root, (jnc_IfaceHdr*) (box + 1), type, vtable);
[+] 	primeIface(box, root, (jnc_IfaceHdr*)(box + 1), type, vtable);
[-] jnc_strengthenClassPtr (jnc_IfaceHdr* iface)
[+] jnc_strengthenClassPtr(jnc_IfaceHdr* iface)
[-] 	ASSERT (iface->m_box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(iface->m_box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ClassType* classType = (ClassType*) iface->m_box->m_type;
[+] 	ClassType* classType = (ClassType*)iface->m_box->m_type;
[-] 	ClassTypeKind classTypeKind = classType->getClassTypeKind ();
[+] 	ClassTypeKind classTypeKind = classType->getClassTypeKind();
[-] 		((ct::ClosureClassType*) classType)->strengthen (iface) :
[+] 		((ct::ClosureClassType*)classType)->strengthen(iface) :
[-] jnc_strLen (jnc_DataPtr ptr)
[+] jnc_strLen(jnc_DataPtr ptr)
[-] 	char* p0 = (char*) ptr.m_p;
[+] 	char* p0 = (char*)ptr.m_p;
[-] 	char* end = (char*) ptr.m_validator->m_rangeEnd;
[+] 	char* end = (char*)ptr.m_validator->m_rangeEnd;
[-] jnc_strDup (
[+] jnc_strDup(
[-] 		length = strlen_s (p);
[+] 		length = strlen_s(p);
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (length + 1);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(length + 1);
[-] 		memcpy (resultPtr.m_p, p, length);
[+] 		memcpy(resultPtr.m_p, p, length);
[-] jnc_memDup (
[+] jnc_memDup(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (size);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(size);
[-] 		memcpy (resultPtr.m_p, p, size);
[+] 		memcpy(resultPtr.m_p, p, size);
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_StructType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_StructField_getOffset (jnc_StructField* field)
[+] jnc_StructField_getOffset(jnc_StructField* field)
[-] 	return jnc_g_dynamicExtensionLibHost->m_structFieldFuncTable->m_getOffsetFunc (field);
[+] 	return jnc_g_dynamicExtensionLibHost->m_structFieldFuncTable->m_getOffsetFunc(field);
[-] jnc_StructField_getOffset (jnc_StructField* field)
[+] jnc_StructField_getOffset(jnc_StructField* field)
[-] 	return field->getOffset ();
[+] 	return field->getOffset();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Type.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_getTypeKindFlags (jnc_TypeKind typeKind)
[+] jnc_getTypeKindFlags(jnc_TypeKind typeKind)
[-] 	static uint_t flagTable [jnc_TypeKind__Count] =
[+] 	static uint_t flagTable[jnc_TypeKind__Count] =
[-] 	return typeKind < jnc_TypeKind__Count ? flagTable [typeKind] : 0;
[+] 	return typeKind < jnc_TypeKind__Count ? flagTable[typeKind] : 0;
[-] jnc_getDataPtrTypeKindString (jnc_DataPtrTypeKind ptrTypeKind)
[+] jnc_getDataPtrTypeKindString(jnc_DataPtrTypeKind ptrTypeKind)
[-] 	static const char* stringTable [jnc_DataPtrTypeKind__Count] =
[+] 	static const char* stringTable[jnc_DataPtrTypeKind__Count] =
[-] 	return (size_t) ptrTypeKind < jnc_DataPtrTypeKind__Count ?
[+] 	return (size_t)ptrTypeKind < jnc_DataPtrTypeKind__Count ?
[-] 		stringTable [ptrTypeKind] :
[+] 		stringTable[ptrTypeKind] :
[-] jnc_Type_getTypeKind (jnc_Type* type)
[+] jnc_Type_getTypeKind(jnc_Type* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getTypeKindFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getTypeKindFunc(type);
[-] jnc_Type_getSize (jnc_Type* type)
[+] jnc_Type_getSize(jnc_Type* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getSizeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getSizeFunc(type);
[-] jnc_Type_getTypeString (jnc_Type* type)
[+] jnc_Type_getTypeString(jnc_Type* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getTypeStringFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getTypeStringFunc(type);
[-] jnc_Type_cmp (
[+] jnc_Type_cmp(
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_cmpFunc (type, type2);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_cmpFunc(type, type2);
[-] jnc_Type_getDataPtrType (
[+] jnc_Type_getDataPtrType(
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getDataPtrTypeFunc (type, ptrTypeKind, flags);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_getDataPtrTypeFunc(type, ptrTypeKind, flags);
[-] jnc_Type_markGcRoots (
[+] jnc_Type_markGcRoots(
[-] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_markGcRootsFunc (type, p, gcHeap);
[+] 	return jnc_g_dynamicExtensionLibHost->m_typeFuncTable->m_markGcRootsFunc(type, p, gcHeap);
[-] jnc_DataPtrType_getPtrTypeKind (jnc_DataPtrType* type)
[+] jnc_DataPtrType_getPtrTypeKind(jnc_DataPtrType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_dataPtrTypeFuncTable->m_getPtrTypeKindFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_dataPtrTypeFuncTable->m_getPtrTypeKindFunc(type);
[-] jnc_DataPtrType_getTargetType (jnc_DataPtrType* type)
[+] jnc_DataPtrType_getTargetType(jnc_DataPtrType* type)
[-] 	return jnc_g_dynamicExtensionLibHost->m_dataPtrTypeFuncTable->m_getTargetTypeFunc (type);
[+] 	return jnc_g_dynamicExtensionLibHost->m_dataPtrTypeFuncTable->m_getTargetTypeFunc(type);
[-] jnc_Type_getTypeKind (jnc_Type* type)
[+] jnc_Type_getTypeKind(jnc_Type* type)
[-] 	return type->getTypeKind ();
[+] 	return type->getTypeKind();
[-] jnc_Type_getSize (jnc_Type* type)
[+] jnc_Type_getSize(jnc_Type* type)
[-] 	return type->getSize ();
[+] 	return type->getSize();
[-] jnc_Type_getTypeString (jnc_Type* type)
[+] jnc_Type_getTypeString(jnc_Type* type)
[-] 	return type->getTypeString ();
[+] 	return type->getTypeString();
[-] jnc_Type_getTypeStringPrefix (jnc_Type* type)
[+] jnc_Type_getTypeStringPrefix(jnc_Type* type)
[-] 	return type->getTypeStringPrefix ();
[+] 	return type->getTypeStringPrefix();
[-] jnc_Type_getTypeStringSuffix (jnc_Type* type)
[+] jnc_Type_getTypeStringSuffix(jnc_Type* type)
[-] 	return type->getTypeStringSuffix ();
[+] 	return type->getTypeStringSuffix();
[-] jnc_Type_cmp (
[+] jnc_Type_cmp(
[-] 	return type->cmp (type2);
[+] 	return type->cmp(type2);
[-] jnc_Type_getDataPtrType (
[+] jnc_Type_getDataPtrType(
[-] 	return type->getDataPtrType (ptrTypeKind, flags);
[+] 	return type->getDataPtrType(ptrTypeKind, flags);
[-] jnc_Type_markGcRoots (
[+] jnc_Type_markGcRoots(
[-] 	return type->markGcRoots (p, gcHeap);
[+] 	return type->markGcRoots(p, gcHeap);
[-] jnc_DataPtrType_getPtrTypeKind (jnc_DataPtrType* type)
[+] jnc_DataPtrType_getPtrTypeKind(jnc_DataPtrType* type)
[-] 	return type->getPtrTypeKind ();
[+] 	return type->getPtrTypeKind();
[-] jnc_DataPtrType_getTargetType (jnc_DataPtrType* type)
[+] jnc_DataPtrType_getTargetType(jnc_DataPtrType* type)
[-] 	return type->getTargetType ();
[+] 	return type->getTargetType();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_UnionType.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Variable.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Variable_hasInitializer (jnc_Variable* variable)
[+] jnc_Variable_hasInitializer(jnc_Variable* variable)
[-] 	return !variable->getInitializer ().isEmpty ();
[+] 	return !variable->getInitializer().isEmpty();
[-] jnc_Variable_getInitializerString_v (jnc_Variable* variable)
[+] jnc_Variable_getInitializerString_v(jnc_Variable* variable)
[-] 	return *jnc::getTlsStringBuffer () = variable->getInitializerString ();
[+] 	return *jnc::getTlsStringBuffer() = variable->getInitializerString();
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_api\jnc_Variant.cpp
----------------------
[-] #elif defined (_JNC_CORE)
[+] #elif defined(_JNC_CORE)
[-] jnc_Variant_cast (
[+] jnc_Variant_cast(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_castFunc (variant, type, buffer);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_castFunc(variant, type, buffer);
[-] jnc_Variant_unaryOperator (
[+] jnc_Variant_unaryOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_unaryOperatorFunc (variant, opKind, result);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_unaryOperatorFunc(variant, opKind, result);
[-] jnc_Variant_binaryOperator (
[+] jnc_Variant_binaryOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_binaryOperatorFunc (variant, variant2, opKind, result);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_binaryOperatorFunc(variant, variant2, opKind, result);
[-] jnc_Variant_relationalOperator (
[+] jnc_Variant_relationalOperator(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_relationalOperatorFunc (variant, variant2, opKind, result);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_relationalOperatorFunc(variant, variant2, opKind, result);
[-] jnc_Variant_getMember (
[+] jnc_Variant_getMember(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_getMemberFunc (variant, name, result);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_getMemberFunc(variant, name, result);
[-] jnc_Variant_setMember (
[+] jnc_Variant_setMember(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_setMemberFunc (variant, name, value);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_setMemberFunc(variant, name, value);
[-] jnc_Variant_getElement (
[+] jnc_Variant_getElement(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_getElementFunc (variant, index, result);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_getElementFunc(variant, index, result);
[-] jnc_Variant_setElement (
[+] jnc_Variant_setElement(
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_setElementFunc (variant, index, value);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_setElementFunc(variant, index, value);
[-] jnc_Variant_hash (const jnc_Variant* variant)
[+] jnc_Variant_hash(const jnc_Variant* variant)
[-] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_hashFunc (variant);
[+] 	return jnc_g_dynamicExtensionLibHost->m_variantFuncTable->m_hashFunc(variant);
[-] jnc_Variant_cast (
[+] jnc_Variant_cast(
[-] 	ct::Module* module = type->getModule ();
[+] 	ct::Module* module = type->getModule();
[-] 	ct::Value opValue (variant, module->m_typeMgr.getPrimitiveType (TypeKind_Variant));
[+] 	ct::Value opValue(variant, module->m_typeMgr.getPrimitiveType(TypeKind_Variant));
[-] 	ct::CastOperator* castOp = module->m_operatorMgr.getStdCastOperator (ct::StdCast_FromVariant);
[+] 	ct::CastOperator* castOp = module->m_operatorMgr.getStdCastOperator(ct::StdCast_FromVariant);
[-] 	memset (buffer, 0, type->getSize ());
[+] 	memset(buffer, 0, type->getSize());
[-] 	return castOp->constCast (opValue, type, buffer);
[+] 	return castOp->constCast(opValue, type, buffer);
[-] jnc_Variant_unaryOperator (
[+] jnc_Variant_unaryOperator(
[-] 		opValue.createConst (variant, variant->m_type);
[+] 		opValue.createConst(variant, variant->m_type);
[-] 	ct::Module* module = variant->m_type->getModule ();
[+] 	ct::Module* module = variant->m_type->getModule();
[-] 	bool result = module->m_operatorMgr.unaryOperator (
[+] 	bool result = module->m_operatorMgr.unaryOperator(
[-] 		module->m_operatorMgr.castOperator (&resultValue, TypeKind_Variant);
[+] 		module->m_operatorMgr.castOperator(&resultValue, TypeKind_Variant);
[-] 	*resultVariant = *(Variant*) resultValue.getConstData ();
[+] 	*resultVariant = *(Variant*)resultValue.getConstData();
[-] jnc_Variant_binaryOperator (
[+] jnc_Variant_binaryOperator(
[-] 		opValue1.createConst (variant, variant->m_type);
[+] 		opValue1.createConst(variant, variant->m_type);
[-] 		opValue1.createConst (NULL, variant2->m_type);
[+] 		opValue1.createConst(NULL, variant2->m_type);
[-] 		opValue2.createConst (variant2, variant2->m_type);
[+] 		opValue2.createConst(variant2, variant2->m_type);
[-] 		ASSERT (variant->m_type);
[+] 		ASSERT(variant->m_type);
[-] 		opValue2.createConst (NULL, variant->m_type);
[+] 		opValue2.createConst(NULL, variant->m_type);
[-] 	ct::Module* module = opValue1.getType ()->getModule ();
[+] 	ct::Module* module = opValue1.getType()->getModule();
[-] 	bool result = module->m_operatorMgr.binaryOperator (
[+] 	bool result = module->m_operatorMgr.binaryOperator(
[-] 		module->m_operatorMgr.castOperator (&resultValue, TypeKind_Variant);
[+] 		module->m_operatorMgr.castOperator(&resultValue, TypeKind_Variant);
[-] 	*resultVariant = *(Variant*) resultValue.getConstData ();
[+] 	*resultVariant = *(Variant*)resultValue.getConstData();
[-] jnc_Variant_relationalOperator (
[+] jnc_Variant_relationalOperator(
[-] 	ASSERT (opKind >= BinOpKind_Eq && opKind <= BinOpKind_Ge);
[+] 	ASSERT(opKind >= BinOpKind_Eq && opKind <= BinOpKind_Ge);
[-] 		opValue1.createConst (variant, variant->m_type);
[+] 		opValue1.createConst(variant, variant->m_type);
[-] 		opValue1.createConst (NULL, variant2->m_type);
[+] 		opValue1.createConst(NULL, variant2->m_type);
[-] 		opValue2.createConst (variant2, variant2->m_type);
[+] 		opValue2.createConst(variant2, variant2->m_type);
[-] 		ASSERT (variant->m_type);
[+] 		ASSERT(variant->m_type);
[-] 		opValue2.createConst (NULL, variant->m_type);
[+] 		opValue2.createConst(NULL, variant->m_type);
[-] 	ct::Module* module = opValue1.getType ()->getModule ();
[+] 	ct::Module* module = opValue1.getType()->getModule();
[-] 	bool result = module->m_operatorMgr.binaryOperator (
[+] 	bool result = module->m_operatorMgr.binaryOperator(
[-] 		module->m_operatorMgr.castOperator (&resultValue, TypeKind_Bool);
[+] 		module->m_operatorMgr.castOperator(&resultValue, TypeKind_Bool);
[-] 	*resultBool = *(bool*) resultValue.getConstData ();
[+] 	*resultBool = *(bool*)resultValue.getConstData();
[-] jnc_Variant_getMember (
[+] jnc_Variant_getMember(
[-] 		err::setError ("cannot apply member operator to 'null'");
[+] 		err::setError("cannot apply member operator to 'null'");
[-] 	ct::Module* module = variant->m_type->getModule ();
[+] 	ct::Module* module = variant->m_type->getModule();
[-] 	ct::Value opValue (variant, variant->m_type);
[+] 	ct::Value opValue(variant, variant->m_type);
[-] 		module->m_operatorMgr.memberOperator (opValue, name, &memberValue) &&
[+] 		module->m_operatorMgr.memberOperator(opValue, name, &memberValue) &&
[-] 		module->m_operatorMgr.castOperator (&memberValue, TypeKind_Variant);
[+] 		module->m_operatorMgr.castOperator(&memberValue, TypeKind_Variant);
[-] 	*resultVariant = *(Variant*) memberValue.getConstData ();
[+] 	*resultVariant = *(Variant*)memberValue.getConstData();
[-] jnc_Variant_setMember (
[+] jnc_Variant_setMember(
[-] 		err::setError ("cannot apply member operator to 'null'");
[+] 		err::setError("cannot apply member operator to 'null'");
[-] 	ct::Module* module = variant->m_type->getModule ();
[+] 	ct::Module* module = variant->m_type->getModule();
[-] 	if (variant->m_type->getTypeKindFlags () & TypeKindFlag_Ptr)
[+] 	if (variant->m_type->getTypeKindFlags() & TypeKindFlag_Ptr)
[-] 		opValue.createConst (variant, variant->m_type);
[+] 		opValue.createConst(variant, variant->m_type);
[-] 		ASSERT (variant->m_type->getSize () <= sizeof (DataPtr));
[+] 		ASSERT(variant->m_type->getSize() <= sizeof(DataPtr));
[-] 		opValue.createConst (&variant, variant->m_type->getDataPtrType_c (TypeKind_DataRef));
[+] 		opValue.createConst(&variant, variant->m_type->getDataPtrType_c(TypeKind_DataRef));
[-] 	ct::Value opValue2 (&valueVariant, module->m_typeMgr.getPrimitiveType (TypeKind_Variant));
[+] 	ct::Value opValue2(&valueVariant, module->m_typeMgr.getPrimitiveType(TypeKind_Variant));
[-] 		module->m_operatorMgr.memberOperator (opValue, name, &memberValue) &&
[+] 		module->m_operatorMgr.memberOperator(opValue, name, &memberValue) &&
[-] 		module->m_operatorMgr.binaryOperator (BinOpKind_Assign, memberValue, opValue2);
[+] 		module->m_operatorMgr.binaryOperator(BinOpKind_Assign, memberValue, opValue2);
[-] jnc_Variant_getElement (
[+] jnc_Variant_getElement(
[-] 		err::setError ("cannot apply index operator to 'null'");
[+] 		err::setError("cannot apply index operator to 'null'");
[-] 	ct::Module* module = variant->m_type->getModule ();
[+] 	ct::Module* module = variant->m_type->getModule();
[-] 	if (variant->m_type->getTypeKindFlags () & TypeKindFlag_Ptr)
[+] 	if (variant->m_type->getTypeKindFlags() & TypeKindFlag_Ptr)
[-] 		opValue.createConst (variant, variant->m_type);
[+] 		opValue.createConst(variant, variant->m_type);
[-] 		ASSERT (variant->m_type->getSize () <= sizeof (DataPtr));
[+] 		ASSERT(variant->m_type->getSize() <= sizeof(DataPtr));
[-] 		opValue.createConst (&variant, variant->m_type->getDataPtrType_c (TypeKind_DataRef));
[+] 		opValue.createConst(&variant, variant->m_type->getDataPtrType_c(TypeKind_DataRef));
[-] 		module->m_operatorMgr.memberOperator (opValue, index, &memberValue) &&
[+] 		module->m_operatorMgr.memberOperator(opValue, index, &memberValue) &&
[-] 		module->m_operatorMgr.castOperator (&memberValue, TypeKind_Variant);
[+] 		module->m_operatorMgr.castOperator(&memberValue, TypeKind_Variant);
[-] 	*resultVariant = *(Variant*) memberValue.getConstData ();
[+] 	*resultVariant = *(Variant*)memberValue.getConstData();
[-] jnc_Variant_setElement (
[+] jnc_Variant_setElement(
[-] 		err::setError ("cannot apply index operator to 'null'");
[+] 		err::setError("cannot apply index operator to 'null'");
[-] 	ct::Module* module = variant->m_type->getModule ();
[+] 	ct::Module* module = variant->m_type->getModule();
[-] 	if (variant->m_type->getTypeKindFlags () & TypeKindFlag_Ptr)
[+] 	if (variant->m_type->getTypeKindFlags() & TypeKindFlag_Ptr)
[-] 		opValue.createConst (variant, variant->m_type);
[+] 		opValue.createConst(variant, variant->m_type);
[-] 		ASSERT (variant->m_type->getSize () <= sizeof (DataPtr));
[+] 		ASSERT(variant->m_type->getSize() <= sizeof(DataPtr));
[-] 		opValue.createConst (&variant, variant->m_type->getDataPtrType_c (TypeKind_DataRef));
[+] 		opValue.createConst(&variant, variant->m_type->getDataPtrType_c(TypeKind_DataRef));
[-] 	ct::Value opValue2 (&valueVariant, module->m_typeMgr.getPrimitiveType (TypeKind_Variant));
[+] 	ct::Value opValue2(&valueVariant, module->m_typeMgr.getPrimitiveType(TypeKind_Variant));
[-] 		module->m_operatorMgr.memberOperator (opValue, index, &memberValue) &&
[+] 		module->m_operatorMgr.memberOperator(opValue, index, &memberValue) &&
[-] 		module->m_operatorMgr.binaryOperator (BinOpKind_Assign, memberValue, opValue2);
[+] 		module->m_operatorMgr.binaryOperator(BinOpKind_Assign, memberValue, opValue2);
[-] jnc_Variant_hash (const jnc_Variant* variant)
[+] jnc_Variant_hash(const jnc_Variant* variant)
[-] 	size_t size = variant->m_type->getSize ();
[+] 	size_t size = variant->m_type->getSize();
[-] 	if (variant->m_type->getTypeKindFlags () & TypeKindFlag_BigEndian)
[+] 	if (variant->m_type->getTypeKindFlags() & TypeKindFlag_BigEndian)
[-] 		axl::sl::swapByteOrder (&result, &variant->m_int64, size);
[+] 		axl::sl::swapByteOrder(&result, &variant->m_int64, size);
[-] 		return (uintptr_t) result;
[+] 		return (uintptr_t)result;
[-] 	if (size <= sizeof (uintptr_t) || variant->m_type->getTypeKind () == TypeKind_DataPtr)
[+] 	if (size <= sizeof(uintptr_t) || variant->m_type->getTypeKind() == TypeKind_DataPtr)
[-] 	const void* p = size <= sizeof (DataPtr) ? &variant : variant->m_p;
[+] 	const void* p = size <= sizeof(DataPtr) ? &variant : variant->m_p;
[-] 	return sl::djb2 (p, size);
[+] 	return sl::djb2(p, size);
[-] jnc::Variant::relationalOperator (
[+] jnc::Variant::relationalOperator(
[-] 	if (!jnc_Variant_relationalOperator (this, variant2, opKind, &intResult))
[+] 	if (!jnc_Variant_relationalOperator(this, variant2, opKind, &intResult))
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_app\CmdLine.cpp
----------------------
[-] CmdLine::CmdLine ()
[+] CmdLine::CmdLine()
[-] parseSizeString (const sl::StringRef& string)
[+] parseSizeString(const sl::StringRef& string)
[-] 	size_t length = string.getLength ();
[+] 	size_t length = string.getLength();
[-] 	char c = string [length - 1];
[+] 	char c = string[length - 1];
[-] 	if (isalpha (c))
[+] 	if (isalpha(c))
[-] 		switch (c)
[+] 		switch(c)
[-] 	return strtoul (string.cp (), NULL, 10) * multiplier;
[+] 	return strtoul(string.cp(), NULL, 10) * multiplier;
[-] CmdLineParser::onValue (const sl::StringRef& value)
[+] CmdLineParser::onValue(const sl::StringRef& value)
[-] 	m_cmdLine->m_fileNameList.insertTail (value);
[+] 	m_cmdLine->m_fileNameList.insertTail(value);
[-] CmdLineParser::onSwitch (
[+] CmdLineParser::onSwitch(
[-] 	switch (switchKind)
[+] 	switch(switchKind)
[-] 		m_cmdLine->m_gcSizeTriggers.m_allocSizeTrigger = parseSizeString (value);
[+] 		m_cmdLine->m_gcSizeTriggers.m_allocSizeTrigger = parseSizeString(value);
[-] 		m_cmdLine->m_gcSizeTriggers.m_periodSizeTrigger = parseSizeString (value);
[+] 		m_cmdLine->m_gcSizeTriggers.m_periodSizeTrigger = parseSizeString(value);
[-] 		m_cmdLine->m_stackSizeLimit = parseSizeString (value);
[+] 		m_cmdLine->m_stackSizeLimit = parseSizeString(value);
[-] 			err::setFormatStringError ("invalid stack size '%s'", value.sz ());
[+] 			err::setFormatStringError("invalid stack size '%s'", value.sz ());
[-] 		m_cmdLine->m_sourceDirList.insertTail (value);
[+] 		m_cmdLine->m_sourceDirList.insertTail(value);
[-] 		m_cmdLine->m_importDirList.insertTail (value);
[+] 		m_cmdLine->m_importDirList.insertTail(value);
[-] 		m_cmdLine->m_ignoredImportList.insertTail (value);
[+] 		m_cmdLine->m_ignoredImportList.insertTail(value);
[-] 		DoxyCommentMap::Iterator it = DoxyCommentMap::find (value);
[+] 		DoxyCommentMap::Iterator it = DoxyCommentMap::find(value);
[-] CmdLineParser::finalize ()
[+] CmdLineParser::finalize()
[-] 	static char jncSuffix [] = ".jnc";
[+] 	static char jncSuffix[] = ".jnc";
[-] 	static char doxSuffix [] = ".dox";
[+] 	static char doxSuffix[] = ".dox";
[-] 		SuffixLength = lengthof (jncSuffix)
[+] 		SuffixLength = lengthof(jncSuffix)
[-] 	sl::BoxIterator <sl::String> it = m_cmdLine->m_sourceDirList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_cmdLine->m_sourceDirList.getHead();
[-] 		if (dir.isEmpty ())
[+] 		if (dir.isEmpty())
[-] 		if (dir [dir.getLength () - 1])
[+] 		if (dir[dir.getLength() - 1])
[-] 		bool result = fileEnum.openDir (dir);
[+] 		bool result = fileEnum.openDir(dir);
[-] 			printf ("warning: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("warning: %s\n", err::getLastErrorDescription ().sz ());
[-] 		while (fileEnum.hasNextFile ())
[+] 		while (fileEnum.hasNextFile())
[-] 			sl::String filePath = dir + fileEnum.getNextFileName ();
[+] 			sl::String filePath = dir + fileEnum.getNextFileName();
[-] 			if (io::isDir (filePath))
[+] 			if (io::isDir(filePath))
[-] 			size_t length = filePath.getLength ();
[+] 			size_t length = filePath.getLength();
[-] 			const char* suffix = filePath.sz () + length - SuffixLength;
[+] 			const char* suffix = filePath.sz() + length - SuffixLength;
[-] 			if (memcmp (suffix, jncSuffix, SuffixLength) == 0 ||
[+] 			if (memcmp(suffix, jncSuffix, SuffixLength) == 0 ||
[-] 				includeDox && memcmp (suffix, doxSuffix, SuffixLength) == 0)
[+] 				includeDox && memcmp(suffix, doxSuffix, SuffixLength) == 0)
[-] 				m_cmdLine->m_fileNameList.insertTail (filePath);
[+] 				m_cmdLine->m_fileNameList.insertTail(filePath);
[-] 		m_cmdLine->m_fileNameList.isEmpty ())
[+] 		m_cmdLine->m_fileNameList.isEmpty())
[-] 		err::setFormatStringError ("missing input (file-name or --stdin)");
[+] 		err::setFormatStringError("missing input (file-name or --stdin)");
----------------------
27/02/2019 18:02:04 - C:\Projects\repos\ioninja\jancy\src\jnc_app\JncApp.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (JncLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(JncLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (JncLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(JncLib)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (JncLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(JncLib)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] JncApp::JncApp (CmdLine* cmdLine)
[+] JncApp::JncApp(CmdLine* cmdLine)
[-] 	m_module->initialize ("jnc_module", compileFlags);
[+] 	m_module->initialize("jnc_module", compileFlags);
[-] 		m_module->addStaticLib (jnc::StdLib_getLib ());
[+] 		m_module->addStaticLib(jnc::StdLib_getLib());
[-] 		m_module->addStaticLib (jnc::SysLib_getLib ());
[+] 		m_module->addStaticLib(jnc::SysLib_getLib());
[-] 		m_module->addStaticLib (JncLib_getLib ());
[+] 		m_module->addStaticLib(JncLib_getLib());
[-] 	sl::BoxIterator <sl::String> it = cmdLine->m_importDirList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = cmdLine->m_importDirList.getHead();
[-] 		m_module->addImportDir (*it);
[+] 		m_module->addImportDir(*it);
[-] 	it = cmdLine->m_ignoredImportList.getHead ();
[+] 	it = cmdLine->m_ignoredImportList.getHead();
[-] 		m_module->addIgnoredImport (*it);
[+] 		m_module->addIgnoredImport(*it);
[-] 	m_module->addImportDir (io::getExeDir ());
[+] 	m_module->addImportDir(io::getExeDir());
[-] JncApp::parse ()
[+] JncApp::parse()
[-] 		int stdInFile = _fileno (stdin);
[+] 		int stdInFile = _fileno(stdin);
[-] 			char buffer [1024];
[+] 			char buffer[1024];
[-] 			int size = _read (stdInFile, buffer, sizeof (buffer));
[+] 			int size = _read(stdInFile, buffer, sizeof(buffer));
[-] 			int size = read (STDIN_FILENO, buffer, sizeof (buffer));
[+] 			int size = read(STDIN_FILENO, buffer, sizeof(buffer));
[-] 			m_stdInBuffer.append (buffer, size);
[+] 			m_stdInBuffer.append(buffer, size);
[-] 		const char* srcName = !m_cmdLine->m_srcNameOverride.isEmpty () ?
[+] 		const char* srcName = !m_cmdLine->m_srcNameOverride.isEmpty() ?
[-] 			m_cmdLine->m_srcNameOverride.sz () :
[+] 			m_cmdLine->m_srcNameOverride.sz() :
[-] 		result = m_module->parse (srcName, m_stdInBuffer, m_stdInBuffer.getCount ());
[+] 		result = m_module->parse(srcName, m_stdInBuffer, m_stdInBuffer.getCount());
[-] 		sl::BoxIterator <sl::String> fileNameIt = m_cmdLine->m_fileNameList.getHead ();
[+] 		sl::BoxIterator<sl::String> fileNameIt = m_cmdLine->m_fileNameList.getHead();
[-] 		ASSERT (fileNameIt);
[+] 		ASSERT(fileNameIt);
[-] 			result = m_module->parseFile (*fileNameIt);
[+] 			result = m_module->parseFile(*fileNameIt);
[-] 	return m_module->parseImports ();
[+] 	return m_module->parseImports();
[-] JncApp::runFunction (int* returnValue)
[+] JncApp::runFunction(int* returnValue)
[-] 	jnc::ModuleItem* functionItem = m_module->findItem (m_cmdLine->m_functionName);
[+] 	jnc::ModuleItem* functionItem = m_module->findItem(m_cmdLine->m_functionName);
[-] 	if (!functionItem || functionItem->getItemKind () != jnc::ModuleItemKind_Function)
[+] 	if (!functionItem || functionItem->getItemKind() != jnc::ModuleItemKind_Function)
[-] 		err::setFormatStringError ("'%s' is not found or not a function\n", m_cmdLine->m_functionName.sz ());
[+] 		err::setFormatStringError("'%s' is not found or not a function\n", m_cmdLine->m_functionName.sz ());
[-] 	jnc::Function* function = (jnc::Function*) functionItem;
[+] 	jnc::Function* function = (jnc::Function*)functionItem;
[-] 	jnc::FunctionType* functionType = function->getType ();
[+] 	jnc::FunctionType* functionType = function->getType();
[-] 	jnc::TypeKind returnTypeKind = functionType->getReturnType ()->getTypeKind ();
[+] 	jnc::TypeKind returnTypeKind = functionType->getReturnType()->getTypeKind();
[-] 	size_t argCount = functionType->getArgCount ();
[+] 	size_t argCount = functionType->getArgCount();
[-] 		err::setFormatStringError ("'%s' has invalid signature: %s\n", m_cmdLine->m_functionName.sz (), functionType->getTypeString ());
[+] 		err::setFormatStringError("'%s' has invalid signature: %s\n", m_cmdLine->m_functionName.sz (), functionType->getTypeString ());
[-] 	m_runtime->setStackSizeLimit (m_cmdLine->m_stackSizeLimit);
[+] 	m_runtime->setStackSizeLimit(m_cmdLine->m_stackSizeLimit);
[-] 	m_runtime->getGcHeap ()->setSizeTriggers (&m_cmdLine->m_gcSizeTriggers);
[+] 	m_runtime->getGcHeap()->setSizeTriggers(&m_cmdLine->m_gcSizeTriggers);
[-] 	result = m_runtime->startup (m_module);
[+] 	result = m_runtime->startup(m_module);
[-] 		result = jnc::callFunction (m_runtime, function, returnValue);
[+] 		result = jnc::callFunction(m_runtime, function, returnValue);
[-] 		result = jnc::callVoidFunction (m_runtime, function);
[+] 		result = jnc::callVoidFunction(m_runtime, function);
[-] 	m_runtime->shutdown ();
[+] 	m_runtime->shutdown();
[-] JncApp::generateDocumentation ()
[+] JncApp::generateDocumentation()
[-] 	return m_module->generateDocumentation (m_cmdLine->m_outputDir);
[+] 	return m_module->generateDocumentation(m_cmdLine->m_outputDir);
----------------------
27/02/2019 18:02:05 - C:\Projects\repos\ioninja\jancy\src\jnc_app\main.cpp
----------------------
[-] printVersion ()
[+] printVersion()
[-] 	printf (
[+] 	printf(
[-] printUsage ()
[+] printUsage()
[-] 	printVersion ();
[+] 	printVersion();
[-] 	sl::String helpString = CmdLineSwitchTable::getHelpString ();
[+] 	sl::String helpString = CmdLineSwitchTable::getHelpString();
[-] 	printf ("Usage: jancy [<options>...] <source_file>\n%s", helpString.sz ());
[+] 	printf("Usage: jancy [<options>...] <source_file>\n%s", helpString.sz ());
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	g::getModule ()->setTag ("jnc_app");
[+] 	g::getModule()->setTag("jnc_app");
[-] 	jnc::initialize ("jnc_dll:jnc_app");
[+] 	jnc::initialize("jnc_dll:jnc_app");
[-] 	jnc::setErrorRouter (err::getErrorMgr ());
[+] 	jnc::setErrorRouter(err::getErrorMgr());
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	srand ((int) sys::getTimestamp ());
[+] 	srand((int)sys::getTimestamp());
[-] 	CmdLineParser parser (&cmdLine);
[+] 	CmdLineParser parser(&cmdLine);
[-] 		printUsage ();
[+] 		printUsage();
[-] 	result = parser.parse (argc, argv);
[+] 	result = parser.parse(argc, argv);
[-] 		printf ("error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printUsage ();
[+] 		printUsage();
[-] 		printVersion ();
[+] 		printVersion();
[-] 		JncApp app (&cmdLine);
[+] 		JncApp app(&cmdLine);
[-] 		result = app.parse ();
[+] 		result = app.parse();
[-] 			printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			result = app.generateDocumentation ();
[+] 			result = app.generateDocumentation();
[-] 				printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			result = app.compile ();
[+] 			result = app.compile();
[-] 				printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			app.printLlvmIr ();
[+] 			app.printLlvmIr();
[-] 			result = app.jit ();
[+] 			result = app.jit();
[-] 				printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			result = app.runFunction (&returnValue);
[+] 			result = app.runFunction(&returnValue);
[-] 				printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			printf ("'%s' returned: %d\n", cmdLine.m_functionName.sz (), returnValue);
[+] 			printf("'%s' returned: %d\n", cmdLine.m_functionName.sz (), returnValue);
----------------------
27/02/2019 18:02:05 - C:\Projects\repos\ioninja\jancy\src\jnc_app\CmdLine.h
----------------------
[-] 	sl::BoxList <sl::String> m_fileNameList;
[+] 	sl::BoxList<sl::String> m_fileNameList;
[-] 	sl::BoxList <sl::String> m_importDirList;
[+] 	sl::BoxList<sl::String> m_importDirList;
[-] 	sl::BoxList <sl::String> m_sourceDirList;
[+] 	sl::BoxList<sl::String> m_sourceDirList;
[-] 	sl::BoxList <sl::String> m_ignoredImportList;
[+] 	sl::BoxList<sl::String> m_ignoredImportList;
[-] 	CmdLine ();
[+] 	CmdLine();
[-] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE (CmdLineSwitchTable, CmdLineSwitch)
[+] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE(CmdLineSwitchTable, CmdLineSwitch)
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("General options")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("General options")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("Compilation options")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("Compilation options")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_3 (
[+] 	AXL_SL_CMD_LINE_SWITCH_3(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_3 (
[+] 	AXL_SL_CMD_LINE_SWITCH_3(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("Runtime options")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("Runtime options")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_3 (
[+] 	AXL_SL_CMD_LINE_SWITCH_3(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] AXL_SL_END_CMD_LINE_SWITCH_TABLE ()
[+] AXL_SL_END_CMD_LINE_SWITCH_TABLE()
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (DoxyCommentMap, uint_t)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(DoxyCommentMap, uint_t)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("///", jnc::ModuleCompileFlag_DisableDoxyComment1)
[+] 	AXL_SL_HASH_TABLE_ENTRY("///", jnc::ModuleCompileFlag_DisableDoxyComment1)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("//!", jnc::ModuleCompileFlag_DisableDoxyComment2)
[+] 	AXL_SL_HASH_TABLE_ENTRY("//!", jnc::ModuleCompileFlag_DisableDoxyComment2)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("/**", jnc::ModuleCompileFlag_DisableDoxyComment3)
[+] 	AXL_SL_HASH_TABLE_ENTRY("/**", jnc::ModuleCompileFlag_DisableDoxyComment3)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("/*!", jnc::ModuleCompileFlag_DisableDoxyComment4)
[+] 	AXL_SL_HASH_TABLE_ENTRY("/*!", jnc::ModuleCompileFlag_DisableDoxyComment4)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("1",   jnc::ModuleCompileFlag_DisableDoxyComment1)
[+] 	AXL_SL_HASH_TABLE_ENTRY("1",   jnc::ModuleCompileFlag_DisableDoxyComment1)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("2",   jnc::ModuleCompileFlag_DisableDoxyComment2)
[+] 	AXL_SL_HASH_TABLE_ENTRY("2",   jnc::ModuleCompileFlag_DisableDoxyComment2)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("3",   jnc::ModuleCompileFlag_DisableDoxyComment3)
[+] 	AXL_SL_HASH_TABLE_ENTRY("3",   jnc::ModuleCompileFlag_DisableDoxyComment3)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("4",   jnc::ModuleCompileFlag_DisableDoxyComment4)
[+] 	AXL_SL_HASH_TABLE_ENTRY("4",   jnc::ModuleCompileFlag_DisableDoxyComment4)
[-] AXL_SL_END_STRING_HASH_TABLE ()
[+] AXL_SL_END_STRING_HASH_TABLE()
[-] class CmdLineParser: public sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>
[+] class CmdLineParser: public sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>
[-] 	friend class sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>;
[+] 	friend class sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>;
[-] 	CmdLineParser (CmdLine* cmdLine)
[+] 	CmdLineParser(CmdLine* cmdLine)
[-] 	onValue (const sl::StringRef& value);
[+] 	onValue(const sl::StringRef& value);
[-] 	onSwitch (
[+] 	onSwitch(
[-] 	finalize ();
[+] 	finalize();
----------------------
27/02/2019 18:02:05 - C:\Projects\repos\ioninja\jancy\src\jnc_app\JncApp.h
----------------------
[-] 	sl::Array <char> m_stdInBuffer;
[+] 	sl::Array<char> m_stdInBuffer;
[-] 	JncApp (CmdLine* cmdLine);
[+] 	JncApp(CmdLine* cmdLine);
[-] 	parse ();
[+] 	parse();
[-] 	compile ()
[+] 	compile()
[-] 		return m_module->compile ();
[+] 		return m_module->compile();
[-] 	jit ()
[+] 	jit()
[-] 		return m_module->jit ();
[+] 		return m_module->jit();
[-] 	printLlvmIr ()
[+] 	printLlvmIr()
[-] 		printf ("%s", m_module->getLlvmIrString_v ());
[+] 		printf("%s", m_module->getLlvmIrString_v ());
[-] 	generateDocumentation ();
[+] 	generateDocumentation();
[-] 	runFunction (int* returnValue = NULL);
[+] 	runFunction(int* returnValue = NULL);
----------------------
27/02/2019 18:02:07 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\include\jnc_ct_Pch.h
----------------------
[-] #pragma warning (disable: 4141) // warning C4141: 'inline' : used more than once
[+] #pragma warning(disable: 4141) // warning C4141: 'inline' : used more than once
[-] #pragma warning (disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[+] #pragma warning(disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[-] #pragma warning (disable: 4291) // warning C4291: no matching operator delete found; memory will not be freed if initialization throws an exception
[+] #pragma warning(disable: 4291) // warning C4291: no matching operator delete found; memory will not be freed if initialization throws an exception
[-] #pragma warning (disable: 4244) // warning C4244: 'return' : conversion from 'uint64_t' to 'unsigned int', possible loss of data
[+] #pragma warning(disable: 4244) // warning C4244: 'return' : conversion from 'uint64_t' to 'unsigned int', possible loss of data
[-] #pragma warning (disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[+] #pragma warning(disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[-] #pragma warning (disable: 4355) // warning C4355: 'this' : used in base member initializer list
[+] #pragma warning(disable: 4355) // warning C4355: 'this' : used in base member initializer list
[-] #pragma warning (disable: 4624) // warning C4624: destructor could not be generated because a base class destructor is inaccessible
[+] #pragma warning(disable: 4624) // warning C4624: destructor could not be generated because a base class destructor is inaccessible
[-] #pragma warning (disable: 4800) // warning C4800: 'unsigned int' : forcing value to bool 'true' or 'false' (performance warning)
[+] #pragma warning(disable: 4800) // warning C4800: 'unsigned int' : forcing value to bool 'true' or 'false' (performance warning)
[-] #pragma warning (default: 4141)
[+] #pragma warning(default: 4141)
[-] #pragma warning (default: 4146)
[+] #pragma warning(default: 4146)
[-] #pragma warning (default: 4291)
[+] #pragma warning(default: 4291)
[-] #pragma warning (default: 4244)
[+] #pragma warning(default: 4244)
[-] #pragma warning (default: 4267)
[+] #pragma warning(default: 4267)
[-] #pragma warning (default: 4355)
[+] #pragma warning(default: 4355)
[-] #pragma warning (default: 4624)
[+] #pragma warning(default: 4624)
[-] #pragma warning (default: 4800)
[+] #pragma warning(default: 4800)
[-] 	InitializedPtr ()
[+] 	InitializedPtr()
[-] 	InitializedPtr (T* p)
[+] 	InitializedPtr(T* p)
[-] 	operator bool () const
[+] 	operator bool() const
[-] 		return (T2*) m_p;
[+] 		return (T2*)m_p;
[-] typedef InitializedPtr <DIType> DIType_vn;
[+] typedef InitializedPtr<DIType> DIType_vn;
[-] typedef InitializedPtr <DICompositeType> DICompositeType_vn;
[+] typedef InitializedPtr<DICompositeType> DICompositeType_vn;
[-] typedef InitializedPtr <DISubroutineType> DISubroutineType_vn;
[+] typedef InitializedPtr<DISubroutineType> DISubroutineType_vn;
[-] typedef InitializedPtr <DIGlobalVariable> DIGlobalVariable_vn;
[+] typedef InitializedPtr<DIGlobalVariable> DIGlobalVariable_vn;
[-] typedef InitializedPtr <DILocalVariable> DILocalVariable_vn;
[+] typedef InitializedPtr<DILocalVariable> DILocalVariable_vn;
[-] typedef InitializedPtr <DIVariable> DIVariable_vn;
[+] typedef InitializedPtr<DIVariable> DIVariable_vn;
[-] typedef InitializedPtr <DISubprogram> DISubprogram_vn;
[+] typedef InitializedPtr<DISubprogram> DISubprogram_vn;
[-] typedef InitializedPtr <DILexicalBlock> DILexicalBlock_vn;
[+] typedef InitializedPtr<DILexicalBlock> DILexicalBlock_vn;
[-] typedef InitializedPtr <DIScope> DIScope_vn;
[+] typedef InitializedPtr<DIScope> DIScope_vn;
[-] typedef InitializedPtr <DIFile> DIFile_vn;
[+] typedef InitializedPtr<DIFile> DIFile_vn;
[-] 	return std::string (string.cp (), string.getLength ());
[+] 	return std::string(string.cp(), string.getLength());
[-] 	return llvm::StringRef (string.cp (), string.getLength ());
[+] 	return llvm::StringRef(string.cp(), string.getLength());
----------------------
27/02/2019 18:02:07 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv.cpp
----------------------
[-] getLlvmCallConv (CallConvKind callConvKind)
[+] getLlvmCallConv(CallConvKind callConvKind)
[-] 	llvm::CallingConv::ID llvmCallConvTable [CallConvKind__Count] =
[+] 	llvm::CallingConv::ID llvmCallConvTable[CallConvKind__Count] =
[-] 	return (size_t) callConvKind < countof (llvmCallConvTable) ?
[+] 	return (size_t)callConvKind < countof(llvmCallConvTable) ?
[-] 		llvmCallConvTable [callConvKind] :
[+] 		llvmCallConvTable[callConvKind] :
[-] 		llvmCallConvTable [CallConvKind_Undefined];
[+] 		llvmCallConvTable[CallConvKind_Undefined];
[-] getCallConvFlags (CallConvKind callConvKind)
[+] getCallConvFlags(CallConvKind callConvKind)
[-] 	uint_t flagTable [CallConvKind__Count] =
[+] 	uint_t flagTable[CallConvKind__Count] =
[-] 	return (size_t) callConvKind < countof (flagTable) ?
[+] 	return (size_t)callConvKind < countof(flagTable) ?
[-] 		flagTable [callConvKind] :
[+] 		flagTable[callConvKind] :
[-] 		flagTable [CallConvKind_Undefined];
[+] 		flagTable[CallConvKind_Undefined];
[-] getCallConvString (CallConvKind callConvKind)
[+] getCallConvString(CallConvKind callConvKind)
[-] 	static const char* stringTable [CallConvKind__Count] =
[+] 	static const char* stringTable[CallConvKind__Count] =
[-] 	return (size_t) callConvKind < countof (stringTable) ?
[+] 	return (size_t)callConvKind < countof(stringTable) ?
[-] 		stringTable [callConvKind] :
[+] 		stringTable[callConvKind] :
[-] 		stringTable [CallConvKind_Undefined];
[+] 		stringTable[CallConvKind_Undefined];
[-] getCallConvDisplayString (CallConvKind callConvKind)
[+] getCallConvDisplayString(CallConvKind callConvKind)
[-] 	static const char* stringTable [CallConvKind__Count] =
[+] 	static const char* stringTable[CallConvKind__Count] =
[-] 	return (size_t) callConvKind < countof (stringTable) ?
[+] 	return (size_t)callConvKind < countof(stringTable) ?
[-] 		stringTable [callConvKind] :
[+] 		stringTable[callConvKind] :
[-] 		stringTable [CallConvKind_Undefined];
[+] 		stringTable[CallConvKind_Undefined];
[-] getCallConvSignature (CallConvKind callConvKind)
[+] getCallConvSignature(CallConvKind callConvKind)
[-] 	static const char* stringTable [CallConvKind__Count] =
[+] 	static const char* stringTable[CallConvKind__Count] =
[-] 	return (size_t) callConvKind < countof (stringTable) ?
[+] 	return (size_t)callConvKind < countof(stringTable) ?
[-] 		stringTable [callConvKind] :
[+] 		stringTable[callConvKind] :
[-] 		stringTable [CallConvKind_Undefined];
[+] 		stringTable[CallConvKind_Undefined];
[-] getCallConvKindFromModifiers (uint_t modifiers)
[+] getCallConvKindFromModifiers(uint_t modifiers)
[-] CallConv::CallConv ()
[+] CallConv::CallConv()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] CallConv::prepareFunctionType (FunctionType* functionType)
[+] CallConv::prepareFunctionType(FunctionType* functionType)
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 		llvmArgTypeArray [i] = argArray [i]->getType ()->getLlvmType ();
[+] 		llvmArgTypeArray[i] = argArray[i]->getType()->getLlvmType();
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		functionType->getReturnType ()->getLlvmType (),
[+] 		functionType->getReturnType()->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CallConv::createLlvmFunction (
[+] CallConv::createLlvmFunction(
[-] 	llvm::FunctionType* llvmType = (llvm::FunctionType*) functionType->getLlvmType ();
[+] 	llvm::FunctionType* llvmType = (llvm::FunctionType*)functionType->getLlvmType();
[-] 	llvm::Function* llvmFunction = llvm::Function::Create (
[+] 	llvm::Function* llvmFunction = llvm::Function::Create(
[-] 		m_module->getLlvmModule ()
[+] 		m_module->getLlvmModule()
[-] 	llvm::CallingConv::ID llvmCallConv = getLlvmCallConv ();
[+] 	llvm::CallingConv::ID llvmCallConv = getLlvmCallConv();
[-] 		llvmFunction->setCallingConv (llvmCallConv);
[+] 		llvmFunction->setCallingConv(llvmCallConv);
[-] CallConv::call (
[+] CallConv::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] CallConv::ret (
[+] CallConv::ret(
[-] 	m_module->m_llvmIrBuilder.createRet (value);
[+] 	m_module->m_llvmIrBuilder.createRet(value);
[-] CallConv::getThisArgValue (Function* function)
[+] CallConv::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	return Value (&*llvmArg, function->getThisArgType ());
[+] 	return Value(&*llvmArg, function->getThisArgType());
[-] CallConv::getArgValue (
[+] CallConv::getArgValue(
[-] 	FunctionArg* arg = functionType->m_argArray [argIdx];
[+] 	FunctionArg* arg = functionType->m_argArray[argIdx];
[-] 	return Value (llvmValue, arg->getType ());
[+] 	return Value(llvmValue, arg->getType());
[-] CallConv::createArgVariablesImpl (
[+] CallConv::createArgVariablesImpl(
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if (function->isMember ()) // skip this
[+] 	if (function->isMember()) // skip this
[-] 	sl::Array <FunctionArg*> argArray = function->getType ()->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = function->getType()->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		if (!arg->isNamed ())
[+] 		if (!arg->isNamed())
[-] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable (arg, i);
[+] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable(arg, i);
[-] 		function->getScope ()->addItem (argVariable);
[+] 		function->getScope()->addItem(argVariable);
[-] 		Value argValue (llvmArgValue, arg->getType ());
[+] 		Value argValue(llvmArgValue, arg->getType());
[-] 		m_module->m_llvmIrBuilder.createStore (argValue, argVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(argValue, argVariable);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv_gcc32.cpp
----------------------
[-] CallConv_gcc32::prepareFunctionType (FunctionType* functionType)
[+] CallConv_gcc32::prepareFunctionType(FunctionType* functionType)
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::prepareFunctionType (functionType);
[+] 		CallConv::prepareFunctionType(functionType);
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount () + 1;
[+] 	size_t argCount = argArray.getCount() + 1;
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 	llvmArgTypeArray [0] = returnType->getDataPtrType_c ()->getLlvmType ();
[+] 	llvmArgTypeArray[0] = returnType->getDataPtrType_c()->getLlvmType();
[-] 		llvmArgTypeArray [j] = argArray [i]->getType ()->getLlvmType ();
[+] 		llvmArgTypeArray[j] = argArray[i]->getType()->getLlvmType();
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Void)->getLlvmType (),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Void)->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CallConv_gcc32::createLlvmFunction (
[+] CallConv_gcc32::createLlvmFunction(
[-] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction (functionType, tag);
[+] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction(functionType, tag);
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		llvmFunction->addAttribute (1, llvm::Attribute::StructRet);
[+] 		llvmFunction->addAttribute(1, llvm::Attribute::StructRet);
[-] CallConv_gcc32::call (
[+] CallConv_gcc32::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::call (calleeValue, functionType, argValueList, resultValue);
[+] 		CallConv::call(calleeValue, functionType, argValueList, resultValue);
[-] 	m_module->m_llvmIrBuilder.createAlloca (
[+] 	m_module->m_llvmIrBuilder.createAlloca(
[-] 		returnType->getDataPtrType_c (),
[+] 		returnType->getDataPtrType_c(),
[-] 	argValueList->insertHead (tmpReturnValue);
[+] 	argValueList->insertHead(tmpReturnValue);
[-] 	llvm::CallInst* inst = m_module->m_llvmIrBuilder.createCall (
[+] 	llvm::CallInst* inst = m_module->m_llvmIrBuilder.createCall(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Void),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Void),
[-] 	inst->addAttribute (1, llvm::Attribute::StructRet);
[+] 	inst->addAttribute(1, llvm::Attribute::StructRet);
[-] 	m_module->m_llvmIrBuilder.createLoad (tmpReturnValue, returnType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(tmpReturnValue, returnType, resultValue);
[-] CallConv_gcc32::ret (
[+] CallConv_gcc32::ret(
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::ret (function, value);
[+] 		CallConv::ret(function, value);
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	returnPtrValue.setLlvmValue (&*llvmArg, returnType->getDataPtrType_c ());
[+] 	returnPtrValue.setLlvmValue(&*llvmArg, returnType->getDataPtrType_c());
[-] 	m_module->m_llvmIrBuilder.createStore (value, returnPtrValue);
[+] 	m_module->m_llvmIrBuilder.createStore(value, returnPtrValue);
[-] 	m_module->m_llvmIrBuilder.createRet ();
[+] 	m_module->m_llvmIrBuilder.createRet();
[-] CallConv_gcc32::getThisArgValue (Function* function)
[+] CallConv_gcc32::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		return CallConv::getThisArgValue (function);
[+] 		return CallConv::getThisArgValue(function);
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	return Value (&*llvmArg, function->getThisArgType ());
[+] 	return Value(&*llvmArg, function->getThisArgType());
[-] CallConv_gcc32::createArgVariables (Function* function)
[+] CallConv_gcc32::createArgVariables(Function* function)
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	CallConv::createArgVariablesImpl (
[+] 	CallConv::createArgVariablesImpl(
[-] 		(returnType->getFlags () & TypeFlag_StructRet) ? 1 : 0
[+] 		(returnType->getFlags() & TypeFlag_StructRet) ? 1 : 0
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv_msc32.cpp
----------------------
[-] AXL_TODO ("beware: structs with sizes between 16 and 24 are returned incorrectly (coercion must be implemented in XxxCallConv_msc32)")
[+] AXL_TODO("beware: structs with sizes between 16 and 24 are returned incorrectly (coercion must be implemented in XxxCallConv_msc32)")
[-] CallConv_msc32::prepareFunctionType (FunctionType* functionType)
[+] CallConv_msc32::prepareFunctionType(FunctionType* functionType)
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!isStructRet (returnType))
[+] 	if (!isStructRet(returnType))
[-] 		CallConv::prepareFunctionType (functionType);
[+] 		CallConv::prepareFunctionType(functionType);
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount () + 1;
[+] 	size_t argCount = argArray.getCount() + 1;
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 	llvmArgTypeArray [0] = returnType->getDataPtrType_c ()->getLlvmType ();
[+] 	llvmArgTypeArray[0] = returnType->getDataPtrType_c()->getLlvmType();
[-] 		llvmArgTypeArray [j] = argArray [i]->getType ()->getLlvmType ();
[+] 		llvmArgTypeArray[j] = argArray[i]->getType()->getLlvmType();
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Void)->getLlvmType (),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Void)->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CallConv_msc32::createLlvmFunction (
[+] CallConv_msc32::createLlvmFunction(
[-] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction (functionType, tag);
[+] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction(functionType, tag);
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (isStructRet (returnType))
[+] 	if (isStructRet(returnType))
[-] 		llvmFunction->addAttribute (1, llvm::Attribute::StructRet);
[+] 		llvmFunction->addAttribute(1, llvm::Attribute::StructRet);
[-] CallConv_msc32::call (
[+] CallConv_msc32::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!isStructRet (returnType))
[+] 	if (!isStructRet(returnType))
[-] 		CallConv::call (calleeValue, functionType, argValueList, resultValue);
[+] 		CallConv::call(calleeValue, functionType, argValueList, resultValue);
[-] 	m_module->m_llvmIrBuilder.createAlloca (
[+] 	m_module->m_llvmIrBuilder.createAlloca(
[-] 		returnType->getDataPtrType_c (),
[+] 		returnType->getDataPtrType_c(),
[-] 	argValueList->insertHead (tmpReturnValue);
[+] 	argValueList->insertHead(tmpReturnValue);
[-] 	llvm::CallInst* inst = m_module->m_llvmIrBuilder.createCall (
[+] 	llvm::CallInst* inst = m_module->m_llvmIrBuilder.createCall(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Void),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Void),
[-] 	inst->addAttribute (1, llvm::Attribute::StructRet);
[+] 	inst->addAttribute(1, llvm::Attribute::StructRet);
[-] 	m_module->m_llvmIrBuilder.createLoad (tmpReturnValue, returnType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(tmpReturnValue, returnType, resultValue);
[-] CallConv_msc32::ret (
[+] CallConv_msc32::ret(
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!isStructRet (returnType))
[+] 	if (!isStructRet(returnType))
[-] 		CallConv::ret (function, value);
[+] 		CallConv::ret(function, value);
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	returnPtrValue.setLlvmValue (&*llvmArg, returnType->getDataPtrType_c ());
[+] 	returnPtrValue.setLlvmValue(&*llvmArg, returnType->getDataPtrType_c());
[-] 	m_module->m_llvmIrBuilder.createStore (value, returnPtrValue);
[+] 	m_module->m_llvmIrBuilder.createStore(value, returnPtrValue);
[-] 	m_module->m_llvmIrBuilder.createRet ();
[+] 	m_module->m_llvmIrBuilder.createRet();
[-] CallConv_msc32::getThisArgValue (Function* function)
[+] CallConv_msc32::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!isStructRet (returnType))
[+] 	if (!isStructRet(returnType))
[-] 		return CallConv::getThisArgValue (function);
[+] 		return CallConv::getThisArgValue(function);
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	return Value (&*llvmArg, function->getThisArgType ());
[+] 	return Value(&*llvmArg, function->getThisArgType());
[-] CallConv_msc32::createArgVariables (Function* function)
[+] CallConv_msc32::createArgVariables(Function* function)
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	CallConv::createArgVariablesImpl (
[+] 	CallConv::createArgVariablesImpl(
[-] 		isStructRet (returnType) ? 1 : 0
[+] 		isStructRet(returnType) ? 1 : 0
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_arm.cpp
----------------------
[-] CdeclCallConv_arm::getArgCoerceType (Type* type)
[+] CdeclCallConv_arm::getArgCoerceType(Type* type)
[-] 	size_t size = type->getSize ();
[+] 	size_t size = type->getSize();
[-] 	size_t atomSize = m_regType->getSize ();
[+] 	size_t atomSize = m_regType->getSize();
[-] 	if (type->getAlignment () <= atomSize)
[+] 	if (type->getAlignment() <= atomSize)
[-] 		atomType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 		atomType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 		atomSize = sizeof (int64_t);
[+] 		atomSize = sizeof(int64_t);
[-] 	return atomType->getArrayType (atomCount);
[+] 	return atomType->getArrayType(atomCount);
[-] CdeclCallConv_arm::prepareFunctionType (FunctionType* functionType)
[+] CdeclCallConv_arm::prepareFunctionType(FunctionType* functionType)
[-] 	size_t regSize = m_regType->getSize ();
[+] 	size_t regSize = m_regType->getSize();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 	functionType->m_argFlagArray.setCountZeroConstruct (argCount);
[+] 	functionType->m_argFlagArray.setCountZeroConstruct(argCount);
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () > regSize) // return in memory
[+] 		if (returnType->getSize() > regSize) // return in memory
[-] 			llvmArgTypeArray.setCount (argCount);
[+] 			llvmArgTypeArray.setCount(argCount);
[-] 			llvmArgTypeArray [0] = returnType->getDataPtrType_c ()->getLlvmType ();
[+] 			llvmArgTypeArray[0] = returnType->getDataPtrType_c()->getLlvmType();
[-] 			returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 			returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 			returnType = getArgCoerceType (returnType);
[+] 			returnType = getArgCoerceType(returnType);
[-] 		Type* type = argArray [i]->getType ();
[+] 		Type* type = argArray[i]->getType();
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 			llvmType = type->getLlvmType ();
[+] 			llvmType = type->getLlvmType();
[-] 			llvmType = getArgCoerceType (type)->getLlvmType ();
[+] 			llvmType = getArgCoerceType(type)->getLlvmType();
[-] 			functionType->m_argFlagArray [i] = ArgFlag_Coerced;
[+] 			functionType->m_argFlagArray[i] = ArgFlag_Coerced;
[-] 		llvmArgTypeArray [j] = llvmType;
[+] 		llvmArgTypeArray[j] = llvmType;
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		returnType->getLlvmType (),
[+] 		returnType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CdeclCallConv_arm::createLlvmFunction (
[+] CdeclCallConv_arm::createLlvmFunction(
[-] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction (functionType, tag);
[+] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction(functionType, tag);
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > m_regType->getSize ()) // return in memory
[+] 		returnType->getSize() > m_regType->getSize()) // return in memory
[-] 		llvmFunction->addAttribute (1, llvm::Attribute::StructRet);
[+] 		llvmFunction->addAttribute(1, llvm::Attribute::StructRet);
[-] CdeclCallConv_arm::call (
[+] CdeclCallConv_arm::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	size_t regSize = m_regType->getSize ();
[+] 	size_t regSize = m_regType->getSize();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		!(functionType->getFlags () & (FunctionTypeFlag_CoercedArgs | FunctionTypeFlag_VarArg)))
[+] 		!(functionType->getFlags() & (FunctionTypeFlag_CoercedArgs | FunctionTypeFlag_VarArg)))
[-] 		CallConv::call (calleeValue, functionType, argValueList, resultValue);
[+] 		CallConv::call(calleeValue, functionType, argValueList, resultValue);
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > regSize) // return in memory
[+] 		returnType->getSize() > regSize) // return in memory
[-] 		m_module->m_llvmIrBuilder.createAlloca (
[+] 		m_module->m_llvmIrBuilder.createAlloca(
[-] 			returnType->getDataPtrType_c (),
[+] 			returnType->getDataPtrType_c(),
[-] 		argValueList->insertHead (tmpReturnValue);
[+] 		argValueList->insertHead(tmpReturnValue);
[-] 	sl::BoxIterator <Value> it = argValueList->getHead ();
[+] 	sl::BoxIterator<Value> it = argValueList->getHead();
[-] 		Type* type = it->getType ();
[+] 		Type* type = it->getType();
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 		Type* coerceType = getArgCoerceType (type);
[+] 		Type* coerceType = getArgCoerceType(type);
[-] 		m_module->m_operatorMgr.forceCast (it.p (), coerceType);
[+] 		m_module->m_operatorMgr.forceCast(it.p(), coerceType);
[-] 	llvm::CallInst* llvmInst = m_module->m_llvmIrBuilder.createCall (
[+] 	llvm::CallInst* llvmInst = m_module->m_llvmIrBuilder.createCall(
[-] 			m_module->m_typeMgr.getPrimitiveType (TypeKind_Void) :
[+] 			m_module->m_typeMgr.getPrimitiveType(TypeKind_Void) :
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () > regSize) // return in memory
[+] 		if (returnType->getSize() > regSize) // return in memory
[-] 			llvmInst->addAttribute (1, llvm::Attribute::StructRet);
[+] 			llvmInst->addAttribute(1, llvm::Attribute::StructRet);
[-] 			m_module->m_llvmIrBuilder.createLoad (tmpReturnValue, returnType, resultValue);
[+] 			m_module->m_llvmIrBuilder.createLoad(tmpReturnValue, returnType, resultValue);
[-] 			Type* coerceType = getArgCoerceType (returnType);
[+] 			Type* coerceType = getArgCoerceType(returnType);
[-] 			resultValue->overrideType (coerceType);
[+] 			resultValue->overrideType(coerceType);
[-] 			m_module->m_operatorMgr.forceCast (resultValue, returnType);
[+] 			m_module->m_operatorMgr.forceCast(resultValue, returnType);
[-] CdeclCallConv_arm::ret (
[+] CdeclCallConv_arm::ret(
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::ret (function, value);
[+] 		CallConv::ret(function, value);
[-] 	if (returnType->getSize () > m_regType->getSize ()) // return in memory
[+] 	if (returnType->getSize() > m_regType->getSize()) // return in memory
[-] 		Value returnPtrValue (&*function->getLlvmFunction ()->arg_begin());
[+] 		Value returnPtrValue(&*function->getLlvmFunction()->arg_begin());
[-] 		m_module->m_llvmIrBuilder.createStore (value, returnPtrValue);
[+] 		m_module->m_llvmIrBuilder.createStore(value, returnPtrValue);
[-] 		m_module->m_llvmIrBuilder.createRet ();
[+] 		m_module->m_llvmIrBuilder.createRet();
[-] 		Type* coerceType = getArgCoerceType (returnType);
[+] 		Type* coerceType = getArgCoerceType(returnType);
[-] 		m_module->m_operatorMgr.forceCast (value, coerceType, &tmpValue);
[+] 		m_module->m_operatorMgr.forceCast(value, coerceType, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createRet (tmpValue);
[+] 		m_module->m_llvmIrBuilder.createRet(tmpValue);
[-] CdeclCallConv_arm::getThisArgValue (Function* function)
[+] CdeclCallConv_arm::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > m_regType->getSize ())
[+] 		returnType->getSize() > m_regType->getSize())
[-] 	return getArgValue (&*llvmArg, functionType, 0);
[+] 	return getArgValue(&*llvmArg, functionType, 0);
[-] CdeclCallConv_arm::getArgValue (
[+] CdeclCallConv_arm::getArgValue(
[-] 	Type* type = functionType->m_argArray [argIdx]->getType ();
[+] 	Type* type = functionType->m_argArray[argIdx]->getType();
[-] 	uint_t flags = functionType->m_argFlagArray [argIdx];
[+] 	uint_t flags = functionType->m_argFlagArray[argIdx];
[-] 		Type* coerceType = getArgCoerceType (type);
[+] 		Type* coerceType = getArgCoerceType(type);
[-] 		m_module->m_operatorMgr.forceCast (Value (llvmValue, coerceType), type, &value);
[+] 		m_module->m_operatorMgr.forceCast(Value(llvmValue, coerceType), type, &value);
[-] 		value.setLlvmValue (llvmValue, type);
[+] 		value.setLlvmValue(llvmValue, type);
[-] CdeclCallConv_arm::createArgVariables (Function* function)
[+] CdeclCallConv_arm::createArgVariables(Function* function)
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > m_regType->getSize ())
[+] 		returnType->getSize() > m_regType->getSize())
[-] 	if (function->isMember ()) // skip this
[+] 	if (function->isMember()) // skip this
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		if (!arg->isNamed ())
[+] 		if (!arg->isNamed())
[-] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable (arg, i);
[+] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable(arg, i);
[-] 		function->getScope ()->addItem (argVariable);
[+] 		function->getScope()->addItem(argVariable);
[-] 		Value argValue = getArgValue (&*llvmArg, functionType, i);
[+] 		Value argValue = getArgValue(&*llvmArg, functionType, i);
[-] 		m_module->m_llvmIrBuilder.createStore (argValue, argVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(argValue, argVariable);
[-] CdeclCallConv_arm32::CdeclCallConv_arm32 ()
[+] CdeclCallConv_arm32::CdeclCallConv_arm32()
[-] 	m_regType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 	m_regType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] CdeclCallConv_arm64::CdeclCallConv_arm64 ()
[+] CdeclCallConv_arm64::CdeclCallConv_arm64()
[-] 	m_regType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 	m_regType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_gcc64.cpp
----------------------
[-] CdeclCallConv_gcc64::getArgCoerceType (Type* type)
[+] CdeclCallConv_gcc64::getArgCoerceType(Type* type)
[-] 	AXL_TODO ("implement proper coercion for structures with floating point fields")
[+] 	AXL_TODO("implement proper coercion for structures with floating point fields")
[-] 	return type->getSize () > sizeof (uint64_t) ?
[+] 	return type->getSize() > sizeof(uint64_t) ?
[-] 		m_module->m_typeMgr.getStdType (StdType_Int64Int64) :
[+] 		m_module->m_typeMgr.getStdType(StdType_Int64Int64) :
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] CdeclCallConv_gcc64::prepareFunctionType (FunctionType* functionType)
[+] CdeclCallConv_gcc64::prepareFunctionType(FunctionType* functionType)
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 	functionType->m_argFlagArray.setCountZeroConstruct (argCount);
[+] 	functionType->m_argFlagArray.setCountZeroConstruct(argCount);
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () > sizeof (uint64_t) * 2) // return in memory
[+] 		if (returnType->getSize() > sizeof(uint64_t)* 2) // return in memory
[-] 			llvmArgTypeArray.setCount (argCount);
[+] 			llvmArgTypeArray.setCount(argCount);
[-] 			llvmArgTypeArray [0] = returnType->getDataPtrType_c ()->getLlvmType ();
[+] 			llvmArgTypeArray[0] = returnType->getDataPtrType_c()->getLlvmType();
[-] 			returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 			returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 			returnType = getArgCoerceType (returnType);
[+] 			returnType = getArgCoerceType(returnType);
[-] 		Type* type = argArray [i]->getType ();
[+] 		Type* type = argArray[i]->getType();
[-] 		size_t size = type->getSize ();
[+] 		size_t size = type->getSize();
[-] 		size_t regCount = size > sizeof (uint64_t) ? 2 : 1;
[+] 		size_t regCount = size > sizeof(uint64_t) ? 2 : 1;
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 			llvmType = type->getLlvmType ();
[+] 			llvmType = type->getLlvmType();
[-] 		else if (size > sizeof (uint64_t) * 2 || argRegCount < regCount) // pass on stack
[+] 		else if (size > sizeof(uint64_t)* 2 || argRegCount < regCount) // pass on stack
[-] 			llvmType = type->getDataPtrType_c ()->getLlvmType ();
[+] 			llvmType = type->getDataPtrType_c()->getLlvmType();
[-] 			functionType->m_argFlagArray [i] = ArgFlag_ByVal;
[+] 			functionType->m_argFlagArray[i] = ArgFlag_ByVal;
[-] 			llvmType = getArgCoerceType (type)->getLlvmType ();
[+] 			llvmType = getArgCoerceType(type)->getLlvmType();
[-] 			functionType->m_argFlagArray [i] = ArgFlag_Coerced;
[+] 			functionType->m_argFlagArray[i] = ArgFlag_Coerced;
[-] 		llvmArgTypeArray [j] = llvmType;
[+] 		llvmArgTypeArray[j] = llvmType;
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		returnType->getLlvmType (),
[+] 		returnType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CdeclCallConv_gcc64::createLlvmFunction (
[+] CdeclCallConv_gcc64::createLlvmFunction(
[-] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction (functionType, tag);
[+] 	llvm::Function* llvmFunction = CallConv::createLlvmFunction(functionType, tag);
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t) * 2) // return in memory
[+] 		returnType->getSize() > sizeof(uint64_t)* 2) // return in memory
[-] 		llvmFunction->addAttribute (1, llvm::Attribute::StructRet);
[+] 		llvmFunction->addAttribute(1, llvm::Attribute::StructRet);
[-] 	if (functionType->getFlags () & FunctionTypeFlag_ByValArgs)
[+] 	if (functionType->getFlags() & FunctionTypeFlag_ByValArgs)
[-] 		sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 		sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 		size_t argCount = argArray.getCount ();
[+] 		size_t argCount = argArray.getCount();
[-] 			if (functionType->m_argFlagArray [i] & ArgFlag_ByVal)
[+] 			if (functionType->m_argFlagArray[i] & ArgFlag_ByVal)
[-] 				llvmFunction->addAttribute (j, llvm::Attribute::ByVal);
[+] 				llvmFunction->addAttribute(j, llvm::Attribute::ByVal);
[-] CdeclCallConv_gcc64::call (
[+] CdeclCallConv_gcc64::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		!(functionType->getFlags () & (FunctionTypeFlag_ByValArgs | FunctionTypeFlag_CoercedArgs | FunctionTypeFlag_VarArg)))
[+] 		!(functionType->getFlags() & (FunctionTypeFlag_ByValArgs | FunctionTypeFlag_CoercedArgs | FunctionTypeFlag_VarArg)))
[-] 		CallConv::call (calleeValue, functionType, argValueList, resultValue);
[+] 		CallConv::call(calleeValue, functionType, argValueList, resultValue);
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t) * 2) // return in memory
[+] 		returnType->getSize() > sizeof(uint64_t)* 2) // return in memory
[-] 		m_module->m_llvmIrBuilder.createAlloca (
[+] 		m_module->m_llvmIrBuilder.createAlloca(
[-] 			returnType->getDataPtrType_c (),
[+] 			returnType->getDataPtrType_c(),
[-] 		argValueList->insertHead (tmpReturnValue);
[+] 		argValueList->insertHead(tmpReturnValue);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <unsigned> byValArgIdxArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<unsigned> byValArgIdxArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	sl::BoxIterator <Value> it = argValueList->getHead ();
[+] 	sl::BoxIterator<Value> it = argValueList->getHead();
[-] 		Type* type = it->getType ();
[+] 		Type* type = it->getType();
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 		size_t size = type->getSize ();
[+] 		size_t size = type->getSize();
[-] 		size_t regCount = size > sizeof (uint64_t) ? 2 : 1;
[+] 		size_t regCount = size > sizeof(uint64_t) ? 2 : 1;
[-] 		if (size > sizeof (uint64_t) * 2 || argRegCount < regCount) // pass on stack
[+] 		if (size > sizeof(uint64_t)* 2 || argRegCount < regCount) // pass on stack
[-] 			m_module->m_llvmIrBuilder.createAlloca (type, "tmpArg", NULL, &tmpValue);
[+] 			m_module->m_llvmIrBuilder.createAlloca(type, "tmpArg", NULL, &tmpValue);
[-] 			m_module->m_llvmIrBuilder.createStore (*it, tmpValue);
[+] 			m_module->m_llvmIrBuilder.createStore(*it, tmpValue);
[-] 			byValArgIdxArray.append (j);
[+] 			byValArgIdxArray.append(j);
[-] 			Type* coerceType = getArgCoerceType (type);
[+] 			Type* coerceType = getArgCoerceType(type);
[-] 			m_module->m_operatorMgr.forceCast (it.p (), coerceType);
[+] 			m_module->m_operatorMgr.forceCast(it.p(), coerceType);
[-] 	llvm::CallInst* llvmInst = m_module->m_llvmIrBuilder.createCall (
[+] 	llvm::CallInst* llvmInst = m_module->m_llvmIrBuilder.createCall(
[-] 			m_module->m_typeMgr.getPrimitiveType (TypeKind_Void) :
[+] 			m_module->m_typeMgr.getPrimitiveType(TypeKind_Void) :
[-] 	size_t byValArgCount = byValArgIdxArray.getCount ();
[+] 	size_t byValArgCount = byValArgIdxArray.getCount();
[-] 		llvmInst->addAttribute (byValArgIdxArray [i], llvm::Attribute::ByVal);
[+] 		llvmInst->addAttribute(byValArgIdxArray[i], llvm::Attribute::ByVal);
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () > sizeof (uint64_t) * 2) // return in memory
[+] 		if (returnType->getSize() > sizeof(uint64_t)* 2) // return in memory
[-] 			llvmInst->addAttribute (1, llvm::Attribute::StructRet);
[+] 			llvmInst->addAttribute(1, llvm::Attribute::StructRet);
[-] 			m_module->m_llvmIrBuilder.createLoad (tmpReturnValue, returnType, resultValue);
[+] 			m_module->m_llvmIrBuilder.createLoad(tmpReturnValue, returnType, resultValue);
[-] 			Type* coerceType = getArgCoerceType (returnType);
[+] 			Type* coerceType = getArgCoerceType(returnType);
[-] 			resultValue->overrideType (coerceType);
[+] 			resultValue->overrideType(coerceType);
[-] 			m_module->m_operatorMgr.forceCast (resultValue, returnType);
[+] 			m_module->m_operatorMgr.forceCast(resultValue, returnType);
[-] CdeclCallConv_gcc64::ret (
[+] CdeclCallConv_gcc64::ret(
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::ret (function, value);
[+] 		CallConv::ret(function, value);
[-] 	if (returnType->getSize () > sizeof (uint64_t) * 2) // return in memory
[+] 	if (returnType->getSize() > sizeof(uint64_t)* 2) // return in memory
[-] 		Value returnPtrValue (&*function->getLlvmFunction ()->arg_begin());
[+] 		Value returnPtrValue(&*function->getLlvmFunction()->arg_begin());
[-] 		m_module->m_llvmIrBuilder.createStore (value, returnPtrValue);
[+] 		m_module->m_llvmIrBuilder.createStore(value, returnPtrValue);
[-] 		m_module->m_llvmIrBuilder.createRet ();
[+] 		m_module->m_llvmIrBuilder.createRet();
[-] 		Type* coerceType = getArgCoerceType (returnType);
[+] 		Type* coerceType = getArgCoerceType(returnType);
[-] 		m_module->m_operatorMgr.forceCast (value, coerceType, &tmpValue);
[+] 		m_module->m_operatorMgr.forceCast(value, coerceType, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createRet (tmpValue);
[+] 		m_module->m_llvmIrBuilder.createRet(tmpValue);
[-] CdeclCallConv_gcc64::getThisArgValue (Function* function)
[+] CdeclCallConv_gcc64::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t) * 2)
[+] 		returnType->getSize() > sizeof(uint64_t)* 2)
[-] 	return getArgValue (&*llvmArg, functionType, 0);
[+] 	return getArgValue(&*llvmArg, functionType, 0);
[-] CdeclCallConv_gcc64::getArgValue (
[+] CdeclCallConv_gcc64::getArgValue(
[-] 	Type* type = functionType->m_argArray [argIdx]->getType ();
[+] 	Type* type = functionType->m_argArray[argIdx]->getType();
[-] 	uint_t flags = functionType->m_argFlagArray [argIdx];
[+] 	uint_t flags = functionType->m_argFlagArray[argIdx];
[-] 		m_module->m_llvmIrBuilder.createLoad (llvmValue, type, &value);
[+] 		m_module->m_llvmIrBuilder.createLoad(llvmValue, type, &value);
[-] 		Type* coerceType = getArgCoerceType (type);
[+] 		Type* coerceType = getArgCoerceType(type);
[-] 		m_module->m_operatorMgr.forceCast (Value (llvmValue, coerceType), type, &value);
[+] 		m_module->m_operatorMgr.forceCast(Value(llvmValue, coerceType), type, &value);
[-] 		value.setLlvmValue (llvmValue, type);
[+] 		value.setLlvmValue(llvmValue, type);
[-] CdeclCallConv_gcc64::createArgVariables (Function* function)
[+] CdeclCallConv_gcc64::createArgVariables(Function* function)
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t) * 2)
[+] 		returnType->getSize() > sizeof(uint64_t)* 2)
[-] 	if (function->isMember ()) // skip this
[+] 	if (function->isMember()) // skip this
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		if (!arg->isNamed ())
[+] 		if (!arg->isNamed())
[-] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable (arg, i);
[+] 		Variable* argVariable = m_module->m_variableMgr.createArgVariable(arg, i);
[-] 		function->getScope ()->addItem (argVariable);
[+] 		function->getScope()->addItem(argVariable);
[-] 		Value argValue = getArgValue (&*llvmArg, functionType, i);
[+] 		Value argValue = getArgValue(&*llvmArg, functionType, i);
[-] 		m_module->m_llvmIrBuilder.createStore (argValue, argVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(argValue, argVariable);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_msc64.cpp
----------------------
[-] CdeclCallConv_msc64::prepareFunctionType (FunctionType* functionType)
[+] CdeclCallConv_msc64::prepareFunctionType(FunctionType* functionType)
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Type*> llvmArgTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Type*> llvmArgTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgTypeArray.setCount (argCount);
[+] 	llvmArgTypeArray.setCount(argCount);
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () <= sizeof (uint64_t))
[+] 		if (returnType->getSize() <= sizeof(uint64_t))
[-] 			returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 			returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 			returnType = returnType->getDataPtrType_c ();
[+] 			returnType = returnType->getDataPtrType_c();
[-] 			llvmArgTypeArray.setCount (argCount);
[+] 			llvmArgTypeArray.setCount(argCount);
[-] 			llvmArgTypeArray [0] = returnType->getLlvmType ();
[+] 			llvmArgTypeArray[0] = returnType->getLlvmType();
[-] 		Type* type = argArray [i]->getType ();
[+] 		Type* type = argArray[i]->getType();
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 			llvmArgTypeArray [j] = type->getLlvmType ();
[+] 			llvmArgTypeArray[j] = type->getLlvmType();
[-] 		else if (type->getSize () <= sizeof (uint64_t))
[+] 		else if (type->getSize() <= sizeof(uint64_t))
[-] 			llvmArgTypeArray [j] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64)->getLlvmType ();
[+] 			llvmArgTypeArray[j] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64)->getLlvmType();
[-] 			llvmArgTypeArray [j] = type->getDataPtrType_c ()->getLlvmType ();
[+] 			llvmArgTypeArray[j] = type->getDataPtrType_c()->getLlvmType();
[-] 	functionType->m_llvmType = llvm::FunctionType::get (
[+] 	functionType->m_llvmType = llvm::FunctionType::get(
[-] 		returnType->getLlvmType (),
[+] 		returnType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, argCount),
[+] 		llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, argCount),
[-] 		(functionType->getFlags () & FunctionTypeFlag_VarArg) != 0
[+] 		(functionType->getFlags() & FunctionTypeFlag_VarArg) != 0
[-] CdeclCallConv_msc64::call (
[+] CdeclCallConv_msc64::call(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	if (!(functionType->getFlags () & FunctionTypeFlag_CoercedArgs) &&
[+] 	if (!(functionType->getFlags() & FunctionTypeFlag_CoercedArgs) &&
[-] 		!(returnType->getFlags () & TypeFlag_StructRet))
[+] 		!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::call (calleeValue, functionType, argValueList, resultValue);
[+] 		CallConv::call(calleeValue, functionType, argValueList, resultValue);
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		m_module->m_llvmIrBuilder.createAlloca (
[+] 		m_module->m_llvmIrBuilder.createAlloca(
[-] 			returnType->getDataPtrType_c (),
[+] 			returnType->getDataPtrType_c(),
[-] 		if (returnType->getSize () > sizeof (uint64_t))
[+] 		if (returnType->getSize() > sizeof(uint64_t))
[-] 			argValueList->insertHead (tmpReturnValue);
[+] 			argValueList->insertHead(tmpReturnValue);
[-] 	if (functionType->getFlags () & FunctionTypeFlag_CoercedArgs)
[+] 	if (functionType->getFlags() & FunctionTypeFlag_CoercedArgs)
[-] 		sl::BoxIterator <Value> it = argValueList->getHead ();
[+] 		sl::BoxIterator<Value> it = argValueList->getHead();
[-] 			Type* type = it->getType ();
[+] 			Type* type = it->getType();
[-] 			if (!(type->getFlags () & TypeFlag_StructRet))
[+] 			if (!(type->getFlags() & TypeFlag_StructRet))
[-] 			if (type->getSize () > sizeof (uint64_t))
[+] 			if (type->getSize() > sizeof(uint64_t))
[-] 				m_module->m_llvmIrBuilder.createAlloca (type, "tmpArg", NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createAlloca(type, "tmpArg", NULL, &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createStore (*it, tmpValue);
[+] 				m_module->m_llvmIrBuilder.createStore(*it, tmpValue);
[-] 				Type* coerceType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 				Type* coerceType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 				m_module->m_llvmIrBuilder.createAlloca (coerceType, "tmpArg", NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createAlloca(coerceType, "tmpArg", NULL, &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createBitCast (tmpValue, type->getDataPtrType_c (), &tmpValue2);
[+] 				m_module->m_llvmIrBuilder.createBitCast(tmpValue, type->getDataPtrType_c(), &tmpValue2);
[-] 				m_module->m_llvmIrBuilder.createStore (*it, tmpValue2);
[+] 				m_module->m_llvmIrBuilder.createStore(*it, tmpValue2);
[-] 				m_module->m_llvmIrBuilder.createLoad (tmpValue, NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createLoad(tmpValue, NULL, &tmpValue);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 	if (returnType->getFlags () & TypeFlag_StructRet)
[+] 	if (returnType->getFlags() & TypeFlag_StructRet)
[-] 		if (returnType->getSize () <= sizeof (uint64_t))
[+] 		if (returnType->getSize() <= sizeof(uint64_t))
[-] 			Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64)->getDataPtrType_c ();
[+] 			Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64)->getDataPtrType_c();
[-] 			m_module->m_llvmIrBuilder.createBitCast (tmpReturnValue, type, &tmpValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(tmpReturnValue, type, &tmpValue);
[-] 			m_module->m_llvmIrBuilder.createStore (*resultValue, tmpValue);
[+] 			m_module->m_llvmIrBuilder.createStore(*resultValue, tmpValue);
[-] 		m_module->m_llvmIrBuilder.createLoad (tmpReturnValue, returnType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(tmpReturnValue, returnType, resultValue);
[-] CdeclCallConv_msc64::ret (
[+] CdeclCallConv_msc64::ret(
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	if (!(returnType->getFlags () & TypeFlag_StructRet))
[+] 	if (!(returnType->getFlags() & TypeFlag_StructRet))
[-] 		CallConv::ret (function, value);
[+] 		CallConv::ret(function, value);
[-] 	if (returnType->getSize () > sizeof (uint64_t))
[+] 	if (returnType->getSize() > sizeof(uint64_t))
[-] 		Value returnPtrValue (&*function->getLlvmFunction ()->arg_begin());
[+] 		Value returnPtrValue(&*function->getLlvmFunction()->arg_begin());
[-] 		m_module->m_llvmIrBuilder.createStore (value, returnPtrValue);
[+] 		m_module->m_llvmIrBuilder.createStore(value, returnPtrValue);
[-] 		m_module->m_llvmIrBuilder.createRet (returnPtrValue);
[+] 		m_module->m_llvmIrBuilder.createRet(returnPtrValue);
[-] 		Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 		Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 		m_module->m_llvmIrBuilder.createAlloca (type, "tmpRetVal", NULL, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createAlloca(type, "tmpRetVal", NULL, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (tmpValue, returnType->getDataPtrType_c (), &tmpValue2);
[+] 		m_module->m_llvmIrBuilder.createBitCast(tmpValue, returnType->getDataPtrType_c(), &tmpValue2);
[-] 		m_module->m_llvmIrBuilder.createStore (value, tmpValue2);
[+] 		m_module->m_llvmIrBuilder.createStore(value, tmpValue2);
[-] 		m_module->m_llvmIrBuilder.createLoad (tmpValue, NULL, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(tmpValue, NULL, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createRet (tmpValue);
[+] 		m_module->m_llvmIrBuilder.createRet(tmpValue);
[-] CdeclCallConv_msc64::getThisArgValue (Function* function)
[+] CdeclCallConv_msc64::getThisArgValue(Function* function)
[-] 	ASSERT (function->isMember ());
[+] 	ASSERT(function->isMember());
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t))
[+] 		returnType->getSize() > sizeof(uint64_t))
[-] 	return getArgValue (&*llvmArg, functionType, 0);
[+] 	return getArgValue(&*llvmArg, functionType, 0);
[-] CdeclCallConv_msc64::getArgValue (
[+] CdeclCallConv_msc64::getArgValue(
[-] 	Type* type = functionType->m_argArray [argIdx]->getType ();
[+] 	Type* type = functionType->m_argArray[argIdx]->getType();
[-] 	if (!(type->getFlags () & TypeFlag_StructRet))
[+] 	if (!(type->getFlags() & TypeFlag_StructRet))
[-] 		return Value (llvmValue, type);
[+] 		return Value(llvmValue, type);
[-] 	if (type->getSize () > sizeof (uint64_t))
[+] 	if (type->getSize() > sizeof(uint64_t))
[-] 		m_module->m_llvmIrBuilder.createLoad (llvmValue, type, &value);
[+] 		m_module->m_llvmIrBuilder.createLoad(llvmValue, type, &value);
[-] 	Type* int64Type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 	Type* int64Type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 	m_module->m_llvmIrBuilder.createAlloca (int64Type, "tmpArg", NULL, &value);
[+] 	m_module->m_llvmIrBuilder.createAlloca(int64Type, "tmpArg", NULL, &value);
[-] 	m_module->m_llvmIrBuilder.createStore (llvmValue, value);
[+] 	m_module->m_llvmIrBuilder.createStore(llvmValue, value);
[-] 	m_module->m_llvmIrBuilder.createBitCast (value, type->getDataPtrType_c (), &value);
[+] 	m_module->m_llvmIrBuilder.createBitCast(value, type->getDataPtrType_c(), &value);
[-] 	m_module->m_llvmIrBuilder.createLoad (value, type, &value);
[+] 	m_module->m_llvmIrBuilder.createLoad(value, type, &value);
[-] CdeclCallConv_msc64::createArgVariables (Function* function)
[+] CdeclCallConv_msc64::createArgVariables(Function* function)
[-] 	Type* returnType = function->getType ()->getReturnType ();
[+] 	Type* returnType = function->getType()->getReturnType();
[-] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 	llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 	if ((returnType->getFlags () & TypeFlag_StructRet) &&
[+] 	if ((returnType->getFlags() & TypeFlag_StructRet) &&
[-] 		returnType->getSize () > sizeof (uint64_t))
[+] 		returnType->getSize() > sizeof(uint64_t))
[-] 	if (function->isMember ()) // skip this
[+] 	if (function->isMember()) // skip this
[-] 	sl::Array <FunctionArg*> argArray = function->getType ()->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = function->getType()->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		if (!arg->isNamed ())
[+] 		if (!arg->isNamed())
[-] 		Type* type = arg->getType ();
[+] 		Type* type = arg->getType();
[-] 		if (!(type->getFlags () & TypeFlag_StructRet))
[+] 		if (!(type->getFlags() & TypeFlag_StructRet))
[-] 			Variable* argVariable = m_module->m_variableMgr.createArgVariable (arg, i);
[+] 			Variable* argVariable = m_module->m_variableMgr.createArgVariable(arg, i);
[-] 			function->getScope ()->addItem (argVariable);
[+] 			function->getScope()->addItem(argVariable);
[-] 			m_module->m_llvmIrBuilder.createStore (llvmArgValue, argVariable);
[+] 			m_module->m_llvmIrBuilder.createStore(llvmArgValue, argVariable);
[-] 			Variable* argVariable = m_module->m_variableMgr.createArgVariable (arg, i);
[+] 			Variable* argVariable = m_module->m_variableMgr.createArgVariable(arg, i);
[-] 			function->getScope ()->addItem (argVariable);
[+] 			function->getScope()->addItem(argVariable);
[-] 			if (type->getSize () > sizeof (uint64_t))
[+] 			if (type->getSize() > sizeof(uint64_t))
[-] 				m_module->m_llvmIrBuilder.createLoad (llvmArgValue, NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createLoad(llvmArgValue, NULL, &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createStore (tmpValue, argVariable);
[+] 				m_module->m_llvmIrBuilder.createStore(tmpValue, argVariable);
[-] 				Type* int64Type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 				Type* int64Type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 				m_module->m_llvmIrBuilder.createAlloca (int64Type, "tmpArg", NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createAlloca(int64Type, "tmpArg", NULL, &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createStore (llvmArgValue, tmpValue);
[+] 				m_module->m_llvmIrBuilder.createStore(llvmArgValue, tmpValue);
[-] 				m_module->m_llvmIrBuilder.createBitCast (tmpValue, type->getDataPtrType_c (), &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createBitCast(tmpValue, type->getDataPtrType_c(), &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createLoad (tmpValue, NULL, &tmpValue);
[+] 				m_module->m_llvmIrBuilder.createLoad(tmpValue, NULL, &tmpValue);
[-] 				m_module->m_llvmIrBuilder.createStore (tmpValue, argVariable);
[+] 				m_module->m_llvmIrBuilder.createStore(tmpValue, argVariable);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv.h
----------------------
[-] getLlvmCallConv (CallConvKind callConvKind);
[+] getLlvmCallConv(CallConvKind callConvKind);
[-] getCallConvFlags (CallConvKind callConvKind);
[+] getCallConvFlags(CallConvKind callConvKind);
[-] getCallConvString (CallConvKind callConvKind);
[+] getCallConvString(CallConvKind callConvKind);
[-] getCallConvDisplayString (CallConvKind callConvKind);
[+] getCallConvDisplayString(CallConvKind callConvKind);
[-] getCallConvSignature (CallConvKind callConvKind);
[+] getCallConvSignature(CallConvKind callConvKind);
[-] getCallConvKindFromModifiers (uint_t modifiers);
[+] getCallConvKindFromModifiers(uint_t modifiers);
[-] 	CallConv ();
[+] 	CallConv();
[-] 	getCallConvKind ()
[+] 	getCallConvKind()
[-] 	getFlags ()
[+] 	getFlags()
[-] 		return ct::getCallConvFlags (m_callConvKind);
[+] 		return ct::getCallConvFlags(m_callConvKind);
[-] 	getLlvmCallConv ()
[+] 	getLlvmCallConv()
[-] 		return ct::getLlvmCallConv (m_callConvKind);
[+] 		return ct::getLlvmCallConv(m_callConvKind);
[-] 	getCallConvString ()
[+] 	getCallConvString()
[-] 		return ct::getCallConvString (m_callConvKind);
[+] 		return ct::getCallConvString(m_callConvKind);
[-] 	getCallConvDisplayString ()
[+] 	getCallConvDisplayString()
[-] 		return ct::getCallConvDisplayString (m_callConvKind);
[+] 		return ct::getCallConvDisplayString(m_callConvKind);
[-] 	isDefault ()
[+] 	isDefault()
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	createLlvmFunction (
[+] 	createLlvmFunction(
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	getArgValue (
[+] 	getArgValue(
[-] 	createArgVariables (Function* function)
[+] 	createArgVariables(Function* function)
[-] 		createArgVariablesImpl (function, 0);
[+] 		createArgVariablesImpl(function, 0);
[-] 	createArgVariablesImpl (
[+] 	createArgVariablesImpl(
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv_gcc32.h
----------------------
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	createLlvmFunction (
[+] 	createLlvmFunction(
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	createArgVariables (Function* function);
[+] 	createArgVariables(Function* function);
[-] 	CdeclCallConv_gcc32 ()
[+] 	CdeclCallConv_gcc32()
[-] 	StdcallCallConv_gcc32 ()
[+] 	StdcallCallConv_gcc32()
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CallConv_msc32.h
----------------------
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	createLlvmFunction (
[+] 	createLlvmFunction(
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	createArgVariables (Function* function);
[+] 	createArgVariables(Function* function);
[-] 	isStructRet (Type* type)
[+] 	isStructRet(Type* type)
[-] 			(type->getFlags () & TypeFlag_StructRet) &&
[+] 			(type->getFlags() & TypeFlag_StructRet) &&
[-] 			type->getSize () > sizeof (uint64_t);
[+] 			type->getSize() > sizeof(uint64_t);
[-] 	CdeclCallConv_msc32 ()
[+] 	CdeclCallConv_msc32()
[-] 	StdcallCallConv_msc32 ()
[+] 	StdcallCallConv_msc32()
[-] 	ThiscallCallConv_msc32 ()
[+] 	ThiscallCallConv_msc32()
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_arm.h
----------------------
[-] 	CdeclCallConv_arm ()
[+] 	CdeclCallConv_arm()
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	createLlvmFunction (
[+] 	createLlvmFunction(
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getArgValue (
[+] 	getArgValue(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	createArgVariables (Function* function);
[+] 	createArgVariables(Function* function);
[-] 	getArgCoerceType (Type* type);
[+] 	getArgCoerceType(Type* type);
[-] 	CdeclCallConv_arm32 ();
[+] 	CdeclCallConv_arm32();
[-] 	CdeclCallConv_arm64 ();
[+] 	CdeclCallConv_arm64();
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_gcc64.h
----------------------
[-] 	CdeclCallConv_gcc64 ()
[+] 	CdeclCallConv_gcc64()
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	createLlvmFunction (
[+] 	createLlvmFunction(
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	getArgValue (
[+] 	getArgValue(
[-] 	createArgVariables (Function* function);
[+] 	createArgVariables(Function* function);
[-] 	getArgCoerceType (Type* type);
[+] 	getArgCoerceType(Type* type);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_CdeclCallConv_msc64.h
----------------------
[-] 	CdeclCallConv_msc64 ()
[+] 	CdeclCallConv_msc64()
[-] 	prepareFunctionType (FunctionType* functionType);
[+] 	prepareFunctionType(FunctionType* functionType);
[-] 	call (
[+] 	call(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	ret (
[+] 	ret(
[-] 	getArgValue (
[+] 	getArgValue(
[-] 	getThisArgValue (Function* function);
[+] 	getThisArgValue(Function* function);
[-] 	createArgVariables (Function* function);
[+] 	createArgVariables(Function* function);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_CallConv\jnc_ct_JnccallCallConv.h
----------------------
[-] 	JnccallCallConv_msc32 ()
[+] 	JnccallCallConv_msc32()
[-] 	JnccallCallConv_msc64 ()
[+] 	JnccallCallConv_msc64()
[-] 	JnccallCallConv_gcc32 ()
[+] 	JnccallCallConv_gcc32()
[-] 	JnccallCallConv_gcc64 ()
[+] 	JnccallCallConv_gcc64()
[-] 	JnccallCallConv_arm32 ()
[+] 	JnccallCallConv_arm32()
[-] 	JnccallCallConv_arm64 ()
[+] 	JnccallCallConv_arm64()
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_BasicBlock.cpp
----------------------
[-] BasicBlock::BasicBlock ()
[+] BasicBlock::BasicBlock()
[-] BasicBlock::getBlockAddressValue ()
[+] BasicBlock::getBlockAddressValue()
[-] 	llvm::BlockAddress* llvmAddress = llvm::BlockAddress::get (m_function->getLlvmFunction (), m_llvmBlock);
[+] 	llvm::BlockAddress* llvmAddress = llvm::BlockAddress::get(m_function->getLlvmFunction(), m_llvmBlock);
[-] 	value.setLlvmValue (llvmAddress, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	value.setLlvmValue(llvmAddress, m_module->m_typeMgr.getStdType(StdType_BytePtr));
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_ControlFlowMgr.cpp
----------------------
[-] ControlFlowMgr::ControlFlowMgr ()
[+] ControlFlowMgr::ControlFlowMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] ControlFlowMgr::clear ()
[+] ControlFlowMgr::clear()
[-] 	m_blockList.clear ();
[+] 	m_blockList.clear();
[-] 	m_asyncBlockArray.clear ();
[+] 	m_asyncBlockArray.clear();
[-] 	m_returnBlockArray.clear ();
[+] 	m_returnBlockArray.clear();
[-] 	m_landingPadBlockArray.clear ();
[+] 	m_landingPadBlockArray.clear();
[-] 	m_sjljFrameArrayValue.clear ();
[+] 	m_sjljFrameArrayValue.clear();
[-] 	m_prevSjljFrameValue.clear ();
[+] 	m_prevSjljFrameValue.clear();
[-] ControlFlowMgr::finalizeFunction ()
[+] ControlFlowMgr::finalizeFunction()
[-] 		finalizeSjljFrameArray ();
[+] 		finalizeSjljFrameArray();
[-] 	m_asyncBlockArray.clear ();
[+] 	m_asyncBlockArray.clear();
[-] 	m_returnBlockArray.clear ();
[+] 	m_returnBlockArray.clear();
[-] 	m_landingPadBlockArray.clear ();
[+] 	m_landingPadBlockArray.clear();
[-] 	m_sjljFrameArrayValue.clear ();
[+] 	m_sjljFrameArrayValue.clear();
[-] 	m_prevSjljFrameValue.clear ();
[+] 	m_prevSjljFrameValue.clear();
[-] ControlFlowMgr::createBlock (
[+] ControlFlowMgr::createBlock(
[-] 	BasicBlock* block = AXL_MEM_NEW (BasicBlock);
[+] 	BasicBlock* block = AXL_MEM_NEW(BasicBlock);
[-] 	block->m_llvmBlock = llvm::BasicBlock::Create (
[+] 	block->m_llvmBlock = llvm::BasicBlock::Create(
[-] 		*m_module->getLlvmContext (),
[+] 		*m_module->getLlvmContext(),
[-] 	m_blockList.insertTail (block);
[+] 	m_blockList.insertTail(block);
[-] ControlFlowMgr::createAsyncBlock (Scope* scope)
[+] ControlFlowMgr::createAsyncBlock(Scope* scope)
[-] 	BasicBlock* block = createBlock ("async_block");
[+] 	BasicBlock* block = createBlock("async_block");
[-] 	m_landingPadBlockArray.append (block);
[+] 	m_landingPadBlockArray.append(block);
[-] 	m_asyncBlockArray.append (block);
[+] 	m_asyncBlockArray.append(block);
[-] ControlFlowMgr::setCurrentBlock (BasicBlock* block)
[+] ControlFlowMgr::setCurrentBlock(BasicBlock* block)
[-] 		prevCurrentBlock->m_llvmDebugLoc = m_module->m_llvmIrBuilder.getCurrentDebugLoc ();
[+] 		prevCurrentBlock->m_llvmDebugLoc = m_module->m_llvmIrBuilder.getCurrentDebugLoc();
[-] 		addBlock (block);
[+] 		addBlock(block);
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (block);
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(block);
[-] 	bool hasDebugLoc = !block->m_llvmDebugLoc.isUnknown ();
[+] 	bool hasDebugLoc = !block->m_llvmDebugLoc.isUnknown();
[-] 	bool hasDebugLoc = (bool) block->m_llvmDebugLoc;
[+] 	bool hasDebugLoc = (bool)block->m_llvmDebugLoc;
[-] 		m_module->m_llvmIrBuilder.setCurrentDebugLoc (block->m_llvmDebugLoc);
[+] 		m_module->m_llvmIrBuilder.setCurrentDebugLoc(block->m_llvmDebugLoc);
[-] ControlFlowMgr::addBlock (BasicBlock* block)
[+] ControlFlowMgr::addBlock(BasicBlock* block)
[-] 	ASSERT (!block->m_function);
[+] 	ASSERT(!block->m_function);
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function);
[+] 	ASSERT(function);
[-] 	function->getLlvmFunction ()->getBasicBlockList ().push_back (block->m_llvmBlock);
[+] 	function->getLlvmFunction()->getBasicBlockList().push_back(block->m_llvmBlock);
[-] ControlFlowMgr::deleteUnreachableBlocks ()
[+] ControlFlowMgr::deleteUnreachableBlocks()
[-] 	sl::List <BasicBlock> pendingDeleteList;
[+] 	sl::List<BasicBlock> pendingDeleteList;
[-] 	sl::Iterator <BasicBlock> it = m_blockList.getHead ();
[+] 	sl::Iterator<BasicBlock> it = m_blockList.getHead();
[-] 			m_blockList.remove (block);
[+] 			m_blockList.remove(block);
[-] 			if (!block->m_llvmBlock->use_empty ())
[+] 			if (!block->m_llvmBlock->use_empty())
[-] 				pendingDeleteList.insertTail (block);
[+] 				pendingDeleteList.insertTail(block);
[-] 					block->m_llvmBlock->eraseFromParent ();
[+] 					block->m_llvmBlock->eraseFromParent();
[-] 				AXL_MEM_DELETE (block);
[+] 				AXL_MEM_DELETE(block);
[-] 	while (!pendingDeleteList.isEmpty ())
[+] 	while (!pendingDeleteList.isEmpty())
[-] 		it = pendingDeleteList.getHead ();
[+] 		it = pendingDeleteList.getHead();
[-] 			if (!block->m_llvmBlock->use_empty ())
[+] 			if (!block->m_llvmBlock->use_empty())
[-] 				block->m_llvmBlock->eraseFromParent ();
[+] 				block->m_llvmBlock->eraseFromParent();
[-] 			pendingDeleteList.erase (block);
[+] 			pendingDeleteList.erase(block);
[-] 		if (isFixedPoint && !pendingDeleteList.isEmpty ())
[+] 		if (isFixedPoint && !pendingDeleteList.isEmpty())
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				pendingDeleteList.getHead ()->m_llvmBlock->getName ().begin ()
[+] 				pendingDeleteList.getHead()->m_llvmBlock->getName().begin()
[-] ControlFlowMgr::getUnreachableBlock ()
[+] ControlFlowMgr::getUnreachableBlock()
[-] 	if (m_unreachableBlock && m_unreachableBlock->getInstructionCount () == 1)
[+] 	if (m_unreachableBlock && m_unreachableBlock->getInstructionCount() == 1)
[-] 	m_unreachableBlock = createBlock ("unreachable_block");
[+] 	m_unreachableBlock = createBlock("unreachable_block");
[-] 	markUnreachable (m_unreachableBlock);
[+] 	markUnreachable(m_unreachableBlock);
[-] ControlFlowMgr::getReturnBlock ()
[+] ControlFlowMgr::getReturnBlock()
[-] 	m_returnBlock = createBlock ("return_block");
[+] 	m_returnBlock = createBlock("return_block");
[-] 	BasicBlock* prevBlock = setCurrentBlock (m_returnBlock);
[+] 	BasicBlock* prevBlock = setCurrentBlock(m_returnBlock);
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 	if (function->getFunctionKind () == FunctionKind_Async)
[+] 	if (function->getFunctionKind() == FunctionKind_Async)
[-] 		Type* returnType = function->getAsyncLauncher ()->getType ()->getAsyncReturnType ();
[+] 		Type* returnType = function->getAsyncLauncher()->getType()->getAsyncReturnType();
[-] 		Value returnValue = returnType->getTypeKind () == TypeKind_Void ?
[+] 		Value returnValue = returnType->getTypeKind() == TypeKind_Void ?
[-] 			m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant)->getZeroValue () :
[+] 			m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant)->getZeroValue() :
[-] 			getReturnValueVariable ();
[+] 			getReturnValueVariable();
[-] 		Function* retFunc = m_module->m_functionMgr.getStdFunction (StdFunc_AsyncRet);
[+] 		Function* retFunc = m_module->m_functionMgr.getStdFunction(StdFunc_AsyncRet);
[-] 		Value promiseValue = m_module->m_functionMgr.getPromiseValue ();
[+] 		Value promiseValue = m_module->m_functionMgr.getPromiseValue();
[-] 		bool result = m_module->m_operatorMgr.callOperator (retFunc, promiseValue, returnValue);
[+] 		bool result = m_module->m_operatorMgr.callOperator(retFunc, promiseValue, returnValue);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		m_module->m_llvmIrBuilder.createRet ();
[+] 		m_module->m_llvmIrBuilder.createRet();
[-] 	else if (functionType->getReturnType ()->getTypeKind () == TypeKind_Void)
[+] 	else if (functionType->getReturnType()->getTypeKind() == TypeKind_Void)
[-] 		m_module->m_llvmIrBuilder.createRet ();
[+] 		m_module->m_llvmIrBuilder.createRet();
[-] 		m_module->m_llvmIrBuilder.createLoad (getReturnValueVariable (), NULL, &returnValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(getReturnValueVariable(), NULL, &returnValue);
[-] 		functionType->getCallConv ()->ret (function, returnValue);
[+] 		functionType->getCallConv()->ret(function, returnValue);
[-] 	m_returnBlockArray.append (m_currentBlock);
[+] 	m_returnBlockArray.append(m_currentBlock);
[-] 	setCurrentBlock (prevBlock);
[+] 	setCurrentBlock(prevBlock);
[-] ControlFlowMgr::getReturnValueVariable ()
[+] ControlFlowMgr::getReturnValueVariable()
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	Type* returnType = function->getFunctionKind () == FunctionKind_Async ?
[+] 	Type* returnType = function->getFunctionKind() == FunctionKind_Async ?
[-] 		function->getAsyncLauncher ()->getType ()->getAsyncReturnType () :
[+] 		function->getAsyncLauncher()->getType()->getAsyncReturnType() :
[-] 		function->getType ()->getReturnType ();
[+] 		function->getType()->getReturnType();
[-] 	ASSERT (returnType->getTypeKind () != TypeKind_Void);
[+] 	ASSERT(returnType->getTypeKind() != TypeKind_Void);
[-] 	BasicBlock* prevBlock = setCurrentBlock (function->getPrologueBlock ());
[+] 	BasicBlock* prevBlock = setCurrentBlock(function->getPrologueBlock());
[-] 	m_returnValueVariable = m_module->m_variableMgr.createSimpleStackVariable ("savedReturnValue", returnType);
[+] 	m_returnValueVariable = m_module->m_variableMgr.createSimpleStackVariable("savedReturnValue", returnType);
[-] 	setCurrentBlock (prevBlock);
[+] 	setCurrentBlock(prevBlock);
[-] ControlFlowMgr::markUnreachable (BasicBlock* block)
[+] ControlFlowMgr::markUnreachable(BasicBlock* block)
[-] 	ASSERT (block->isEmpty () && block->m_flags == 0);
[+] 	ASSERT(block->isEmpty() && block->m_flags == 0);
[-] 	BasicBlock* prevCurrentBlock = setCurrentBlock (block);
[+] 	BasicBlock* prevCurrentBlock = setCurrentBlock(block);
[-] 	m_module->m_llvmIrBuilder.createUnreachable ();
[+] 	m_module->m_llvmIrBuilder.createUnreachable();
[-] 	setCurrentBlock (prevCurrentBlock);
[+] 	setCurrentBlock(prevCurrentBlock);
[-] ControlFlowMgr::jump (
[+] ControlFlowMgr::jump(
[-] 	m_module->m_llvmIrBuilder.createBr (block);
[+] 	m_module->m_llvmIrBuilder.createBr(block);
[-] 		followBlock = getUnreachableBlock ();
[+] 		followBlock = getUnreachableBlock();
[-] 	setCurrentBlock (followBlock);
[+] 	setCurrentBlock(followBlock);
[-] ControlFlowMgr::follow (BasicBlock* block)
[+] ControlFlowMgr::follow(BasicBlock* block)
[-] 	if (!m_currentBlock->hasTerminator ())
[+] 	if (!m_currentBlock->hasTerminator())
[-] 		m_module->m_llvmIrBuilder.createBr (block);
[+] 		m_module->m_llvmIrBuilder.createBr(block);
[-] 	setCurrentBlock (block);
[+] 	setCurrentBlock(block);
[-] ControlFlowMgr::conditionalJump (
[+] ControlFlowMgr::conditionalJump(
[-] 	bool result = m_module->m_operatorMgr.castOperator (value, TypeKind_Bool, &boolValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(value, TypeKind_Bool, &boolValue);
[-] 	m_module->m_llvmIrBuilder.createCondBr (boolValue, thenBlock, elseBlock);
[+] 	m_module->m_llvmIrBuilder.createCondBr(boolValue, thenBlock, elseBlock);
[-] 	setCurrentBlock (followBlock);
[+] 	setCurrentBlock(followBlock);
[-] ControlFlowMgr::breakJump (size_t level)
[+] ControlFlowMgr::breakJump(size_t level)
[-] 	Scope* targetScope = m_module->m_namespaceMgr.findBreakScope (level);
[+] 	Scope* targetScope = m_module->m_namespaceMgr.findBreakScope(level);
[-] 		err::setFormatStringError ("illegal break");
[+] 		err::setFormatStringError("illegal break");
[-] 	escapeScope (targetScope, targetScope->m_breakBlock);
[+] 	escapeScope(targetScope, targetScope->m_breakBlock);
[-] ControlFlowMgr::continueJump (size_t level)
[+] ControlFlowMgr::continueJump(size_t level)
[-] 	Scope* targetScope = m_module->m_namespaceMgr.findContinueScope (level);
[+] 	Scope* targetScope = m_module->m_namespaceMgr.findContinueScope(level);
[-] 		err::setFormatStringError ("illegal continue");
[+] 		err::setFormatStringError("illegal continue");
[-] 	escapeScope (targetScope, targetScope->m_continueBlock);
[+] 	escapeScope(targetScope, targetScope->m_continueBlock);
[-] ControlFlowMgr::escapeScope (
[+] ControlFlowMgr::escapeScope(
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 			ASSERT (scope->m_finallyBlock);
[+] 			ASSERT(scope->m_finallyBlock);
[-] 				ASSERT (prevFinallyBlock);
[+] 				ASSERT(prevFinallyBlock);
[-] 				prevFinallyBlock->m_finallyRouteMap [routeIdx] = scope->m_finallyBlock;
[+] 				prevFinallyBlock->m_finallyRouteMap[routeIdx] = scope->m_finallyBlock;
[-] 		scope = scope->getParentScope ();
[+] 		scope = scope->getParentScope();
[-] 		ASSERT (!firstFinallyBlock); // if we have finally then we return via return-block
[+] 		ASSERT(!firstFinallyBlock); // if we have finally then we return via return-block
[-] 		scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 		scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 			setSjljFrame (-1);
[+] 			setSjljFrame(-1);
[-] 	markLandingPad (targetBlock, targetScope, LandingPadKind_EscapeScope);
[+] 	markLandingPad(targetBlock, targetScope, LandingPadKind_EscapeScope);
[-] 		jump (targetBlock);
[+] 		jump(targetBlock);
[-] 	prevFinallyBlock->m_finallyRouteMap [routeIdx] = targetBlock;
[+] 	prevFinallyBlock->m_finallyRouteMap[routeIdx] = targetBlock;
[-] 	Variable* routeIdxVariable = getFinallyRouteIdxVariable ();
[+] 	Variable* routeIdxVariable = getFinallyRouteIdxVariable();
[-] 	Value routeIdxValue (routeIdx, m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr));
[+] 	Value routeIdxValue(routeIdx, m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr));
[-] 	m_module->m_llvmIrBuilder.createStore (routeIdxValue, routeIdxVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(routeIdxValue, routeIdxVariable);
[-] 	jump (firstFinallyBlock);
[+] 	jump(firstFinallyBlock);
[-] ControlFlowMgr::asyncRet (BasicBlock* nextBlock)
[+] ControlFlowMgr::asyncRet(BasicBlock* nextBlock)
[-] 		ASSERT (m_module->m_namespaceMgr.getCurrentScope ()->m_sjljFrameIdx != -1);
[+] 		ASSERT(m_module->m_namespaceMgr.getCurrentScope()->m_sjljFrameIdx != -1);
[-] 		setSjljFrame (-1);
[+] 		setSjljFrame(-1);
[-] 	m_module->m_llvmIrBuilder.createRet ();
[+] 	m_module->m_llvmIrBuilder.createRet();
[-] 	ASSERT (!(m_currentBlock->m_flags & BasicBlockFlag_Return));
[+] 	ASSERT(!(m_currentBlock->m_flags & BasicBlockFlag_Return));
[-] 	m_returnBlockArray.append (m_currentBlock);
[+] 	m_returnBlockArray.append(m_currentBlock);
[-] 	setCurrentBlock (nextBlock ? nextBlock : getUnreachableBlock ());
[+] 	setCurrentBlock(nextBlock ? nextBlock : getUnreachableBlock());
[-] ControlFlowMgr::ret (const Value& value)
[+] ControlFlowMgr::ret(const Value& value)
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function);
[+] 	ASSERT(function);
[-] 	bool isAsync = function->getFunctionKind () == FunctionKind_Async;
[+] 	bool isAsync = function->getFunctionKind() == FunctionKind_Async;
[-] 	FunctionType* functionType = function->getType ();
[+] 	FunctionType* functionType = function->getType();
[-] 		function->getAsyncLauncher ()->getType ()->getAsyncReturnType () :
[+] 		function->getAsyncLauncher()->getType()->getAsyncReturnType() :
[-] 		functionType->getReturnType ();
[+] 		functionType->getReturnType();
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		if (returnType->getTypeKind () != TypeKind_Void)
[+] 		if (returnType->getTypeKind() != TypeKind_Void)
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				function->m_tag.sz (),
[+] 				function->m_tag.sz(),
[-] 				returnType->getTypeString ().sz ()
[+] 				returnType->getTypeString().sz()
[-] 			escapeScope (function->getScope (), getReturnBlock ());
[+] 			escapeScope(function->getScope(), getReturnBlock());
[-] 		escapeScope (NULL, NULL);
[+] 		escapeScope(NULL, NULL);
[-] 		m_module->m_llvmIrBuilder.createRet ();
[+] 		m_module->m_llvmIrBuilder.createRet();
[-] 		if (returnType->getTypeKind () == TypeKind_Void)
[+] 		if (returnType->getTypeKind() == TypeKind_Void)
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				function->m_tag.sz (),
[+] 				function->m_tag.sz(),
[-] 				value.getType ()->getTypeString ().sz ()
[+] 				value.getType()->getTypeString().sz()
[-] 		bool result = m_module->m_operatorMgr.castOperator (value, returnType, &returnValue);
[+] 		bool result = m_module->m_operatorMgr.castOperator(value, returnType, &returnValue);
[-] 		if ((scope->getFlags () & ScopeFlag_Finalizable) || isAsync)
[+] 		if ((scope->getFlags() & ScopeFlag_Finalizable) || isAsync)
[-] 			m_module->m_llvmIrBuilder.createStore (returnValue, getReturnValueVariable ());
[+] 			m_module->m_llvmIrBuilder.createStore(returnValue, getReturnValueVariable());
[-] 			escapeScope (function->getScope (), getReturnBlock ());
[+] 			escapeScope(function->getScope(), getReturnBlock());
[-] 		escapeScope (NULL, NULL);
[+] 		escapeScope(NULL, NULL);
[-] 		functionType->getCallConv ()->ret (function, returnValue);
[+] 		functionType->getCallConv()->ret(function, returnValue);
[-] 	ASSERT (!(m_currentBlock->m_flags & BasicBlockFlag_Return));
[+] 	ASSERT(!(m_currentBlock->m_flags & BasicBlockFlag_Return));
[-] 	m_returnBlockArray.append (m_currentBlock);
[+] 	m_returnBlockArray.append(m_currentBlock);
[-] 	setCurrentBlock (getUnreachableBlock ());
[+] 	setCurrentBlock(getUnreachableBlock());
[-] ControlFlowMgr::checkReturn ()
[+] ControlFlowMgr::checkReturn()
[-] 	if (m_currentBlock->hasTerminator ())
[+] 	if (m_currentBlock->hasTerminator())
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	if (function->getFunctionKind () == FunctionKind_Async)
[+] 	if (function->getFunctionKind() == FunctionKind_Async)
[-] 		function = function->getAsyncLauncher ();
[+] 		function = function->getAsyncLauncher();
[-] 		returnType = function->getType ()->getAsyncReturnType ();
[+] 		returnType = function->getType()->getAsyncReturnType();
[-] 		returnType = function->getType ()->getReturnType ();
[+] 		returnType = function->getType()->getReturnType();
[-] 		m_module->m_llvmIrBuilder.createUnreachable (); // just to make LLVM happy
[+] 		m_module->m_llvmIrBuilder.createUnreachable(); // just to make LLVM happy
[-] 	else if (returnType->getTypeKind () == TypeKind_Void)
[+] 	else if (returnType->getTypeKind() == TypeKind_Void)
[-] 		ret ();
[+] 		ret();
[-] 	else if (m_returnBlockArray.isEmpty ())
[+] 	else if (m_returnBlockArray.isEmpty())
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			function->m_tag.sz (),
[+] 			function->m_tag.sz(),
[-] 			returnType->getTypeString ().sz ()
[+] 			returnType->getTypeString().sz()
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			function->m_tag.sz ()
[+] 			function->m_tag.sz()
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_ControlFlowMgr_Eh.cpp
----------------------
[-] ControlFlowMgr::getDynamicThrowBlock ()
[+] ControlFlowMgr::getDynamicThrowBlock()
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function->getFunctionKind () != FunctionKind_Async); // async functions always can static-throw
[+] 	ASSERT(function->getFunctionKind() != FunctionKind_Async); // async functions always can static-throw
[-] 	m_dynamicThrowBlock = createBlock ("dynamic_throw_block", BasicBlockFlag_Reachable);
[+] 	m_dynamicThrowBlock = createBlock("dynamic_throw_block", BasicBlockFlag_Reachable);
[-] 	BasicBlock* prevBlock = setCurrentBlock (m_dynamicThrowBlock);
[+] 	BasicBlock* prevBlock = setCurrentBlock(m_dynamicThrowBlock);
[-] 	Function* throwFunc = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicThrow);
[+] 	Function* throwFunc = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicThrow);
[-] 	m_module->m_llvmIrBuilder.createCall (throwFunc, throwFunc->getType (), NULL);
[+] 	m_module->m_llvmIrBuilder.createCall(throwFunc, throwFunc->getType(), NULL);
[-] 	m_module->m_llvmIrBuilder.createUnreachable ();
[+] 	m_module->m_llvmIrBuilder.createUnreachable();
[-] 	setCurrentBlock (prevBlock);
[+] 	setCurrentBlock(prevBlock);
[-] ControlFlowMgr::getFinallyRouteIdxVariable ()
[+] ControlFlowMgr::getFinallyRouteIdxVariable()
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	BasicBlock* prevBlock = setCurrentBlock (function->getPrologueBlock ());
[+] 	BasicBlock* prevBlock = setCurrentBlock(function->getPrologueBlock());
[-] 	m_finallyRouteIdxVariable = m_module->m_variableMgr.createSimpleStackVariable ("finallyRouteIdx", m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr));
[+] 	m_finallyRouteIdxVariable = m_module->m_variableMgr.createSimpleStackVariable("finallyRouteIdx", m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr));
[-] 	setCurrentBlock (prevBlock);
[+] 	setCurrentBlock(prevBlock);
[-] ControlFlowMgr::markLandingPad (
[+] ControlFlowMgr::markLandingPad(
[-] 	ASSERT (landingPadKind >= block->m_landingPadKind); // escapeScope, then catchLabel/finallyLabel
[+] 	ASSERT(landingPadKind >= block->m_landingPadKind); // escapeScope, then catchLabel/finallyLabel
[-] 		m_landingPadBlockArray.append (block);
[+] 		m_landingPadBlockArray.append(block);
[-] ControlFlowMgr::throwException ()
[+] ControlFlowMgr::throwException()
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	if (!scope->canStaticThrow ())
[+] 	if (!scope->canStaticThrow())
[-] 		jump (getDynamicThrowBlock ());
[+] 		jump(getDynamicThrowBlock());
[-] 		Scope* catchScope = m_module->m_namespaceMgr.findCatchScope ();
[+] 		Scope* catchScope = m_module->m_namespaceMgr.findCatchScope();
[-] 			escapeScope (
[+] 			escapeScope(
[-] 			FunctionType* currentFunctionType = m_module->m_functionMgr.getCurrentFunction ()->getType ();
[+] 			FunctionType* currentFunctionType = m_module->m_functionMgr.getCurrentFunction()->getType();
[-] 			ASSERT (currentFunctionType->getFlags () & FunctionTypeFlag_ErrorCode);
[+] 			ASSERT(currentFunctionType->getFlags() & FunctionTypeFlag_ErrorCode);
[-] 			Value throwValue = currentFunctionType->getReturnType ()->getErrorCodeValue ();
[+] 			Value throwValue = currentFunctionType->getReturnType()->getErrorCodeValue();
[-] 			ret (throwValue);
[+] 			ret(throwValue);
[-] ControlFlowMgr::setJmp (
[+] ControlFlowMgr::setJmp(
[-] 		preCreateSjljFrameArray ();
[+] 		preCreateSjljFrameArray();
[-] 	Variable* sjljFrameVariable = m_module->m_variableMgr.getStdVariable (StdVariable_SjljFrame);
[+] 	Variable* sjljFrameVariable = m_module->m_variableMgr.getStdVariable(StdVariable_SjljFrame);
[-] 	Function* setJmpFunc = m_module->m_functionMgr.getStdFunction (StdFunc_SetJmp);
[+] 	Function* setJmpFunc = m_module->m_functionMgr.getStdFunction(StdFunc_SetJmp);
[-] 	m_module->m_llvmIrBuilder.createGep (m_sjljFrameArrayValue, sjljFrameIdx, NULL, &sjljFrameValue);
[+] 	m_module->m_llvmIrBuilder.createGep(m_sjljFrameArrayValue, sjljFrameIdx, NULL, &sjljFrameValue);
[-] 	m_module->m_llvmIrBuilder.createStore (sjljFrameValue, sjljFrameVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(sjljFrameValue, sjljFrameVariable);
[-] 	m_module->m_llvmIrBuilder.createCall (setJmpFunc, setJmpFunc->getType (), sjljFrameValue, &returnValue);
[+] 	m_module->m_llvmIrBuilder.createCall(setJmpFunc, setJmpFunc->getType(), sjljFrameValue, &returnValue);
[-] 	BasicBlock* followBlock = createBlock ("follow_block");
[+] 	BasicBlock* followBlock = createBlock("follow_block");
[-] 	bool result = conditionalJump (returnValue, catchBlock, followBlock, followBlock);
[+] 	bool result = conditionalJump(returnValue, catchBlock, followBlock, followBlock);
[-] 		ASSERT (m_sjljFrameCount == sjljFrameIdx);
[+] 		ASSERT(m_sjljFrameCount == sjljFrameIdx);
[-] ControlFlowMgr::setJmpFinally (
[+] ControlFlowMgr::setJmpFinally(
[-] 	BasicBlock* catchBlock = createBlock ("finally_sjlj_block");
[+] 	BasicBlock* catchBlock = createBlock("finally_sjlj_block");
[-] 	setJmp (catchBlock, sjljFrameIdx);
[+] 	setJmp(catchBlock, sjljFrameIdx);
[-] 	BasicBlock* prevBlock = setCurrentBlock (catchBlock);
[+] 	BasicBlock* prevBlock = setCurrentBlock(catchBlock);
[-] 	Variable* finallyRouteIdxVariable = getFinallyRouteIdxVariable ();
[+] 	Variable* finallyRouteIdxVariable = getFinallyRouteIdxVariable();
[-] 	Value minusOneValue (&minusOne, finallyRouteIdxVariable->getType ());
[+] 	Value minusOneValue(&minusOne, finallyRouteIdxVariable->getType());
[-] 	m_module->m_llvmIrBuilder.createStore (minusOneValue, finallyRouteIdxVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(minusOneValue, finallyRouteIdxVariable);
[-] 	jump (finallyBlock);
[+] 	jump(finallyBlock);
[-] 	setCurrentBlock (prevBlock);
[+] 	setCurrentBlock(prevBlock);
[-] ControlFlowMgr::beginTryOperator (TryExpr* tryExpr)
[+] ControlFlowMgr::beginTryOperator(TryExpr* tryExpr)
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	tryExpr->m_catchBlock = createBlock ("try_catch_block");
[+] 	tryExpr->m_catchBlock = createBlock("try_catch_block");
[-] 	setJmp (tryExpr->m_catchBlock, tryExpr->m_sjljFrameIdx);
[+] 	setJmp(tryExpr->m_catchBlock, tryExpr->m_sjljFrameIdx);
[-] ControlFlowMgr::endTryOperator (
[+] ControlFlowMgr::endTryOperator(
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	BasicBlock* phiBlock = createBlock ("try_phi_block");
[+] 	BasicBlock* phiBlock = createBlock("try_phi_block");
[-] 	Type* type = value->getType ();
[+] 	Type* type = value->getType();
[-] 	if (type->getTypeKind () == TypeKind_Void)
[+] 	if (type->getTypeKind() == TypeKind_Void)
[-] 		value->setConstBool (true, m_module);
[+] 		value->setConstBool(true, m_module);
[-] 		errorValue.setConstBool (false, m_module);
[+] 		errorValue.setConstBool(false, m_module);
[-] 	else if (type->getTypeKindFlags () & TypeKindFlag_ErrorCode)
[+] 	else if (type->getTypeKindFlags() & TypeKindFlag_ErrorCode)
[-] 		errorValue = type->getErrorCodeValue ();
[+] 		errorValue = type->getErrorCodeValue();
[-] 		err::setFormatStringError ("'%s' cannot be used as error code", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' cannot be used as error code", type->getTypeString ().sz ());
[-] 	ASSERT (tryExpr->m_sjljFrameIdx != -1);
[+] 	ASSERT(tryExpr->m_sjljFrameIdx != -1);
[-] 	setSjljFrame (tryExpr->m_sjljFrameIdx - 1); // restore prev sjlj frame on normal flow
[+] 	setSjljFrame(tryExpr->m_sjljFrameIdx - 1); // restore prev sjlj frame on normal flow
[-] 	jump (phiBlock, tryExpr->m_catchBlock);
[+] 	jump(phiBlock, tryExpr->m_catchBlock);
[-] 	markLandingPad (tryExpr->m_catchBlock, scope, LandingPadKind_Exception);
[+] 	markLandingPad(tryExpr->m_catchBlock, scope, LandingPadKind_Exception);
[-] 	jump (phiBlock, phiBlock);
[+] 	jump(phiBlock, phiBlock);
[-] 	m_module->m_llvmIrBuilder.createPhi (*value, prevBlock, errorValue, tryExpr->m_catchBlock, value);
[+] 	m_module->m_llvmIrBuilder.createPhi(*value, prevBlock, errorValue, tryExpr->m_catchBlock, value);
[-] ControlFlowMgr::throwExceptionIf (
[+] ControlFlowMgr::throwExceptionIf(
[-] 	Type* returnType = functionType->getReturnType ();
[+] 	Type* returnType = functionType->getReturnType();
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		(functionType->getFlags () & FunctionTypeFlag_ErrorCode) &&
[+] 		(functionType->getFlags() & FunctionTypeFlag_ErrorCode) &&
[-] 		(returnType->getTypeKindFlags () & TypeKindFlag_ErrorCode));
[+] 		(returnType->getTypeKindFlags() & TypeKindFlag_ErrorCode));
[-] 	if (returnType->getTypeKind () == TypeKind_Bool || !(returnType->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 	if (returnType->getTypeKind() == TypeKind_Bool || !(returnType->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		minusOneValue.createConst (&minusOne, returnType);
[+] 		minusOneValue.createConst(&minusOne, returnType);
[-] 		result = m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, returnValue, minusOneValue, &indicatorValue);
[+] 		result = m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, returnValue, minusOneValue, &indicatorValue);
[-] 	BasicBlock* followBlock = createBlock ("follow_block");
[+] 	BasicBlock* followBlock = createBlock("follow_block");
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	if (!scope->canStaticThrow ())
[+] 	if (!scope->canStaticThrow())
[-] 		BasicBlock* throwBlock = getDynamicThrowBlock ();
[+] 		BasicBlock* throwBlock = getDynamicThrowBlock();
[-] 		result = conditionalJump (indicatorValue, followBlock, throwBlock, throwBlock);
[+] 		result = conditionalJump(indicatorValue, followBlock, throwBlock, throwBlock);
[-] 		BasicBlock* throwBlock = createBlock ("static_throw_block");
[+] 		BasicBlock* throwBlock = createBlock("static_throw_block");
[-] 		result = conditionalJump (indicatorValue, followBlock, throwBlock, throwBlock);
[+] 		result = conditionalJump(indicatorValue, followBlock, throwBlock, throwBlock);
[-] 		throwException ();
[+] 		throwException();
[-] 	setCurrentBlock (followBlock);
[+] 	setCurrentBlock(followBlock);
[-] ControlFlowMgr::finalizeTryScope (Scope* scope)
[+] ControlFlowMgr::finalizeTryScope(Scope* scope)
[-] 	bool result = catchLabel (Token::Pos ());
[+] 	bool result = catchLabel(Token::Pos());
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	finalizeCatchScope (scope);
[+] 	finalizeCatchScope(scope);
[-] ControlFlowMgr::catchLabel (const Token::Pos& pos)
[+] ControlFlowMgr::catchLabel(const Token::Pos& pos)
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		result = checkReturn ();
[+] 		result = checkReturn();
[-] 		m_module->m_namespaceMgr.closeScope ();
[+] 		m_module->m_namespaceMgr.closeScope();
[-] 		scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 		scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		err::setFormatStringError ("'catch' is already defined");
[+] 		err::setFormatStringError("'catch' is already defined");
[-] 	ASSERT (!(scope->m_flags & ScopeFlag_Finally));
[+] 	ASSERT(!(scope->m_flags & ScopeFlag_Finally));
[-] 			normalFinallyFlow ();
[+] 			normalFinallyFlow();
[-] 			m_catchFinallyFollowBlock = createBlock ("catch_follow");
[+] 			m_catchFinallyFollowBlock = createBlock("catch_follow");
[-] 			ASSERT (scope->m_sjljFrameIdx != - 1);
[+] 			ASSERT(scope->m_sjljFrameIdx != - 1);
[-] 			setSjljFrame (scope->m_sjljFrameIdx - 1); // restore prev sjlj frame on normal flow
[+] 			setSjljFrame(scope->m_sjljFrameIdx - 1); // restore prev sjlj frame on normal flow
[-] 			jump (m_catchFinallyFollowBlock);
[+] 			jump(m_catchFinallyFollowBlock);
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	ASSERT (scope->m_catchBlock);
[+] 	ASSERT(scope->m_catchBlock);
[-] 	setCurrentBlock (scope->m_catchBlock);
[+] 	setCurrentBlock(scope->m_catchBlock);
[-] 	Scope* catchScope = m_module->m_namespaceMgr.openScope (pos, ScopeFlag_Catch);
[+] 	Scope* catchScope = m_module->m_namespaceMgr.openScope(pos, ScopeFlag_Catch);
[-] 	markLandingPad (scope->m_catchBlock, catchScope, LandingPadKind_Exception);
[+] 	markLandingPad(scope->m_catchBlock, catchScope, LandingPadKind_Exception);
[-] 		setJmpFinally (catchScope->m_finallyBlock, catchScope->m_sjljFrameIdx);
[+] 		setJmpFinally(catchScope->m_finallyBlock, catchScope->m_sjljFrameIdx);
[-] ControlFlowMgr::finalizeCatchScope (Scope* scope)
[+] ControlFlowMgr::finalizeCatchScope(Scope* scope)
[-] 		follow (m_catchFinallyFollowBlock);
[+] 		follow(m_catchFinallyFollowBlock);
[-] ControlFlowMgr::finallyLabel (const Token::Pos& pos)
[+] ControlFlowMgr::finallyLabel(const Token::Pos& pos)
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		m_module->m_namespaceMgr.closeScope ();
[+] 		m_module->m_namespaceMgr.closeScope();
[-] 		scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 		scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		err::setFormatStringError ("'finally' should follow 'catch'");
[+] 		err::setFormatStringError("'finally' should follow 'catch'");
[-] 		err::setFormatStringError ("'finally' is already defined");
[+] 		err::setFormatStringError("'finally' is already defined");
[-] 		bool result = catchLabel (pos);
[+] 		bool result = catchLabel(pos);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		normalFinallyFlow ();
[+] 		normalFinallyFlow();
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	ASSERT (scope->m_finallyBlock);
[+] 	ASSERT(scope->m_finallyBlock);
[-] 	setCurrentBlock (scope->m_finallyBlock);
[+] 	setCurrentBlock(scope->m_finallyBlock);
[-] 	Scope* finallyScope = m_module->m_namespaceMgr.openScope (pos, ScopeFlag_Finally);
[+] 	Scope* finallyScope = m_module->m_namespaceMgr.openScope(pos, ScopeFlag_Finally);
[-] 	markLandingPad (scope->m_finallyBlock, finallyScope, LandingPadKind_Exception);
[+] 	markLandingPad(scope->m_finallyBlock, finallyScope, LandingPadKind_Exception);
[-] void ControlFlowMgr::finalizeFinallyScope (Scope* scope)
[+] void ControlFlowMgr::finalizeFinallyScope(Scope* scope)
[-] 	ASSERT (scope && scope->m_finallyBlock && m_finallyRouteIdxVariable);
[+] 	ASSERT(scope && scope->m_finallyBlock && m_finallyRouteIdxVariable);
[-] 	m_module->m_operatorMgr.loadDataRef (m_finallyRouteIdxVariable, &routeIdxValue);
[+] 	m_module->m_operatorMgr.loadDataRef(m_finallyRouteIdxVariable, &routeIdxValue);
[-] 	BasicBlock* throwBlock = getDynamicThrowBlock ();
[+] 	BasicBlock* throwBlock = getDynamicThrowBlock();
[-] 	size_t count = scope->m_finallyBlock->m_finallyRouteMap.getCount ();
[+] 	size_t count = scope->m_finallyBlock->m_finallyRouteMap.getCount();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 		jump (throwBlock);
[+] 		jump(throwBlock);
[-] 	char buffer1 [256];
[+] 	char buffer1[256];
[-] 	sl::Array <intptr_t> routeIdxArray (ref::BufKind_Stack, buffer1, sizeof (buffer1));
[+] 	sl::Array<intptr_t> routeIdxArray(ref::BufKind_Stack, buffer1, sizeof(buffer1));
[-] 	routeIdxArray.setCount (count);
[+] 	routeIdxArray.setCount(count);
[-] 	char buffer2 [256];
[+] 	char buffer2[256];
[-] 	sl::Array <BasicBlock*> blockArray (ref::BufKind_Stack, buffer2, sizeof (buffer2));
[+] 	sl::Array<BasicBlock*> blockArray(ref::BufKind_Stack, buffer2, sizeof(buffer2));
[-] 	blockArray.setCount (count);
[+] 	blockArray.setCount(count);
[-] 	sl::HashTableIterator <size_t, BasicBlock*> it = scope->m_finallyBlock->m_finallyRouteMap.getHead ();
[+] 	sl::HashTableIterator<size_t, BasicBlock*> it = scope->m_finallyBlock->m_finallyRouteMap.getHead();
[-] 		ASSERT (i < count);
[+] 		ASSERT(i < count);
[-] 		routeIdxArray [i] = it->getKey ();
[+] 		routeIdxArray[i] = it->getKey();
[-] 		blockArray [i] = it->m_value;
[+] 		blockArray[i] = it->m_value;
[-] 		it->m_value->markReachable ();
[+] 		it->m_value->markReachable();
[-] 	m_module->m_llvmIrBuilder.createSwitch (
[+] 	m_module->m_llvmIrBuilder.createSwitch(
[-] 		setCurrentBlock (m_catchFinallyFollowBlock);
[+] 		setCurrentBlock(m_catchFinallyFollowBlock);
[-] 		setCurrentBlock (getUnreachableBlock ());
[+] 		setCurrentBlock(getUnreachableBlock());
[-] ControlFlowMgr::disposeVariable (Variable* variable)
[+] ControlFlowMgr::disposeVariable(Variable* variable)
[-] 	result = m_module->m_operatorMgr.loadDataRef (variable, &disposableValue);
[+] 	result = m_module->m_operatorMgr.loadDataRef(variable, &disposableValue);
[-] 	Type* type = variable->getType ();
[+] 	Type* type = variable->getType();
[-] 	ASSERT (type->getTypeKind () == TypeKind_ClassPtr || type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_ClassPtr || type->getTypeKind() == TypeKind_DataPtr);
[-] 	if (type->getTypeKind () == TypeKind_DataPtr &&
[+] 	if (type->getTypeKind() == TypeKind_DataPtr &&
[-] 		(((DataPtrType*) type)->getTargetType ()->getTypeKindFlags () & TypeKindFlag_Ptr))
[+] 		(((DataPtrType*)type)->getTargetType()->getTypeKindFlags() & TypeKindFlag_Ptr))
[-] 		disposeBlock = createBlock ("dispose_ptr_block");
[+] 		disposeBlock = createBlock("dispose_ptr_block");
[-] 		followBlock = createBlock ("dispose_ptr_follow_block");
[+] 		followBlock = createBlock("dispose_ptr_follow_block");
[-] 			m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, &disposableValue) &&
[+] 			m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, &disposableValue) &&
[-] 			m_module->m_operatorMgr.loadDataRef (&disposableValue) &&
[+] 			m_module->m_operatorMgr.loadDataRef(&disposableValue) &&
[-] 			conditionalJump (disposableValue, disposeBlock, followBlock, disposeBlock);
[+] 			conditionalJump(disposableValue, disposeBlock, followBlock, disposeBlock);
[-] 		m_module->m_operatorMgr.memberOperator (disposableValue, "dispose", &disposeValue) &&
[+] 		m_module->m_operatorMgr.memberOperator(disposableValue, "dispose", &disposeValue) &&
[-] 		m_module->m_operatorMgr.callOperator (disposeValue);
[+] 		m_module->m_operatorMgr.callOperator(disposeValue);
[-] 		follow (followBlock);
[+] 		follow(followBlock);
[-] ControlFlowMgr::finalizeDisposableScope (Scope* scope)
[+] ControlFlowMgr::finalizeDisposableScope(Scope* scope)
[-] 	size_t count = scope->m_disposableVariableArray.getCount ();
[+] 	size_t count = scope->m_disposableVariableArray.getCount();
[-] 	ASSERT (scope && count && scope->m_disposeLevelVariable);
[+] 	ASSERT(scope && count && scope->m_disposeLevelVariable);
[-] 	bool result = finallyLabel (Token::Pos ());
[+] 	bool result = finallyLabel(Token::Pos());
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	char buffer1 [256];
[+] 	char buffer1[256];
[-] 	sl::Array <intptr_t> levelArray (ref::BufKind_Stack, buffer1, sizeof (buffer1));
[+] 	sl::Array<intptr_t> levelArray(ref::BufKind_Stack, buffer1, sizeof(buffer1));
[-] 	levelArray.setCount (count);
[+] 	levelArray.setCount(count);
[-] 	char buffer2 [256];
[+] 	char buffer2[256];
[-] 	sl::Array <BasicBlock*> blockArray (ref::BufKind_Stack, buffer2, sizeof (buffer2));
[+] 	sl::Array<BasicBlock*> blockArray(ref::BufKind_Stack, buffer2, sizeof(buffer2));
[-] 	blockArray.setCount (count + 1);
[+] 	blockArray.setCount(count + 1);
[-] 		BasicBlock* block = createBlock ("dispose_variable_block", BasicBlockFlag_Reachable);
[+] 		BasicBlock* block = createBlock("dispose_variable_block", BasicBlockFlag_Reachable);
[-] 		levelArray [i] = j;
[+] 		levelArray[i] = j;
[-] 		blockArray [i] = block;
[+] 		blockArray[i] = block;
[-] 	BasicBlock* followBlock = createBlock ("dispose_finally_follow_block");
[+] 	BasicBlock* followBlock = createBlock("dispose_finally_follow_block");
[-] 	blockArray [count] = followBlock;
[+] 	blockArray[count] = followBlock;
[-] 		setCurrentBlock (blockArray [j]);
[+] 		setCurrentBlock(blockArray[j]);
[-] 		Variable* variable = scope->m_disposableVariableArray [i];
[+] 		Variable* variable = scope->m_disposableVariableArray[i];
[-] 		result = disposeVariable (variable);
[+] 		result = disposeVariable(variable);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		follow (blockArray [j + 1]);
[+] 		follow(blockArray[j + 1]);
[-] 	setCurrentBlock (switchBlock);
[+] 	setCurrentBlock(switchBlock);
[-] 	m_module->m_llvmIrBuilder.createLoad (
[+] 	m_module->m_llvmIrBuilder.createLoad(
[-] 		scope->m_disposeLevelVariable->getType (),
[+] 		scope->m_disposeLevelVariable->getType(),
[-] 	m_module->m_llvmIrBuilder.createSwitch (
[+] 	m_module->m_llvmIrBuilder.createSwitch(
[-] 	setCurrentBlock (followBlock);
[+] 	setCurrentBlock(followBlock);
[-] 	scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (scope->m_flags & ScopeFlag_Finally);
[+] 	ASSERT(scope->m_flags & ScopeFlag_Finally);
[-] 	finalizeFinallyScope (scope);
[+] 	finalizeFinallyScope(scope);
[-] ControlFlowMgr::normalFinallyFlow ()
[+] ControlFlowMgr::normalFinallyFlow()
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT ((scope->m_flags & ScopeFlag_FinallyAhead) && scope->m_finallyBlock);
[+] 	ASSERT((scope->m_flags & ScopeFlag_FinallyAhead) && scope->m_finallyBlock);
[-] 		m_catchFinallyFollowBlock = createBlock ("finally_follow");
[+] 		m_catchFinallyFollowBlock = createBlock("finally_follow");
[-] 	scope->m_finallyBlock->m_finallyRouteMap [routeIdx] = m_catchFinallyFollowBlock;
[+] 	scope->m_finallyBlock->m_finallyRouteMap[routeIdx] = m_catchFinallyFollowBlock;
[-] 	Variable* routeIdxVariable = getFinallyRouteIdxVariable ();
[+] 	Variable* routeIdxVariable = getFinallyRouteIdxVariable();
[-] 	Value routeIdxValue (routeIdx, m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr));
[+] 	Value routeIdxValue(routeIdx, m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr));
[-] 	m_module->m_llvmIrBuilder.createStore (routeIdxValue, routeIdxVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(routeIdxValue, routeIdxVariable);
[-] 	jump (scope->m_finallyBlock);
[+] 	jump(scope->m_finallyBlock);
[-] ControlFlowMgr::setSjljFrame (size_t index)
[+] ControlFlowMgr::setSjljFrame(size_t index)
[-] 	ASSERT (m_sjljFrameArrayValue);
[+] 	ASSERT(m_sjljFrameArrayValue);
[-] 	Variable* sjljFrameVariable = m_module->m_variableMgr.getStdVariable (StdVariable_SjljFrame);
[+] 	Variable* sjljFrameVariable = m_module->m_variableMgr.getStdVariable(StdVariable_SjljFrame);
[-] 		m_module->m_llvmIrBuilder.createStore (m_prevSjljFrameValue, sjljFrameVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(m_prevSjljFrameValue, sjljFrameVariable);
[-] 		m_module->m_llvmIrBuilder.createGep (m_sjljFrameArrayValue, index, NULL, &sjljFrameValue);
[+] 		m_module->m_llvmIrBuilder.createGep(m_sjljFrameArrayValue, index, NULL, &sjljFrameValue);
[-] 		m_module->m_llvmIrBuilder.createStore (sjljFrameValue, sjljFrameVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(sjljFrameValue, sjljFrameVariable);
[-] ControlFlowMgr::preCreateSjljFrameArray ()
[+] ControlFlowMgr::preCreateSjljFrameArray()
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	BasicBlock* prologueBlock = function->getPrologueBlock ();
[+] 	BasicBlock* prologueBlock = function->getPrologueBlock();
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	ASSERT (!m_sjljFrameArrayValue);
[+] 	ASSERT(!m_sjljFrameArrayValue);
[-] 	Type* type = m_module->m_typeMgr.getStdType (StdType_SjljFrame);
[+] 	Type* type = m_module->m_typeMgr.getStdType(StdType_SjljFrame);
[-] 	m_module->m_llvmIrBuilder.createAlloca (
[+] 	m_module->m_llvmIrBuilder.createAlloca(
[-] 		type->getDataPtrType_c (),
[+] 		type->getDataPtrType_c(),
[-] 	Variable* variable = m_module->m_variableMgr.getStdVariable (StdVariable_SjljFrame);
[+] 	Variable* variable = m_module->m_variableMgr.getStdVariable(StdVariable_SjljFrame);
[-] 	m_module->m_llvmIrBuilder.createLoad (variable, variable->getType (), &m_prevSjljFrameValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(variable, variable->getType(), &m_prevSjljFrameValue);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
[-] ControlFlowMgr::finalizeSjljFrameArray ()
[+] ControlFlowMgr::finalizeSjljFrameArray()
[-] 	ASSERT (m_sjljFrameArrayValue);
[+] 	ASSERT(m_sjljFrameArrayValue);
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function);
[+] 	ASSERT(function);
[-] 	BasicBlock* prologueBlock = function->getPrologueBlock ();
[+] 	BasicBlock* prologueBlock = function->getPrologueBlock();
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (&*prologueBlock->getLlvmBlock ()->begin ());
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(&*prologueBlock->getLlvmBlock()->begin());
[-] 	Type* type = m_module->m_typeMgr.getStdType (StdType_SjljFrame);
[+] 	Type* type = m_module->m_typeMgr.getStdType(StdType_SjljFrame);
[-] 	ArrayType* arrayType = type->getArrayType (m_sjljFrameCount);
[+] 	ArrayType* arrayType = type->getArrayType(m_sjljFrameCount);
[-] 	llvm::AllocaInst* llvmAlloca = m_module->m_llvmIrBuilder.createAlloca (arrayType, "sjljFrameArray", NULL, &sjljFrameArrayValue);
[+] 	llvm::AllocaInst* llvmAlloca = m_module->m_llvmIrBuilder.createAlloca(arrayType, "sjljFrameArray", NULL, &sjljFrameArrayValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (sjljFrameArrayValue, type->getDataPtrType_c (), &sjljFrameArrayValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(sjljFrameArrayValue, type->getDataPtrType_c(), &sjljFrameArrayValue);
[-] 	llvmAlloca->setAlignment (16);
[+] 	llvmAlloca->setAlignment(16);
[-] 	ASSERT (llvm::isa <llvm::AllocaInst> (m_sjljFrameArrayValue.getLlvmValue ()));
[+] 	ASSERT(llvm::isa<llvm::AllocaInst> (m_sjljFrameArrayValue.getLlvmValue()));
[-] 	llvmAlloca = (llvm::AllocaInst*) m_sjljFrameArrayValue.getLlvmValue ();
[+] 	llvmAlloca = (llvm::AllocaInst*)m_sjljFrameArrayValue.getLlvmValue();
[-] 	llvmAlloca->replaceAllUsesWith (sjljFrameArrayValue.getLlvmValue ());
[+] 	llvmAlloca->replaceAllUsesWith(sjljFrameArrayValue.getLlvmValue());
[-] 	llvmAlloca->eraseFromParent ();
[+] 	llvmAlloca->eraseFromParent();
[-] 	bool hasGcShadowStackFrame = m_module->m_gcShadowStackMgr.hasFrame () && function->getFunctionKind () != FunctionKind_Async;
[+] 	bool hasGcShadowStackFrame = m_module->m_gcShadowStackMgr.hasFrame() && function->getFunctionKind() != FunctionKind_Async;
[-] 		gcShadowStackTopVariable = m_module->m_variableMgr.getStdVariable (StdVariable_GcShadowStackTop);
[+] 		gcShadowStackTopVariable = m_module->m_variableMgr.getStdVariable(StdVariable_GcShadowStackTop);
[-] 		m_module->m_llvmIrBuilder.createLoad (gcShadowStackTopVariable, NULL, &prevGcShadowStackFrameValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(gcShadowStackTopVariable, NULL, &prevGcShadowStackFrameValue);
[-] 	size_t count = m_landingPadBlockArray.getCount ();
[+] 	size_t count = m_landingPadBlockArray.getCount();
[-] 		BasicBlock* block = m_landingPadBlockArray [i];
[+] 		BasicBlock* block = m_landingPadBlockArray[i];
[-] 		ASSERT (block->m_landingPadScope && !block->m_llvmBlock->empty ());
[+] 		ASSERT(block->m_landingPadScope && !block->m_llvmBlock->empty());
[-] 		m_module->m_llvmIrBuilder.setInsertPoint (&*block->m_llvmBlock->begin ());
[+] 		m_module->m_llvmIrBuilder.setInsertPoint(&*block->m_llvmBlock->begin());
[-] 		setSjljFrame (block->m_landingPadScope->m_sjljFrameIdx);
[+] 		setSjljFrame(block->m_landingPadScope->m_sjljFrameIdx);
[-] 			m_module->m_llvmIrBuilder.createStore (prevGcShadowStackFrameValue, gcShadowStackTopVariable);
[+] 			m_module->m_llvmIrBuilder.createStore(prevGcShadowStackFrameValue, gcShadowStackTopVariable);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_ControlFlowMgr_Stmt.cpp
----------------------
[-] ControlFlowMgr::ifStmt_Create (IfStmt* stmt)
[+] ControlFlowMgr::ifStmt_Create(IfStmt* stmt)
[-] 	stmt->m_thenBlock = createBlock ("if_then");
[+] 	stmt->m_thenBlock = createBlock("if_then");
[-] 	stmt->m_elseBlock = createBlock ("if_else");
[+] 	stmt->m_elseBlock = createBlock("if_else");
[-] ControlFlowMgr::ifStmt_Condition (
[+] ControlFlowMgr::ifStmt_Condition(
[-] 	bool result = conditionalJump (value, stmt->m_thenBlock, stmt->m_elseBlock);
[+] 	bool result = conditionalJump(value, stmt->m_thenBlock, stmt->m_elseBlock);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::ifStmt_Else (
[+] ControlFlowMgr::ifStmt_Else(
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	stmt->m_followBlock = createBlock ("if_follow");
[+] 	stmt->m_followBlock = createBlock("if_follow");
[-] 	jump (stmt->m_followBlock, stmt->m_elseBlock);
[+] 	jump(stmt->m_followBlock, stmt->m_elseBlock);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::ifStmt_Follow (IfStmt* stmt)
[+] ControlFlowMgr::ifStmt_Follow(IfStmt* stmt)
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	follow (stmt->m_followBlock);
[+] 	follow(stmt->m_followBlock);
[-] ControlFlowMgr::switchStmt_Create (SwitchStmt* stmt)
[+] ControlFlowMgr::switchStmt_Create(SwitchStmt* stmt)
[-] 	stmt->m_followBlock = createBlock ("switch_follow");
[+] 	stmt->m_followBlock = createBlock("switch_follow");
[-] ControlFlowMgr::switchStmt_Condition (
[+] ControlFlowMgr::switchStmt_Condition(
[-] 	bool result = m_module->m_operatorMgr.castOperator (value, TypeKind_Int, &stmt->m_value);
[+] 	bool result = m_module->m_operatorMgr.castOperator(value, TypeKind_Int, &stmt->m_value);
[-] 	stmt->m_switchBlock = getCurrentBlock ();
[+] 	stmt->m_switchBlock = getCurrentBlock();
[-] 	BasicBlock* bodyBlock = createBlock ("switch_body");
[+] 	BasicBlock* bodyBlock = createBlock("switch_body");
[-] 	setCurrentBlock (bodyBlock);
[+] 	setCurrentBlock(bodyBlock);
[-] 	markUnreachable (bodyBlock);
[+] 	markUnreachable(bodyBlock);
[-] 	Scope* scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	Scope* scope = m_module->m_namespaceMgr.openScope(pos);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::switchStmt_Case (
[+] ControlFlowMgr::switchStmt_Case(
[-] 	sl::HashTableIterator <intptr_t, BasicBlock*> it = stmt->m_caseMap.visit (value);
[+] 	sl::HashTableIterator<intptr_t, BasicBlock*> it = stmt->m_caseMap.visit(value);
[-] 		err::setFormatStringError ("redefinition of label (%d) of 'switch' statement", value);
[+] 		err::setFormatStringError("redefinition of label (%d) of 'switch' statement", value);
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	BasicBlock* block = createBlock ("switch_case");
[+] 	BasicBlock* block = createBlock("switch_case");
[-] 	follow (block);
[+] 	follow(block);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::switchStmt_Default (
[+] ControlFlowMgr::switchStmt_Default(
[-] 		err::setFormatStringError ("redefinition of 'default' label of 'switch' statement");
[+] 		err::setFormatStringError("redefinition of 'default' label of 'switch' statement");
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	BasicBlock* block = createBlock ("switch_default");
[+] 	BasicBlock* block = createBlock("switch_default");
[-] 	follow (block);
[+] 	follow(block);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::switchStmt_Follow (SwitchStmt* stmt)
[+] ControlFlowMgr::switchStmt_Follow(SwitchStmt* stmt)
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	follow (stmt->m_followBlock);
[+] 	follow(stmt->m_followBlock);
[-] 	setCurrentBlock (stmt->m_switchBlock);
[+] 	setCurrentBlock(stmt->m_switchBlock);
[-] 	m_module->m_llvmIrBuilder.createSwitch (
[+] 	m_module->m_llvmIrBuilder.createSwitch(
[-] 		stmt->m_caseMap.getHead (),
[+] 		stmt->m_caseMap.getHead(),
[-] 		stmt->m_caseMap.getCount ()
[+] 		stmt->m_caseMap.getCount()
[-] 	setCurrentBlock (stmt->m_followBlock);
[+] 	setCurrentBlock(stmt->m_followBlock);
[-] ControlFlowMgr::reSwitchStmt_Create (ReSwitchStmt* stmt)
[+] ControlFlowMgr::reSwitchStmt_Create(ReSwitchStmt* stmt)
[-] 	stmt->m_followBlock = createBlock ("reswitch_follow");
[+] 	stmt->m_followBlock = createBlock("reswitch_follow");
[-] ControlFlowMgr::reSwitchStmt_Condition (
[+] ControlFlowMgr::reSwitchStmt_Condition(
[-] 	ClassType* regexStateType = (ClassType*) m_module->m_typeMgr.getStdType (StdType_RegexState);
[+] 	ClassType* regexStateType = (ClassType*)m_module->m_typeMgr.getStdType(StdType_RegexState);
[-] 	ClassPtrType* regexStatePtrType = regexStateType->getClassPtrType (ClassPtrTypeKind_Normal, PtrTypeFlag_Safe);
[+] 	ClassPtrType* regexStatePtrType = regexStateType->getClassPtrType(ClassPtrTypeKind_Normal, PtrTypeFlag_Safe);
[-] 	Type* charPtrType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType (DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[+] 	Type* charPtrType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType(DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[-] 		m_module->m_operatorMgr.castOperator (regexStateValue, regexStatePtrType, &stmt->m_regexStateValue) &&
[+] 		m_module->m_operatorMgr.castOperator(regexStateValue, regexStatePtrType, &stmt->m_regexStateValue) &&
[-] 		m_module->m_operatorMgr.castOperator (dataValue, charPtrType, &stmt->m_dataValue);
[+] 		m_module->m_operatorMgr.castOperator(dataValue, charPtrType, &stmt->m_dataValue);
[-] 		stmt->m_sizeValue.setConstSizeT (-1, m_module);
[+] 		stmt->m_sizeValue.setConstSizeT(-1, m_module);
[-] 		result = m_module->m_operatorMgr.castOperator (sizeValue, TypeKind_SizeT, &stmt->m_sizeValue);
[+] 		result = m_module->m_operatorMgr.castOperator(sizeValue, TypeKind_SizeT, &stmt->m_sizeValue);
[-] 	stmt->m_switchBlock = getCurrentBlock ();
[+] 	stmt->m_switchBlock = getCurrentBlock();
[-] 	BasicBlock* bodyBlock = createBlock ("reswitch_body");
[+] 	BasicBlock* bodyBlock = createBlock("reswitch_body");
[-] 	setCurrentBlock (bodyBlock);
[+] 	setCurrentBlock(bodyBlock);
[-] 	markUnreachable (bodyBlock);
[+] 	markUnreachable(bodyBlock);
[-] 	Scope* scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	Scope* scope = m_module->m_namespaceMgr.openScope(pos);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::reSwitchStmt_Case (
[+] ControlFlowMgr::reSwitchStmt_Case(
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	BasicBlock* block = createBlock ("reswitch_case");
[+] 	BasicBlock* block = createBlock("reswitch_case");
[-] 	follow (block);
[+] 	follow(block);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] 	ReSwitchAcceptContext* context = AXL_MEM_NEW (ReSwitchAcceptContext);
[+] 	ReSwitchAcceptContext* context = AXL_MEM_NEW(ReSwitchAcceptContext);
[-] 	context->m_firstGroupId = stmt->m_regex.getGroupCount ();
[+] 	context->m_firstGroupId = stmt->m_regex.getGroupCount();
[-] 	stmt->m_acceptContextList.insertTail (context);
[+] 	stmt->m_acceptContextList.insertTail(context);
[-] 	fsm::RegexCompiler regexCompiler (&stmt->m_regex);
[+] 	fsm::RegexCompiler regexCompiler(&stmt->m_regex);
[-] 	return regexCompiler.incrementalCompile (regexSource, context);
[+] 	return regexCompiler.incrementalCompile(regexSource, context);
[-] ControlFlowMgr::reSwitchStmt_Default (
[+] ControlFlowMgr::reSwitchStmt_Default(
[-] 		err::setFormatStringError ("redefinition of 'default' label of 'regex switch' statement");
[+] 		err::setFormatStringError("redefinition of 'default' label of 'regex switch' statement");
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	BasicBlock* block = createBlock ("reswitch_default");
[+] 	BasicBlock* block = createBlock("reswitch_default");
[-] 	follow (block);
[+] 	follow(block);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::reSwitchStmt_Finalize (ReSwitchStmt* stmt)
[+] ControlFlowMgr::reSwitchStmt_Finalize(ReSwitchStmt* stmt)
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	follow (stmt->m_followBlock);
[+] 	follow(stmt->m_followBlock);
[-] 	setCurrentBlock (stmt->m_switchBlock);
[+] 	setCurrentBlock(stmt->m_switchBlock);
[-] 	fsm::RegexCompiler regexCompiler (&stmt->m_regex);
[+] 	fsm::RegexCompiler regexCompiler(&stmt->m_regex);
[-] 	regexCompiler.finalize ();
[+] 	regexCompiler.finalize();
[-] 	sl::Iterator <ReSwitchAcceptContext> prev = stmt->m_acceptContextList.getHead ();
[+] 	sl::Iterator<ReSwitchAcceptContext> prev = stmt->m_acceptContextList.getHead();
[-] 	sl::Iterator <ReSwitchAcceptContext> next = prev.getNext ();
[+] 	sl::Iterator<ReSwitchAcceptContext> next = prev.getNext();
[-] 		err::setError ("empty regex switch");
[+] 		err::setError("empty regex switch");
[-] 	prev->m_groupCount = stmt->m_regex.getGroupCount () - prev->m_firstGroupId;
[+] 	prev->m_groupCount = stmt->m_regex.getGroupCount() - prev->m_firstGroupId;
[-] 	Dfa* dfa = m_module->m_regexMgr.createDfa ();
[+] 	Dfa* dfa = m_module->m_regexMgr.createDfa();
[-] 	result = dfa->build (&stmt->m_regex);
[+] 	result = dfa->build(&stmt->m_regex);
[-] 	sl::Array <fsm::DfaState*> stateArray = stmt->m_regex.getDfaStateArray ();
[+] 	sl::Array<fsm::DfaState*> stateArray = stmt->m_regex.getDfaStateArray();
[-] 	sl::SimpleHashTable <intptr_t, BasicBlock*> caseMap;
[+] 	sl::SimpleHashTable<intptr_t, BasicBlock*> caseMap;
[-] 	size_t stateCount = stateArray.getCount ();
[+] 	size_t stateCount = stateArray.getCount();
[-] 		fsm::DfaState* state = stateArray [i];
[+] 		fsm::DfaState* state = stateArray[i];
[-] 			ReSwitchAcceptContext* context = (ReSwitchAcceptContext*) state->m_acceptContext;
[+] 			ReSwitchAcceptContext* context = (ReSwitchAcceptContext*)state->m_acceptContext;
[-] 			caseMap [state->m_id] = context->m_actionBlock;
[+] 			caseMap[state->m_id] = context->m_actionBlock;
[-] 	caseMap [rtl::RegexResult_Continue] = defaultBlock;
[+] 	caseMap[rtl::RegexResult_Continue] = defaultBlock;
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (stmt->m_switchBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(stmt->m_switchBlock);
[-] 	ClassType* regexStateType = (ClassType*) m_module->m_typeMgr.getStdType (StdType_RegexState);
[+] 	ClassType* regexStateType = (ClassType*)m_module->m_typeMgr.getStdType(StdType_RegexState);
[-] 	Function* execFunc = regexStateType->findFunctionByName ("exec");
[+] 	Function* execFunc = regexStateType->findFunctionByName("exec");
[-] 	ASSERT (execFunc);
[+] 	ASSERT(execFunc);
[-] 	Value dfaValue (&dfa, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value dfaValue(&dfa, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	result = m_module->m_operatorMgr.callOperator (
[+] 	result = m_module->m_operatorMgr.callOperator(
[-] 	m_module->m_llvmIrBuilder.createSwitch (
[+] 	m_module->m_llvmIrBuilder.createSwitch(
[-] 		caseMap.getHead (),
[+] 		caseMap.getHead(),
[-] 		caseMap.getCount ()
[+] 		caseMap.getCount()
[-] 	setCurrentBlock (stmt->m_followBlock);
[+] 	setCurrentBlock(stmt->m_followBlock);
[-] ControlFlowMgr::whileStmt_Create (WhileStmt* stmt)
[+] ControlFlowMgr::whileStmt_Create(WhileStmt* stmt)
[-] 	stmt->m_conditionBlock = createBlock ("while_condition");
[+] 	stmt->m_conditionBlock = createBlock("while_condition");
[-] 	stmt->m_bodyBlock = createBlock ("while_body");
[+] 	stmt->m_bodyBlock = createBlock("while_body");
[-] 	stmt->m_followBlock = createBlock ("while_follow");
[+] 	stmt->m_followBlock = createBlock("while_follow");
[-] 	follow (stmt->m_conditionBlock);
[+] 	follow(stmt->m_conditionBlock);
[-] ControlFlowMgr::whileStmt_Condition (
[+] ControlFlowMgr::whileStmt_Condition(
[-] 	m_module->m_operatorMgr.gcSafePoint ();
[+] 	m_module->m_operatorMgr.gcSafePoint();
[-] 	Scope* scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	Scope* scope = m_module->m_namespaceMgr.openScope(pos);
[-] 	return conditionalJump (value, stmt->m_bodyBlock, stmt->m_followBlock);
[+] 	return conditionalJump(value, stmt->m_bodyBlock, stmt->m_followBlock);
[-] ControlFlowMgr::whileStmt_Follow (WhileStmt* stmt)
[+] ControlFlowMgr::whileStmt_Follow(WhileStmt* stmt)
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	jump (stmt->m_conditionBlock, stmt->m_followBlock);
[+] 	jump(stmt->m_conditionBlock, stmt->m_followBlock);
[-] ControlFlowMgr::doStmt_Create (DoStmt* stmt)
[+] ControlFlowMgr::doStmt_Create(DoStmt* stmt)
[-] 	stmt->m_conditionBlock = createBlock ("do_condition");
[+] 	stmt->m_conditionBlock = createBlock("do_condition");
[-] 	stmt->m_bodyBlock = createBlock ("do_body");
[+] 	stmt->m_bodyBlock = createBlock("do_body");
[-] 	stmt->m_followBlock = createBlock ("do_follow");
[+] 	stmt->m_followBlock = createBlock("do_follow");
[-] 	follow (stmt->m_bodyBlock);
[+] 	follow(stmt->m_bodyBlock);
[-] ControlFlowMgr::doStmt_PreBody (
[+] ControlFlowMgr::doStmt_PreBody(
[-] 	m_module->m_operatorMgr.gcSafePoint ();
[+] 	m_module->m_operatorMgr.gcSafePoint();
[-] 	Scope* scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	Scope* scope = m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::doStmt_PostBody (DoStmt* stmt)
[+] ControlFlowMgr::doStmt_PostBody(DoStmt* stmt)
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	follow (stmt->m_conditionBlock);
[+] 	follow(stmt->m_conditionBlock);
[-] ControlFlowMgr::doStmt_Condition (
[+] ControlFlowMgr::doStmt_Condition(
[-] 	return conditionalJump (value, stmt->m_bodyBlock, stmt->m_followBlock, stmt->m_followBlock);
[+] 	return conditionalJump(value, stmt->m_bodyBlock, stmt->m_followBlock, stmt->m_followBlock);
[-] ControlFlowMgr::forStmt_Create (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_Create(ForStmt* stmt)
[-] 	stmt->m_bodyBlock = createBlock ("for_body");
[+] 	stmt->m_bodyBlock = createBlock("for_body");
[-] 	stmt->m_followBlock = createBlock ("for_follow");
[+] 	stmt->m_followBlock = createBlock("for_follow");
[-] ControlFlowMgr::forStmt_PreInit (
[+] ControlFlowMgr::forStmt_PreInit(
[-] 	stmt->m_scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	stmt->m_scope = m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::forStmt_NoCondition (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_NoCondition(ForStmt* stmt)
[-] 	follow (stmt->m_bodyBlock);
[+] 	follow(stmt->m_bodyBlock);
[-] ControlFlowMgr::forStmt_PreCondition (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_PreCondition(ForStmt* stmt)
[-] 	stmt->m_conditionBlock = createBlock ("for_condition");
[+] 	stmt->m_conditionBlock = createBlock("for_condition");
[-] 	follow (stmt->m_conditionBlock);
[+] 	follow(stmt->m_conditionBlock);
[-] ControlFlowMgr::forStmt_PostCondition (
[+] ControlFlowMgr::forStmt_PostCondition(
[-] 	return conditionalJump (value, stmt->m_bodyBlock, stmt->m_followBlock);
[+] 	return conditionalJump(value, stmt->m_bodyBlock, stmt->m_followBlock);
[-] ControlFlowMgr::forStmt_PreLoop (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_PreLoop(ForStmt* stmt)
[-] 	stmt->m_loopBlock = createBlock ("for_loop", m_currentBlock->m_flags & BasicBlockFlag_Reachable);
[+] 	stmt->m_loopBlock = createBlock("for_loop", m_currentBlock->m_flags & BasicBlockFlag_Reachable);
[-] 	setCurrentBlock (stmt->m_loopBlock);
[+] 	setCurrentBlock(stmt->m_loopBlock);
[-] ControlFlowMgr::forStmt_PostLoop (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_PostLoop(ForStmt* stmt)
[-] 	jump (stmt->m_conditionBlock, stmt->m_bodyBlock);
[+] 	jump(stmt->m_conditionBlock, stmt->m_bodyBlock);
[-] ControlFlowMgr::forStmt_PreBody (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_PreBody(ForStmt* stmt)
[-] 	m_module->m_operatorMgr.gcSafePoint ();
[+] 	m_module->m_operatorMgr.gcSafePoint();
[-] ControlFlowMgr::forStmt_PostBody (ForStmt* stmt)
[+] ControlFlowMgr::forStmt_PostBody(ForStmt* stmt)
[-] 	jump (stmt->m_loopBlock, stmt->m_followBlock);
[+] 	jump(stmt->m_loopBlock, stmt->m_followBlock);
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	if (!(stmt->m_followBlock->getFlags () & BasicBlockFlag_Jumped))
[+] 	if (!(stmt->m_followBlock->getFlags() & BasicBlockFlag_Jumped))
[-] 		markUnreachable (stmt->m_followBlock);
[+] 		markUnreachable(stmt->m_followBlock);
[-] ControlFlowMgr::onceStmt_Create (
[+] ControlFlowMgr::onceStmt_Create(
[-] 		err::setFormatStringError ("'%s once' is illegal (only 'static' or 'threadlocal' is allowed)", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("'%s once' is illegal (only 'static' or 'threadlocal' is allowed)", getStorageKindString (storageKind));
[-] 	flagVariable = m_module->m_variableMgr.createOnceFlagVariable (storageKind);
[+] 	flagVariable = m_module->m_variableMgr.createOnceFlagVariable(storageKind);
[-] 		BasicBlock* block = setCurrentBlock (m_module->getConstructor ()->getPrologueBlock ());
[+] 		BasicBlock* block = setCurrentBlock(m_module->getConstructor()->getPrologueBlock());
[-] 		m_module->m_operatorMgr.zeroInitialize (flagVariable);
[+] 		m_module->m_operatorMgr.zeroInitialize(flagVariable);
[-] 		setCurrentBlock (block);
[+] 		setCurrentBlock(block);
[-] 	onceStmt_Create (stmt, flagVariable);
[+] 	onceStmt_Create(stmt, flagVariable);
[-] ControlFlowMgr::onceStmt_Create (
[+] ControlFlowMgr::onceStmt_Create(
[-] 	stmt->m_followBlock = createBlock ("once_follow");
[+] 	stmt->m_followBlock = createBlock("once_follow");
[-] ControlFlowMgr::onceStmt_PreBody (
[+] ControlFlowMgr::onceStmt_PreBody(
[-] 	StorageKind storageKind = stmt->m_flagVariable->getStorageKind ();
[+] 	StorageKind storageKind = stmt->m_flagVariable->getStorageKind();
[-] 	ASSERT (storageKind == StorageKind_Static || storageKind == StorageKind_Tls);
[+] 	ASSERT(storageKind == StorageKind_Static || storageKind == StorageKind_Tls);
[-] 	m_module->m_namespaceMgr.setSourcePos (pos);
[+] 	m_module->m_namespaceMgr.setSourcePos(pos);
[-] 	Type* type = stmt->m_flagVariable->getType ();
[+] 	Type* type = stmt->m_flagVariable->getType();
[-] 		BasicBlock* bodyBlock = createBlock ("once_body");
[+] 		BasicBlock* bodyBlock = createBlock("once_body");
[-] 			m_module->m_operatorMgr.binaryOperator (BinOpKind_Eq, stmt->m_flagVariable, Value ((int64_t) 0, type), &value) &&
[+] 			m_module->m_operatorMgr.binaryOperator(BinOpKind_Eq, stmt->m_flagVariable, Value((int64_t) 0, type), &value) &&
[-] 			conditionalJump (value, bodyBlock, stmt->m_followBlock);
[+] 			conditionalJump(value, bodyBlock, stmt->m_followBlock);
[-] 		result = m_module->m_operatorMgr.loadDataRef (stmt->m_flagVariable, &value);
[+] 		result = m_module->m_operatorMgr.loadDataRef(stmt->m_flagVariable, &value);
[-] 		BasicBlock* preBodyBlock = createBlock ("once_prebody");
[+] 		BasicBlock* preBodyBlock = createBlock("once_prebody");
[-] 		BasicBlock* bodyBlock = createBlock ("once_body");
[+] 		BasicBlock* bodyBlock = createBlock("once_body");
[-] 		BasicBlock* loopBlock = createBlock ("once_loop");
[+] 		BasicBlock* loopBlock = createBlock("once_loop");
[-] 		intptr_t constArray [2] = { 0, 1 };
[+] 		intptr_t constArray[2] = { 0, 1 };
[-] 		BasicBlock* blockArray [2] = { preBodyBlock, loopBlock };
[+] 		BasicBlock* blockArray[2] = { preBodyBlock, loopBlock };
[-] 		m_module->m_llvmIrBuilder.createSwitch (value, stmt->m_followBlock, constArray, blockArray, 2);
[+] 		m_module->m_llvmIrBuilder.createSwitch(value, stmt->m_followBlock, constArray, blockArray, 2);
[-] 		setCurrentBlock (loopBlock);
[+] 		setCurrentBlock(loopBlock);
[-] 			m_module->m_operatorMgr.binaryOperator (BinOpKind_Eq, stmt->m_flagVariable, Value (2, type), &value) &&
[+] 			m_module->m_operatorMgr.binaryOperator(BinOpKind_Eq, stmt->m_flagVariable, Value(2, type), &value) &&
[-] 			conditionalJump (value, stmt->m_followBlock, loopBlock, preBodyBlock);
[+] 			conditionalJump(value, stmt->m_followBlock, loopBlock, preBodyBlock);
[-] 		m_module->m_llvmIrBuilder.createCmpXchg (
[+] 		m_module->m_llvmIrBuilder.createCmpXchg(
[-] 			Value ((int64_t) 0, type),
[+] 			Value((int64_t) 0, type),
[-] 			Value (1, type),
[+] 			Value(1, type),
[-] 			m_module->m_operatorMgr.binaryOperator (BinOpKind_Eq, value, Value ((int64_t) 0, type), &value) &&
[+] 			m_module->m_operatorMgr.binaryOperator(BinOpKind_Eq, value, Value((int64_t) 0, type), &value) &&
[-] 			conditionalJump (value, bodyBlock, loopBlock);
[+] 			conditionalJump(value, bodyBlock, loopBlock);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (value, 1, m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool), &value);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(value, 1, m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool), &value);
[-] 		result = conditionalJump (value, bodyBlock, loopBlock);
[+] 		result = conditionalJump(value, bodyBlock, loopBlock);
[-] 	m_module->m_namespaceMgr.openScope (pos);
[+] 	m_module->m_namespaceMgr.openScope(pos);
[-] ControlFlowMgr::onceStmt_PostBody (
[+] ControlFlowMgr::onceStmt_PostBody(
[-] 	StorageKind storageKind = stmt->m_flagVariable->getStorageKind ();
[+] 	StorageKind storageKind = stmt->m_flagVariable->getStorageKind();
[-] 	ASSERT (storageKind == StorageKind_Static || storageKind == StorageKind_Tls);
[+] 	ASSERT(storageKind == StorageKind_Static || storageKind == StorageKind_Tls);
[-] 	Type* type = stmt->m_flagVariable->getType ();
[+] 	Type* type = stmt->m_flagVariable->getType();
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	m_module->m_namespaceMgr.setSourcePos (pos);
[+] 	m_module->m_namespaceMgr.setSourcePos(pos);
[-] 		m_module->m_llvmIrBuilder.createStore (
[+] 		m_module->m_llvmIrBuilder.createStore(
[-] 			Value ((int64_t) 2, type),
[+] 			Value((int64_t) 2, type),
[-] 		m_module->m_llvmIrBuilder.createRmw (
[+] 		m_module->m_llvmIrBuilder.createRmw(
[-] 			Value ((int64_t) 2, type),
[+] 			Value((int64_t) 2, type),
[-] 	follow (stmt->m_followBlock);
[+] 	follow(stmt->m_followBlock);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_BasicBlock.h
----------------------
[-] 	sl::SimpleHashTable <size_t, BasicBlock*> m_finallyRouteMap;
[+] 	sl::SimpleHashTable<size_t, BasicBlock*> m_finallyRouteMap;
[-] 	BasicBlock ();
[+] 	BasicBlock();
[-] 	getFlags ()
[+] 	getFlags()
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_llvmBlock->getInstList ().empty ();
[+] 		return m_llvmBlock->getInstList().empty();
[-] 	getInstructionCount ()
[+] 	getInstructionCount()
[-] 		return m_llvmBlock->getInstList ().size ();
[+] 		return m_llvmBlock->getInstList().size();
[-] 	hasTerminator ()
[+] 	hasTerminator()
[-] 		return m_llvmBlock->getTerminator () != NULL;
[+] 		return m_llvmBlock->getTerminator() != NULL;
[-] 	hasReturn ()
[+] 	hasReturn()
[-] 		llvm::TerminatorInst* inst = m_llvmBlock->getTerminator ();
[+] 		llvm::TerminatorInst* inst = m_llvmBlock->getTerminator();
[-] 		return inst && inst->getOpcode () == llvm::Instruction::Ret;
[+] 		return inst && inst->getOpcode() == llvm::Instruction::Ret;
[-] 	getName ()
[+] 	getName()
[-] 	getFunction ()
[+] 	getFunction()
[-] 	getLandingPadKind ()
[+] 	getLandingPadKind()
[-] 	getLandingPadScope ()
[+] 	getLandingPadScope()
[-] 	getLlvmBlock ()
[+] 	getLlvmBlock()
[-] 	getBlockAddressValue ();
[+] 	getBlockAddressValue();
[-] 	markEntry ()
[+] 	markEntry()
[-] 	markReachable ()
[+] 	markReachable()
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_ControlFlowMgr\jnc_ct_ControlFlowMgr.h
----------------------
[-] 	sl::SimpleHashTable <intptr_t, BasicBlock*> m_caseMap;
[+] 	sl::SimpleHashTable<intptr_t, BasicBlock*> m_caseMap;
[-] 	sl::List <ReSwitchAcceptContext> m_acceptContextList;
[+] 	sl::List<ReSwitchAcceptContext> m_acceptContextList;
[-] 	sl::List <BasicBlock> m_blockList;
[+] 	sl::List<BasicBlock> m_blockList;
[-] 	sl::Array <BasicBlock*> m_asyncBlockArray;
[+] 	sl::Array<BasicBlock*> m_asyncBlockArray;
[-] 	sl::Array <BasicBlock*> m_returnBlockArray;
[+] 	sl::Array<BasicBlock*> m_returnBlockArray;
[-] 	sl::Array <BasicBlock*> m_landingPadBlockArray;
[+] 	sl::Array<BasicBlock*> m_landingPadBlockArray;
[-] 	ControlFlowMgr ();
[+] 	ControlFlowMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	createBlock (
[+] 	createBlock(
[-] 	createAsyncBlock (Scope* scope);
[+] 	createAsyncBlock(Scope* scope);
[-] 	getCurrentBlock ()
[+] 	getCurrentBlock()
[-] 	setCurrentBlock (BasicBlock* block); // returns prev
[+] 	setCurrentBlock(BasicBlock* block); // returns prev
[-] 	markUnreachable (BasicBlock* block);
[+] 	markUnreachable(BasicBlock* block);
[-] 	markLandingPad (
[+] 	markLandingPad(
[-] 	deleteUnreachableBlocks ();
[+] 	deleteUnreachableBlocks();
[-] 	sl::Array <BasicBlock*>
[+] 	sl::Array<BasicBlock*>
[-] 	getAsyncBlockArray ()
[+] 	getAsyncBlockArray()
[-] 	sl::Array <BasicBlock*>
[+] 	sl::Array<BasicBlock*>
[-] 	getReturnBlockArray ()
[+] 	getReturnBlockArray()
[-] 	sl::Array <BasicBlock*>
[+] 	sl::Array<BasicBlock*>
[-] 	getLandingPadBlockArray ()
[+] 	getLandingPadBlockArray()
[-] 	finalizeFunction ();
[+] 	finalizeFunction();
[-] 	jump (
[+] 	jump(
[-] 	follow (BasicBlock* block);
[+] 	follow(BasicBlock* block);
[-] 	conditionalJump (
[+] 	conditionalJump(
[-] 	breakJump (size_t level);
[+] 	breakJump(size_t level);
[-] 	continueJump (size_t level);
[+] 	continueJump(size_t level);
[-] 	ret (const Value& value);
[+] 	ret(const Value& value);
[-] 	ret ()
[+] 	ret()
[-] 		return ret (Value ());
[+] 		return ret(Value());
[-] 	asyncRet (BasicBlock* nextBlock);
[+] 	asyncRet(BasicBlock* nextBlock);
[-] 	checkReturn ();
[+] 	checkReturn();
[-] 	beginTryOperator (TryExpr* tryExpr);
[+] 	beginTryOperator(TryExpr* tryExpr);
[-] 	endTryOperator (
[+] 	endTryOperator(
[-] 	throwException ();
[+] 	throwException();
[-] 	throwExceptionIf (
[+] 	throwExceptionIf(
[-] 	setJmp (
[+] 	setJmp(
[-] 	setJmpFinally (
[+] 	setJmpFinally(
[-] 	finalizeTryScope (Scope* scope);
[+] 	finalizeTryScope(Scope* scope);
[-] 	catchLabel (const Token::Pos& pos);
[+] 	catchLabel(const Token::Pos& pos);
[-] 	finalizeCatchScope (Scope* scope);
[+] 	finalizeCatchScope(Scope* scope);
[-] 	finallyLabel (const Token::Pos& pos);
[+] 	finallyLabel(const Token::Pos& pos);
[-] 	finalizeFinallyScope (Scope* scope);
[+] 	finalizeFinallyScope(Scope* scope);
[-] 	finalizeDisposableScope (Scope* scope);
[+] 	finalizeDisposableScope(Scope* scope);
[-] 	disposeVariable (Variable* variable);
[+] 	disposeVariable(Variable* variable);
[-] 	ifStmt_Create (IfStmt* stmt);
[+] 	ifStmt_Create(IfStmt* stmt);
[-] 	ifStmt_Condition (
[+] 	ifStmt_Condition(
[-] 	ifStmt_Else (
[+] 	ifStmt_Else(
[-] 	ifStmt_Follow (IfStmt* stmt);
[+] 	ifStmt_Follow(IfStmt* stmt);
[-] 	switchStmt_Create (SwitchStmt* stmt);
[+] 	switchStmt_Create(SwitchStmt* stmt);
[-] 	switchStmt_Condition (
[+] 	switchStmt_Condition(
[-] 	switchStmt_Case (
[+] 	switchStmt_Case(
[-] 	switchStmt_Default (
[+] 	switchStmt_Default(
[-] 	switchStmt_Follow (SwitchStmt* stmt);
[+] 	switchStmt_Follow(SwitchStmt* stmt);
[-] 	reSwitchStmt_Create (ReSwitchStmt* stmt);
[+] 	reSwitchStmt_Create(ReSwitchStmt* stmt);
[-] 	reSwitchStmt_Condition (
[+] 	reSwitchStmt_Condition(
[-] 	reSwitchStmt_Case (
[+] 	reSwitchStmt_Case(
[-] 	reSwitchStmt_Default (
[+] 	reSwitchStmt_Default(
[-] 	reSwitchStmt_Finalize (ReSwitchStmt* stmt);
[+] 	reSwitchStmt_Finalize(ReSwitchStmt* stmt);
[-] 	whileStmt_Create (WhileStmt* stmt);
[+] 	whileStmt_Create(WhileStmt* stmt);
[-] 	whileStmt_Condition (
[+] 	whileStmt_Condition(
[-] 	whileStmt_Follow (WhileStmt* stmt);
[+] 	whileStmt_Follow(WhileStmt* stmt);
[-] 	doStmt_Create (DoStmt* stmt);
[+] 	doStmt_Create(DoStmt* stmt);
[-] 	doStmt_PreBody (
[+] 	doStmt_PreBody(
[-] 	doStmt_PostBody (DoStmt* stmt);
[+] 	doStmt_PostBody(DoStmt* stmt);
[-] 	doStmt_Condition (
[+] 	doStmt_Condition(
[-] 	forStmt_Create (ForStmt* stmt);
[+] 	forStmt_Create(ForStmt* stmt);
[-] 	forStmt_PreInit (
[+] 	forStmt_PreInit(
[-] 	forStmt_NoCondition (ForStmt* stmt);
[+] 	forStmt_NoCondition(ForStmt* stmt);
[-] 	forStmt_PreCondition (ForStmt* stmt);
[+] 	forStmt_PreCondition(ForStmt* stmt);
[-] 	forStmt_PostCondition (
[+] 	forStmt_PostCondition(
[-] 	forStmt_PreLoop (ForStmt* stmt);
[+] 	forStmt_PreLoop(ForStmt* stmt);
[-] 	forStmt_PostLoop (ForStmt* stmt);
[+] 	forStmt_PostLoop(ForStmt* stmt);
[-] 	forStmt_PreBody (ForStmt* stmt);
[+] 	forStmt_PreBody(ForStmt* stmt);
[-] 	forStmt_PostBody (ForStmt* stmt);
[+] 	forStmt_PostBody(ForStmt* stmt);
[-] 	onceStmt_Create (
[+] 	onceStmt_Create(
[-] 	onceStmt_Create (
[+] 	onceStmt_Create(
[-] 	onceStmt_PreBody (
[+] 	onceStmt_PreBody(
[-] 	onceStmt_PostBody (
[+] 	onceStmt_PostBody(
[-] 	getFinallyRouteIdxVariable ();
[+] 	getFinallyRouteIdxVariable();
[-] 	addBlock (BasicBlock* block);
[+] 	addBlock(BasicBlock* block);
[-] 	escapeScope (
[+] 	escapeScope(
[-] 	getUnreachableBlock ();
[+] 	getUnreachableBlock();
[-] 	getReturnBlock ();
[+] 	getReturnBlock();
[-] 	getDynamicThrowBlock ();
[+] 	getDynamicThrowBlock();
[-] 	getReturnValueVariable ();
[+] 	getReturnValueVariable();
[-] 	normalFinallyFlow ();
[+] 	normalFinallyFlow();
[-] 	preCreateSjljFrameArray ();
[+] 	preCreateSjljFrameArray();
[-] 	finalizeSjljFrameArray ();
[+] 	finalizeSjljFrameArray();
[-] 	setSjljFrame (size_t index);
[+] 	setSjljFrame(size_t index);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyBlock.cpp
----------------------
[-] DoxyBlock::DoxyBlock ()
[+] DoxyBlock::DoxyBlock()
[-] DoxyBlock::getRefId ()
[+] DoxyBlock::getRefId()
[-] 	if (!m_refId.isEmpty ())
[+] 	if (!m_refId.isEmpty())
[-] 	ASSERT (m_item);
[+] 	ASSERT(m_item);
[-] 	m_refId = m_item->createDoxyRefId ();
[+] 	m_refId = m_item->createDoxyRefId();
[-] DoxyBlock::getDescriptionString ()
[+] DoxyBlock::getDescriptionString()
[-] 	m_briefDescription.trim ();
[+] 	m_briefDescription.trim();
[-] 	m_detailedDescription.trim ();
[+] 	m_detailedDescription.trim();
[-] 	m_seeAlsoDescription.trim ();
[+] 	m_seeAlsoDescription.trim();
[-] 	if (!m_briefDescription.isEmpty ())
[+] 	if (!m_briefDescription.isEmpty())
[-] 		string.append ("<briefdescription><para>");
[+] 		string.append("<briefdescription><para>");
[-] 		appendXmlElementContents (&string, m_briefDescription);
[+] 		appendXmlElementContents(&string, m_briefDescription);
[-] 		string.append ("</para></briefdescription>\n");
[+] 		string.append("</para></briefdescription>\n");
[-] 	if (!m_detailedDescription.isEmpty () ||
[+] 	if (!m_detailedDescription.isEmpty() ||
[-] 		!m_seeAlsoDescription.isEmpty () ||
[+] 		!m_seeAlsoDescription.isEmpty() ||
[-] 		!m_internalDescription.isEmpty ()
[+] 		!m_internalDescription.isEmpty()
[-] 		string.append ("<detaileddescription>\n");
[+] 		string.append("<detaileddescription>\n");
[-] 		if (!m_detailedDescription.isEmpty ())
[+] 		if (!m_detailedDescription.isEmpty())
[-] 			string.append ("<para>");
[+] 			string.append("<para>");
[-] 			appendXmlElementContents (&string, m_detailedDescription);
[+] 			appendXmlElementContents(&string, m_detailedDescription);
[-] 			string.append ("</para>\n");
[+] 			string.append("</para>\n");
[-] 		if (!m_seeAlsoDescription.isEmpty ())
[+] 		if (!m_seeAlsoDescription.isEmpty())
[-] 			string.append ("<para><simplesect kind='see'><para>");
[+] 			string.append("<para><simplesect kind='see'><para>");
[-] 			appendXmlElementContents (&string, m_seeAlsoDescription);
[+] 			appendXmlElementContents(&string, m_seeAlsoDescription);
[-] 			string.append ("</para></simplesect></para>\n");
[+] 			string.append("</para></simplesect></para>\n");
[-] 		if (!m_internalDescription.isEmpty ())
[+] 		if (!m_internalDescription.isEmpty())
[-] 			string.append ("<internal><para>");
[+] 			string.append("<internal><para>");
[-] 			appendXmlElementContents (&string, m_internalDescription);
[+] 			appendXmlElementContents(&string, m_internalDescription);
[-] 			string.append ("</para></internal>\n");
[+] 			string.append("</para></internal>\n");
[-] 		string.append ("</detaileddescription>\n");
[+] 		string.append("</detaileddescription>\n");
[-] DoxyBlock::getFootnoteString ()
[+] DoxyBlock::getFootnoteString()
[-] 	size_t count = m_footnoteArray.getCount ();
[+] 	size_t count = m_footnoteArray.getCount();
[-] 		DoxyBlock* footnote = m_footnoteArray [i];
[+] 		DoxyBlock* footnote = m_footnoteArray[i];
[-] 		string.append ("<memberdef kind='footnote'>\n");
[+] 		string.append("<memberdef kind='footnote'>\n");
[-] 		string.appendFormat ("<name>%s</name>\n", footnote->getRefId ().sz ());
[+] 		string.appendFormat("<name>%s</name>\n", footnote->getRefId ().sz ());
[-] 		string.append (footnote->getDescriptionString ());
[+] 		string.append(footnote->getDescriptionString());
[-] 		string.append ("</memberdef>\n");
[+] 		string.append("</memberdef>\n");
[-] DoxyBlock::getImportString ()
[+] DoxyBlock::getImportString()
[-] 	sl::BoxIterator <sl::String> it = m_importList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_importList.getHead();
[-] 		string.appendFormat ("<includes>%s</includes>\n", it->sz ());
[+] 		string.appendFormat("<includes>%s</includes>\n", it->sz ());
[-] appendXmlElementContents (
[+] appendXmlElementContents(
[-] 	if (contents.findOneOf ("<>&") == -1)
[+] 	if (contents.findOneOf("<>&") == -1)
[-] 		string->append (contents);
[+] 		string->append(contents);
[-] 		string->append ("<![CDATA[");
[+] 		string->append("<![CDATA[");
[-] 		string->append (contents);
[+] 		string->append(contents);
[-] 		string->append ("]]>");
[+] 		string->append("]]>");
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyGroup.cpp
----------------------
[-] DoxyGroup::generateDocumentation (
[+] DoxyGroup::generateDocumentation(
[-] 	indexXml->appendFormat (
[+] 	indexXml->appendFormat(
[-] 		m_refId.sz (),
[+] 		m_refId.sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		m_refId.sz (),
[+] 		m_refId.sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	appendXmlElementContents (itemXml, m_title);
[+] 	appendXmlElementContents(itemXml, m_title);
[-] 	itemXml->append ("</title>\n");
[+] 	itemXml->append("</title>\n");
[-] 	size_t count = m_itemArray.getCount ();
[+] 	size_t count = m_itemArray.getCount();
[-] 		ModuleItem* item = m_itemArray [i];
[+] 		ModuleItem* item = m_itemArray[i];
[-] 		ModuleItemDecl* decl = item->getDecl ();
[+] 		ModuleItemDecl* decl = item->getDecl();
[-] 		ModuleItemKind itemKind = item->getItemKind ();
[+] 		ModuleItemKind itemKind = item->getItemKind();
[-] 			itemKind == ModuleItemKind_Type && ((Type*) item)->getTypeKind () != TypeKind_Enum;
[+] 			itemKind == ModuleItemKind_Type && ((Type*)item)->getTypeKind() != TypeKind_Enum;
[-] 		sl::String refId = item->getDoxyBlock ()->getRefId ();
[+] 		sl::String refId = item->getDoxyBlock()->getRefId();
[-] 			sectionDef.appendFormat ("<memberdef id='%s'/>", refId.sz ());
[+] 			sectionDef.appendFormat("<memberdef id='%s'/>", refId.sz ());
[-] 			sectionDef.append ('\n');
[+] 			sectionDef.append('\n');
[-] 			sl::String refId = item->getDoxyBlock ()->getRefId ();
[+] 			sl::String refId = item->getDoxyBlock()->getRefId();
[-] 			itemXml->appendFormat ("<%s refid='%s'/>", elemName, refId.sz ());
[+] 			itemXml->appendFormat("<%s refid='%s'/>", elemName, refId.sz ());
[-] 			itemXml->append ('\n');
[+] 			itemXml->append('\n');
[-] 	sectionDef += getFootnoteString ();
[+] 	sectionDef += getFootnoteString();
[-] 	if (!sectionDef.isEmpty ())
[+] 	if (!sectionDef.isEmpty())
[-] 		itemXml->append ("<sectiondef>\n");
[+] 		itemXml->append("<sectiondef>\n");
[-] 		itemXml->append (sectionDef);
[+] 		itemXml->append(sectionDef);
[-] 		itemXml->append ("</sectiondef>\n");
[+] 		itemXml->append("</sectiondef>\n");
[-] 	sl::BoxIterator <DoxyGroup*> groupIt = m_groupList.getHead ();
[+] 	sl::BoxIterator<DoxyGroup*> groupIt = m_groupList.getHead();
[-] 		itemXml->appendFormat ("<innergroup refid='%s'/>", group->m_refId.sz ());
[+] 		itemXml->appendFormat("<innergroup refid='%s'/>", group->m_refId.sz ());
[-] 		itemXml->append ('\n');
[+] 		itemXml->append('\n');
[-] 	itemXml->append (getImportString ());
[+] 	itemXml->append(getImportString());
[-] 	itemXml->append (getDescriptionString ());
[+] 	itemXml->append(getDescriptionString());
[-] 	itemXml->append ("</compounddef>\n");
[+] 	itemXml->append("</compounddef>\n");
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyLexer.cpp
----------------------
[-] DoxyLexer::createTextToken (DoxyTokenKind tokenKind)
[+] DoxyLexer::createTextToken(DoxyTokenKind tokenKind)
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] 	token->m_data.m_string = sl::StringRef (ts, te - ts);
[+] 	token->m_data.m_string = sl::StringRef(ts, te - ts);
[-] DoxyLexer::createNewLineToken ()
[+] DoxyLexer::createNewLineToken()
[-] 	ASSERT (*ts == '\n');
[+] 	ASSERT(*ts == '\n');
[-] 	Token* token = createToken ('\n');
[+] 	Token* token = createToken('\n');
[-] 	token->m_data.m_string = sl::StringRef (ts + 1, te - ts - 1);
[+] 	token->m_data.m_string = sl::StringRef(ts + 1, te - ts - 1);
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyMgr.cpp
----------------------
[-] DoxyMgr::DoxyMgr ()
[+] DoxyMgr::DoxyMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] DoxyMgr::clear ()
[+] DoxyMgr::clear()
[-] 	m_blockList.clear ();
[+] 	m_blockList.clear();
[-] 	m_groupList.clear ();
[+] 	m_groupList.clear();
[-] 	m_refIdMap.clear ();
[+] 	m_refIdMap.clear();
[-] 	m_groupMap.clear ();
[+] 	m_groupMap.clear();
[-] 	m_targetList.clear ();
[+] 	m_targetList.clear();
[-] DoxyMgr::getGroup (const sl::StringRef& name)
[+] DoxyMgr::getGroup(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <DoxyGroup*> it = m_groupMap.visit (name);
[+] 	sl::StringHashTableIterator<DoxyGroup*> it = m_groupMap.visit(name);
[-] 	refId.format ("group_%s", name.sz ());
[+] 	refId.format("group_%s", name.sz ());
[-] 	refId.replace ('-', '_');
[+] 	refId.replace('-', '_');
[-] 	DoxyGroup* group = AXL_MEM_NEW (DoxyGroup);
[+] 	DoxyGroup* group = AXL_MEM_NEW(DoxyGroup);
[-] 	group->m_refId = adjustRefId (refId);
[+] 	group->m_refId = adjustRefId(refId);
[-] 	m_groupList.insertTail (group);
[+] 	m_groupList.insertTail(group);
[-] DoxyMgr::createBlock ()
[+] DoxyMgr::createBlock()
[-] 	DoxyBlock* block = AXL_MEM_NEW (DoxyBlock);
[+] 	DoxyBlock* block = AXL_MEM_NEW(DoxyBlock);
[-] 	m_blockList.insertTail (block);
[+] 	m_blockList.insertTail(block);
[-] DoxyMgr::createFootnote ()
[+] DoxyMgr::createFootnote()
[-] 	DoxyFootnote* footnote = AXL_MEM_NEW (DoxyFootnote);
[+] 	DoxyFootnote* footnote = AXL_MEM_NEW(DoxyFootnote);
[-] 	m_blockList.insertTail (footnote);
[+] 	m_blockList.insertTail(footnote);
[-] DoxyMgr::adjustRefId (const sl::StringRef& refId)
[+] DoxyMgr::adjustRefId(const sl::StringRef& refId)
[-] 	sl::StringHashTableIterator <size_t> it = m_refIdMap.visit (refId);
[+] 	sl::StringHashTableIterator<size_t> it = m_refIdMap.visit(refId);
[-] 	adjustedRefId.format ("%s_%d", refId.sz (), it->m_value);
[+] 	adjustedRefId.format("%s_%d", refId.sz (), it->m_value);
[-] DoxyMgr::setBlockTarget (
[+] DoxyMgr::setBlockTarget(
[-] 	Target* target = AXL_MEM_NEW (Target);
[+] 	Target* target = AXL_MEM_NEW(Target);
[-] 	m_targetList.insertTail (target);
[+] 	m_targetList.insertTail(target);
[-] DoxyMgr::resolveBlockTargets ()
[+] DoxyMgr::resolveBlockTargets()
[-] 	GlobalNamespace* globalNspace = m_module->m_namespaceMgr.getGlobalNamespace ();
[+] 	GlobalNamespace* globalNspace = m_module->m_namespaceMgr.getGlobalNamespace();
[-] 	sl::Iterator <Target> it = m_targetList.getHead ();
[+] 	sl::Iterator<Target> it = m_targetList.getHead();
[-] 		if (prevNspace && target->m_itemName.find ('.') == -1)
[+] 		if (prevNspace && target->m_itemName.find('.') == -1)
[-] 				prevNspace->getNamespaceKind () == NamespaceKind_Type &&
[+] 				prevNspace->getNamespaceKind() == NamespaceKind_Type &&
[-] 				((NamedType*) prevNspace)->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 				((NamedType*)prevNspace)->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 				DerivableType* type = (DerivableType*) prevNspace;
[+] 				DerivableType* type = (DerivableType*)prevNspace;
[-] 					item = type->getConstructor ();
[+] 					item = type->getConstructor();
[-] 					item = type->getDestructor ();
[+] 					item = type->getDestructor();
[-] 				item = prevNspace->findItem (target->m_itemName);
[+] 				item = prevNspace->findItem(target->m_itemName);
[-] 			item = globalNspace->findItemByName (target->m_itemName);
[+] 			item = globalNspace->findItemByName(target->m_itemName);
[-] 		if (target->m_overloadIdx && item->getItemKind () == ModuleItemKind_Function)
[+] 		if (target->m_overloadIdx && item->getItemKind() == ModuleItemKind_Function)
[-] 			Function* overload = ((Function*) item)->getOverload (target->m_overloadIdx);
[+] 			Function* overload = ((Function*)item)->getOverload(target->m_overloadIdx);
[-] 		item->setDoxyBlock (target->m_block);
[+] 		item->setDoxyBlock(target->m_block);
[-] 		if (item->getItemKind () != ModuleItemKind_Property)
[+] 		if (item->getItemKind() != ModuleItemKind_Property)
[-] 			Namespace* itemNspace = item->getNamespace ();
[+] 			Namespace* itemNspace = item->getNamespace();
[-] 		err::setError ("documentation target(s) not found");
[+] 		err::setError("documentation target(s) not found");
[-] DoxyMgr::deleteEmptyGroups ()
[+] DoxyMgr::deleteEmptyGroups()
[-] 		sl::Iterator <DoxyGroup> groupIt = m_groupList.getHead ();
[+] 		sl::Iterator<DoxyGroup> groupIt = m_groupList.getHead();
[-] 			sl::Iterator <DoxyGroup> nextIt = groupIt.getNext ();
[+] 			sl::Iterator<DoxyGroup> nextIt = groupIt.getNext();
[-] 			if (groupIt->isEmpty ())
[+] 			if (groupIt->isEmpty())
[-] 					groupIt->m_group->m_groupList.remove (groupIt->m_parentGroupListIt);
[+] 					groupIt->m_group->m_groupList.remove(groupIt->m_parentGroupListIt);
[-] 				m_groupMap.eraseKey (groupIt->m_name);
[+] 				m_groupMap.eraseKey(groupIt->m_name);
[-] 				m_groupList.erase (groupIt);
[+] 				m_groupList.erase(groupIt);
[-] DoxyMgr::generateGroupDocumentation (
[+] DoxyMgr::generateGroupDocumentation(
[-] 	static char compoundFileHdr [] =
[+] 	static char compoundFileHdr[] =
[-] 	static char compoundFileTerm [] = "</doxygen>\n";
[+] 	static char compoundFileTerm[] = "</doxygen>\n";
[-] 	sl::Iterator <DoxyGroup> groupIt = m_groupList.getHead ();
[+] 	sl::Iterator<DoxyGroup> groupIt = m_groupList.getHead();
[-] 		result = groupIt->generateDocumentation (outputDir, &itemXml, indexXml);
[+] 		result = groupIt->generateDocumentation(outputDir, &itemXml, indexXml);
[-] 		sl::String refId = groupIt->getRefId ();
[+] 		sl::String refId = groupIt->getRefId();
[-] 		sl::String fileName = sl::String (outputDir) + "/" + refId + ".xml";
[+] 		sl::String fileName = sl::String(outputDir) + "/" + refId + ".xml";
[-] 			compoundFile.open (fileName, io::FileFlag_Clear) &&
[+] 			compoundFile.open(fileName, io::FileFlag_Clear) &&
[-] 			compoundFile.write (compoundFileHdr, lengthof (compoundFileHdr)) != -1 &&
[+] 			compoundFile.write(compoundFileHdr, lengthof(compoundFileHdr)) != -1 &&
[-] 			compoundFile.write (itemXml, itemXml.getLength ()) != -1 &&
[+] 			compoundFile.write(itemXml, itemXml.getLength()) != -1 &&
[-] 			compoundFile.write (compoundFileTerm, lengthof (compoundFileTerm)) != -1;
[+] 			compoundFile.write(compoundFileTerm, lengthof(compoundFileTerm)) != -1;
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyParser.cpp
----------------------
[-] DoxyParser::DoxyParser (Module* module)
[+] DoxyParser::DoxyParser(Module* module)
[-] DoxyParser::popBlock ()
[+] DoxyParser::popBlock()
[-] 		if (m_block->getBlockKind () == DoxyBlockKind_Footnote)
[+] 		if (m_block->getBlockKind() == DoxyBlockKind_Footnote)
[-] 			m_block = ((DoxyFootnote*) m_block)->getParent ();
[+] 			m_block = ((DoxyFootnote*)m_block)->getParent();
[-] 		if (m_block->getBlockKind () != DoxyBlockKind_Group)
[+] 		if (m_block->getBlockKind() != DoxyBlockKind_Group)
[-] 	if (!m_groupStack.isEmpty ())
[+] 	if (!m_groupStack.isEmpty())
[-] 		GroupStackEntry entry = m_groupStack.getBack ();
[+] 		GroupStackEntry entry = m_groupStack.getBack();
[-] 		if (entry.m_namespace == m_module->m_namespaceMgr.getCurrentNamespace ())
[+] 		if (entry.m_namespace == m_module->m_namespaceMgr.getCurrentNamespace())
[-] 				doxyBlock = m_module->m_doxyMgr.createBlock ();
[+] 				doxyBlock = m_module->m_doxyMgr.createBlock();
[-] DoxyParser::setBlockTarget (
[+] DoxyParser::setBlockTarget(
[-] 	switch (tokenKind)
[+] 	switch(tokenKind)
[-] 		m_overloadName.clear ();
[+] 		m_overloadName.clear();
[-] 	m_module->m_doxyMgr.setBlockTarget (m_block, tokenKind, name, m_overloadIdx);
[+] 	m_module->m_doxyMgr.setBlockTarget(m_block, tokenKind, name, m_overloadIdx);
[-] DoxyParser::addComment (
[+] DoxyParser::addComment(
[-] 		m_block = m_module->m_doxyMgr.createBlock ();
[+] 		m_block = m_module->m_doxyMgr.createBlock();
[-] 		lastDeclaredItem->setDoxyBlock (m_block);
[+] 		lastDeclaredItem->setDoxyBlock(m_block);
[-] 	switch (m_descriptionKind)
[+] 	switch(m_descriptionKind)
[-] 	lexer.create ("doxy", comment);
[+] 	lexer.create("doxy", comment);
[-] 	lexer.setLineCol (pos.m_line, pos.m_col + 3); // doxygen comments always start with 3 characters: ///, //!, /** /*!
[+] 	lexer.setLineCol(pos.m_line, pos.m_col + 3); // doxygen comments always start with 3 characters: ///, //!, /** /*!
[-] 		const DoxyToken* token = lexer.getToken ();
[+] 		const DoxyToken* token = lexer.getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 			if (m_blockTargetKind || m_block->getBlockKind () == DoxyBlockKind_Footnote) // create a new one
[+] 			if (m_blockTargetKind || m_block->getBlockKind() == DoxyBlockKind_Footnote) // create a new one
[-] 				m_block = m_module->m_doxyMgr.createBlock ();
[+] 				m_block = m_module->m_doxyMgr.createBlock();
[-] 			name = nextToken->m_data.m_string.getTrimmedString ();
[+] 			name = nextToken->m_data.m_string.getTrimmedString();
[-] 			setBlockTarget ((DoxyTokenKind) token->m_token, name);
[+] 			setBlockTarget((DoxyTokenKind)token->m_token, name);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 			i = nextToken->m_data.m_string.findOneOf (" \t");
[+] 			i = nextToken->m_data.m_string.findOneOf(" \t");
[-] 				m_block = m_module->m_doxyMgr.getGroup (nextToken->m_data.m_string);
[+] 				m_block = m_module->m_doxyMgr.getGroup(nextToken->m_data.m_string);
[-] 				DoxyGroup* group = m_module->m_doxyMgr.getGroup (nextToken->m_data.m_string.getSubString (0, i));
[+] 				DoxyGroup* group = m_module->m_doxyMgr.getGroup(nextToken->m_data.m_string.getSubString(0, i));
[-] 				group->m_title = nextToken->m_data.m_string.getSubString (i + 1).getLeftTrimmedString ();
[+] 				group->m_title = nextToken->m_data.m_string.getSubString(i + 1).getLeftTrimmedString();
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 				DoxyGroup* group = m_module->m_doxyMgr.getGroup (nextToken->m_data.m_string);
[+] 				DoxyGroup* group = m_module->m_doxyMgr.getGroup(nextToken->m_data.m_string);
[-] 				if (m_block->getBlockKind () == DoxyBlockKind_Group)
[+] 				if (m_block->getBlockKind() == DoxyBlockKind_Group)
[-] 					DoxyGroup* innerGroup = (DoxyGroup*) m_block;
[+] 					DoxyGroup* innerGroup = (DoxyGroup*)m_block;
[-] 					innerGroup->m_parentGroupListIt = group->addGroup (innerGroup);
[+] 					innerGroup->m_parentGroupListIt = group->addGroup(innerGroup);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			if (m_block->getBlockKind () == DoxyBlockKind_Group)
[+] 			if (m_block->getBlockKind() == DoxyBlockKind_Group)
[-] 				entry.m_group = (DoxyGroup*) m_block;
[+] 				entry.m_group = (DoxyGroup*)m_block;
[-] 				entry.m_namespace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 				entry.m_namespace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 				m_groupStack.append (entry);
[+] 				m_groupStack.append(entry);
[-] 			m_groupStack.pop ();
[+] 			m_groupStack.pop();
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 			m_block->m_importList.insertTail (nextToken->m_data.m_string);
[+] 			m_block->m_importList.insertTail(nextToken->m_data.m_string);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			nextToken = lexer.getToken (1);
[+] 			nextToken = lexer.getToken(1);
[-] 			if (m_block->getBlockKind () == DoxyBlockKind_Footnote)
[+] 			if (m_block->getBlockKind() == DoxyBlockKind_Footnote)
[-] 				m_block = ((DoxyFootnote*) m_block)->getParent ();
[+] 				m_block = ((DoxyFootnote*)m_block)->getParent();
[-] 				ASSERT (m_block->getBlockKind () != DoxyBlockKind_Footnote);
[+] 				ASSERT(m_block->getBlockKind() != DoxyBlockKind_Footnote);
[-] 			name = nextToken->m_data.m_string.getTrimmedString ();
[+] 			name = nextToken->m_data.m_string.getTrimmedString();
[-] 			footnote = m_module->m_doxyMgr.createFootnote ();
[+] 			footnote = m_module->m_doxyMgr.createFootnote();
[-] 			footnote->m_parent->m_footnoteArray.append (footnote);
[+] 			footnote->m_parent->m_footnoteArray.append(footnote);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 			if (!description->isEmpty ())
[+] 			if (!description->isEmpty())
[-] 				description->append ('\n');
[+] 				description->append('\n');
[-] 			if (description->isEmpty ())
[+] 			if (description->isEmpty())
[-] 				description->copy (token->m_data.m_string.getLeftTrimmedString ());
[+] 				description->copy(token->m_data.m_string.getLeftTrimmedString());
[-] 				if (!m_indent.isEmpty ())
[+] 				if (!m_indent.isEmpty())
[-] 					size_t indentLength = m_indent.getLength ();
[+] 					size_t indentLength = m_indent.getLength();
[-] 					size_t firstIndentLength = m_firstIndent.getLength ();
[+] 					size_t firstIndentLength = m_firstIndent.getLength();
[-] 					size_t commonIndentLength = AXL_MIN (indentLength, firstIndentLength);
[+] 					size_t commonIndentLength = AXL_MIN(indentLength, firstIndentLength);
[-] 						if (m_indent [i] != m_firstIndent [i])
[+] 						if (m_indent[i] != m_firstIndent[i])
[-] 						description->append (m_indent.sz () + i, indentLength - i);
[+] 						description->append(m_indent.sz() + i, indentLength - i);
[-] 					m_indent.clear (); // do this once per line
[+] 					m_indent.clear(); // do this once per line
[-] 				description->append (token->m_data.m_string);
[+] 				description->append(token->m_data.m_string);
[-] 				!description->isEmpty ()) // empty line ends \brief or \seealso description
[+] 				!description->isEmpty()) // empty line ends \brief or \seealso description
[-] 			else if (!description->isEmpty ())
[+] 			else if (!description->isEmpty())
[-] 				description->append ('\n');
[+] 				description->append('\n');
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
----------------------
27/02/2019 18:02:08 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyBlock.h
----------------------
[-] 	sl::BoxList <sl::String> m_importList;
[+] 	sl::BoxList<sl::String> m_importList;
[-] 	sl::Array <DoxyBlock*> m_footnoteArray;
[+] 	sl::Array<DoxyBlock*> m_footnoteArray;
[-] 	DoxyBlock ();
[+] 	DoxyBlock();
[-] 	getBlockKind ()
[+] 	getBlockKind()
[-] 	getGroup ()
[+] 	getGroup()
[-] 	getItem ()
[+] 	getItem()
[-] 	getRefId ();
[+] 	getRefId();
[-] 	getTitle ()
[+] 	getTitle()
[-] 	getBriefDescription ()
[+] 	getBriefDescription()
[-] 	getDetailedDescription ()
[+] 	getDetailedDescription()
[-] 	getSeeAlsoDescription ()
[+] 	getSeeAlsoDescription()
[-] 	isDescriptionEmpty ()
[+] 	isDescriptionEmpty()
[-] 		return m_briefDescription.isEmpty () && m_detailedDescription.isEmpty ();
[+] 		return m_briefDescription.isEmpty() && m_detailedDescription.isEmpty();
[-] 	getDescriptionString ();
[+] 	getDescriptionString();
[-] 	getFootnoteString ();
[+] 	getFootnoteString();
[-] 	getImportString ();
[+] 	getImportString();
[-] 	DoxyFootnote ()
[+] 	DoxyFootnote()
[-] 	getParent ()
[+] 	getParent()
[-] appendXmlElementContents (
[+] appendXmlElementContents(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyGroup.h
----------------------
[-] 	sl::Array <ModuleItem*> m_itemArray;
[+] 	sl::Array<ModuleItem*> m_itemArray;
[-] 	sl::BoxList <DoxyGroup*> m_groupList;
[+] 	sl::BoxList<DoxyGroup*> m_groupList;
[-] 	sl::BoxIterator <DoxyGroup*> m_parentGroupListIt;
[+] 	sl::BoxIterator<DoxyGroup*> m_parentGroupListIt;
[-] 	DoxyGroup ()
[+] 	DoxyGroup()
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_itemArray.isEmpty () && m_groupList.isEmpty ();
[+] 		return m_itemArray.isEmpty() && m_groupList.isEmpty();
[-] 	getName ()
[+] 	getName()
[-] 	sl::Array <ModuleItem*>
[+] 	sl::Array<ModuleItem*>
[-] 	getItemArray ()
[+] 	getItemArray()
[-] 	sl::ConstBoxList <DoxyGroup*>
[+] 	sl::ConstBoxList<DoxyGroup*>
[-] 	getGroupList ()
[+] 	getGroupList()
[-] 	addItem (ModuleItem* item)
[+] 	addItem(ModuleItem* item)
[-] 		m_itemArray.append (item);
[+] 		m_itemArray.append(item);
[-] 	sl::BoxIterator <DoxyGroup*>
[+] 	sl::BoxIterator<DoxyGroup*>
[-] 	addGroup (DoxyGroup* group)
[+] 	addGroup(DoxyGroup* group)
[-] 		return m_groupList.insertTail (group);
[+] 		return m_groupList.insertTail(group);
[-] 	generateDocumentation (
[+] 	generateDocumentation(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyLexer.h
----------------------
[-] AXL_LEX_BEGIN_TOKEN_NAME_MAP (DoxyTokenName)
[+] AXL_LEX_BEGIN_TOKEN_NAME_MAP(DoxyTokenName)
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Eof,           "eof")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Eof,           "eof")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Error,         "error")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Error,         "error")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Text,          "text")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Text,          "text")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_OtherCommand,  "other-command")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_OtherCommand,  "other-command")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_OpeningBrace,  "@{")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_OpeningBrace,  "@{")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_ClosingBrace,  "@}")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_ClosingBrace,  "@}")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Import,        "\\import")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Import,        "\\import")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Enum,          "\\enum")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Enum,          "\\enum")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_EnumValue,     "\\enumvalue")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_EnumValue,     "\\enumvalue")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Struct,        "\\struct")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Struct,        "\\struct")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Union,         "\\union")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Union,         "\\union")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Class,         "\\class")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Class,         "\\class")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Alias,         "\\alias")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Alias,         "\\alias")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Variable,      "\\variable")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Variable,      "\\variable")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Field,         "\\field")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Field,         "\\field")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Function,      "\\function")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Function,      "\\function")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Overload,      "\\overload")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Overload,      "\\overload")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Property,      "\\property")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Property,      "\\property")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Event,         "\\event")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Event,         "\\event")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Typedef,       "\\typedef")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Typedef,       "\\typedef")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Namespace,     "\\namespace")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Namespace,     "\\namespace")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Group,         "\\group")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Group,         "\\group")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_InGroup,       "\\ingroup")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_InGroup,       "\\ingroup")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_SubGroup,      "\\subgroup")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_SubGroup,      "\\subgroup")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Title,         "\\title")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Title,         "\\title")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Brief,         "\\brief")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Brief,         "\\brief")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_SeeAlso,       "\\see")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_SeeAlso,       "\\see")
[-] 	AXL_LEX_TOKEN_NAME (DoxyTokenKind_Footnote,      "\\footnote")
[+] 	AXL_LEX_TOKEN_NAME(DoxyTokenKind_Footnote,      "\\footnote")
[-] AXL_LEX_END_TOKEN_NAME_MAP ();
[+] AXL_LEX_END_TOKEN_NAME_MAP();
[-] typedef lex::RagelToken <DoxyTokenKind, DoxyTokenName, lex::StdTokenData> DoxyToken;
[+] typedef lex::RagelToken<DoxyTokenKind, DoxyTokenName, lex::StdTokenData> DoxyToken;
[-] class DoxyLexer: public lex::RagelLexer <DoxyLexer, DoxyToken>
[+] class DoxyLexer: public lex::RagelLexer<DoxyLexer, DoxyToken>
[-] 	friend class lex::RagelLexer <DoxyLexer, DoxyToken>;
[+] 	friend class lex::RagelLexer<DoxyLexer, DoxyToken>;
[-] 	createTextToken (DoxyTokenKind tokenKind);
[+] 	createTextToken(DoxyTokenKind tokenKind);
[-] 	createNewLineToken ();
[+] 	createNewLineToken();
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyMgr.h
----------------------
[-] 	sl::List <DoxyBlock> m_blockList;
[+] 	sl::List<DoxyBlock> m_blockList;
[-] 	sl::List <DoxyGroup> m_groupList;
[+] 	sl::List<DoxyGroup> m_groupList;
[-] 	sl::List <DoxyFootnote> m_footnoteList;
[+] 	sl::List<DoxyFootnote> m_footnoteList;
[-] 	sl::StringHashTable <size_t> m_refIdMap;
[+] 	sl::StringHashTable<size_t> m_refIdMap;
[-] 	sl::StringHashTable <DoxyGroup*> m_groupMap;
[+] 	sl::StringHashTable<DoxyGroup*> m_groupMap;
[-] 	sl::List <Target> m_targetList;
[+] 	sl::List<Target> m_targetList;
[-] 	DoxyMgr ();
[+] 	DoxyMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	sl::ConstList <DoxyBlock>
[+] 	sl::ConstList<DoxyBlock>
[-] 	getBlockList ()
[+] 	getBlockList()
[-] 	sl::ConstList <DoxyGroup>
[+] 	sl::ConstList<DoxyGroup>
[-] 	getGroupList ()
[+] 	getGroupList()
[-] 	getGroup (const sl::StringRef& name);
[+] 	getGroup(const sl::StringRef& name);
[-] 	createBlock ();
[+] 	createBlock();
[-] 	createFootnote ();
[+] 	createFootnote();
[-] 	adjustRefId (const sl::StringRef& refId);
[+] 	adjustRefId(const sl::StringRef& refId);
[-] 	setBlockTarget (
[+] 	setBlockTarget(
[-] 	resolveBlockTargets ();
[+] 	resolveBlockTargets();
[-] 	deleteEmptyGroups ();
[+] 	deleteEmptyGroups();
[-] 	generateGroupDocumentation (
[+] 	generateGroupDocumentation(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_DoxyMgr\jnc_ct_DoxyParser.h
----------------------
[-] 	sl::Array <GroupStackEntry> m_groupStack;
[+] 	sl::Array<GroupStackEntry> m_groupStack;
[-] 	DoxyParser (Module* module);
[+] 	DoxyParser(Module* module);
[-] 	popBlock ();
[+] 	popBlock();
[-] 	addComment (
[+] 	addComment(
[-] 	setBlockTarget (
[+] 	setBlockTarget(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_AsyncFunction.cpp
----------------------
[-] AsyncFunction::compile ()
[+] AsyncFunction::compile()
[-] 	ASSERT (m_parentUnit && m_parentNamespace);
[+] 	ASSERT(m_parentUnit && m_parentNamespace);
[-] 	m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 	m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 	m_module->m_namespaceMgr.openNamespace (m_parentNamespace);
[+] 	m_module->m_namespaceMgr.openNamespace(m_parentNamespace);
[-] 	m_module->m_functionMgr.internalPrologue (this, &promiseValue, 1, &m_body.getHead ()->m_pos);
[+] 	m_module->m_functionMgr.internalPrologue(this, &promiseValue, 1, &m_body.getHead()->m_pos);
[-] 	Scope* scope = m_module->m_namespaceMgr.openScope (
[+] 	Scope* scope = m_module->m_namespaceMgr.openScope(
[-] 		m_body.getHead ()->m_pos,
[+] 		m_body.getHead()->m_pos,
[-] 	ASSERT (!m_promiseType);
[+] 	ASSERT(!m_promiseType);
[-] 	m_promiseType = ((ClassPtrType*) promiseValue.getType ())->getTargetType ();
[+] 	m_promiseType = ((ClassPtrType*)promiseValue.getType())->getTargetType();
[-] 	sl::Array <StructField*> promiseFieldArray = m_promiseType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> promiseFieldArray = m_promiseType->getMemberFieldArray();
[-] 	size_t argCount = promiseFieldArray.getCount ();
[+] 	size_t argCount = promiseFieldArray.getCount();
[-] 		StructField* argField = promiseFieldArray [i];
[+] 		StructField* argField = promiseFieldArray[i];
[-] 		result = m_module->m_operatorMgr.getField (promiseValue, argField, &argFieldValue);
[+] 		result = m_module->m_operatorMgr.getField(promiseValue, argField, &argFieldValue);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		Variable* argVar = m_module->m_variableMgr.createAsyncArgVariable (
[+] 		Variable* argVar = m_module->m_variableMgr.createAsyncArgVariable(
[-] 			argField->getName (),
[+] 			argField->getName(),
[-] 			argField->getType (),
[+] 			argField->getType(),
[-] 		scope->addItem (argVar);
[+] 		scope->addItem(argVar);
[-] 	BasicBlock* firstAsyncBlock = m_module->m_controlFlowMgr.createAsyncBlock (scope);
[+] 	BasicBlock* firstAsyncBlock = m_module->m_controlFlowMgr.createAsyncBlock(scope);
[-] 	BasicBlock* switchBlock = m_module->m_controlFlowMgr.setCurrentBlock (firstAsyncBlock);
[+] 	BasicBlock* switchBlock = m_module->m_controlFlowMgr.setCurrentBlock(firstAsyncBlock);
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 		parser.parseTokenList (SymbolKind_compound_stmt, m_body, true) &&
[+] 		parser.parseTokenList(SymbolKind_compound_stmt, m_body, true) &&
[-] 		m_module->m_controlFlowMgr.checkReturn ();
[+] 		m_module->m_controlFlowMgr.checkReturn();
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (switchBlock);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(switchBlock);
[-] 	result = m_module->m_operatorMgr.getPromiseField (promiseValue, "m_state", &stateValue);
[+] 	result = m_module->m_operatorMgr.getPromiseField(promiseValue, "m_state", &stateValue);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	result = m_module->m_operatorMgr.loadDataRef (&stateValue);
[+] 	result = m_module->m_operatorMgr.loadDataRef(&stateValue);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	sl::Array <BasicBlock*> asyncBlockArray = m_module->m_controlFlowMgr.getAsyncBlockArray ();
[+] 	sl::Array<BasicBlock*> asyncBlockArray = m_module->m_controlFlowMgr.getAsyncBlockArray();
[-] 	size_t count = asyncBlockArray.getCount ();
[+] 	size_t count = asyncBlockArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <intptr_t> stateIdArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<intptr_t> stateIdArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	stateIdArray.setCount (count);
[+] 	stateIdArray.setCount(count);
[-] 		stateIdArray [i] = i;
[+] 		stateIdArray[i] = i;
[-] 	m_module->m_llvmIrBuilder.createSwitch (
[+] 	m_module->m_llvmIrBuilder.createSwitch(
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
[-] 	result = m_module->m_controlFlowMgr.catchLabel (m_body.getTail ()->m_pos);
[+] 	result = m_module->m_controlFlowMgr.catchLabel(m_body.getTail()->m_pos);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	Function* throwFunc = m_module->m_functionMgr.getStdFunction (StdFunc_AsyncThrow);
[+] 	Function* throwFunc = m_module->m_functionMgr.getStdFunction(StdFunc_AsyncThrow);
[-] 	m_module->m_llvmIrBuilder.createGep2 (promiseValue, 0, NULL, &promiseValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(promiseValue, 0, NULL, &promiseValue);
[-] 	m_module->m_llvmIrBuilder.createCall (throwFunc, throwFunc->getType (), promiseValue, NULL);
[+] 	m_module->m_llvmIrBuilder.createCall(throwFunc, throwFunc->getType(), promiseValue, NULL);
[-] 	m_module->m_controlFlowMgr.asyncRet (NULL);
[+] 	m_module->m_controlFlowMgr.asyncRet(NULL);
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] AsyncFunction::replaceAllocas ()
[+] AsyncFunction::replaceAllocas()
[-] 	llvm::Value* llvmPromiseValue = &m_llvmFunction->getArgumentList ().front ();
[+] 	llvm::Value* llvmPromiseValue = &m_llvmFunction->getArgumentList().front();
[-] 	llvm::BasicBlock* llvmAllocaBlock = m_allocaBlock->getLlvmBlock ();
[+] 	llvm::BasicBlock* llvmAllocaBlock = m_allocaBlock->getLlvmBlock();
[-] 	llvm::BasicBlock::iterator it = llvmAllocaBlock->begin ();
[+] 	llvm::BasicBlock::iterator it = llvmAllocaBlock->begin();
[-] 	llvm::DataLayout llvmDataLayout (m_module->getLlvmModule ());
[+] 	llvm::DataLayout llvmDataLayout(m_module->getLlvmModule());
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (it);
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(it);
[-] 	m_module->m_llvmIrBuilder.createBitCast (llvmPromiseValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &bufferValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(llvmPromiseValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &bufferValue);
[-] 	while (it != llvmAllocaBlock->end ())
[+] 	while (it != llvmAllocaBlock->end())
[-] 		if (!llvm::isa <llvm::AllocaInst> (it))
[+] 		if (!llvm::isa<llvm::AllocaInst> (it))
[-] 		llvm::Type* llvmPtrType = llvmAlloca->getType ();
[+] 		llvm::Type* llvmPtrType = llvmAlloca->getType();
[-] 		llvm::Type* llvmType = llvmAlloca->getAllocatedType ();
[+] 		llvm::Type* llvmType = llvmAlloca->getAllocatedType();
[-] 		size_t size = llvmDataLayout.getTypeAllocSize (llvmType);
[+] 		size_t size = llvmDataLayout.getTypeAllocSize(llvmType);
[-] 		size_t typeAlign = llvmDataLayout.getPrefTypeAlignment (llvmType);
[+] 		size_t typeAlign = llvmDataLayout.getPrefTypeAlignment(llvmType);
[-] 		size_t allocaAlign = llvmAlloca->getAlignment ();
[+] 		size_t allocaAlign = llvmAlloca->getAlignment();
[-] 		offset = sl::align (offset, AXL_MAX (typeAlign, allocaAlign));
[+] 		offset = sl::align(offset, AXL_MAX(typeAlign, allocaAlign));
[-] 		llvm::raw_string_ostream stream (s);
[+] 		llvm::raw_string_ostream stream(s);
[-] 		llvmAlloca->print (stream);
[+] 		llvmAlloca->print(stream);
[-] 		m_module->m_llvmIrBuilder.setInsertPoint (llvmAlloca);
[+] 		m_module->m_llvmIrBuilder.setInsertPoint(llvmAlloca);
[-] 		m_module->m_llvmIrBuilder.createGep (bufferValue, offset, NULL, &gepValue);
[+] 		m_module->m_llvmIrBuilder.createGep(bufferValue, offset, NULL, &gepValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (gepValue.getLlvmValue (), llvmPtrType, &gepValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(gepValue.getLlvmValue(), llvmPtrType, &gepValue);
[-] 		llvmAlloca->replaceAllUsesWith (gepValue.getLlvmValue ());
[+] 		llvmAlloca->replaceAllUsesWith(gepValue.getLlvmValue());
[-] 		llvmAlloca->eraseFromParent ();
[+] 		llvmAlloca->eraseFromParent();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_Function.cpp
----------------------
[-] Function::Function ()
[+] Function::Function()
[-] Function::setBody (sl::BoxList <Token>* tokenList)
[+] Function::setBody(sl::BoxList<Token>* tokenList)
[-] 	if (!m_body.isEmpty ())
[+] 	if (!m_body.isEmpty())
[-] 		err::setFormatStringError ("'%s' already has a body", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' already has a body", m_tag.sz ());
[-] 		err::setFormatStringError ("'%s' is abstract and hence cannot have a body", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' is abstract and hence cannot have a body", m_tag.sz ());
[-] 	sl::takeOver (&m_body, tokenList);
[+] 	sl::takeOver(&m_body, tokenList);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] Function::addUsingSet (Namespace* anchorNamespace)
[+] Function::addUsingSet(Namespace* anchorNamespace)
[-] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState () < ModuleCompileState_Linked ?
[+] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState() < ModuleCompileState_Linked ?
[-] 	for (Namespace* nspace = anchorNamespace; nspace; nspace = nspace->getParentNamespace ())
[+] 	for (Namespace* nspace = anchorNamespace; nspace; nspace = nspace->getParentNamespace())
[-] 		m_usingSet.append (importNamespaceMgr, nspace->getUsingSet ());
[+] 		m_usingSet.append(importNamespaceMgr, nspace->getUsingSet());
[-] Function::addUsingSet (UsingSet* usingSet)
[+] Function::addUsingSet(UsingSet* usingSet)
[-] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState () < ModuleCompileState_Linked ?
[+] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState() < ModuleCompileState_Linked ?
[-] 	m_usingSet.append (importNamespaceMgr, usingSet);
[+] 	m_usingSet.append(importNamespaceMgr, usingSet);
[-] Function::getLlvmFunction ()
[+] Function::getLlvmFunction()
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_McJit)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_McJit)
[-] 	m_llvmFunction = m_type->getCallConv ()->createLlvmFunction (m_type, llvmName);
[+] 	m_llvmFunction = m_type->getCallConv()->createLlvmFunction(m_type, llvmName);
[-] Function::getLlvmDiSubprogram ()
[+] Function::getLlvmDiSubprogram()
[-] 	m_llvmDiSubprogram = m_module->m_llvmDiBuilder.createFunction (this);
[+] 	m_llvmDiSubprogram = m_module->m_llvmDiBuilder.createFunction(this);
[-] Function::convertToMemberMethod (DerivableType* parentType)
[+] Function::convertToMemberMethod(DerivableType* parentType)
[-] 	ASSERT (m_typeOverload.getOverloadCount () == 1);
[+] 	ASSERT(m_typeOverload.getOverloadCount() == 1);
[-] 	m_type = parentType->getMemberMethodType (m_type, m_thisArgTypeFlags);
[+] 	m_type = parentType->getMemberMethodType(m_type, m_thisArgTypeFlags);
[-] 	ASSERT (!m_type->getArgArray ().isEmpty ());
[+] 	ASSERT(!m_type->getArgArray().isEmpty());
[-] 	m_thisArgType = m_type->getArgArray () [0]->getType ();
[+] 	m_thisArgType = m_type->getArgArray() [0]->getType();
[-] Function::addOverload (Function* function)
[+] Function::addOverload(Function* function)
[-] 	size_t overloadIdx = m_typeOverload.addOverload (function->m_type);
[+] 	size_t overloadIdx = m_typeOverload.addOverload(function->m_type);
[-] 	m_overloadArray.append (function);
[+] 	m_overloadArray.append(function);
[-] 	ASSERT (overloadIdx == m_overloadArray.getCount ());
[+] 	ASSERT(overloadIdx == m_overloadArray.getCount());
[-] Function::addTlsVariable (Variable* variable)
[+] Function::addTlsVariable(Variable* variable)
[-] 	llvm::AllocaInst* llvmAlloca = (llvm::AllocaInst*) variable->getLlvmValue ();
[+] 	llvm::AllocaInst* llvmAlloca = (llvm::AllocaInst*)variable->getLlvmValue();
[-] 	ASSERT (llvmAlloca && llvm::isa <llvm::AllocaInst> (*llvmAlloca));
[+] 	ASSERT(llvmAlloca && llvm::isa<llvm::AllocaInst> (*llvmAlloca));
[-] 	m_tlsVariableArray.append (tlsVariable);
[+] 	m_tlsVariableArray.append(tlsVariable);
[-] Function::compile ()
[+] Function::compile()
[-] 	ASSERT (!m_body.isEmpty () || !m_initializer.isEmpty ()); // otherwise what are we doing here?
[+] 	ASSERT(!m_body.isEmpty() || !m_initializer.isEmpty()); // otherwise what are we doing here?
[-] 	ASSERT (!m_prologueBlock);
[+] 	ASSERT(!m_prologueBlock);
[-] 		m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 	if (!m_body.isEmpty ())
[+] 	if (!m_body.isEmpty())
[-] 		Token::Pos beginPos = m_body.getHead ()->m_pos;
[+] 		Token::Pos beginPos = m_body.getHead()->m_pos;
[-] 		Token::Pos endPos = m_body.getTail ()->m_pos;
[+] 		Token::Pos endPos = m_body.getTail()->m_pos;
[-] 		m_module->m_functionMgr.prologue (this, beginPos);
[+] 		m_module->m_functionMgr.prologue(this, beginPos);
[-] 		m_module->m_namespaceMgr.getCurrentScope ()->getUsingSet ()->append (NULL, &m_usingSet);
[+] 		m_module->m_namespaceMgr.getCurrentScope()->getUsingSet()->append(NULL, &m_usingSet);
[-] 			(m_type->getFlags () & FunctionTypeFlag_Async) ? compileAsyncLauncher () :
[+] 			(m_type->getFlags() & FunctionTypeFlag_Async) ? compileAsyncLauncher() :
[-] 			m_functionKind == FunctionKind_Constructor ? compileConstructorBody () :
[+] 			m_functionKind == FunctionKind_Constructor ? compileConstructorBody() :
[-] 			compileNormalBody ();
[+] 			compileNormalBody();
[-] 		m_module->m_namespaceMgr.setSourcePos (endPos);
[+] 		m_module->m_namespaceMgr.setSourcePos(endPos);
[-] 		return m_module->m_functionMgr.epilogue ();
[+] 		return m_module->m_functionMgr.epilogue();
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	result = parser.parseTokenList (SymbolKind_qualified_name_save_name, m_initializer);
[+] 	result = parser.parseTokenList(SymbolKind_qualified_name_save_name, m_initializer);
[-] 	ModuleItem* item = m_parentNamespace->findItemTraverse (parser.m_qualifiedName);
[+] 	ModuleItem* item = m_parentNamespace->findItemTraverse(parser.m_qualifiedName);
[-] 		err::setFormatStringError ("name '%s' is not found", parser.m_qualifiedName.getFullName ().sz ());
[+] 		err::setFormatStringError("name '%s' is not found", parser.m_qualifiedName.getFullName ().sz ());
[-] 	if (item->getItemKind () != ModuleItemKind_Function)
[+] 	if (item->getItemKind() != ModuleItemKind_Function)
[-] 		err::setFormatStringError ("'%s' is not function", parser.m_qualifiedName.getFullName ().sz ());
[+] 		err::setFormatStringError("'%s' is not function", parser.m_qualifiedName.getFullName ().sz ());
[-] 	Function* targetFunction = (Function*) item;
[+] 	Function* targetFunction = (Function*)item;
[-] 		Function* targetOverload = targetFunction->findOverload (m_type);
[+] 		Function* targetOverload = targetFunction->findOverload(m_type);
[-] 			result = targetOverload->m_llvmFunction != NULL || targetOverload->compile ();
[+] 			result = targetOverload->m_llvmFunction != NULL || targetOverload->compile();
[-] 	size_t argCount = m_type->getArgArray ().getCount ();
[+] 	size_t argCount = m_type->getArgArray().getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (this, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(this, argValueArray, argCount);
[-] 	sl::BoxList <Value> argValueList;
[+] 	sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValueArray [i]);
[+] 		argValueList.insertTail(argValueArray[i]);
[-] 	result = m_module->m_operatorMgr.callOperator (targetFunction, &argValueList, &resultValue);
[+] 	result = m_module->m_operatorMgr.callOperator(targetFunction, &argValueList, &resultValue);
[-] 	if (m_type->getTypeKind () != TypeKind_Void)
[+] 	if (m_type->getTypeKind() != TypeKind_Void)
[-] 		result = m_module->m_controlFlowMgr.ret (resultValue);
[+] 		result = m_module->m_controlFlowMgr.ret(resultValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] Function::compileConstructorBody ()
[+] Function::compileConstructorBody()
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	NamespaceKind namespaceKind = m_parentNamespace->getNamespaceKind ();
[+] 	NamespaceKind namespaceKind = m_parentNamespace->getNamespaceKind();
[-] 	ASSERT (namespaceKind == NamespaceKind_Type || namespaceKind == NamespaceKind_Property);
[+] 	ASSERT(namespaceKind == NamespaceKind_Type || namespaceKind == NamespaceKind_Property);
[-] 		parser.m_constructorType = (DerivableType*) m_parentNamespace;
[+] 		parser.m_constructorType = (DerivableType*)m_parentNamespace;
[-] 		parser.m_constructorProperty = (Property*) m_parentNamespace;
[+] 		parser.m_constructorProperty = (Property*)m_parentNamespace;
[-] 	return parser.parseTokenList (SymbolKind_constructor_compound_stmt, m_body, true);
[+] 	return parser.parseTokenList(SymbolKind_constructor_compound_stmt, m_body, true);
[-] Function::compileNormalBody ()
[+] Function::compileNormalBody()
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	return parser.parseTokenList (SymbolKind_compound_stmt, m_body, true);
[+] 	return parser.parseTokenList(SymbolKind_compound_stmt, m_body, true);
[-] Function::compileAsyncLauncher ()
[+] Function::compileAsyncLauncher()
[-] 	ClassType* promiseType = m_module->m_typeMgr.createClassType (promiseName, promiseName);
[+] 	ClassType* promiseType = m_module->m_typeMgr.createClassType(promiseName, promiseName);
[-] 	promiseType->addBaseType (m_module->m_typeMgr.getStdType (StdType_Promise));
[+] 	promiseType->addBaseType(m_module->m_typeMgr.getStdType(StdType_Promise));
[-] 	sl::Array <Variable*> argVariableArray = m_module->m_variableMgr.getArgVariableArray ();
[+] 	sl::Array<Variable*> argVariableArray = m_module->m_variableMgr.getArgVariableArray();
[-] 	size_t argCount = argVariableArray.getCount ();
[+] 	size_t argCount = argVariableArray.getCount();
[-] 		Variable* argVar = argVariableArray [i];
[+] 		Variable* argVar = argVariableArray[i];
[-] 		promiseType->createField (argVar->getName (), argVar->getType ());
[+] 		promiseType->createField(argVar->getName(), argVar->getType());
[-] 	sl::Array <StructField*> argFieldArray = promiseType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> argFieldArray = promiseType->getMemberFieldArray();
[-] 	ASSERT (argFieldArray.getCount () == argCount);
[+] 	ASSERT(argFieldArray.getCount() == argCount);
[-] 	promiseType->ensureLayout ();
[+] 	promiseType->ensureLayout();
[-] 	result = m_module->m_operatorMgr.newOperator (promiseType, &promiseValue);
[+] 	result = m_module->m_operatorMgr.newOperator(promiseType, &promiseValue);
[-] 	ASSERT (argFieldArray.getCount () == argVariableArray.getCount ());
[+] 	ASSERT(argFieldArray.getCount() == argVariableArray.getCount());
[-] 		Variable* argVar = argVariableArray [i];
[+] 		Variable* argVar = argVariableArray[i];
[-] 		StructField* argField = argFieldArray [i];
[+] 		StructField* argField = argFieldArray[i];
[-] 			m_module->m_operatorMgr.getField (promiseValue, argField, &argFieldValue) &&
[+] 			m_module->m_operatorMgr.getField(promiseValue, argField, &argFieldValue) &&
[-] 			m_module->m_operatorMgr.storeDataRef (argFieldValue, argVar);
[+] 			m_module->m_operatorMgr.storeDataRef(argFieldValue, argVar);
[-] 	Type* argType = promiseType->getClassPtrType (ClassPtrTypeKind_Normal, PtrTypeFlag_Safe);
[+] 	Type* argType = promiseType->getClassPtrType(ClassPtrTypeKind_Normal, PtrTypeFlag_Safe);
[-] 	FunctionType* functionType = m_module->m_typeMgr.getFunctionType (&argType, 1);
[+] 	FunctionType* functionType = m_module->m_typeMgr.getFunctionType(&argType, 1);
[-] 	Function* sequencerFunc = m_module->m_functionMgr.createFunction (
[+] 	Function* sequencerFunc = m_module->m_functionMgr.createFunction(
[-] 	sequencerFunc->setBody (&m_body);
[+] 	sequencerFunc->setBody(&m_body);
[-] 	m_module->m_operatorMgr.callOperator (sequencerFunc, promiseValue);
[+] 	m_module->m_operatorMgr.callOperator(sequencerFunc, promiseValue);
[-] 	return m_module->m_controlFlowMgr.ret (promiseValue);
[+] 	return m_module->m_controlFlowMgr.ret(promiseValue);
[-] Function::generateDocumentation (
[+] Function::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	itemXml->format ("<memberdef kind='function' id='%s'", doxyBlock->getRefId ().sz ());
[+] 	itemXml->format("<memberdef kind='function' id='%s'", doxyBlock->getRefId ().sz ());
[-] 		itemXml->appendFormat (" prot='%s'", getAccessKindString (m_accessKind));
[+] 		itemXml->appendFormat(" prot='%s'", getAccessKindString (m_accessKind));
[-] 		itemXml->append (" static='yes'");
[+] 		itemXml->append(" static='yes'");
[-] 	if (isMember () && (m_thisArgTypeFlags & PtrTypeFlag_Const))
[+] 	if (isMember() && (m_thisArgTypeFlags & PtrTypeFlag_Const))
[-] 		itemXml->append (" const='yes'");
[+] 		itemXml->append(" const='yes'");
[-] 	if (isVirtual ())
[+] 	if (isVirtual())
[-] 		itemXml->appendFormat (" virt='%s'", getStorageKindString (m_storageKind));
[+] 		itemXml->appendFormat(" virt='%s'", getStorageKindString (m_storageKind));
[-] 	itemXml->appendFormat (">\n<functionkind>%s</functionkind>\n", getFunctionKindString (m_functionKind));
[+] 	itemXml->appendFormat(">\n<functionkind>%s</functionkind>\n", getFunctionKindString (m_functionKind));
[-] 	itemXml->appendFormat ("<name>%s</name>\n", !m_name.isEmpty () ? m_name.sz () : getFunctionKindString (m_functionKind));
[+] 	itemXml->appendFormat("<name>%s</name>\n", !m_name.isEmpty () ? m_name.sz () : getFunctionKindString (m_functionKind));
[-] 	itemXml->append (m_type->getDoxyTypeString ());
[+] 	itemXml->append(m_type->getDoxyTypeString());
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
[-] 	size_t overloadCount = m_overloadArray.getCount ();
[+] 	size_t overloadCount = m_overloadArray.getCount();
[-] 		Function* overload = m_overloadArray [i];
[+] 		Function* overload = m_overloadArray[i];
[-] 		overload->generateDocumentation (outputDir, &overloadXml, indexXml);
[+] 		overload->generateDocumentation(outputDir, &overloadXml, indexXml);
[-] 		itemXml->append ('\n');
[+] 		itemXml->append('\n');
[-] 		itemXml->append (overloadXml);
[+] 		itemXml->append(overloadXml);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_FunctionMgr.cpp
----------------------
[-] FunctionMgr::FunctionMgr ()
[+] FunctionMgr::FunctionMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 	memset (m_stdFunctionArray, 0, sizeof (m_stdFunctionArray));
[+] 	memset(m_stdFunctionArray, 0, sizeof(m_stdFunctionArray));
[-] 	memset (m_lazyStdFunctionArray, 0, sizeof (m_lazyStdFunctionArray));
[+] 	memset(m_lazyStdFunctionArray, 0, sizeof(m_lazyStdFunctionArray));
[-] 	memset (m_stdPropertyArray, 0, sizeof (m_stdPropertyArray));
[+] 	memset(m_stdPropertyArray, 0, sizeof(m_stdPropertyArray));
[-] FunctionMgr::clear ()
[+] FunctionMgr::clear()
[-] 	m_functionList.clear ();
[+] 	m_functionList.clear();
[-] 	m_propertyList.clear ();
[+] 	m_propertyList.clear();
[-] 	m_propertyTemplateList.clear ();
[+] 	m_propertyTemplateList.clear();
[-] 	m_scheduleLauncherFunctionList.clear ();
[+] 	m_scheduleLauncherFunctionList.clear();
[-] 	m_asyncFunctionList.clear ();
[+] 	m_asyncFunctionList.clear();
[-] 	m_thunkFunctionList.clear ();
[+] 	m_thunkFunctionList.clear();
[-] 	m_thunkPropertyList.clear ();
[+] 	m_thunkPropertyList.clear();
[-] 	m_dataThunkPropertyList.clear ();
[+] 	m_dataThunkPropertyList.clear();
[-] 	m_thunkFunctionMap.clear ();
[+] 	m_thunkFunctionMap.clear();
[-] 	m_thunkPropertyMap.clear ();
[+] 	m_thunkPropertyMap.clear();
[-] 	m_scheduleLauncherFunctionMap.clear ();
[+] 	m_scheduleLauncherFunctionMap.clear();
[-] 	m_staticConstructArray.clear ();
[+] 	m_staticConstructArray.clear();
[-] 	memset (m_stdFunctionArray, 0, sizeof (m_stdFunctionArray));
[+] 	memset(m_stdFunctionArray, 0, sizeof(m_stdFunctionArray));
[-] 	memset (m_lazyStdFunctionArray, 0, sizeof (m_lazyStdFunctionArray));
[+] 	memset(m_lazyStdFunctionArray, 0, sizeof(m_lazyStdFunctionArray));
[-] 	memset (m_stdPropertyArray, 0, sizeof (m_stdPropertyArray));
[+] 	memset(m_stdPropertyArray, 0, sizeof(m_stdPropertyArray));
[-] 	m_thisValue.clear ();
[+] 	m_thisValue.clear();
[-] 	m_promiseValue.clear ();
[+] 	m_promiseValue.clear();
[-] FunctionMgr::callStaticConstructors ()
[+] FunctionMgr::callStaticConstructors()
[-] 	Function* addDestructor = getStdFunction (StdFunc_AddStaticDestructor);
[+] 	Function* addDestructor = getStdFunction(StdFunc_AddStaticDestructor);
[-] 	Type* dtorType = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 	Type* dtorType = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	size_t count = m_staticConstructArray.getCount ();
[+] 	size_t count = m_staticConstructArray.getCount();
[-] 		NamedTypeBlock* namedTypeBlock = m_staticConstructArray [i];
[+] 		NamedTypeBlock* namedTypeBlock = m_staticConstructArray[i];
[-] 		Function* destructor = namedTypeBlock->getStaticDestructor ();
[+] 		Function* destructor = namedTypeBlock->getStaticDestructor();
[-] 			m_module->m_llvmIrBuilder.createBitCast (destructor, dtorType, &dtorValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(destructor, dtorType, &dtorValue);
[-] 			m_module->m_llvmIrBuilder.createCall (addDestructor, addDestructor->getType (), dtorValue, NULL);
[+] 			m_module->m_llvmIrBuilder.createCall(addDestructor, addDestructor->getType(), dtorValue, NULL);
[-] 		Function* constructor = namedTypeBlock->getStaticConstructor ();
[+] 		Function* constructor = namedTypeBlock->getStaticConstructor();
[-] 		ASSERT (constructor);
[+] 		ASSERT(constructor);
[-] 		m_module->m_llvmIrBuilder.createCall (constructor, constructor->getType (), NULL);
[+] 		m_module->m_llvmIrBuilder.createCall(constructor, constructor->getType(), NULL);
[-] FunctionMgr::overrideThisValue (const Value& value)
[+] FunctionMgr::overrideThisValue(const Value& value)
[-] FunctionMgr::createFunction (
[+] FunctionMgr::createFunction(
[-] 	switch (functionKind)
[+] 	switch(functionKind)
[-] 		function = AXL_MEM_NEW (ThunkFunction);
[+] 		function = AXL_MEM_NEW(ThunkFunction);
[-] 		m_thunkFunctionList.insertTail ((ThunkFunction*) function);
[+] 		m_thunkFunctionList.insertTail((ThunkFunction*)function);
[-] 		function = AXL_MEM_NEW (ScheduleLauncherFunction);
[+] 		function = AXL_MEM_NEW(ScheduleLauncherFunction);
[-] 		m_scheduleLauncherFunctionList.insertTail ((ScheduleLauncherFunction*) function);
[+] 		m_scheduleLauncherFunctionList.insertTail((ScheduleLauncherFunction*)function);
[-] 		function = AXL_MEM_NEW (AsyncFunction);
[+] 		function = AXL_MEM_NEW(AsyncFunction);
[-] 		m_asyncFunctionList.insertTail ((AsyncFunction*) function);
[+] 		m_asyncFunctionList.insertTail((AsyncFunction*)function);
[-] 		function = AXL_MEM_NEW (Function);
[+] 		function = AXL_MEM_NEW(Function);
[-] 		m_functionList.insertTail (function);
[+] 		m_functionList.insertTail(function);
[-] 	function->m_typeOverload.addOverload (type);
[+] 	function->m_typeOverload.addOverload(type);
[-] FunctionMgr::createProperty (
[+] FunctionMgr::createProperty(
[-] 	switch (propertyKind)
[+] 	switch(propertyKind)
[-] 		prop = AXL_MEM_NEW (ThunkProperty);
[+] 		prop = AXL_MEM_NEW(ThunkProperty);
[-] 		m_thunkPropertyList.insertTail ((ThunkProperty*) prop);
[+] 		m_thunkPropertyList.insertTail((ThunkProperty*)prop);
[-] 		prop = AXL_MEM_NEW (DataThunkProperty);
[+] 		prop = AXL_MEM_NEW(DataThunkProperty);
[-] 		m_dataThunkPropertyList.insertTail ((DataThunkProperty*) prop);
[+] 		m_dataThunkPropertyList.insertTail((DataThunkProperty*)prop);
[-] 		prop = AXL_MEM_NEW (Property);
[+] 		prop = AXL_MEM_NEW(Property);
[-] 		m_propertyList.insertTail (prop);
[+] 		m_propertyList.insertTail(prop);
[-] 	m_module->markForLayout (prop, true);
[+] 	m_module->markForLayout(prop, true);
[-] FunctionMgr::createPropertyTemplate ()
[+] FunctionMgr::createPropertyTemplate()
[-] 	PropertyTemplate* propertyTemplate = AXL_MEM_NEW (PropertyTemplate);
[+] 	PropertyTemplate* propertyTemplate = AXL_MEM_NEW(PropertyTemplate);
[-] 	m_propertyTemplateList.insertTail (propertyTemplate);
[+] 	m_propertyTemplateList.insertTail(propertyTemplate);
[-] FunctionMgr::fireOnChanged ()
[+] FunctionMgr::fireOnChanged()
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		function->m_property->getType ()->getFlags () & PropertyTypeFlag_Bindable
[+] 		function->m_property->getType()->getFlags() & PropertyTypeFlag_Bindable
[-] 		ASSERT (m_thisValue);
[+] 		ASSERT(m_thisValue);
[-] 		Closure* closure = propertyValue.createClosure ();
[+] 		Closure* closure = propertyValue.createClosure();
[-] 		closure->insertThisArgValue (m_thisValue);
[+] 		closure->insertThisArgValue(m_thisValue);
[-] 		m_module->m_operatorMgr.getPropertyOnChanged (propertyValue, &onChanged) &&
[+] 		m_module->m_operatorMgr.getPropertyOnChanged(propertyValue, &onChanged) &&
[-] 		m_module->m_operatorMgr.memberOperator (&onChanged, "call") &&
[+] 		m_module->m_operatorMgr.memberOperator(&onChanged, "call") &&
[-] 		m_module->m_operatorMgr.callOperator (onChanged);
[+] 		m_module->m_operatorMgr.callOperator(onChanged);
[-] FunctionMgr::setCurrentFunction (Function* function)
[+] FunctionMgr::setCurrentFunction(Function* function)
[-] FunctionMgr::prologue (
[+] FunctionMgr::prologue(
[-] 	function->m_allocaBlock = m_module->m_controlFlowMgr.createBlock ("function_entry");
[+] 	function->m_allocaBlock = m_module->m_controlFlowMgr.createBlock("function_entry");
[-] 	function->m_allocaBlock->markEntry ();
[+] 	function->m_allocaBlock->markEntry();
[-] 	function->m_prologueBlock = m_module->m_controlFlowMgr.createBlock ("function_prologue");
[+] 	function->m_prologueBlock = m_module->m_controlFlowMgr.createBlock("function_prologue");
[-] 	function->m_prologueBlock->markEntry ();
[+] 	function->m_prologueBlock->markEntry();
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (function->m_allocaBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(function->m_allocaBlock);
[-] 	m_module->m_controlFlowMgr.jump (function->m_prologueBlock);
[+] 	m_module->m_controlFlowMgr.jump(function->m_prologueBlock);
[-] 	m_module->m_llvmIrBuilder.setAllocaBlock (function->m_allocaBlock);
[+] 	m_module->m_llvmIrBuilder.setAllocaBlock(function->m_allocaBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (function->m_prologueBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(function->m_prologueBlock);
[-] 	m_module->m_namespaceMgr.openNamespace (function->m_parentNamespace);
[+] 	m_module->m_namespaceMgr.openNamespace(function->m_parentNamespace);
[-] 	function->m_scope = m_module->m_namespaceMgr.openScope (pos);
[+] 	function->m_scope = m_module->m_namespaceMgr.openScope(pos);
[-] 		function->m_scope->m_usingSet.addGlobalNamespace (function->m_extensionNamespace);
[+] 		function->m_scope->m_usingSet.addGlobalNamespace(function->m_extensionNamespace);
[-] 		function->m_scope->m_usingSet.addExtensionNamespace (function->m_extensionNamespace);
[+] 		function->m_scope->m_usingSet.addExtensionNamespace(function->m_extensionNamespace);
[-] 	if (function->m_type->getFlags () & FunctionTypeFlag_Unsafe)
[+] 	if (function->m_type->getFlags() & FunctionTypeFlag_Unsafe)
[-] 		m_module->m_operatorMgr.enterUnsafeRgn ();
[+] 		m_module->m_operatorMgr.enterUnsafeRgn();
[-] 	function->getType ()->getCallConv ()->createArgVariables (function);
[+] 	function->getType()->getCallConv()->createArgVariables(function);
[-] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock ("function_body");
[+] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock("function_body");
[-] 	m_module->m_controlFlowMgr.jump (bodyBlock, bodyBlock);
[+] 	m_module->m_controlFlowMgr.jump(bodyBlock, bodyBlock);
[-] 	uint_t compileFlags = m_module->getCompileFlags ();
[+] 	uint_t compileFlags = m_module->getCompileFlags();
[-] 		m_module->m_operatorMgr.checkStackOverflow ();
[+] 		m_module->m_operatorMgr.checkStackOverflow();
[-] 		m_module->m_operatorMgr.gcSafePoint ();
[+] 		m_module->m_operatorMgr.gcSafePoint();
[-] 	if (function->isMember ())
[+] 	if (function->isMember())
[-] 		createThisValue ();
[+] 		createThisValue();
[-] 		if (function->getProperty ())
[+] 		if (function->getProperty())
[-] 			function->getProperty ()->initializeStaticFields ();
[+] 			function->getProperty()->initializeStaticFields();
[-] 		else if (function->getParentType ())
[+] 		else if (function->getParentType())
[-] 			function->getParentType ()->initializeStaticFields ();
[+] 			function->getParentType()->initializeStaticFields();
[-] FunctionMgr::createThisValue ()
[+] FunctionMgr::createThisValue()
[-] 	ASSERT (function && function->isMember ());
[+] 	ASSERT(function && function->isMember());
[-] 	Value thisArgValue = function->getType ()->getCallConv ()->getThisArgValue (function);
[+] 	Value thisArgValue = function->getType()->getCallConv()->getThisArgValue(function);
[-] 	if (function->m_thisArgType->cmp (function->m_thisType) == 0)
[+] 	if (function->m_thisArgType->cmp(function->m_thisType) == 0)
[-] 		if (function->m_thisType->getTypeKind () != TypeKind_DataPtr)
[+] 		if (function->m_thisType->getTypeKind() != TypeKind_DataPtr)
[-] 			ASSERT (
[+] 			ASSERT(
[-] 				thisArgValue.getType ()->getTypeKind () == TypeKind_DataPtr &&
[+] 				thisArgValue.getType()->getTypeKind() == TypeKind_DataPtr &&
[-] 				((DataPtrType*) thisArgValue.getType ())->getPtrTypeKind () == DataPtrTypeKind_Normal);
[+] 				((DataPtrType*)thisArgValue.getType())->getPtrTypeKind() == DataPtrTypeKind_Normal);
[-] 			DataPtrType* ptrType = ((DataPtrType*) thisArgValue.getType ());
[+] 			DataPtrType* ptrType = ((DataPtrType*)thisArgValue.getType());
[-] 			ptrType = ptrType->getTargetType ()->getDataPtrType (DataPtrTypeKind_Lean, ptrType->getFlags ());
[+] 			ptrType = ptrType->getTargetType()->getDataPtrType(DataPtrTypeKind_Lean, ptrType->getFlags());
[-] 			Type* validatorType = m_module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr);
[+] 			Type* validatorType = m_module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr);
[-] 			m_module->m_llvmIrBuilder.createExtractValue (thisArgValue, 0, NULL, &ptrValue);
[+] 			m_module->m_llvmIrBuilder.createExtractValue(thisArgValue, 0, NULL, &ptrValue);
[-] 			m_module->m_llvmIrBuilder.createExtractValue (thisArgValue, 1, validatorType, &validatorValue);
[+] 			m_module->m_llvmIrBuilder.createExtractValue(thisArgValue, 1, validatorType, &validatorValue);
[-] 			m_module->m_llvmIrBuilder.createBitCast (ptrValue, ptrType, &ptrValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(ptrValue, ptrType, &ptrValue);
[-] 			m_thisValue.setLeanDataPtr (ptrValue.getLlvmValue (), ptrType, validatorValue);
[+] 			m_thisValue.setLeanDataPtr(ptrValue.getLlvmValue(), ptrType, validatorValue);
[-] 		ASSERT (function->m_storageKind == StorageKind_Override);
[+] 		ASSERT(function->m_storageKind == StorageKind_Override);
[-] 			m_module->m_llvmIrBuilder.createBitCast (thisArgValue, function->m_thisType, &m_thisValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(thisArgValue, function->m_thisType, &m_thisValue);
[-] 			m_module->m_llvmIrBuilder.createBitCast (thisArgValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(thisArgValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 			m_module->m_llvmIrBuilder.createGep (ptrValue, (int32_t) function->m_thisArgDelta, NULL, &ptrValue);
[+] 			m_module->m_llvmIrBuilder.createGep(ptrValue, (int32_t)function->m_thisArgDelta, NULL, &ptrValue);
[-] 			m_module->m_llvmIrBuilder.createBitCast (ptrValue, function->m_thisType, &m_thisValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(ptrValue, function->m_thisType, &m_thisValue);
[-] FunctionMgr::epilogue ()
[+] FunctionMgr::epilogue()
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (m_currentFunction && scope);
[+] 	ASSERT(m_currentFunction && scope);
[-] 		ASSERT (m_thisValue);
[+] 		ASSERT(m_thisValue);
[-] 		if (function->getProperty ())
[+] 		if (function->getProperty())
[-] 			Property* prop = function->getProperty ();
[+] 			Property* prop = function->getProperty();
[-] 			result = prop->callMemberPropertyDestructors (m_thisValue);
[+] 			result = prop->callMemberPropertyDestructors(m_thisValue);
[-] 			ASSERT (function->getParentType ()->getTypeKind () == TypeKind_Class && m_thisValue);
[+] 			ASSERT(function->getParentType()->getTypeKind() == TypeKind_Class && m_thisValue);
[-] 			ClassType* classType = (ClassType*) function->getParentType ();
[+] 			ClassType* classType = (ClassType*)function->getParentType();
[-] 				classType->callMemberPropertyDestructors (m_thisValue) &&
[+] 				classType->callMemberPropertyDestructors(m_thisValue) &&
[-] 				classType->callBaseTypeDestructors (m_thisValue);
[+] 				classType->callBaseTypeDestructors(m_thisValue);
[-] 	result = m_module->m_controlFlowMgr.checkReturn ();
[+] 	result = m_module->m_controlFlowMgr.checkReturn();
[-] 	if (function->m_type->getFlags () & FunctionTypeFlag_Unsafe)
[+] 	if (function->m_type->getFlags() & FunctionTypeFlag_Unsafe)
[-] 		m_module->m_operatorMgr.leaveUnsafeRgn ();
[+] 		m_module->m_operatorMgr.leaveUnsafeRgn();
[-] 	finalizeFunction (function, true);
[+] 	finalizeFunction(function, true);
[-] #if (defined (_JNC_DEBUG) && !defined (_JNC_NO_VERIFY))
[+] #if (defined(_JNC_DEBUG) && !defined(_JNC_NO_VERIFY))
[-] 	bool isBroken = llvm::verifyFunction (*function->getLlvmFunction (), llvm::ReturnStatusAction);
[+] 	bool isBroken = llvm::verifyFunction(*function->getLlvmFunction(), llvm::ReturnStatusAction);
[-] 	bool isBroken = llvm::verifyFunction (*function->getLlvmFunction ());
[+] 	bool isBroken = llvm::verifyFunction(*function->getLlvmFunction());
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			function->m_tag.sz ()
[+] 			function->m_tag.sz()
[-] FunctionMgr::finalizeFunction (
[+] FunctionMgr::finalizeFunction(
[-] 	ASSERT (function == m_currentFunction);
[+] 	ASSERT(function == m_currentFunction);
[-] 	m_module->m_namespaceMgr.closeScope ();
[+] 	m_module->m_namespaceMgr.closeScope();
[-] 		m_module->m_namespaceMgr.closeNamespace ();
[+] 		m_module->m_namespaceMgr.closeNamespace();
[-] 	m_module->m_operatorMgr.resetUnsafeRgn ();
[+] 	m_module->m_operatorMgr.resetUnsafeRgn();
[-] 	m_module->m_variableMgr.finalizeFunction ();
[+] 	m_module->m_variableMgr.finalizeFunction();
[-] 	m_module->m_gcShadowStackMgr.finalizeFunction ();
[+] 	m_module->m_gcShadowStackMgr.finalizeFunction();
[-] 	m_module->m_controlFlowMgr.finalizeFunction ();
[+] 	m_module->m_controlFlowMgr.finalizeFunction();
[-] 	size_t count = function->m_tlsVariableArray.getCount ();
[+] 	size_t count = function->m_tlsVariableArray.getCount();
[-] 		function->m_tlsVariableArray [i].m_variable->m_llvmValue = NULL;
[+] 		function->m_tlsVariableArray[i].m_variable->m_llvmValue = NULL;
[-] 	m_thisValue.clear ();
[+] 	m_thisValue.clear();
[-] 	m_promiseValue.clear ();
[+] 	m_promiseValue.clear();
[-] FunctionMgr::internalPrologue (
[+] FunctionMgr::internalPrologue(
[-] 	m_module->m_llvmIrBuilder.setCurrentDebugLoc (llvm::DebugLoc ());
[+] 	m_module->m_llvmIrBuilder.setCurrentDebugLoc(llvm::DebugLoc());
[-] 	function->m_allocaBlock = m_module->m_controlFlowMgr.createBlock ("function_entry");
[+] 	function->m_allocaBlock = m_module->m_controlFlowMgr.createBlock("function_entry");
[-] 	function->m_allocaBlock->markEntry ();
[+] 	function->m_allocaBlock->markEntry();
[-] 	function->m_prologueBlock = m_module->m_controlFlowMgr.createBlock ("function_prologue");
[+] 	function->m_prologueBlock = m_module->m_controlFlowMgr.createBlock("function_prologue");
[-] 	function->m_prologueBlock->markEntry ();
[+] 	function->m_prologueBlock->markEntry();
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (function->m_allocaBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(function->m_allocaBlock);
[-] 	m_module->m_controlFlowMgr.jump (function->m_prologueBlock);
[+] 	m_module->m_controlFlowMgr.jump(function->m_prologueBlock);
[-] 	m_module->m_llvmIrBuilder.setAllocaBlock (function->m_allocaBlock);
[+] 	m_module->m_llvmIrBuilder.setAllocaBlock(function->m_allocaBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (function->m_prologueBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(function->m_prologueBlock);
[-] 		m_module->m_namespaceMgr.openScope (*pos) :
[+] 		m_module->m_namespaceMgr.openScope(*pos) :
[-] 		m_module->m_namespaceMgr.openInternalScope ();
[+] 		m_module->m_namespaceMgr.openInternalScope();
[-] 	if (function->isMember ())
[+] 	if (function->isMember())
[-] 		createThisValue ();
[+] 		createThisValue();
[-] 		llvm::Function::arg_iterator llvmArg = function->getLlvmFunction ()->arg_begin ();
[+] 		llvm::Function::arg_iterator llvmArg = function->getLlvmFunction()->arg_begin();
[-] 		FunctionType* functionType = function->getType ();
[+] 		FunctionType* functionType = function->getType();
[-] 		CallConv* callConv = functionType->getCallConv ();
[+] 		CallConv* callConv = functionType->getCallConv();
[-] 			Value argValue = callConv->getArgValue (&*llvmArg, functionType, i);
[+] 			Value argValue = callConv->getArgValue(&*llvmArg, functionType, i);
[-] 			argValueArray [i] = argValue;
[+] 			argValueArray[i] = argValue;
[-] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock ("function_body");
[+] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock("function_body");
[-] 	m_module->m_controlFlowMgr.jump (bodyBlock, bodyBlock);
[+] 	m_module->m_controlFlowMgr.jump(bodyBlock, bodyBlock);
[-] 	uint_t compileFlags = m_module->getCompileFlags ();
[+] 	uint_t compileFlags = m_module->getCompileFlags();
[-] 		m_module->m_operatorMgr.checkStackOverflow ();
[+] 		m_module->m_operatorMgr.checkStackOverflow();
[-] 		m_module->m_operatorMgr.gcSafePoint ();
[+] 		m_module->m_operatorMgr.gcSafePoint();
[-] FunctionMgr::internalEpilogue ()
[+] FunctionMgr::internalEpilogue()
[-] 	BasicBlock* currentBlock = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* currentBlock = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	if (!currentBlock->hasTerminator ())
[+] 	if (!currentBlock->hasTerminator())
[-] 		Type* returnType = function->getType ()->getReturnType ();
[+] 		Type* returnType = function->getType()->getReturnType();
[-] 		if (returnType->getTypeKind () != TypeKind_Void)
[+] 		if (returnType->getTypeKind() != TypeKind_Void)
[-] 			returnValue = returnType->getZeroValue ();
[+] 			returnValue = returnType->getZeroValue();
[-] 		m_module->m_controlFlowMgr.ret (returnValue);
[+] 		m_module->m_controlFlowMgr.ret(returnValue);
[-] 	finalizeFunction (function, false);
[+] 	finalizeFunction(function, false);
[-] FunctionMgr::getDirectThunkFunction (
[+] FunctionMgr::getDirectThunkFunction(
[-] 	if (!hasUnusedClosure && targetFunction->m_type->cmp (thunkFunctionType) == 0)
[+] 	if (!hasUnusedClosure && targetFunction->m_type->cmp(thunkFunctionType) == 0)
[-] 		thunkFunctionType = thunkFunctionType->getStdObjectMemberMethodType ();
[+] 		thunkFunctionType = thunkFunctionType->getStdObjectMemberMethodType();
[-] 	signature.format (
[+] 	signature.format(
[-] 		thunkFunctionType->getSignature ().sz ()
[+] 		thunkFunctionType->getSignature().sz()
[-] 	sl::StringHashTableIterator <Function*> thunk = m_thunkFunctionMap.visit (signature);
[+] 	sl::StringHashTableIterator<Function*> thunk = m_thunkFunctionMap.visit(signature);
[-] 	ThunkFunction* thunkFunction = (ThunkFunction*) createFunction (FunctionKind_Thunk, thunkFunctionType);
[+] 	ThunkFunction* thunkFunction = (ThunkFunction*)createFunction(FunctionKind_Thunk, thunkFunctionType);
[-] 	m_module->markForCompile (thunkFunction);
[+] 	m_module->markForCompile(thunkFunction);
[-] FunctionMgr::getDirectThunkProperty (
[+] FunctionMgr::getDirectThunkProperty(
[-] 	if (!hasUnusedClosure && targetProperty->m_type->cmp (thunkPropertyType) == 0)
[+] 	if (!hasUnusedClosure && targetProperty->m_type->cmp(thunkPropertyType) == 0)
[-] 	signature.format (
[+] 	signature.format(
[-] 		thunkPropertyType->getSignature ().sz ()
[+] 		thunkPropertyType->getSignature().sz()
[-] 	sl::StringHashTableIterator <Property*> thunk = m_thunkPropertyMap.visit (signature);
[+] 	sl::StringHashTableIterator<Property*> thunk = m_thunkPropertyMap.visit(signature);
[-] 	ThunkProperty* thunkProperty = (ThunkProperty*) createProperty (PropertyKind_Thunk);
[+] 	ThunkProperty* thunkProperty = (ThunkProperty*)createProperty(PropertyKind_Thunk);
[-] 	bool result = thunkProperty->create (targetProperty, thunkPropertyType, hasUnusedClosure);
[+] 	bool result = thunkProperty->create(targetProperty, thunkPropertyType, hasUnusedClosure);
[-] 	thunkProperty->ensureLayout ();
[+] 	thunkProperty->ensureLayout();
[-] FunctionMgr::getDirectDataThunkProperty (
[+] FunctionMgr::getDirectDataThunkProperty(
[-] 	signature.format (
[+] 	signature.format(
[-] 		thunkPropertyType->getSignature ().sz ()
[+] 		thunkPropertyType->getSignature().sz()
[-] 	sl::StringHashTableIterator <Property*> thunk = m_thunkPropertyMap.visit (signature);
[+] 	sl::StringHashTableIterator<Property*> thunk = m_thunkPropertyMap.visit(signature);
[-] 	DataThunkProperty* thunkProperty = (DataThunkProperty*) createProperty (PropertyKind_DataThunk);
[+] 	DataThunkProperty* thunkProperty = (DataThunkProperty*)createProperty(PropertyKind_DataThunk);
[-] 		thunkPropertyType = thunkPropertyType->getStdObjectMemberPropertyType ();
[+] 		thunkPropertyType = thunkPropertyType->getStdObjectMemberPropertyType();
[-] 	result = thunkProperty->create (thunkPropertyType);
[+] 	result = thunkProperty->create(thunkPropertyType);
[-] 	thunkProperty->ensureLayout ();
[+] 	thunkProperty->ensureLayout();
[-] 	m_module->markForCompile (thunkProperty);
[+] 	m_module->markForCompile(thunkProperty);
[-] FunctionMgr::getScheduleLauncherFunction (
[+] FunctionMgr::getScheduleLauncherFunction(
[-] 	sl::String signature = targetFunctionPtrType->getSignature ();
[+] 	sl::String signature = targetFunctionPtrType->getSignature();
[-] 	sl::StringHashTableIterator <Function*> thunk = m_scheduleLauncherFunctionMap.visit (signature);
[+] 	sl::StringHashTableIterator<Function*> thunk = m_scheduleLauncherFunctionMap.visit(signature);
[-] 	ClassPtrType* schedulerPtrType = ((ClassType*) m_module->m_typeMgr.getStdType (StdType_Scheduler))->getClassPtrType (schedulerPtrTypeKind);
[+] 	ClassPtrType* schedulerPtrType = ((ClassType*)m_module->m_typeMgr.getStdType(StdType_Scheduler))->getClassPtrType(schedulerPtrTypeKind);
[-] 	sl::Array <FunctionArg*> argArray  = targetFunctionPtrType->getTargetType ()->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray  = targetFunctionPtrType->getTargetType()->getArgArray();
[-] 	argArray.insert (0, targetFunctionPtrType->getSimpleFunctionArg ());
[+] 	argArray.insert(0, targetFunctionPtrType->getSimpleFunctionArg());
[-] 	argArray.insert (1, schedulerPtrType->getSimpleFunctionArg ());
[+] 	argArray.insert(1, schedulerPtrType->getSimpleFunctionArg());
[-] 	FunctionType* launcherType = m_module->m_typeMgr.getFunctionType (argArray);
[+] 	FunctionType* launcherType = m_module->m_typeMgr.getFunctionType(argArray);
[-] 	ScheduleLauncherFunction* launcherFunction = (ScheduleLauncherFunction*) createFunction (FunctionKind_ScheduleLauncher, launcherType);
[+] 	ScheduleLauncherFunction* launcherFunction = (ScheduleLauncherFunction*)createFunction(FunctionKind_ScheduleLauncher, launcherType);
[-] 	m_module->markForCompile (launcherFunction);
[+] 	m_module->markForCompile(launcherFunction);
[-] FunctionMgr::injectTlsPrologues ()
[+] FunctionMgr::injectTlsPrologues()
[-] 	sl::Iterator <Function> it = m_functionList.getHead ();
[+] 	sl::Iterator<Function> it = m_functionList.getHead();
[-] 		if (it->getPrologueBlock () && it->isTlsRequired ())
[+] 		if (it->getPrologueBlock() && it->isTlsRequired())
[-] 			injectTlsPrologue (*it);
[+] 			injectTlsPrologue(*it);
[-] 	it = m_thunkFunctionList.getHead ();
[+] 	it = m_thunkFunctionList.getHead();
[-] 		if (it->isTlsRequired ())
[+] 		if (it->isTlsRequired())
[-] 			injectTlsPrologue (*it);
[+] 			injectTlsPrologue(*it);
[-] 	it = m_scheduleLauncherFunctionList.getHead ();
[+] 	it = m_scheduleLauncherFunctionList.getHead();
[-] 		if (it->isTlsRequired ())
[+] 		if (it->isTlsRequired())
[-] 			injectTlsPrologue (*it);
[+] 			injectTlsPrologue(*it);
[-] 	it = m_asyncFunctionList.getHead ();
[+] 	it = m_asyncFunctionList.getHead();
[-] 		if (it->isTlsRequired ())
[+] 		if (it->isTlsRequired())
[-] 			injectTlsPrologue (*it);
[+] 			injectTlsPrologue(*it);
[-] FunctionMgr::injectTlsPrologue (Function* function)
[+] FunctionMgr::injectTlsPrologue(Function* function)
[-] 	BasicBlock* block = function->getPrologueBlock ();
[+] 	BasicBlock* block = function->getPrologueBlock();
[-] 	ASSERT (block);
[+] 	ASSERT(block);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (block);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(block);
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (&*block->getLlvmBlock ()->begin ());
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(&*block->getLlvmBlock()->begin());
[-] 	Function* getTls = getStdFunction (StdFunc_GetTls);
[+] 	Function* getTls = getStdFunction(StdFunc_GetTls);
[-] 	m_module->m_llvmIrBuilder.createCall (getTls, getTls->getType (), &tlsValue);
[+] 	m_module->m_llvmIrBuilder.createCall(getTls, getTls->getType(), &tlsValue);
[-] 	sl::Array <TlsVariable> tlsVariableArray = function->getTlsVariableArray ();
[+] 	sl::Array<TlsVariable> tlsVariableArray = function->getTlsVariableArray();
[-] 	size_t count = tlsVariableArray.getCount ();
[+] 	size_t count = tlsVariableArray.getCount();
[-] 		StructField* field = tlsVariableArray [i].m_variable->getTlsField ();
[+] 		StructField* field = tlsVariableArray[i].m_variable->getTlsField();
[-] 		ASSERT (field);
[+] 		ASSERT(field);
[-] 		m_module->m_llvmIrBuilder.createGep2 (tlsValue, field->getLlvmIndex (), NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(tlsValue, field->getLlvmIndex(), NULL, &ptrValue);
[-] 		tlsVariableArray [i].m_llvmAlloca->replaceAllUsesWith (ptrValue.getLlvmValue ());
[+] 		tlsVariableArray[i].m_llvmAlloca->replaceAllUsesWith(ptrValue.getLlvmValue());
[-] 	count = tlsVariableArray.getCount ();
[+] 	count = tlsVariableArray.getCount();
[-] 		tlsVariableArray [i].m_llvmAlloca->eraseFromParent ();
[+] 		tlsVariableArray[i].m_llvmAlloca->eraseFromParent();
[-] FunctionMgr::replaceAsyncAllocas ()
[+] FunctionMgr::replaceAsyncAllocas()
[-] 	sl::Iterator <AsyncFunction> it = m_asyncFunctionList.getHead ();
[+] 	sl::Iterator<AsyncFunction> it = m_asyncFunctionList.getHead();
[-] 		it->replaceAllocas ();
[+] 		it->replaceAllocas();
[-] llvmFatalErrorHandler (
[+] llvmFatalErrorHandler(
[-] 	throw err::Error (errorString.c_str ());
[+] 	throw err::Error(errorString.c_str());
[-] FunctionMgr::jitFunctions ()
[+] FunctionMgr::jitFunctions()
[-] 	err::setFormatStringError ("LLVM jitting is disabled");
[+] 	err::setFormatStringError("LLVM jitting is disabled");
[-] 	llvm::ScopedFatalErrorHandler scopeErrorHandler (llvmFatalErrorHandler);
[+] 	llvm::ScopedFatalErrorHandler scopeErrorHandler(llvmFatalErrorHandler);
[-] 	llvm::ExecutionEngine* llvmExecutionEngine = m_module->getLlvmExecutionEngine ();
[+] 	llvm::ExecutionEngine* llvmExecutionEngine = m_module->getLlvmExecutionEngine();
[-] 		sl::Iterator <Function> functionIt = m_functionList.getHead ();
[+] 		sl::Iterator<Function> functionIt = m_functionList.getHead();
[-] 			if (!function->getPrologueBlock ())
[+] 			if (!function->getPrologueBlock())
[-] 			llvm::Function* llvmFunction = function->getLlvmFunction ();
[+] 			llvm::Function* llvmFunction = function->getLlvmFunction();
[-] 			function->m_machineCode = llvmExecutionEngine->getPointerToFunction (llvmFunction);
[+] 			function->m_machineCode = llvmExecutionEngine->getPointerToFunction(llvmFunction);
[-] 		llvmExecutionEngine->finalizeObject ();
[+] 		llvmExecutionEngine->finalizeObject();
[-] 	catch (err::Error error)
[+] 	catch(err::Error error)
[-] 		err::setFormatStringError ("LLVM jitting failed: %s", error->getDescription ().sz ());
[+] 		err::setFormatStringError("LLVM jitting failed: %s", error->getDescription ().sz ());
[-] FunctionMgr::getStdFunction (StdFunc func)
[+] FunctionMgr::getStdFunction(StdFunc func)
[-] 	ASSERT ((size_t) func < StdFunc__Count);
[+] 	ASSERT((size_t)func < StdFunc__Count);
[-] 	if (m_stdFunctionArray [func])
[+] 	if (m_stdFunctionArray[func])
[-] 		return m_stdFunctionArray [func];
[+] 		return m_stdFunctionArray[func];
[-] 	Type* argTypeArray [8] = { 0 };
[+] 	Type* argTypeArray[8] = { 0 };
[-] 	llvm::Type* llvmArgTypeArray [8] = { 0 };
[+] 	llvm::Type* llvmArgTypeArray[8] = { 0 };
[-] 	switch (func)
[+] 	switch(func)
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BoxPtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BoxPtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.primeStaticClass", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.primeStaticClass", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.tryAllocateClass", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.tryAllocateClass", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.allocateClass", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.allocateClass", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractDataPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractDataPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.tryAllocateData", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.tryAllocateData", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractDataPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractDataPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.allocateData", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.allocateData", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractDataPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractDataPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.tryAllocateArray", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.tryAllocateArray", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_AbstractDataPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_AbstractDataPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.allocateArray", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.allocateArray", functionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BoxPtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BoxPtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.createDataPtrValidator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.createDataPtrValidator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3, FunctionTypeFlag_ErrorCode);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3, FunctionTypeFlag_ErrorCode);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.tryCheckDataPtrRangeIndirect", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.tryCheckDataPtrRangeIndirect", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.checkDataPtrRangeIndirect", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.checkDataPtrRangeIndirect", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [3] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[3] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [4] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		argTypeArray[4] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 5);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 5);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.llvmMemcpy", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.llvmMemcpy", functionType);
[-] 		llvmArgTypeArray [0] = argTypeArray [0]->getLlvmType ();
[+] 		llvmArgTypeArray[0] = argTypeArray[0]->getLlvmType();
[-] 		llvmArgTypeArray [1] = argTypeArray [1]->getLlvmType ();
[+] 		llvmArgTypeArray[1] = argTypeArray[1]->getLlvmType();
[-] 		llvmArgTypeArray [2] = argTypeArray [2]->getLlvmType ();
[+] 		llvmArgTypeArray[2] = argTypeArray[2]->getLlvmType();
[-] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration (
[+] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration(
[-] 			m_module->getLlvmModule (),
[+] 			m_module->getLlvmModule(),
[-] 			llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, 3)
[+] 			llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, 3)
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [3] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[3] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [4] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		argTypeArray[4] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 5);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 5);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.llvmMemmove", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.llvmMemmove", functionType);
[-] 		llvmArgTypeArray [0] = argTypeArray [0]->getLlvmType ();
[+] 		llvmArgTypeArray[0] = argTypeArray[0]->getLlvmType();
[-] 		llvmArgTypeArray [1] = argTypeArray [1]->getLlvmType ();
[+] 		llvmArgTypeArray[1] = argTypeArray[1]->getLlvmType();
[-] 		llvmArgTypeArray [2] = argTypeArray [2]->getLlvmType ();
[+] 		llvmArgTypeArray[2] = argTypeArray[2]->getLlvmType();
[-] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration (
[+] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration(
[-] 			m_module->getLlvmModule (),
[+] 			m_module->getLlvmModule(),
[-] 			llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, 3)
[+] 			llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, 3)
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int8);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int8);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [3] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 		argTypeArray[3] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 		argTypeArray [4] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		argTypeArray[4] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 5);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 5);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.llvmMemset", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.llvmMemset", functionType);
[-] 		llvmArgTypeArray [0] = argTypeArray [0]->getLlvmType ();
[+] 		llvmArgTypeArray[0] = argTypeArray[0]->getLlvmType();
[-] 		llvmArgTypeArray [1] = argTypeArray [2]->getLlvmType ();
[+] 		llvmArgTypeArray[1] = argTypeArray[2]->getLlvmType();
[-] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration (
[+] 		function->m_llvmFunction = llvm::Intrinsic::getDeclaration(
[-] 			m_module->getLlvmModule (),
[+] 			m_module->getLlvmModule(),
[-] 			llvm::ArrayRef <llvm::Type*> (llvmArgTypeArray, 2)
[+] 			llvm::ArrayRef<llvm::Type*> (llvmArgTypeArray, 2)
[-] 		returnType = m_module->m_variableMgr.getTlsStructType ()->getDataPtrType (DataPtrTypeKind_Thin);
[+] 		returnType = m_module->m_variableMgr.getTlsStructType()->getDataPtrType(DataPtrTypeKind_Thin);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, NULL, 0);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, NULL, 0);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.getTls", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.getTls", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_SjljFrame)->getDataPtrType_c ();
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_SjljFrame)->getDataPtrType_c();
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.setJmp", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.setJmp", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, NULL, 0);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, NULL, 0);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.dynamicThrow", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.dynamicThrow", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_PromisePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_PromisePtr);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.asyncRet", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.asyncRet", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_PromisePtr);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_PromisePtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 1);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 1);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.asyncThrow", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.asyncThrow", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantUnaryOperator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantUnaryOperator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantBinaryOperator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantBinaryOperator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantRelationalOperator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantRelationalOperator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (jnc_StdType_CharConstPtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(jnc_StdType_CharConstPtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantMemberOperator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantMemberOperator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantIndexOperator", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantIndexOperator", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant)->getDataPtrType (DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant)->getDataPtrType(DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (jnc_StdType_CharConstPtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(jnc_StdType_CharConstPtr);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantMemberProperty.get", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantMemberProperty.get", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant)->getDataPtrType ();
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant)->getDataPtrType();
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (jnc_StdType_CharConstPtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(jnc_StdType_CharConstPtr);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantMemberProperty.set", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantMemberProperty.set", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant)->getDataPtrType (DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant)->getDataPtrType(DataPtrTypeKind_Normal, PtrTypeFlag_Const);
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 2);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 2);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantIndexProperty.get", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantIndexProperty.get", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant)->getDataPtrType ();
[+] 		argTypeArray[0] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant)->getDataPtrType();
[-] 		argTypeArray [1] = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.variantIndexProperty.set", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.variantIndexProperty.set", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, NULL, 0);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, NULL, 0);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.gcSafePoint", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.gcSafePoint", functionType);
[-] 		returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 		argTypeArray [0] = m_module->m_typeMgr.getStdType (StdType_GcShadowStackFrame)->getDataPtrType_c ();
[+] 		argTypeArray[0] = m_module->m_typeMgr.getStdType(StdType_GcShadowStackFrame)->getDataPtrType_c();
[-] 		argTypeArray [1] = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		argTypeArray[1] = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		argTypeArray [2] = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		argTypeArray[2] = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		functionType = m_module->m_typeMgr.getFunctionType (returnType, argTypeArray, 3);
[+] 		functionType = m_module->m_typeMgr.getFunctionType(returnType, argTypeArray, 3);
[-] 		function = createFunction (FunctionKind_Internal, "jnc.setGcShadowStackFrameMap", functionType);
[+] 		function = createFunction(FunctionKind_Internal, "jnc.setGcShadowStackFrameMap", functionType);
[-] 		source = getStdFunctionSource (func);
[+] 		source = getStdFunctionSource(func);
[-] 		ASSERT (source->m_source);
[+] 		ASSERT(source->m_source);
[-] 		function = parseStdFunction (
[+] 		function = parseStdFunction(
[-] 			sl::StringRef (source->m_source, source->m_length)
[+] 			sl::StringRef(source->m_source, source->m_length)
[-] 		function = ((MulticastClassType*) m_module->m_typeMgr.getStdType (StdType_SimpleMulticast))->getMethod (MulticastMethodKind_Call);
[+] 		function = ((MulticastClassType*)m_module->m_typeMgr.getStdType(StdType_SimpleMulticast))->getMethod(MulticastMethodKind_Call);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	m_stdFunctionArray [func] = function;
[+] 	m_stdFunctionArray[func] = function;
[-] FunctionMgr::parseStdFunction (
[+] FunctionMgr::parseStdFunction(
[-] 	lexer.create ("jnc_StdFunctions.jnc", source);
[+] 	lexer.create("jnc_StdFunctions.jnc", source);
[-] 		m_module->m_namespaceMgr.openStdNamespace (stdNamespace);
[+] 		m_module->m_namespaceMgr.openStdNamespace(stdNamespace);
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	parser.create (SymbolKind_normal_item_declaration);
[+] 	parser.create(SymbolKind_normal_item_declaration);
[-] 		const Token* token = lexer.getToken ();
[+] 		const Token* token = lexer.getToken();
[-] 		result = parser.parseToken (token);
[+] 		result = parser.parseToken(token);
[-] 			TRACE ("parse std function error: %s\n", err::getLastErrorDescription ().sz ());
[+] 			TRACE("parse std function error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 		m_module->m_namespaceMgr.closeNamespace ();
[+] 		m_module->m_namespaceMgr.closeNamespace();
[-] 	ASSERT (item && item->getItemKind () == ModuleItemKind_Function);
[+] 	ASSERT(item && item->getItemKind() == ModuleItemKind_Function);
[-] 	result = m_module->postParseStdItem ();
[+] 	result = m_module->postParseStdItem();
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	return (Function*) item;
[+] 	return (Function*)item;
[-] FunctionMgr::getLazyStdFunction (StdFunc func)
[+] FunctionMgr::getLazyStdFunction(StdFunc func)
[-] 	ASSERT ((size_t) func < StdFunc__Count);
[+] 	ASSERT((size_t)func < StdFunc__Count);
[-] 	if (m_lazyStdFunctionArray [func])
[+] 	if (m_lazyStdFunctionArray[func])
[-] 		return m_lazyStdFunctionArray [func];
[+] 		return m_lazyStdFunctionArray[func];
[-] 	LazyStdFunction* function = AXL_MEM_NEW (LazyStdFunction);
[+] 	LazyStdFunction* function = AXL_MEM_NEW(LazyStdFunction);
[-] 	m_lazyStdFunctionList.insertTail (function);
[+] 	m_lazyStdFunctionList.insertTail(function);
[-] 	m_lazyStdFunctionArray [func] = function;
[+] 	m_lazyStdFunctionArray[func] = function;
[-] FunctionMgr::getStdProperty (StdProp stdProp)
[+] FunctionMgr::getStdProperty(StdProp stdProp)
[-] 	ASSERT ((size_t) stdProp < StdProp__Count);
[+] 	ASSERT((size_t)stdProp < StdProp__Count);
[-] 	if (m_stdPropertyArray [stdProp])
[+] 	if (m_stdPropertyArray[stdProp])
[-] 		return m_stdPropertyArray [stdProp];
[+] 		return m_stdPropertyArray[stdProp];
[-] 	switch (stdProp)
[+] 	switch(stdProp)
[-] 		prop = createProperty (PropertyKind_Internal, "g_variantMember", "jnc.g_variantMember", "jnc.g_variantMember");
[+] 		prop = createProperty(PropertyKind_Internal, "g_variantMember", "jnc.g_variantMember", "jnc.g_variantMember");
[-] 		prop->m_getter = getStdFunction (StdFunc_VariantMemberProperty_get);
[+] 		prop->m_getter = getStdFunction(StdFunc_VariantMemberProperty_get);
[-] 		prop->m_setter = getStdFunction (StdFunc_VariantMemberProperty_set);
[+] 		prop->m_setter = getStdFunction(StdFunc_VariantMemberProperty_set);
[-] 		prop->m_type = m_module->m_typeMgr.getPropertyType (prop->m_getter->getType (), prop->m_setter->getType ());
[+] 		prop->m_type = m_module->m_typeMgr.getPropertyType(prop->m_getter->getType(), prop->m_setter->getType());
[-] 		prop = createProperty (PropertyKind_Internal, "g_variantIndex", "jnc.g_variantIndex", "jnc.g_variantIndex");
[+] 		prop = createProperty(PropertyKind_Internal, "g_variantIndex", "jnc.g_variantIndex", "jnc.g_variantIndex");
[-] 		prop->m_getter = getStdFunction (StdFunc_VariantIndexProperty_get);
[+] 		prop->m_getter = getStdFunction(StdFunc_VariantIndexProperty_get);
[-] 		prop->m_setter = getStdFunction (StdFunc_VariantIndexProperty_set);
[+] 		prop->m_setter = getStdFunction(StdFunc_VariantIndexProperty_set);
[-] 		prop->m_type = m_module->m_typeMgr.getPropertyType (prop->m_getter->getType (), prop->m_setter->getType ());
[+] 		prop->m_type = m_module->m_typeMgr.getPropertyType(prop->m_getter->getType(), prop->m_setter->getType());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	m_stdPropertyArray [stdProp] = prop;
[+] 	m_stdPropertyArray[stdProp] = prop;
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_Property.cpp
----------------------
[-] Property::Property ():
[+] Property::Property():
[-] 	NamedTypeBlock (this)
[+] 	NamedTypeBlock(this)
[-] Property::compile ()
[+] Property::compile()
[-] 		result = compileAutoGetter ();
[+] 		result = compileAutoGetter();
[-] 		result = compileAutoSetter ();
[+] 		result = compileAutoSetter();
[-] 	if (m_type->getFlags () & PropertyTypeFlag_Bindable)
[+] 	if (m_type->getFlags() & PropertyTypeFlag_Bindable)
[-] 		result = compileBinder ();
[+] 		result = compileBinder();
[-] Property::create (PropertyType* type)
[+] Property::create(PropertyType* type)
[-] 	if (type->getFlags () & PropertyTypeFlag_Bindable)
[+] 	if (type->getFlags() & PropertyTypeFlag_Bindable)
[-] 		result = createOnChanged ();
[+] 		result = createOnChanged();
[-] 	FunctionType* getterType = type->getGetterType ();
[+] 	FunctionType* getterType = type->getGetterType();
[-] 		result = createAutoGetValue (getterType->getReturnType ());
[+] 		result = createAutoGetValue(getterType->getReturnType());
[-] 		Function* getter = m_module->m_functionMgr.createFunction (FunctionKind_Getter, getterType);
[+] 		Function* getter = m_module->m_functionMgr.createFunction(FunctionKind_Getter, getterType);
[-] 		result = addMethod (getter);
[+] 		result = addMethod(getter);
[-] 	size_t setterTypeOverloadCount = type->getSetterType ()->getOverloadCount ();
[+] 	size_t setterTypeOverloadCount = type->getSetterType()->getOverloadCount();
[-] 		FunctionType* setterType = type->getSetterType ()->getOverload (i);
[+] 		FunctionType* setterType = type->getSetterType()->getOverload(i);
[-] 		Function* setter = m_module->m_functionMgr.createFunction (FunctionKind_Setter, setterType);
[+] 		Function* setter = m_module->m_functionMgr.createFunction(FunctionKind_Setter, setterType);
[-] 		result = addMethod (setter);
[+] 		result = addMethod(setter);
[-] 	m_type = m_parentType ? m_parentType->getMemberPropertyType (type) : type;
[+] 	m_type = m_parentType ? m_parentType->getMemberPropertyType(type) : type;
[-] 		m_module->markForCompile (this);
[+] 		m_module->markForCompile(this);
[-] Property::setOnChanged (
[+] Property::setOnChanged(
[-] 		err::setFormatStringError ("'%s' already has 'bindable %s'", m_tag.sz (), m_onChanged->m_tag.sz ());
[+] 		err::setFormatStringError("'%s' already has 'bindable %s'", m_tag.sz (), m_onChanged->m_tag.sz ());
[-] 	if (item->getItemKind () == ModuleItemKind_Alias)
[+] 	if (item->getItemKind() == ModuleItemKind_Alias)
[-] 	Type* type = getModuleItemType (item);
[+] 	Type* type = getModuleItemType(item);
[-] 		err::setFormatStringError ("invalid bindable item");
[+] 		err::setFormatStringError("invalid bindable item");
[-] 	FunctionType* binderType = (FunctionType*) m_module->m_typeMgr.getStdType (StdType_Binder);
[+] 	FunctionType* binderType = (FunctionType*)m_module->m_typeMgr.getStdType(StdType_Binder);
[-] 	Function* binder = m_module->m_functionMgr.createFunction (FunctionKind_Binder, binderType);
[+] 	Function* binder = m_module->m_functionMgr.createFunction(FunctionKind_Binder, binderType);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] 	return addMethod (binder);
[+] 	return addMethod(binder);
[-] Property::createOnChanged ()
[+] Property::createOnChanged()
[-] 	Type* type = m_module->m_typeMgr.getStdType (StdType_SimpleMulticast);
[+] 	Type* type = m_module->m_typeMgr.getStdType(StdType_SimpleMulticast);
[-] 		StructField* field = createField (name, type);
[+] 		StructField* field = createField(name, type);
[-] 			setOnChanged (field);
[+] 			setOnChanged(field);
[-] 		Variable* variable = m_module->m_variableMgr.createVariable (
[+] 		Variable* variable = m_module->m_variableMgr.createVariable(
[-] 			createQualifiedName (name),
[+] 			createQualifiedName(name),
[-] 			addItem (variable) &&
[+] 			addItem(variable) &&
[-] 			setOnChanged (variable);
[+] 			setOnChanged(variable);
[-] Property::setAutoGetValue (
[+] Property::setAutoGetValue(
[-] 		err::setFormatStringError ("'%s' already has 'autoget %s'", m_tag.sz (), m_autoGetValue->m_tag.sz ());
[+] 		err::setFormatStringError("'%s' already has 'autoget %s'", m_tag.sz (), m_autoGetValue->m_tag.sz ());
[-] 	if (item->getItemKind () == ModuleItemKind_Alias)
[+] 	if (item->getItemKind() == ModuleItemKind_Alias)
[-] 	Type* type = getModuleItemType (item);
[+] 	Type* type = getModuleItemType(item);
[-] 		err::setFormatStringError ("invalid autoget item");
[+] 		err::setFormatStringError("invalid autoget item");
[-] 	FunctionType* getterType = m_module->m_typeMgr.getFunctionType (type, NULL, 0, 0);
[+] 	FunctionType* getterType = m_module->m_typeMgr.getFunctionType(type, NULL, 0, 0);
[-] 		if (m_getter->getType ()->getReturnType ()->cmp (type) != 0)
[+] 		if (m_getter->getType()->getReturnType()->cmp(type) != 0)
[-] 			err::setFormatStringError ("'autoget %s' does not match property declaration", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'autoget %s' does not match property declaration", type->getTypeString ().sz ());
[-] 	Function* getter = m_module->m_functionMgr.createFunction (FunctionKind_Getter, getterType);
[+] 	Function* getter = m_module->m_functionMgr.createFunction(FunctionKind_Getter, getterType);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] 	return addMethod (getter);
[+] 	return addMethod(getter);
[-] Property::createAutoGetValue (Type* type)
[+] Property::createAutoGetValue(Type* type)
[-] 		StructField* field = createField (name, type);
[+] 		StructField* field = createField(name, type);
[-] 			setAutoGetValue (field);
[+] 			setAutoGetValue(field);
[-] 		Variable* variable = m_module->m_variableMgr.createVariable (
[+] 		Variable* variable = m_module->m_variableMgr.createVariable(
[-] 			createQualifiedName (name),
[+] 			createQualifiedName(name),
[-] 			addItem (variable) &&
[+] 			addItem(variable) &&
[-] 			setAutoGetValue (variable);
[+] 			setAutoGetValue(variable);
[-] Property::createFieldImpl (
[+] Property::createFieldImpl(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	ASSERT (m_parentType);
[+] 	ASSERT(m_parentType);
[-] 	if (!(m_parentType->getTypeKindFlags () & TypeKindFlag_Derivable))
[+] 	if (!(m_parentType->getTypeKindFlags() & TypeKindFlag_Derivable))
[-] 		err::setFormatStringError ("'%s' cannot have field members", m_parentType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' cannot have field members", m_parentType->getTypeString ().sz ());
[-] 	DerivableType* parentType = (DerivableType*) m_parentType;
[+] 	DerivableType* parentType = (DerivableType*)m_parentType;
[-] 	StructField* field = parentType->createField (sl::String (), type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 	StructField* field = parentType->createField(sl::String(), type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 	if (!name.isEmpty ())
[+] 	if (!name.isEmpty())
[-] 		result = addItem (field);
[+] 		result = addItem(field);
[-] Property::addMethod (Function* function)
[+] Property::addMethod(Function* function)
[-] 	StorageKind storageKind = function->getStorageKind ();
[+] 	StorageKind storageKind = function->getStorageKind();
[-] 	FunctionKind functionKind = function->getFunctionKind ();
[+] 	FunctionKind functionKind = function->getFunctionKind();
[-] 	uint_t functionKindFlags = getFunctionKindFlags (functionKind);
[+] 	uint_t functionKindFlags = getFunctionKindFlags(functionKind);
[-] 	bool hasArgs = !function->getType ()->getArgArray ().isEmpty ();
[+] 	bool hasArgs = !function->getType()->getArgArray().isEmpty();
[-] 		switch (storageKind)
[+] 		switch(storageKind)
[-] 				err::setFormatStringError ("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[+] 				err::setFormatStringError("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[-] 			function->convertToMemberMethod (m_parentType);
[+] 			function->convertToMemberMethod(m_parentType);
[-] 			if (m_parentType->getTypeKind () != TypeKind_Class)
[+] 			if (m_parentType->getTypeKind() != TypeKind_Class)
[-] 				err::setFormatStringError ("virtual method cannot be added to '%s'", m_parentType->getTypeString ().sz ());
[+] 				err::setFormatStringError("virtual method cannot be added to '%s'", m_parentType->getTypeString ().sz ());
[-] 			if (m_parentType->getFlags () & ModuleItemFlag_Sealed)
[+] 			if (m_parentType->getFlags() & ModuleItemFlag_Sealed)
[-] 				err::setFormatStringError ("'%s' is completed, cannot add virtual methods to it", m_parentType->getTypeString ().sz ());
[+] 				err::setFormatStringError("'%s' is completed, cannot add virtual methods to it", m_parentType->getTypeString ().sz ());
[-] 			if (!function->isAccessor ())
[+] 			if (!function->isAccessor())
[-] 				((ClassType*) m_parentType)->m_virtualMethodArray.append (function); // otherwise we are already on VirtualPropertyArray
[+] 				((ClassType*)m_parentType)->m_virtualMethodArray.append(function); // otherwise we are already on VirtualPropertyArray
[-] 			function->convertToMemberMethod (m_parentType);
[+] 			function->convertToMemberMethod(m_parentType);
[-] 			err::setFormatStringError ("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[+] 			err::setFormatStringError("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[-] 		switch (storageKind)
[+] 		switch(storageKind)
[-] 			err::setFormatStringError ("invalid storage specifier '%s' for static property member", getStorageKindString (storageKind));
[+] 			err::setFormatStringError("invalid storage specifier '%s' for static property member", getStorageKindString (storageKind));
[-] 			err::setFormatStringError ("global property methods cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[+] 			err::setFormatStringError("global property methods cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[-] 	switch (functionKind)
[+] 	switch(functionKind)
[-] 			err::setFormatStringError ("property constructor cannot have arguments");
[+] 			err::setFormatStringError("property constructor cannot have arguments");
[-] 		result = m_verifier.checkGetter (function->getType ());
[+] 		result = m_verifier.checkGetter(function->getType());
[-] 			err::setFormatStringError ("const property '%s' cannot have setters", m_tag.sz ());
[+] 			err::setFormatStringError("const property '%s' cannot have setters", m_tag.sz ());
[-] 		result = m_verifier.checkSetter (function->getType ());
[+] 		result = m_verifier.checkSetter(function->getType());
[-] 		return addFunction (function) != -1;
[+] 		return addFunction(function) != -1;
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getFunctionKindString (functionKind),
[+] 			getFunctionKindString(functionKind),
[-] 			m_tag.sz ()
[+] 			m_tag.sz()
[-] 	function->m_tag.format ("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[+] 	function->m_tag.format("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[-] 		result = (*target)->addOverload (function) != -1;
[+] 		result = (*target)->addOverload(function) != -1;
[-] Property::addProperty (Property* prop)
[+] Property::addProperty(Property* prop)
[-] 	ASSERT (prop->isNamed ());
[+] 	ASSERT(prop->isNamed());
[-] 	bool result = addItem (prop);
[+] 	bool result = addItem(prop);
[-] 	StorageKind storageKind = prop->getStorageKind ();
[+] 	StorageKind storageKind = prop->getStorageKind();
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 		if (m_parentType->getTypeKind () != TypeKind_Class)
[+] 		if (m_parentType->getTypeKind() != TypeKind_Class)
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				getStorageKindString (storageKind),
[+] 				getStorageKindString(storageKind),
[-] 				m_parentType->getTypeString ().sz ()
[+] 				m_parentType->getTypeString().sz()
[-] 		((ClassType*) m_parentType)->m_virtualPropertyArray.append (prop);
[+] 		((ClassType*)m_parentType)->m_virtualPropertyArray.append(prop);
[-] 		err::setFormatStringError ("invalid storage specifier '%s' for property member", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("invalid storage specifier '%s' for property member", getStorageKindString (storageKind));
[-] Property::calcLayout ()
[+] Property::calcLayout()
[-] 	ASSERT (m_storageKind && m_vtable.isEmpty ());
[+] 	ASSERT(m_storageKind && m_vtable.isEmpty());
[-] 	if (m_autoGetValue && m_autoGetValue->getItemKind () == ModuleItemKind_Alias)
[+] 	if (m_autoGetValue && m_autoGetValue->getItemKind() == ModuleItemKind_Alias)
[-] 		Alias* alias = (Alias*) m_autoGetValue;
[+] 		Alias* alias = (Alias*)m_autoGetValue;
[-] 		result = alias->ensureLayout () && setAutoGetValue (alias->getTargetItem (), true);
[+] 		result = alias->ensureLayout() && setAutoGetValue(alias->getTargetItem(), true);
[-] 		ASSERT (m_autoGetValue->getItemKind () != ModuleItemKind_Alias);
[+] 		ASSERT(m_autoGetValue->getItemKind() != ModuleItemKind_Alias);
[-] 	if (m_onChanged && m_onChanged->getItemKind () == ModuleItemKind_Alias)
[+] 	if (m_onChanged && m_onChanged->getItemKind() == ModuleItemKind_Alias)
[-] 		Alias* alias = (Alias*) m_onChanged;
[+] 		Alias* alias = (Alias*)m_onChanged;
[-] 		result = alias->ensureLayout () && setOnChanged (alias->getTargetItem (), true);
[+] 		result = alias->ensureLayout() && setOnChanged(alias->getTargetItem(), true);
[-] 		ASSERT (m_onChanged->getItemKind () != ModuleItemKind_Alias);
[+] 		ASSERT(m_onChanged->getItemKind() != ModuleItemKind_Alias);
[-] 		err::setFormatStringError ("incomplete property: no 'get' method or 'autoget' field");
[+] 		err::setFormatStringError("incomplete property: no 'get' method or 'autoget' field");
[-] 		createType ();
[+] 		createType();
[-] 	size_t setterCount = m_setter ? m_setter->getOverloadCount () : 0;
[+] 	size_t setterCount = m_setter ? m_setter->getOverloadCount() : 0;
[-] 	m_vtable.reserve (2 + setterCount);
[+] 	m_vtable.reserve(2 + setterCount);
[-] 		result = m_binder->getType ()->ensureLayout ();
[+] 		result = m_binder->getType()->ensureLayout();
[-] 		m_vtable.append (m_binder);
[+] 		m_vtable.append(m_binder);
[-] 	result = m_getter->getType ()->ensureLayout ();
[+] 	result = m_getter->getType()->ensureLayout();
[-] 	m_vtable.append (m_getter);
[+] 	m_vtable.append(m_getter);
[-] 		Function* setter = m_setter->getOverload (i);
[+] 		Function* setter = m_setter->getOverload(i);
[-] 		result = setter->getType ()->ensureLayout ();
[+] 		result = setter->getType()->ensureLayout();
[-] 		m_vtable.append (setter);
[+] 		m_vtable.append(setter);
[-] 	createVTableVariable ();
[+] 	createVTableVariable();
[-] Property::createType ()
[+] Property::createType()
[-] 	ASSERT (!m_type);
[+] 	ASSERT(!m_type);
[-] 		m_module->m_typeMgr.getPropertyType (
[+] 		m_module->m_typeMgr.getPropertyType(
[-] 			m_getter->getType (),
[+] 			m_getter->getType(),
[-] 			*m_setter->getTypeOverload (),
[+] 			*m_setter->getTypeOverload(),
[-] 		m_module->m_typeMgr.getPropertyType (
[+] 		m_module->m_typeMgr.getPropertyType(
[-] 			m_getter->getType (),
[+] 			m_getter->getType(),
[-] Property::createVTableVariable ()
[+] Property::createVTableVariable()
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Constant*> llvmVTable (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Constant*> llvmVTable(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	size_t count = m_vtable.getCount ();
[+] 	size_t count = m_vtable.getCount();
[-] 	llvmVTable.setCount (count);
[+] 	llvmVTable.setCount(count);
[-] 		Function* function = m_vtable [i];
[+] 		Function* function = m_vtable[i];
[-] 		if (function->getStorageKind () == StorageKind_Abstract)
[+] 		if (function->getStorageKind() == StorageKind_Abstract)
[-] 			function = function->getType ()->getAbstractFunction ();
[+] 			function = function->getType()->getAbstractFunction();
[-] 		llvmVTable [i] = function->getLlvmFunction ();
[+] 		llvmVTable[i] = function->getLlvmFunction();
[-] 	StructType* vtableStructType = m_type->getVTableStructType ();
[+] 	StructType* vtableStructType = m_type->getVTableStructType();
[-] 	llvm::Constant* llvmVTableConst = llvm::ConstantStruct::get (
[+] 	llvm::Constant* llvmVTableConst = llvm::ConstantStruct::get(
[-] 		(llvm::StructType*) vtableStructType->getLlvmType (),
[+] 		(llvm::StructType*)vtableStructType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Constant*> (llvmVTable, count)
[+] 		llvm::ArrayRef<llvm::Constant*> (llvmVTable, count)
[-] 	m_vtableVariable = m_module->m_variableMgr.createSimpleStaticVariable (
[+] 	m_vtableVariable = m_module->m_variableMgr.createSimpleStaticVariable(
[-] 		Value (llvmVTableConst, vtableStructType)
[+] 		Value(llvmVTableConst, vtableStructType)
[-] Property::compileAutoGetter ()
[+] Property::compileAutoGetter()
[-] 	ASSERT (m_getter);
[+] 	ASSERT(m_getter);
[-] 	m_module->m_functionMgr.internalPrologue (m_getter);
[+] 	m_module->m_functionMgr.internalPrologue(m_getter);
[-] 		m_module->m_operatorMgr.getPropertyAutoGetValue (getAutoAccessorPropertyValue (), &autoGetValue) &&
[+] 		m_module->m_operatorMgr.getPropertyAutoGetValue(getAutoAccessorPropertyValue(), &autoGetValue) &&
[-] 		m_module->m_controlFlowMgr.ret (autoGetValue);
[+] 		m_module->m_controlFlowMgr.ret(autoGetValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] Property::compileAutoSetter ()
[+] Property::compileAutoSetter()
[-] 	ASSERT (m_setter && !m_setter->isOverloaded ());
[+] 	ASSERT(m_setter && !m_setter->isOverloaded());
[-] 	ASSERT (m_type->getFlags () & PropertyTypeFlag_Bindable);
[+] 	ASSERT(m_type->getFlags() & PropertyTypeFlag_Bindable);
[-] 	if (isMember ())
[+] 	if (isMember())
[-] 		Value argValueArray [2];
[+] 		Value argValueArray[2];
[-] 		m_module->m_functionMgr.internalPrologue (m_setter, argValueArray, 2);
[+] 		m_module->m_functionMgr.internalPrologue(m_setter, argValueArray, 2);
[-] 		srcValue = argValueArray [1];
[+] 		srcValue = argValueArray[1];
[-] 		m_module->m_functionMgr.internalPrologue (m_setter, &srcValue, 1);
[+] 		m_module->m_functionMgr.internalPrologue(m_setter, &srcValue, 1);
[-] 	BasicBlock* assignBlock = m_module->m_controlFlowMgr.createBlock ("assign_block");
[+] 	BasicBlock* assignBlock = m_module->m_controlFlowMgr.createBlock("assign_block");
[-] 	BasicBlock* returnBlock = m_module->m_controlFlowMgr.createBlock ("return_block");
[+] 	BasicBlock* returnBlock = m_module->m_controlFlowMgr.createBlock("return_block");
[-] 		m_module->m_operatorMgr.getPropertyAutoGetValue (getAutoAccessorPropertyValue (), &autoGetValue) &&
[+] 		m_module->m_operatorMgr.getPropertyAutoGetValue(getAutoAccessorPropertyValue(), &autoGetValue) &&
[-] 		m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, autoGetValue, srcValue, &cmpValue) &&
[+] 		m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, autoGetValue, srcValue, &cmpValue) &&
[-] 		m_module->m_controlFlowMgr.conditionalJump (cmpValue, assignBlock, returnBlock) &&
[+] 		m_module->m_controlFlowMgr.conditionalJump(cmpValue, assignBlock, returnBlock) &&
[-] 		m_module->m_operatorMgr.storeDataRef (autoGetValue, srcValue) &&
[+] 		m_module->m_operatorMgr.storeDataRef(autoGetValue, srcValue) &&
[-] 		m_module->m_functionMgr.fireOnChanged ();
[+] 		m_module->m_functionMgr.fireOnChanged();
[-] 	m_module->m_controlFlowMgr.follow (returnBlock);
[+] 	m_module->m_controlFlowMgr.follow(returnBlock);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] Property::compileBinder ()
[+] Property::compileBinder()
[-] 	ASSERT (m_binder);
[+] 	ASSERT(m_binder);
[-] 	m_module->m_functionMgr.internalPrologue (m_binder);
[+] 	m_module->m_functionMgr.internalPrologue(m_binder);
[-] 		m_module->m_operatorMgr.getPropertyOnChanged (getAutoAccessorPropertyValue (), &onChangedValue) &&
[+] 		m_module->m_operatorMgr.getPropertyOnChanged(getAutoAccessorPropertyValue(), &onChangedValue) &&
[-] 		m_module->m_controlFlowMgr.ret (onChangedValue);
[+] 		m_module->m_controlFlowMgr.ret(onChangedValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] Property::getAutoAccessorPropertyValue ()
[+] Property::getAutoAccessorPropertyValue()
[-] 	if (!isMember ())
[+] 	if (!isMember())
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	Closure* closure = propertyValue.createClosure ();
[+] 	Closure* closure = propertyValue.createClosure();
[-] 	closure->insertThisArgValue (thisValue);
[+] 	closure->insertThisArgValue(thisValue);
[-] Property::generateDocumentation (
[+] Property::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	itemXml->format ("<memberdef kind='property' id='%s'", doxyBlock->getRefId ().sz ());
[+] 	itemXml->format("<memberdef kind='property' id='%s'", doxyBlock->getRefId ().sz ());
[-] 		itemXml->appendFormat (" prot='%s'", getAccessKindString (m_accessKind));
[+] 		itemXml->appendFormat(" prot='%s'", getAccessKindString (m_accessKind));
[-] 		itemXml->append (" static='yes'");
[+] 		itemXml->append(" static='yes'");
[-] 	if (isVirtual ())
[+] 	if (isVirtual())
[-] 		itemXml->appendFormat (" virt='%s'", getStorageKindString (m_storageKind));
[+] 		itemXml->appendFormat(" virt='%s'", getStorageKindString (m_storageKind));
[-] 	itemXml->appendFormat (">\n<name>%s</name>\n", m_name.sz ());
[+] 	itemXml->appendFormat(">\n<name>%s</name>\n", m_name.sz ());
[-] 	itemXml->append (m_type->getDoxyTypeString ());
[+] 	itemXml->append(m_type->getDoxyTypeString());
[-] 		modifierString.append (" autoget");
[+] 		modifierString.append(" autoget");
[-] 		modifierString.append (" autoset");
[+] 		modifierString.append(" autoset");
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 		itemXml->appendFormat ("<modifiers>%s</modifiers>\n", modifierString.getTrimmedString ().sz ());
[+] 		itemXml->appendFormat("<modifiers>%s</modifiers>\n", modifierString.getTrimmedString ().sz ());
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_PropertyTemplate.cpp
----------------------
[-] PropertyTemplate::PropertyTemplate ()
[+] PropertyTemplate::PropertyTemplate()
[-] PropertyTemplate::addMethod (
[+] PropertyTemplate::addMethod(
[-] 		err::setFormatStringError ("property templates can only have accessors");
[+] 		err::setFormatStringError("property templates can only have accessors");
[-] 		result = m_verifier.checkGetter (functionType);
[+] 		result = m_verifier.checkGetter(functionType);
[-] 			err::setFormatStringError ("property template already has a getter");
[+] 			err::setFormatStringError("property template already has a getter");
[-] 			m_verifier.checkSetter (functionType) &&
[+] 			m_verifier.checkSetter(functionType) &&
[-] 			m_setterType.addOverload (functionType) != -1;
[+] 			m_setterType.addOverload(functionType) != -1;
[-] PropertyTemplate::calcType ()
[+] PropertyTemplate::calcType()
[-] 		err::setFormatStringError ("incomplete property: no 'get' method or 'autoget' field");
[+] 		err::setFormatStringError("incomplete property: no 'get' method or 'autoget' field");
[-] 	return m_module->m_typeMgr.getPropertyType (m_getterType, m_setterType, m_typeFlags);
[+] 	return m_module->m_typeMgr.getPropertyType(m_getterType, m_setterType, m_typeFlags);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_PropertyVerifier.cpp
----------------------
[-] PropertyVerifier::checkSetter (FunctionType* functionType)
[+] PropertyVerifier::checkSetter(FunctionType* functionType)
[-] 	if (functionType->getArgArray ().isEmpty ())
[+] 	if (functionType->getArgArray().isEmpty())
[-] 		err::setFormatStringError ("'set' must have at least one argument");
[+] 		err::setFormatStringError("'set' must have at least one argument");
[-] 	return checkIndexSignature (FunctionKind_Setter, functionType);
[+] 	return checkIndexSignature(FunctionKind_Setter, functionType);
[-] PropertyVerifier::checkIndexSignature (
[+] PropertyVerifier::checkIndexSignature(
[-] 	ASSERT (functionKind == FunctionKind_Getter || functionKind == FunctionKind_Setter);
[+] 	ASSERT(functionKind == FunctionKind_Getter || functionKind == FunctionKind_Setter);
[-] 	sl::String indexArgSignature = createIndexArgSignature (functionKind, functionType);
[+] 	sl::String indexArgSignature = createIndexArgSignature(functionKind, functionType);
[-] 	if (m_indexArgSignature.isEmpty ())
[+] 	if (m_indexArgSignature.isEmpty())
[-] 		err::setFormatStringError ("index arguments mismatch in property accessors");
[+] 		err::setFormatStringError("index arguments mismatch in property accessors");
[-] PropertyVerifier::createIndexArgSignature (
[+] PropertyVerifier::createIndexArgSignature(
[-] 	ASSERT (functionKind == FunctionKind_Getter || functionKind == FunctionKind_Setter);
[+] 	ASSERT(functionKind == FunctionKind_Getter || functionKind == FunctionKind_Setter);
[-] 	if (functionType->isMemberMethodType ())
[+] 	if (functionType->isMemberMethodType())
[-] 		functionType = functionType->getShortType ();
[+] 		functionType = functionType->getShortType();
[-] 		return functionType->createArgSignature ();
[+] 		return functionType->createArgSignature();
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	ASSERT (argCount);
[+] 	ASSERT(argCount);
[-] 	return functionType->createArgSignature (argArray, argCount - 1, 0);
[+] 	return functionType->createArgSignature(argArray, argCount - 1, 0);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ScheduleLauncherFunction.cpp
----------------------
[-] ScheduleLauncherFunction::compile ()
[+] ScheduleLauncherFunction::compile()
[-] 	size_t argCount = m_type->getArgArray ().getCount ();
[+] 	size_t argCount = m_type->getArgArray().getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (this, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(this, argValueArray, argCount);
[-] 	Value functionPtrValue = argValueArray [0];
[+] 	Value functionPtrValue = argValueArray[0];
[-] 	Value schedulerValue = argValueArray [1];
[+] 	Value schedulerValue = argValueArray[1];
[-] 	result = m_module->m_operatorMgr.memberOperator (schedulerValue, "schedule", &scheduleValue);
[+] 	result = m_module->m_operatorMgr.memberOperator(schedulerValue, "schedule", &scheduleValue);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 			argList.insertTail (argValueArray [i]);
[+] 			argList.insertTail(argValueArray[i]);
[-] 		result = m_module->m_operatorMgr.closureOperator (&functionPtrValue, &argList);
[+] 		result = m_module->m_operatorMgr.closureOperator(&functionPtrValue, &argList);
[-] 	result = m_module->m_operatorMgr.callOperator (scheduleValue, functionPtrValue);
[+] 	result = m_module->m_operatorMgr.callOperator(scheduleValue, functionPtrValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_StdFunction.cpp
----------------------
[-] getStdFunctionSource (StdFunc stdFunc)
[+] getStdFunctionSource(StdFunc stdFunc)
[-] 	static StdItemSource sourceTable [StdFunc__Count] =
[+] 	static StdItemSource sourceTable[StdFunc__Count] =
[-] 			lengthof (dynamicSizeOfSrc),
[+] 			lengthof(dynamicSizeOfSrc),
[-] 			lengthof (dynamicCountOfSrc),
[+] 			lengthof(dynamicCountOfSrc),
[-] 			lengthof (dynamicTypeSizeOfSrc),
[+] 			lengthof(dynamicTypeSizeOfSrc),
[-] 			lengthof (dynamicFieldSizeOfSrc),
[+] 			lengthof(dynamicFieldSizeOfSrc),
[-] 			lengthof (dynamicFieldCountOfSrc),
[+] 			lengthof(dynamicFieldCountOfSrc),
[-] 			lengthof (dynamicCastDataPtrSrc),
[+] 			lengthof(dynamicCastDataPtrSrc),
[-] 			lengthof (dynamicCastClassPtrSrc),
[+] 			lengthof(dynamicCastClassPtrSrc),
[-] 			lengthof (dynamicCastVariantSrc),
[+] 			lengthof(dynamicCastVariantSrc),
[-] 			lengthof (strengthenClassPtrSrc),
[+] 			lengthof(strengthenClassPtrSrc),
[-] 			lengthof (appendFmtLiteralSrc_a),
[+] 			lengthof(appendFmtLiteralSrc_a),
[-] 			lengthof (appendFmtLiteralSrc_p),
[+] 			lengthof(appendFmtLiteralSrc_p),
[-] 			lengthof (appendFmtLiteralSrc_i32),
[+] 			lengthof(appendFmtLiteralSrc_i32),
[-] 			lengthof (appendFmtLiteralSrc_ui32),
[+] 			lengthof(appendFmtLiteralSrc_ui32),
[-] 			lengthof (appendFmtLiteralSrc_i64),
[+] 			lengthof(appendFmtLiteralSrc_i64),
[-] 			lengthof (appendFmtLiteralSrc_ui64),
[+] 			lengthof(appendFmtLiteralSrc_ui64),
[-] 			lengthof (appendFmtLiteralSrc_f),
[+] 			lengthof(appendFmtLiteralSrc_f),
[-] 			lengthof (appendFmtLiteralSrc_v),
[+] 			lengthof(appendFmtLiteralSrc_v),
[-] 			lengthof (assertionFailureSrc),
[+] 			lengthof(assertionFailureSrc),
[-] 			lengthof (addStaticDestructorSrc),
[+] 			lengthof(addStaticDestructorSrc),
[-] 			lengthof (addStaticClassDestructorSrc),
[+] 			lengthof(addStaticClassDestructorSrc),
[-] 			lengthof (tryCheckDataPtrRangeDirectSrc),
[+] 			lengthof(tryCheckDataPtrRangeDirectSrc),
[-] 			lengthof (checkDataPtrRangeDirectSrc),
[+] 			lengthof(checkDataPtrRangeDirectSrc),
[-] 			lengthof (tryCheckNullPtrSrc),
[+] 			lengthof(tryCheckNullPtrSrc),
[-] 			lengthof (checkNullPtrSrc),
[+] 			lengthof(checkNullPtrSrc),
[-] 			lengthof (checkStackOverflowSrc),
[+] 			lengthof(checkStackOverflowSrc),
[-] 			lengthof (checkDivByZeroSrc_i32),
[+] 			lengthof(checkDivByZeroSrc_i32),
[-] 			lengthof (checkDivByZeroSrc_i64),
[+] 			lengthof(checkDivByZeroSrc_i64),
[-] 			lengthof (checkDivByZeroSrc_f32),
[+] 			lengthof(checkDivByZeroSrc_f32),
[-] 			lengthof (checkDivByZeroSrc_f64),
[+] 			lengthof(checkDivByZeroSrc_f64),
[-] 			lengthof (tryLazyGetDynamicLibFunctionSrc),
[+] 			lengthof(tryLazyGetDynamicLibFunctionSrc),
[-] 			lengthof (lazyGetDynamicLibFunctionSrc),
[+] 			lengthof(lazyGetDynamicLibFunctionSrc),
[-] 			lengthof (getDynamicFieldSrc),
[+] 			lengthof(getDynamicFieldSrc),
[-] 	ASSERT ((size_t) stdFunc < StdFunc__Count);
[+] 	ASSERT((size_t)stdFunc < StdFunc__Count);
[-] 	return &sourceTable [stdFunc];
[+] 	return &sourceTable[stdFunc];
[-] LazyStdFunction::getActualItem ()
[+] LazyStdFunction::getActualItem()
[-] 	return m_module->m_functionMgr.getStdFunction (m_func);
[+] 	return m_module->m_functionMgr.getStdFunction(m_func);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ThunkFunction.cpp
----------------------
[-] ThunkFunction::ThunkFunction ()
[+] ThunkFunction::ThunkFunction()
[-] ThunkFunction::compile ()
[+] ThunkFunction::compile()
[-] 	ASSERT (m_targetFunction);
[+] 	ASSERT(m_targetFunction);
[-] 	sl::Array <FunctionArg*> thunkArgArray = m_type->getArgArray ();
[+] 	sl::Array<FunctionArg*> thunkArgArray = m_type->getArgArray();
[-] 	size_t thunkArgCount = thunkArgArray.getCount ();
[+] 	size_t thunkArgCount = thunkArgArray.getCount();
[-] 	char buffer1 [256];
[+] 	char buffer1[256];
[-] 	sl::Array <Value> thunkArgValueArray (ref::BufKind_Stack, buffer1, sizeof (buffer1));
[+] 	sl::Array<Value> thunkArgValueArray(ref::BufKind_Stack, buffer1, sizeof(buffer1));
[-] 	thunkArgValueArray.setCount (thunkArgCount);
[+] 	thunkArgValueArray.setCount(thunkArgCount);
[-] 	m_module->m_functionMgr.internalPrologue (this, thunkArgValueArray, thunkArgCount);
[+] 	m_module->m_functionMgr.internalPrologue(this, thunkArgValueArray, thunkArgCount);
[-] 	sl::Array <FunctionArg*> targetArgArray = m_targetFunction->getType ()->getArgArray ();
[+] 	sl::Array<FunctionArg*> targetArgArray = m_targetFunction->getType()->getArgArray();
[-] 	size_t targetArgCount = targetArgArray.getCount ();
[+] 	size_t targetArgCount = targetArgArray.getCount();
[-] 		ASSERT (thunkArgCount == targetArgCount + 1);
[+] 		ASSERT(thunkArgCount == targetArgCount + 1);
[-] 		AXL_TODO ("make sure we are skipping fat pointer closure in fat->thin thunk")
[+] 		AXL_TODO("make sure we are skipping fat pointer closure in fat->thin thunk")
[-] 	sl::BoxList <Value> targetArgValueList;
[+] 	sl::BoxList<Value> targetArgValueList;
[-] 		Value* argValue = targetArgValueList.insertTail ().p ();
[+] 		Value* argValue = targetArgValueList.insertTail().p();
[-] 		result = m_module->m_operatorMgr.castOperator (
[+] 		result = m_module->m_operatorMgr.castOperator(
[-] 			thunkArgValueArray [j],
[+] 			thunkArgValueArray[j],
[-] 			targetArgArray [i]->getType (),
[+] 			targetArgArray[i]->getType(),
[-] 	result = m_module->m_operatorMgr.callOperator (
[+] 	result = m_module->m_operatorMgr.callOperator(
[-] 	if (m_type->getReturnType ()->getTypeKind () != TypeKind_Void)
[+] 	if (m_type->getReturnType()->getTypeKind() != TypeKind_Void)
[-] 		result = m_module->m_controlFlowMgr.ret (returnValue);
[+] 		result = m_module->m_controlFlowMgr.ret(returnValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ThunkProperty.cpp
----------------------
[-] ThunkProperty::ThunkProperty ()
[+] ThunkProperty::ThunkProperty()
[-] ThunkProperty::create (
[+] ThunkProperty::create(
[-] 		thunkPropertyType->getStdObjectMemberPropertyType () :
[+] 		thunkPropertyType->getStdObjectMemberPropertyType() :
[-] 	m_getter = m_module->m_functionMgr.getDirectThunkFunction (
[+] 	m_getter = m_module->m_functionMgr.getDirectThunkFunction(
[-] 		targetProperty->getGetter (),
[+] 		targetProperty->getGetter(),
[-] 		thunkPropertyType->getGetterType (),
[+] 		thunkPropertyType->getGetterType(),
[-] 	Function* targetSetter = targetProperty->getSetter ();
[+] 	Function* targetSetter = targetProperty->getSetter();
[-] 	FunctionTypeOverload* thunkSetterType = thunkPropertyType->getSetterType ();
[+] 	FunctionTypeOverload* thunkSetterType = thunkPropertyType->getSetterType();
[-] 	size_t setterCount = thunkSetterType->getOverloadCount ();
[+] 	size_t setterCount = thunkSetterType->getOverloadCount();
[-] 		setCastError (targetProperty, thunkPropertyType);
[+] 		setCastError(targetProperty, thunkPropertyType);
[-] 		FunctionType* thunkFunctionType = thunkSetterType->getOverload (i);
[+] 		FunctionType* thunkFunctionType = thunkSetterType->getOverload(i);
[-] 		Function* overload = targetSetter->chooseSetterOverload (thunkFunctionType);
[+] 		Function* overload = targetSetter->chooseSetterOverload(thunkFunctionType);
[-] 		Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction (
[+] 		Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction(
[-] 			result = m_setter->addOverload (thunkFunction) != -1;
[+] 			result = m_setter->addOverload(thunkFunction) != -1;
[-] DataThunkProperty::DataThunkProperty ()
[+] DataThunkProperty::DataThunkProperty()
[-] DataThunkProperty::compile ()
[+] DataThunkProperty::compile()
[-] 	bool result = compileGetter ();
[+] 	bool result = compileGetter();
[-] 		size_t count = m_setter->getOverloadCount ();
[+] 		size_t count = m_setter->getOverloadCount();
[-] 			Function* overload = m_setter->getOverload (i);
[+] 			Function* overload = m_setter->getOverload(i);
[-] 			result = compileSetter (overload);
[+] 			result = compileSetter(overload);
[-] DataThunkProperty::compileGetter ()
[+] DataThunkProperty::compileGetter()
[-] 	m_module->m_functionMgr.internalPrologue (m_getter);
[+] 	m_module->m_functionMgr.internalPrologue(m_getter);
[-] 	bool result = m_module->m_controlFlowMgr.ret (m_targetVariable);
[+] 	bool result = m_module->m_controlFlowMgr.ret(m_targetVariable);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DataThunkProperty::compileSetter (Function* setter)
[+] DataThunkProperty::compileSetter(Function* setter)
[-] 	size_t argCount = setter->getType ()->getArgArray ().getCount ();
[+] 	size_t argCount = setter->getType()->getArgArray().getCount();
[-] 	ASSERT (argCount == 1 || argCount == 2);
[+] 	ASSERT(argCount == 1 || argCount == 2);
[-] 	Value argValueArray [2];
[+] 	Value argValueArray[2];
[-] 	m_module->m_functionMgr.internalPrologue (setter, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(setter, argValueArray, argCount);
[-] 	bool result = m_module->m_operatorMgr.storeDataRef (m_targetVariable, argValueArray [argCount - 1]);
[+] 	bool result = m_module->m_operatorMgr.storeDataRef(m_targetVariable, argValueArray[argCount - 1]);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_AsyncFunction.h
----------------------
[-] 	AsyncFunction ()
[+] 	AsyncFunction()
[-] 	getPromiseType ()
[+] 	getPromiseType()
[-] 	compile ();
[+] 	compile();
[-] 	replaceAllocas ();
[+] 	replaceAllocas();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_Function.h
----------------------
[-] 	FunctionName ()
[+] 	FunctionName()
[-] 	getFunctionKind ()
[+] 	getFunctionKind()
[-] 	getUnOpKind ()
[+] 	getUnOpKind()
[-] 		ASSERT (m_functionKind == FunctionKind_UnaryOperator);
[+] 		ASSERT(m_functionKind == FunctionKind_UnaryOperator);
[-] 	getBinOpKind ()
[+] 	getBinOpKind()
[-] 		ASSERT (m_functionKind == FunctionKind_BinaryOperator);
[+] 		ASSERT(m_functionKind == FunctionKind_BinaryOperator);
[-] 	getCastOpType ()
[+] 	getCastOpType()
[-] 		ASSERT (m_functionKind == FunctionKind_CastOperator);
[+] 		ASSERT(m_functionKind == FunctionKind_CastOperator);
[-] 	getAsyncLauncher ()
[+] 	getAsyncLauncher()
[-] 		ASSERT (m_functionKind == FunctionKind_Async);
[+] 		ASSERT(m_functionKind == FunctionKind_Async);
[-] 	getDeclaratorName ()
[+] 	getDeclaratorName()
[-] 	getThisArgTypeFlags ()
[+] 	getThisArgTypeFlags()
[-] 	sl::Array <Function*> m_overloadArray;
[+] 	sl::Array<Function*> m_overloadArray;
[-] 	sl::BoxList <Token> m_body;
[+] 	sl::BoxList<Token> m_body;
[-] 	sl::Array <TlsVariable> m_tlsVariableArray;
[+] 	sl::Array<TlsVariable> m_tlsVariableArray;
[-] 	Function ();
[+] 	Function();
[-] 	getType ()
[+] 	getType()
[-] 	getTypeOverload ()
[+] 	getTypeOverload()
[-] 	isTlsRequired ()
[+] 	isTlsRequired()
[-] 		return !m_tlsVariableArray.isEmpty ();
[+] 		return !m_tlsVariableArray.isEmpty();
[-] 	isAccessor ()
[+] 	isAccessor()
[-] 	isVoid ()
[+] 	isVoid()
[-] 		return m_type->getReturnType ()->getTypeKind () == TypeKind_Void;
[+] 		return m_type->getReturnType()->getTypeKind() == TypeKind_Void;
[-] 	isMember ()
[+] 	isMember()
[-] 	isVirtual ()
[+] 	isVirtual()
[-] 	getVirtualOriginClassType ()
[+] 	getVirtualOriginClassType()
[-] 	getParentType ()
[+] 	getParentType()
[-] 		return m_parentNamespace->getNamespaceKind () == NamespaceKind_Type ?
[+] 		return m_parentNamespace->getNamespaceKind() == NamespaceKind_Type ?
[-] 			(DerivableType*) (NamedType*) m_parentNamespace : NULL;
[+] 			(DerivableType*)(NamedType*)m_parentNamespace : NULL;
[-] 	getThisArgType ()
[+] 	getThisArgType()
[-] 	getThisType ()
[+] 	getThisType()
[-] 	getThisArgDelta ()
[+] 	getThisArgDelta()
[-] 	getClassVTableIndex ()
[+] 	getClassVTableIndex()
[-] 	getLibraryTableIndex ()
[+] 	getLibraryTableIndex()
[-] 	getProperty ()
[+] 	getProperty()
[-] 	convertToMemberMethod (DerivableType* parentType);
[+] 	convertToMemberMethod(DerivableType* parentType);
[-] 	hasBody ()
[+] 	hasBody()
[-] 		return !m_body.isEmpty ();
[+] 		return !m_body.isEmpty();
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getBody ()
[+] 	getBody()
[-] 	setBody (sl::BoxList <Token>* tokenList);
[+] 	setBody(sl::BoxList<Token>* tokenList);
[-] 	addUsingSet (UsingSet* usingSet);
[+] 	addUsingSet(UsingSet* usingSet);
[-] 	addUsingSet (Namespace* anchorNamespace);
[+] 	addUsingSet(Namespace* anchorNamespace);
[-] 	getScope ()
[+] 	getScope()
[-] 	getAllocaBlock ()
[+] 	getAllocaBlock()
[-] 	getPrologueBlock ()
[+] 	getPrologueBlock()
[-] 	getLlvmFunction ();
[+] 	getLlvmFunction();
[-] 	getLlvmDiSubprogram ();
[+] 	getLlvmDiSubprogram();
[-] 	getMachineCode ()
[+] 	getMachineCode()
[-] 	sl::Array <TlsVariable>
[+] 	sl::Array<TlsVariable>
[-] 	getTlsVariableArray ()
[+] 	getTlsVariableArray()
[-] 	addTlsVariable (Variable* variable);
[+] 	addTlsVariable(Variable* variable);
[-] 	isOverloaded ()
[+] 	isOverloaded()
[-] 		return !m_overloadArray.isEmpty ();
[+] 		return !m_overloadArray.isEmpty();
[-] 	getOverloadCount ()
[+] 	getOverloadCount()
[-] 		return m_overloadArray.getCount () + 1;
[+] 		return m_overloadArray.getCount() + 1;
[-] 	getOverload (size_t overloadIdx)
[+] 	getOverload(size_t overloadIdx)
[-] 			overloadIdx <= m_overloadArray.getCount () ? m_overloadArray [overloadIdx - 1] : NULL;
[+] 			overloadIdx <= m_overloadArray.getCount() ? m_overloadArray[overloadIdx - 1] : NULL;
[-] 	findOverload (FunctionType* type)
[+] 	findOverload(FunctionType* type)
[-] 		size_t i = m_typeOverload.findOverload (type);
[+] 		size_t i = m_typeOverload.findOverload(type);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	findShortOverload (FunctionType* type)
[+] 	findShortOverload(FunctionType* type)
[-] 		size_t i = m_typeOverload.findShortOverload (type);
[+] 		size_t i = m_typeOverload.findShortOverload(type);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 		size_t i = m_typeOverload.chooseOverload (argArray, argCount, castKind);
[+] 		size_t i = m_typeOverload.chooseOverload(argArray, argCount, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 		size_t i = m_typeOverload.chooseOverload (argValueArray, argCount, castKind);
[+] 		size_t i = m_typeOverload.chooseOverload(argValueArray, argCount, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 		const sl::ConstBoxList <Value>& argList,
[+] 		const sl::ConstBoxList<Value>& argList,
[-] 		size_t i = m_typeOverload.chooseOverload (argList, castKind);
[+] 		size_t i = m_typeOverload.chooseOverload(argList, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseSetterOverload (
[+] 	chooseSetterOverload(
[-] 		size_t i = m_typeOverload.chooseSetterOverload (argType, castKind);
[+] 		size_t i = m_typeOverload.chooseSetterOverload(argType, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseSetterOverload (
[+] 	chooseSetterOverload(
[-] 		size_t i = m_typeOverload.chooseSetterOverload (argValue, castKind);
[+] 		size_t i = m_typeOverload.chooseSetterOverload(argValue, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	chooseSetterOverload (
[+] 	chooseSetterOverload(
[-] 		size_t i = m_typeOverload.chooseSetterOverload (functionType, castKind);
[+] 		size_t i = m_typeOverload.chooseSetterOverload(functionType, castKind);
[-] 		return i != -1 ? getOverload (i) : NULL;
[+] 		return i != -1 ? getOverload(i) : NULL;
[-] 	addOverload (Function* function);
[+] 	addOverload(Function* function);
[-] 	compile ();
[+] 	compile();
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	compileConstructorBody ();
[+] 	compileConstructorBody();
[-] 	compileNormalBody ();
[+] 	compileNormalBody();
[-] 	compileAsyncLauncher ();
[+] 	compileAsyncLauncher();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_FunctionMgr.h
----------------------
[-] 	sl::List <Function> m_functionList;
[+] 	sl::List<Function> m_functionList;
[-] 	sl::List <Property> m_propertyList;
[+] 	sl::List<Property> m_propertyList;
[-] 	sl::List <PropertyTemplate> m_propertyTemplateList;
[+] 	sl::List<PropertyTemplate> m_propertyTemplateList;
[-] 	sl::List <ScheduleLauncherFunction> m_scheduleLauncherFunctionList;
[+] 	sl::List<ScheduleLauncherFunction> m_scheduleLauncherFunctionList;
[-] 	sl::List <AsyncFunction> m_asyncFunctionList;
[+] 	sl::List<AsyncFunction> m_asyncFunctionList;
[-] 	sl::List <ThunkFunction> m_thunkFunctionList;
[+] 	sl::List<ThunkFunction> m_thunkFunctionList;
[-] 	sl::List <ThunkProperty> m_thunkPropertyList;
[+] 	sl::List<ThunkProperty> m_thunkPropertyList;
[-] 	sl::List <DataThunkProperty> m_dataThunkPropertyList;
[+] 	sl::List<DataThunkProperty> m_dataThunkPropertyList;
[-] 	sl::List <LazyStdFunction> m_lazyStdFunctionList;
[+] 	sl::List<LazyStdFunction> m_lazyStdFunctionList;
[-] 	sl::StringHashTable <Function*> m_thunkFunctionMap;
[+] 	sl::StringHashTable<Function*> m_thunkFunctionMap;
[-] 	sl::StringHashTable <Property*> m_thunkPropertyMap;
[+] 	sl::StringHashTable<Property*> m_thunkPropertyMap;
[-] 	sl::StringHashTable <Function*> m_scheduleLauncherFunctionMap;
[+] 	sl::StringHashTable<Function*> m_scheduleLauncherFunctionMap;
[-] 	sl::Array <NamedTypeBlock*> m_staticConstructArray;
[+] 	sl::Array<NamedTypeBlock*> m_staticConstructArray;
[-] 	Function* m_stdFunctionArray [StdFunc__Count];
[+] 	Function* m_stdFunctionArray[StdFunc__Count];
[-] 	LazyStdFunction* m_lazyStdFunctionArray [StdFunc__Count];
[+] 	LazyStdFunction* m_lazyStdFunctionArray[StdFunc__Count];
[-] 	Property* m_stdPropertyArray [StdProp__Count];
[+] 	Property* m_stdPropertyArray[StdProp__Count];
[-] 	FunctionMgr ();
[+] 	FunctionMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	getCurrentFunction ()
[+] 	getCurrentFunction()
[-] 	setCurrentFunction (Function* function);
[+] 	setCurrentFunction(Function* function);
[-] 	getCurrentProperty ()
[+] 	getCurrentProperty()
[-] 		return m_currentFunction ? m_currentFunction->getProperty () : NULL;
[+] 		return m_currentFunction ? m_currentFunction->getProperty() : NULL;
[-] 	getThisValue ()
[+] 	getThisValue()
[-] 	getPromiseValue ()
[+] 	getPromiseValue()
[-] 	overrideThisValue (const Value& value);
[+] 	overrideThisValue(const Value& value);
[-] 	clear ();
[+] 	clear();
[-] 	sl::ConstList <Function>
[+] 	sl::ConstList<Function>
[-] 	getFunctionList ()
[+] 	getFunctionList()
[-] 	sl::ConstList <Property>
[+] 	sl::ConstList<Property>
[-] 	getPropertyList ()
[+] 	getPropertyList()
[-] 	sl::ConstList <ThunkFunction>
[+] 	sl::ConstList<ThunkFunction>
[-] 	getThunkFunctionList ()
[+] 	getThunkFunctionList()
[-] 	sl::ConstList <ThunkProperty>
[+] 	sl::ConstList<ThunkProperty>
[-] 	getThunkPropertyList ()
[+] 	getThunkPropertyList()
[-] 	sl::ConstList <DataThunkProperty>
[+] 	sl::ConstList<DataThunkProperty>
[-] 	getDataThunkPropertyList ()
[+] 	getDataThunkPropertyList()
[-] 	sl::Array <NamedTypeBlock*>
[+] 	sl::Array<NamedTypeBlock*>
[-] 	getStaticConstructor ()
[+] 	getStaticConstructor()
[-] 	addStaticConstructor (NamedTypeBlock* namedTypeBlock)
[+] 	addStaticConstructor(NamedTypeBlock* namedTypeBlock)
[-] 		m_staticConstructArray.append (namedTypeBlock);
[+] 		m_staticConstructArray.append(namedTypeBlock);
[-] 	callStaticConstructors ();
[+] 	callStaticConstructors();
[-] 	createFunction (
[+] 	createFunction(
[-] 	createFunction (
[+] 	createFunction(
[-] 		return createFunction (functionKind, sl::String (), sl::String (), sl::String (), type);
[+] 		return createFunction(functionKind, sl::String(), sl::String(), sl::String(), type);
[-] 	createFunction (
[+] 	createFunction(
[-] 		return createFunction (functionKind, sl::String (), sl::String (), tag, type);
[+] 		return createFunction(functionKind, sl::String(), sl::String(), tag, type);
[-] 	createFunction (
[+] 	createFunction(
[-] 		return createFunction (FunctionKind_Normal, name, qualifiedName, qualifiedName, type);
[+] 		return createFunction(FunctionKind_Normal, name, qualifiedName, qualifiedName, type);
[-] 	createProperty (
[+] 	createProperty(
[-] 	createProperty (PropertyKind propertyKind)
[+] 	createProperty(PropertyKind propertyKind)
[-] 		return createProperty (propertyKind, sl::String (), sl::String (), sl::String ());
[+] 		return createProperty(propertyKind, sl::String(), sl::String(), sl::String());
[-] 	createProperty (
[+] 	createProperty(
[-] 		return createProperty (propertyKind, sl::String (), sl::String (), tag);
[+] 		return createProperty(propertyKind, sl::String(), sl::String(), tag);
[-] 	createProperty (
[+] 	createProperty(
[-] 		return createProperty (PropertyKind_Normal, name, qualifiedName, qualifiedName);
[+] 		return createProperty(PropertyKind_Normal, name, qualifiedName, qualifiedName);
[-] 	createPropertyTemplate ();
[+] 	createPropertyTemplate();
[-] 	prologue (
[+] 	prologue(
[-] 	epilogue ();
[+] 	epilogue();
[-] 	fireOnChanged ();
[+] 	fireOnChanged();
[-] 	internalPrologue (
[+] 	internalPrologue(
[-] 	internalEpilogue ();
[+] 	internalEpilogue();
[-] 	injectTlsPrologues ();
[+] 	injectTlsPrologues();
[-] 	replaceAsyncAllocas ();
[+] 	replaceAsyncAllocas();
[-] 	jitFunctions ();
[+] 	jitFunctions();
[-] 	isStdFunctionUsed (StdFunc func)
[+] 	isStdFunctionUsed(StdFunc func)
[-] 		ASSERT (func < StdFunc__Count);
[+] 		ASSERT(func < StdFunc__Count);
[-] 		return m_stdFunctionArray [func] != NULL;
[+] 		return m_stdFunctionArray[func] != NULL;
[-] 	getStdFunction (StdFunc func);
[+] 	getStdFunction(StdFunc func);
[-] 	getLazyStdFunction (StdFunc func);
[+] 	getLazyStdFunction(StdFunc func);
[-] 	getStdProperty (StdProp prop);
[+] 	getStdProperty(StdProp prop);
[-] 	getDirectThunkFunction (
[+] 	getDirectThunkFunction(
[-] 	getDirectThunkProperty (
[+] 	getDirectThunkProperty(
[-] 	getDirectDataThunkProperty (
[+] 	getDirectDataThunkProperty(
[-] 	getScheduleLauncherFunction (
[+] 	getScheduleLauncherFunction(
[-] 	createThisValue ();
[+] 	createThisValue();
[-] 	injectTlsPrologue (Function* function);
[+] 	injectTlsPrologue(Function* function);
[-] 	finalizeFunction (
[+] 	finalizeFunction(
[-] 	parseStdFunction (
[+] 	parseStdFunction(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_Property.h
----------------------
[-] 	sl::Array <Function*> m_vtable;
[+] 	sl::Array<Function*> m_vtable;
[-] 	Property ();
[+] 	Property();
[-] 	getPropertyKind ()
[+] 	getPropertyKind()
[-] 	getType ()
[+] 	getType()
[-] 	getGetter ()
[+] 	getGetter()
[-] 	getSetter ()
[+] 	getSetter()
[-] 	getBinder ()
[+] 	getBinder()
[-] 	getOnChanged ()
[+] 	getOnChanged()
[-] 	setOnChanged (
[+] 	setOnChanged(
[-] 	createOnChanged ();
[+] 	createOnChanged();
[-] 	getAutoGetValue ()
[+] 	getAutoGetValue()
[-] 	setAutoGetValue (
[+] 	setAutoGetValue(
[-] 	createAutoGetValue (Type* type);
[+] 	createAutoGetValue(Type* type);
[-] 	getParentType ()
[+] 	getParentType()
[-] 	isMember ()
[+] 	isMember()
[-] 	isVirtual ()
[+] 	isVirtual()
[-] 	getParentClassVTableIndex ()
[+] 	getParentClassVTableIndex()
[-] 	create (PropertyType* type);
[+] 	create(PropertyType* type);
[-] 	createType ();
[+] 	createType();
[-] 	addMethod (Function* function);
[+] 	addMethod(Function* function);
[-] 	addProperty (Property* prop);
[+] 	addProperty(Property* prop);
[-] 	getVTableVariable ()
[+] 	getVTableVariable()
[-] 	compile ();
[+] 	compile();
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	createFieldImpl (
[+] 	createFieldImpl(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	createVTableVariable ();
[+] 	createVTableVariable();
[-] 	getAutoAccessorPropertyValue ();
[+] 	getAutoAccessorPropertyValue();
[-] 	compileAutoGetter ();
[+] 	compileAutoGetter();
[-] 	compileAutoSetter ();
[+] 	compileAutoSetter();
[-] 	compileBinder ();
[+] 	compileBinder();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_PropertyTemplate.h
----------------------
[-] 	PropertyTemplate ();
[+] 	PropertyTemplate();
[-] 	getGetterType ()
[+] 	getGetterType()
[-] 	getSetterType ()
[+] 	getSetterType()
[-] 	addMethod (
[+] 	addMethod(
[-] 	calcType ();
[+] 	calcType();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_PropertyVerifier.h
----------------------
[-] 	checkGetter (FunctionType* functionType)
[+] 	checkGetter(FunctionType* functionType)
[-] 		return checkIndexSignature (FunctionKind_Getter, functionType);
[+] 		return checkIndexSignature(FunctionKind_Getter, functionType);
[-] 	checkSetter (FunctionType* functionType);
[+] 	checkSetter(FunctionType* functionType);
[-] 	checkIndexSignature (
[+] 	checkIndexSignature(
[-] 	createIndexArgSignature (
[+] 	createIndexArgSignature(
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ScheduleLauncherFunction.h
----------------------
[-] 	ScheduleLauncherFunction ()
[+] 	ScheduleLauncherFunction()
[-] 	compile ();
[+] 	compile();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_StdFunction.h
----------------------
[-] getStdFunctionSource (StdFunc stdFunction);
[+] getStdFunctionSource(StdFunc stdFunction);
[-] 	LazyStdFunction ()
[+] 	LazyStdFunction()
[-] 	getActualItem ();
[+] 	getActualItem();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ThunkFunction.h
----------------------
[-] 	ThunkFunction ();
[+] 	ThunkFunction();
[-] 	compile ();
[+] 	compile();
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_FunctionMgr\jnc_ct_ThunkProperty.h
----------------------
[-] 	ThunkProperty ();
[+] 	ThunkProperty();
[-] 	create (
[+] 	create(
[-] 	DataThunkProperty ();
[+] 	DataThunkProperty();
[-] 	compile ();
[+] 	compile();
[-] 	compileGetter ();
[+] 	compileGetter();
[-] 	compileSetter (Function* setter);
[+] 	compileSetter(Function* setter);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_AttributeBlock.cpp
----------------------
[-] Attribute::calcLayout ()
[+] Attribute::calcLayout()
[-] 	ASSERT (!m_initializer.isEmpty ());
[+] 	ASSERT(!m_initializer.isEmpty());
[-] 		m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 	return m_module->m_operatorMgr.parseConstExpression (m_initializer, &m_value);
[+] 	return m_module->m_operatorMgr.parseConstExpression(m_initializer, &m_value);
[-] AttributeBlock::createAttribute (
[+] AttributeBlock::createAttribute(
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	sl::StringHashTableIterator <Attribute*> it = m_attributeMap.visit (name);
[+] 	sl::StringHashTableIterator<Attribute*> it = m_attributeMap.visit(name);
[-] 		err::setFormatStringError ("redefinition of attribute '%s'", name.sz ());
[+] 		err::setFormatStringError("redefinition of attribute '%s'", name.sz ());
[-] 	Attribute* attribute = AXL_MEM_NEW (Attribute);
[+] 	Attribute* attribute = AXL_MEM_NEW(Attribute);
[-] 		sl::takeOver (&attribute->m_initializer, initializer);
[+] 		sl::takeOver(&attribute->m_initializer, initializer);
[-] 		m_module->markForLayout (attribute);
[+] 		m_module->markForLayout(attribute);
[-] 	m_attributeList.insertTail (attribute);
[+] 	m_attributeList.insertTail(attribute);
[-] 	m_attributeArray.append (attribute);
[+] 	m_attributeArray.append(attribute);
----------------------
27/02/2019 18:02:09 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_AttributeMgr.cpp
----------------------
[-] AttributeMgr::AttributeMgr ()
[+] AttributeMgr::AttributeMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] AttributeMgr::createAttributeBlock ()
[+] AttributeMgr::createAttributeBlock()
[-] 	AttributeBlock* attributeBlock = AXL_MEM_NEW (AttributeBlock);
[+] 	AttributeBlock* attributeBlock = AXL_MEM_NEW(AttributeBlock);
[-] 	m_attributeBlockList.insertTail (attributeBlock);
[+] 	m_attributeBlockList.insertTail(attributeBlock);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ExtensionLibMgr.cpp
----------------------
[-] ExtensionLibMgr::ExtensionLibMgr ()
[+] ExtensionLibMgr::ExtensionLibMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	m_dynamicLibraryDir = io::getTempDir ();
[+] 	m_dynamicLibraryDir = io::getTempDir();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] ExtensionLibMgr::clear ()
[+] ExtensionLibMgr::clear()
[-] 	m_libArray.clear ();
[+] 	m_libArray.clear();
[-] 	while (!m_dynamicLibList.isEmpty ())
[+] 	while (!m_dynamicLibList.isEmpty())
[-] 		DynamicLibEntry* entry = m_dynamicLibList.removeHead ();
[+] 		DynamicLibEntry* entry = m_dynamicLibList.removeHead();
[-] 		if (entry->m_dynamicLib.isOpen ())
[+] 		if (entry->m_dynamicLib.isOpen())
[-] 			DynamicExtensionLibUnloadFunc* unloadFunc = (DynamicExtensionLibUnloadFunc*) entry->m_dynamicLib.getFunction (jnc_g_dynamicExtensionLibUnloadFuncName);
[+] 			DynamicExtensionLibUnloadFunc* unloadFunc = (DynamicExtensionLibUnloadFunc*)entry->m_dynamicLib.getFunction(jnc_g_dynamicExtensionLibUnloadFuncName);
[-] 			if (!unloadFunc || unloadFunc ())
[+] 			if (!unloadFunc || unloadFunc())
[-] 				entry->m_dynamicLib.close ();
[+] 				entry->m_dynamicLib.close();
[-] 				entry->m_dynamicLib.detach (); // don't unload
[+] 				entry->m_dynamicLib.detach(); // don't unload
[-] 		if (!entry->m_dynamicLibFilePath.isEmpty ())
[+] 		if (!entry->m_dynamicLibFilePath.isEmpty())
[-] 			io::deleteFile (entry->m_dynamicLibFilePath);
[+] 			io::deleteFile(entry->m_dynamicLibFilePath);
[-] 		AXL_MEM_DELETE (entry);
[+] 		AXL_MEM_DELETE(entry);
[-] 	m_sourceFileList.clear ();
[+] 	m_sourceFileList.clear();
[-] 	m_sourceFileMap.clear ();
[+] 	m_sourceFileMap.clear();
[-] 	m_opaqueClassTypeInfoMap.clear ();
[+] 	m_opaqueClassTypeInfoMap.clear();
[-] 	m_itemCache.clear ();
[+] 	m_itemCache.clear();
[-] 	m_itemCacheMap.clear ();
[+] 	m_itemCacheMap.clear();
[-] ExtensionLibMgr::addStaticLib (ExtensionLib* lib)
[+] ExtensionLibMgr::addStaticLib(ExtensionLib* lib)
[-] 	m_libArray.append (lib);
[+] 	m_libArray.append(lib);
[-] 	lib->m_addSourcesFunc (m_module);
[+] 	lib->m_addSourcesFunc(m_module);
[-] 	lib->m_addOpaqueClassTypeInfosFunc (m_module);
[+] 	lib->m_addOpaqueClassTypeInfosFunc(m_module);
[-] ExtensionLibMgr::loadDynamicLib (const sl::StringRef& fileName)
[+] ExtensionLibMgr::loadDynamicLib(const sl::StringRef& fileName)
[-] 	static char jncExt [] = ".jnc";
[+] 	static char jncExt[] = ".jnc";
[-] 	static char binExt [] = ".bin";
[+] 	static char binExt[] = ".bin";
[-] 	DynamicLibEntry* entry = AXL_MEM_NEW (DynamicLibEntry);
[+] 	DynamicLibEntry* entry = AXL_MEM_NEW(DynamicLibEntry);
[-] 	m_dynamicLibList.insertTail (entry);
[+] 	m_dynamicLibList.insertTail(entry);
[-] 	result = entry->m_zipReader.openFile (fileName);
[+] 	result = entry->m_zipReader.openFile(fileName);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <size_t> forcedImportIdxArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<size_t> forcedImportIdxArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	sl::Iterator <SourceFile> sourceFileIt = m_sourceFileList.getTail (); // save source file iterator
[+] 	sl::Iterator<SourceFile> sourceFileIt = m_sourceFileList.getTail(); // save source file iterator
[-] 	size_t count = entry->m_zipReader.getFileCount ();
[+] 	size_t count = entry->m_zipReader.getFileCount();
[-] 		sl::String fileName = entry->m_zipReader.getFileName (i);
[+] 		sl::String fileName = entry->m_zipReader.getFileName(i);
[-] 		if (fileName.isEmpty ()) // wat?
[+] 		if (fileName.isEmpty()) // wat?
[-] 		if (fileName.isSuffix (binExt))
[+] 		if (fileName.isSuffix(binExt))
[-] 		else if (fileName.isSuffix (jncExt))
[+] 		else if (fileName.isSuffix(jncExt))
[-] 			if (fileName [0] == '.')
[+] 			if (fileName[0] == '.')
[-] 				forcedImportIdxArray.append (i);
[+] 				forcedImportIdxArray.append(i);
[-] 				SourceFile* sourceFile = AXL_MEM_NEW (SourceFile);
[+] 				SourceFile* sourceFile = AXL_MEM_NEW(SourceFile);
[-] 				m_sourceFileList.insertTail (sourceFile);
[+] 				m_sourceFileList.insertTail(sourceFile);
[-] 				m_sourceFileMap [fileName] = sourceFile;
[+] 				m_sourceFileMap[fileName] = sourceFile;
[-] 		size_t count = forcedImportIdxArray.getCount ();
[+] 		size_t count = forcedImportIdxArray.getCount();
[-] 			size_t j = forcedImportIdxArray [i];
[+] 			size_t j = forcedImportIdxArray[i];
[-] 			sl::Array <char> contents = entry->m_zipReader.extractFileToMem (j);
[+] 			sl::Array<char> contents = entry->m_zipReader.extractFileToMem(j);
[-] 			sl::StringRef source (contents.getHdr (), contents.cp (), contents.getCount ());
[+] 			sl::StringRef source(contents.getHdr(), contents.cp(), contents.getCount());
[-] 			m_module->m_importMgr.addImport (entry->m_lib, NULL, source);
[+] 			m_module->m_importMgr.addImport(entry->m_lib, NULL, source);
[-] 	entry->m_dynamicLibFilePath.format ("%s/%llx-%s", m_dynamicLibraryDir.sz (), sys::getTimestamp (), dynamicLibFileName.sz ());
[+] 	entry->m_dynamicLibFilePath.format("%s/%llx-%s", m_dynamicLibraryDir.sz (), sys::getTimestamp (), dynamicLibFileName.sz ());
[-] 		entry->m_zipReader.extractFileToFile (dynamicLibFileIdx, entry->m_dynamicLibFilePath) &&
[+] 		entry->m_zipReader.extractFileToFile(dynamicLibFileIdx, entry->m_dynamicLibFilePath) &&
[-] 		entry->m_dynamicLib.open (entry->m_dynamicLibFilePath);
[+] 		entry->m_dynamicLib.open(entry->m_dynamicLibFilePath);
[-] 	DynamicExtensionLibMainFunc* mainFunc = (DynamicExtensionLibMainFunc*) entry->m_dynamicLib.getFunction (jnc_g_dynamicExtensionLibMainFuncName);
[+] 	DynamicExtensionLibMainFunc* mainFunc = (DynamicExtensionLibMainFunc*)entry->m_dynamicLib.getFunction(jnc_g_dynamicExtensionLibMainFuncName);
[-] 	ExtensionLib* lib = mainFunc (&jnc_g_dynamicExtensionLibHostImpl);
[+] 	ExtensionLib* lib = mainFunc(&jnc_g_dynamicExtensionLibHostImpl);
[-] 		err::setFormatStringError ("cannot get extension lib in '%s'", fileName.sz ());
[+] 		err::setFormatStringError("cannot get extension lib in '%s'", fileName.sz ());
[-] 	m_libArray.append (lib);
[+] 	m_libArray.append(lib);
[-] 	lib->m_addSourcesFunc (m_module);
[+] 	lib->m_addSourcesFunc(m_module);
[-] 	lib->m_addOpaqueClassTypeInfosFunc (m_module);
[+] 	lib->m_addOpaqueClassTypeInfosFunc(m_module);
[-] ExtensionLibMgr::mapAddresses ()
[+] ExtensionLibMgr::mapAddresses()
[-] 	size_t count = m_libArray.getCount ();
[+] 	size_t count = m_libArray.getCount();
[-] 		bool result = m_libArray [i]->m_mapAddressesFunc (m_module) != 0;
[+] 		bool result = m_libArray[i]->m_mapAddressesFunc(m_module) != 0;
[-] ExtensionLibMgr::findSourceFileContents (
[+] ExtensionLibMgr::findSourceFileContents(
[-] 	sl::StringHashTableIterator <SourceFile*> it = m_sourceFileMap.find (fileName);
[+] 	sl::StringHashTableIterator<SourceFile*> it = m_sourceFileMap.find(fileName);
[-] 		sl::Array <char> contents = file->m_zipReader->extractFileToMem (file->m_zipIndex);
[+] 		sl::Array<char> contents = file->m_zipReader->extractFileToMem(file->m_zipIndex);
[-] 		file->m_contents = sl::StringRef (contents.getHdr (), contents.cp (), contents.getCount ());
[+] 		file->m_contents = sl::StringRef(contents.getHdr(), contents.cp(), contents.getCount());
[-] ExtensionLibMgr::findItem (
[+] ExtensionLibMgr::findItem(
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 		return m_module->m_namespaceMgr.getGlobalNamespace ()->getItemByName (name);
[+] 		return m_module->m_namespaceMgr.getGlobalNamespace()->getItemByName(name);
[-] 	ItemCacheMap::Iterator it = m_itemCacheMap.visit (libGuid);
[+] 	ItemCacheMap::Iterator it = m_itemCacheMap.visit(libGuid);
[-] 		entry = AXL_MEM_NEW (ItemCacheEntry);
[+] 		entry = AXL_MEM_NEW(ItemCacheEntry);
[-] 		m_itemCache.insertTail (entry);
[+] 		m_itemCache.insertTail(entry);
[-] 	size_t count = entry->m_itemArray.getCount ();
[+] 	size_t count = entry->m_itemArray.getCount();
[-] 		entry->m_itemArray.setCountZeroConstruct (cacheSlot + 1);
[+] 		entry->m_itemArray.setCountZeroConstruct(cacheSlot + 1);
[-] 	ModuleItem* item = entry->m_itemArray [cacheSlot];
[+] 	ModuleItem* item = entry->m_itemArray[cacheSlot];
[-] 	item = m_module->m_namespaceMgr.getGlobalNamespace ()->getItemByName (name);
[+] 	item = m_module->m_namespaceMgr.getGlobalNamespace()->getItemByName(name);
[-] 	entry->m_itemArray [cacheSlot] = item;
[+] 	entry->m_itemArray[cacheSlot] = item;
[-] ExtensionLibMgr::addSource (
[+] ExtensionLibMgr::addSource(
[-] 	SourceFile* file = AXL_MEM_NEW (SourceFile);
[+] 	SourceFile* file = AXL_MEM_NEW(SourceFile);
[-] 	m_sourceFileList.insertTail (file);
[+] 	m_sourceFileList.insertTail(file);
[-] 	m_sourceFileMap [fileName] = file;
[+] 	m_sourceFileMap[fileName] = file;
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_GcShadowStackMgr.cpp
----------------------
[-] GcShadowStackMgr::GcShadowStackMgr ()
[+] GcShadowStackMgr::GcShadowStackMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] GcShadowStackMgr::clear ()
[+] GcShadowStackMgr::clear()
[-] 	m_frameMapList.clear ();
[+] 	m_frameMapList.clear();
[-] 	m_functionFrameMapArray.clear ();
[+] 	m_functionFrameMapArray.clear();
[-] 	m_gcRootArrayValue.clear ();
[+] 	m_gcRootArrayValue.clear();
[-] GcShadowStackMgr::finalizeFunction ()
[+] GcShadowStackMgr::finalizeFunction()
[-] 	finalizeFrame ();
[+] 	finalizeFrame();
[-] 	m_gcRootArrayValue.clear ();
[+] 	m_gcRootArrayValue.clear();
[-] 	m_functionFrameMapArray.clear ();
[+] 	m_functionFrameMapArray.clear();
[-] GcShadowStackMgr::finalizeScope (Scope* scope)
[+] GcShadowStackMgr::finalizeScope(Scope* scope)
[-] 		!(m_module->m_controlFlowMgr.getCurrentBlock ()->getFlags () & BasicBlockFlag_Reachable))
[+] 		!(m_module->m_controlFlowMgr.getCurrentBlock()->getFlags() & BasicBlockFlag_Reachable))
[-] 	setFrameMap (scope->m_gcShadowStackFrameMap, GcShadowStackFrameMapOp_Close);
[+] 	setFrameMap(scope->m_gcShadowStackFrameMap, GcShadowStackFrameMapOp_Close);
[-] GcShadowStackMgr::createTmpGcRoot (const Value& value)
[+] GcShadowStackMgr::createTmpGcRoot(const Value& value)
[-] 	Type* type = value.getType ();
[+] 	Type* type = value.getType();
[-] 	ASSERT (type->getFlags () & TypeFlag_GcRoot);
[+] 	ASSERT(type->getFlags() & TypeFlag_GcRoot);
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "tmpGcRoot", NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "tmpGcRoot", NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createStore (value, ptrValue);
[+] 	m_module->m_llvmIrBuilder.createStore(value, ptrValue);
[-] 	markGcRoot (ptrValue, type);
[+] 	markGcRoot(ptrValue, type);
[-] GcShadowStackMgr::markGcRoot (
[+] GcShadowStackMgr::markGcRoot(
[-] 		preCreateFrame ();
[+] 		preCreateFrame();
[-] 	Variable* variableBeingLifted = m_module->m_variableMgr.getCurrentLiftedStackVariable ();
[+] 	Variable* variableBeingLifted = m_module->m_variableMgr.getCurrentLiftedStackVariable();
[-] 		variableBeingLifted->getScope () :
[+] 		variableBeingLifted->getScope() :
[-] 		m_module->m_namespaceMgr.getCurrentScope ();
[+] 		m_module->m_namespaceMgr.getCurrentScope();
[-] 	GcShadowStackFrameMap* frameMap = openFrameMap (scope);
[+] 	GcShadowStackFrameMap* frameMap = openFrameMap(scope);
[-] 	Type* bytePtrType = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 	Type* bytePtrType = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	m_module->m_llvmIrBuilder.createGep (m_gcRootArrayValue, index, NULL, &gcRootValue);
[+] 	m_module->m_llvmIrBuilder.createGep(m_gcRootArrayValue, index, NULL, &gcRootValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, bytePtrType, &bytePtrValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, bytePtrType, &bytePtrValue);
[-] 	m_module->m_llvmIrBuilder.createStore (bytePtrValue, gcRootValue);
[+] 	m_module->m_llvmIrBuilder.createStore(bytePtrValue, gcRootValue);
[-] 	frameMap->m_gcRootArray.append (index);
[+] 	frameMap->m_gcRootArray.append(index);
[-] 	frameMap->m_gcRootTypeArray.append (type);
[+] 	frameMap->m_gcRootTypeArray.append(type);
[-] GcShadowStackMgr::openFrameMap (Scope* scope)
[+] GcShadowStackMgr::openFrameMap(Scope* scope)
[-] 	Scope* parentScope = scope->getParentScope ();
[+] 	Scope* parentScope = scope->getParentScope();
[-] 	GcShadowStackFrameMap* frameMap = AXL_MEM_NEW (GcShadowStackFrameMap);
[+] 	GcShadowStackFrameMap* frameMap = AXL_MEM_NEW(GcShadowStackFrameMap);
[-] 	m_frameMapList.insertTail (frameMap);
[+] 	m_frameMapList.insertTail(frameMap);
[-] 	m_functionFrameMapArray.append (frameMap);
[+] 	m_functionFrameMapArray.append(frameMap);
[-] 	ASSERT (scope->m_gcShadowStackFrameMapInsertPoint);
[+] 	ASSERT(scope->m_gcShadowStackFrameMapInsertPoint);
[-] 	bool isInsertPointChanged = m_module->m_llvmIrBuilder.restoreInsertPoint (
[+] 	bool isInsertPointChanged = m_module->m_llvmIrBuilder.restoreInsertPoint(
[-] 	setFrameMap (frameMap, GcShadowStackFrameMapOp_Open);
[+] 	setFrameMap(frameMap, GcShadowStackFrameMapOp_Open);
[-] 		m_module->m_llvmIrBuilder.saveInsertPoint (&scope->m_firstStackVariable->m_liftInsertPoint);
[+] 		m_module->m_llvmIrBuilder.saveInsertPoint(&scope->m_firstStackVariable->m_liftInsertPoint);
[-] 		m_module->m_llvmIrBuilder.restoreInsertPoint (prevInsertPoint);
[+] 		m_module->m_llvmIrBuilder.restoreInsertPoint(prevInsertPoint);
[-] GcShadowStackMgr::setFrameMap (
[+] GcShadowStackMgr::setFrameMap(
[-] 	ASSERT (m_frameVariable);
[+] 	ASSERT(m_frameVariable);
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_SetGcShadowStackFrameMap);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_SetGcShadowStackFrameMap);
[-] 	m_module->m_llvmIrBuilder.createCall3 (
[+] 	m_module->m_llvmIrBuilder.createCall3(
[-] 		function->getType (),
[+] 		function->getType(),
[-] 		Value (&frameMap, m_module->m_typeMgr.getStdType (StdType_BytePtr)),
[+] 		Value(&frameMap, m_module->m_typeMgr.getStdType(StdType_BytePtr)),
[-] 		Value (op, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int)),
[+] 		Value(op, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int)),
[-] GcShadowStackMgr::preCreateFrame ()
[+] GcShadowStackMgr::preCreateFrame()
[-] 	ASSERT (!m_frameVariable && !m_gcRootArrayValue);
[+] 	ASSERT(!m_frameVariable && !m_gcRootArrayValue);
[-] 	Type* type = m_module->m_typeMgr.getStdType (StdType_GcShadowStackFrame);
[+] 	Type* type = m_module->m_typeMgr.getStdType(StdType_GcShadowStackFrame);
[-] 	m_frameVariable = m_module->m_variableMgr.createSimpleStackVariable ("gcShadowStackFrame", type);
[+] 	m_frameVariable = m_module->m_variableMgr.createSimpleStackVariable("gcShadowStackFrame", type);
[-] 	type = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 	type = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "gcRootArray_tmp", type->getDataPtrType_c (), &m_gcRootArrayValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "gcRootArray_tmp", type->getDataPtrType_c (), &m_gcRootArrayValue);
[-] GcShadowStackMgr::finalizeFrame ()
[+] GcShadowStackMgr::finalizeFrame()
[-] 	ASSERT (m_frameVariable && m_gcRootArrayValue);
[+] 	ASSERT(m_frameVariable && m_gcRootArrayValue);
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function);
[+] 	ASSERT(function);
[-] 	BasicBlock* prologueBlock = function->getPrologueBlock ();
[+] 	BasicBlock* prologueBlock = function->getPrologueBlock();
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (&*prologueBlock->getLlvmBlock ()->begin ());
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(&*prologueBlock->getLlvmBlock()->begin());
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr_u)->getArrayType (m_gcRootCount);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr_u)->getArrayType(m_gcRootCount);
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "gcRootArray", type->getDataPtrType_c (), &gcRootArrayValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "gcRootArray", type->getDataPtrType_c (), &gcRootArrayValue);
[-] 	type = m_module->m_typeMgr.getStdType (StdType_BytePtr)->getDataPtrType_c ();
[+] 	type = m_module->m_typeMgr.getStdType(StdType_BytePtr)->getDataPtrType_c();
[-] 	m_module->m_llvmIrBuilder.createBitCast (gcRootArrayValue, type, &gcRootArrayValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(gcRootArrayValue, type, &gcRootArrayValue);
[-] 	ASSERT (llvm::isa <llvm::AllocaInst> (m_gcRootArrayValue.getLlvmValue ()));
[+] 	ASSERT(llvm::isa<llvm::AllocaInst> (m_gcRootArrayValue.getLlvmValue()));
[-] 	llvm::AllocaInst* llvmAlloca = (llvm::AllocaInst*) m_gcRootArrayValue.getLlvmValue ();
[+] 	llvm::AllocaInst* llvmAlloca = (llvm::AllocaInst*)m_gcRootArrayValue.getLlvmValue();
[-] 	llvmAlloca->replaceAllUsesWith (gcRootArrayValue.getLlvmValue ());
[+] 	llvmAlloca->replaceAllUsesWith(gcRootArrayValue.getLlvmValue());
[-] 	llvmAlloca->eraseFromParent ();
[+] 	llvmAlloca->eraseFromParent();
[-] 	type = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 	type = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	m_module->m_llvmIrBuilder.createGep2 (m_frameVariable, 1, NULL, &frameMapFieldValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(m_frameVariable, 1, NULL, &frameMapFieldValue);
[-] 	m_module->m_llvmIrBuilder.createStore (type->getZeroValue (), frameMapFieldValue);
[+] 	m_module->m_llvmIrBuilder.createStore(type->getZeroValue(), frameMapFieldValue);
[-] 	m_module->m_llvmIrBuilder.createGep2 (m_frameVariable, 2, NULL, &gcRootArrayFieldValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(m_frameVariable, 2, NULL, &gcRootArrayFieldValue);
[-] 	m_module->m_llvmIrBuilder.createStore (gcRootArrayValue, gcRootArrayFieldValue);
[+] 	m_module->m_llvmIrBuilder.createStore(gcRootArrayValue, gcRootArrayFieldValue);
[-] 	bool isAsync = function->getFunctionKind () == FunctionKind_Async;
[+] 	bool isAsync = function->getFunctionKind() == FunctionKind_Async;
[-] 		Value promiseValue = m_module->m_functionMgr.getPromiseValue ();
[+] 		Value promiseValue = m_module->m_functionMgr.getPromiseValue();
[-] 		ASSERT (promiseValue);
[+] 		ASSERT(promiseValue);
[-] 		bool result = m_module->m_operatorMgr.getPromiseField (promiseValue, "m_gcShadowStackFrame", &frameFieldValue);
[+] 		bool result = m_module->m_operatorMgr.getPromiseField(promiseValue, "m_gcShadowStackFrame", &frameFieldValue);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		m_module->m_llvmIrBuilder.createBitCast (m_frameVariable, m_module->m_typeMgr.getStdType (StdType_BytePtr), &frameValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(m_frameVariable, m_module->m_typeMgr.getStdType(StdType_BytePtr), &frameValue);
[-] 		m_module->m_llvmIrBuilder.createStore (frameValue, frameFieldValue);
[+] 		m_module->m_llvmIrBuilder.createStore(frameValue, frameFieldValue);
[-] 		stackTopVariable = m_module->m_variableMgr.getStdVariable (StdVariable_GcShadowStackTop);
[+] 		stackTopVariable = m_module->m_variableMgr.getStdVariable(StdVariable_GcShadowStackTop);
[-] 		m_module->m_llvmIrBuilder.createLoad (stackTopVariable, NULL, &prevStackTopValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(stackTopVariable, NULL, &prevStackTopValue);
[-] 		m_module->m_llvmIrBuilder.createGep2 (m_frameVariable, 0, NULL, &prevFieldValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(m_frameVariable, 0, NULL, &prevFieldValue);
[-] 		m_module->m_llvmIrBuilder.createStore (prevStackTopValue, prevFieldValue);
[+] 		m_module->m_llvmIrBuilder.createStore(prevStackTopValue, prevFieldValue);
[-] 		m_module->m_llvmIrBuilder.createStore (m_frameVariable, stackTopVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(m_frameVariable, stackTopVariable);
[-] 		sl::Array <BasicBlock*> returnBlockArray = m_module->m_controlFlowMgr.getReturnBlockArray ();
[+] 		sl::Array<BasicBlock*> returnBlockArray = m_module->m_controlFlowMgr.getReturnBlockArray();
[-] 		size_t count = returnBlockArray.getCount ();
[+] 		size_t count = returnBlockArray.getCount();
[-] 			BasicBlock* block = returnBlockArray [i];
[+] 			BasicBlock* block = returnBlockArray[i];
[-] 			llvm::TerminatorInst* llvmRet = block->getLlvmBlock ()->getTerminator ();
[+] 			llvm::TerminatorInst* llvmRet = block->getLlvmBlock()->getTerminator();
[-] 			ASSERT (llvm::isa <llvm::ReturnInst> (llvmRet));
[+] 			ASSERT(llvm::isa<llvm::ReturnInst> (llvmRet));
[-] 			m_module->m_llvmIrBuilder.setInsertPoint (llvmRet);
[+] 			m_module->m_llvmIrBuilder.setInsertPoint(llvmRet);
[-] 			m_module->m_llvmIrBuilder.createStore (prevStackTopValue, stackTopVariable);
[+] 			m_module->m_llvmIrBuilder.createStore(prevStackTopValue, stackTopVariable);
[-] 	size_t count = m_functionFrameMapArray.getCount ();
[+] 	size_t count = m_functionFrameMapArray.getCount();
[-] 		GcShadowStackFrameMap* map = m_functionFrameMapArray [i];
[+] 		GcShadowStackFrameMap* map = m_functionFrameMapArray[i];
[-] 		Scope* scope = map->m_scope->getParentScope ();
[+] 		Scope* scope = map->m_scope->getParentScope();
[-] 		map->m_prev = scope ? scope->findGcShadowStackFrameMap () : NULL;
[+] 		map->m_prev = scope ? scope->findGcShadowStackFrameMap() : NULL;
[-] 	sl::Array <BasicBlock*> landingPadBlockArray = m_module->m_controlFlowMgr.getLandingPadBlockArray ();
[+] 	sl::Array<BasicBlock*> landingPadBlockArray = m_module->m_controlFlowMgr.getLandingPadBlockArray();
[-] 	count = landingPadBlockArray.getCount ();
[+] 	count = landingPadBlockArray.getCount();
[-] 		BasicBlock* block = landingPadBlockArray [i];
[+] 		BasicBlock* block = landingPadBlockArray[i];
[-] 		Scope* scope = block->getLandingPadScope ();
[+] 		Scope* scope = block->getLandingPadScope();
[-] 		ASSERT (scope && !block->getLlvmBlock ()->empty ());
[+] 		ASSERT(scope && !block->getLlvmBlock()->empty());
[-] 		m_module->m_llvmIrBuilder.setInsertPoint (&*block->getLlvmBlock ()->begin ());
[+] 		m_module->m_llvmIrBuilder.setInsertPoint(&*block->getLlvmBlock()->begin());
[-] 		if (block->getLandingPadKind () == LandingPadKind_Exception && !isAsync)
[+] 		if (block->getLandingPadKind() == LandingPadKind_Exception && !isAsync)
[-] 			m_module->m_llvmIrBuilder.createStore (m_frameVariable, stackTopVariable);
[+] 			m_module->m_llvmIrBuilder.createStore(m_frameVariable, stackTopVariable);
[-] 		GcShadowStackFrameMap* map = scope->findGcShadowStackFrameMap ();
[+] 		GcShadowStackFrameMap* map = scope->findGcShadowStackFrameMap();
[-] 		setFrameMap (map, GcShadowStackFrameMapOp_Restore);
[+] 		setFrameMap(map, GcShadowStackFrameMapOp_Restore);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ImportMgr.cpp
----------------------
[-] ImportMgr::ImportMgr ()
[+] ImportMgr::ImportMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] ImportMgr::clear ()
[+] ImportMgr::clear()
[-] 	m_importList.clear ();
[+] 	m_importList.clear();
[-] 	m_importFilePathMap.clear ();
[+] 	m_importFilePathMap.clear();
[-] 	m_ignoredImportSet.clear ();
[+] 	m_ignoredImportSet.clear();
[-] ImportMgr::addImport (const sl::StringRef& fileName)
[+] ImportMgr::addImport(const sl::StringRef& fileName)
[-] 	if (m_ignoredImportSet.find (fileName))
[+] 	if (m_ignoredImportSet.find(fileName))
[-] 	bool isExtensionLib = fileName.isSuffix (".jncx");
[+] 	bool isExtensionLib = fileName.isSuffix(".jncx");
[-] 		FindResult findResult = findImportFile (fileName, &filePath);
[+] 		FindResult findResult = findImportFile(fileName, &filePath);
[-] 		return m_module->m_extensionLibMgr.loadDynamicLib (filePath);
[+] 		return m_module->m_extensionLibMgr.loadDynamicLib(filePath);
[-] 	bool isFound = m_module->m_extensionLibMgr.findSourceFileContents (fileName, &lib, &source);
[+] 	bool isFound = m_module->m_extensionLibMgr.findSourceFileContents(fileName, &lib, &source);
[-] 		addImport (lib, fileName, source);
[+] 		addImport(lib, fileName, source);
[-] 	FindResult findResult = findImportFile (fileName, &filePath);
[+] 	FindResult findResult = findImportFile(fileName, &filePath);
[-] 	Import* import = AXL_MEM_NEW (Import);
[+] 	Import* import = AXL_MEM_NEW(Import);
[-] 	m_importList.insertTail (import);
[+] 	m_importList.insertTail(import);
[-] ImportMgr::addImport (
[+] ImportMgr::addImport(
[-] 	sl::StringHashTableIterator <bool> it;
[+] 	sl::StringHashTableIterator<bool> it;
[-] 	if (!filePath.isEmpty ())
[+] 	if (!filePath.isEmpty())
[-] 		it = m_importFilePathMap.visit (filePath);
[+] 		it = m_importFilePathMap.visit(filePath);
[-] 	Import* import = AXL_MEM_NEW (Import);
[+] 	Import* import = AXL_MEM_NEW(Import);
[-] 	m_importList.insertTail (import);
[+] 	m_importList.insertTail(import);
[-] ImportMgr::findImportFile (
[+] ImportMgr::findImportFile(
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	sl::String filePath = io::findFilePath (
[+] 	sl::String filePath = io::findFilePath(
[-] 		unit->getDir (),
[+] 		unit->getDir(),
[-] 	if (filePath.isEmpty ())
[+] 	if (filePath.isEmpty())
[-] 		err::setFormatStringError ("import '%s' not found", fileName.sz ());
[+] 		err::setFormatStringError("import '%s' not found", fileName.sz ());
[-] 	sl::StringHashTableIterator <bool> it = m_importFilePathMap.visit (filePath);
[+] 	sl::StringHashTableIterator<bool> it = m_importFilePathMap.visit(filePath);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_JitMemoryMgr.cpp
----------------------
[-] JitMemoryMgr::getPointerToNamedFunction (
[+] JitMemoryMgr::getPointerToNamedFunction(
[-] 	void* p = m_module->findFunctionMapping (name.c_str ());
[+] 	void* p = m_module->findFunctionMapping(name.c_str());
[-] 		llvm::report_fatal_error (errorString);
[+] 		llvm::report_fatal_error(errorString);
[-] JitMemoryMgr::getSymbolAddress (const std::string &name)
[+] JitMemoryMgr::getSymbolAddress(const std::string &name)
[-] 	void* p = m_module->findFunctionMapping (name.c_str ());
[+] 	void* p = m_module->findFunctionMapping(name.c_str());
[-] 		return (uint64_t) p;
[+] 		return (uint64_t)p;
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_LlvmDiBuilder.cpp
----------------------
[-] LlvmDiBuilder::LlvmDiBuilder ()
[+] LlvmDiBuilder::LlvmDiBuilder()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] LlvmDiBuilder::create ()
[+] LlvmDiBuilder::create()
[-] 	clear ();
[+] 	clear();
[-] 	llvm::Module* llvmModule = m_module->getLlvmModule ();
[+] 	llvm::Module* llvmModule = m_module->getLlvmModule();
[-] 	ASSERT (llvmModule);
[+] 	ASSERT(llvmModule);
[-] 	m_llvmDiBuilder = new llvm::DIBuilder (*llvmModule);
[+] 	m_llvmDiBuilder = new llvm::DIBuilder(*llvmModule);
[-] 	m_llvmDiBuilder->createCompileUnit (
[+] 	m_llvmDiBuilder->createCompileUnit(
[-] 		m_module->getName ().sz (),
[+] 		m_module->getName().sz(),
[-] 		io::getCurrentDir ().sz (),
[+] 		io::getCurrentDir().sz(),
[-] 		m_llvmDiBuilder->createFile (
[+] 		m_llvmDiBuilder->createFile(
[-] 			m_module->getName ().sz (),
[+] 			m_module->getName().sz(),
[-] 			io::getCurrentDir ().sz ()
[+] 			io::getCurrentDir().sz()
[-] LlvmDiBuilder::clear ()
[+] LlvmDiBuilder::clear()
[-] LlvmDiBuilder::getEmptyDebugLoc ()
[+] LlvmDiBuilder::getEmptyDebugLoc()
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 		llvm::DebugLoc::get (0, 0, unit->getLlvmDiFile ()) :
[+] 		llvm::DebugLoc::get(0, 0, unit->getLlvmDiFile()) :
[-] 		llvm::DebugLoc ();
[+] 		llvm::DebugLoc();
[-] LlvmDiBuilder::createSubroutineType (FunctionType* functionType)
[+] LlvmDiBuilder::createSubroutineType(FunctionType* functionType)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t count = argArray.getCount ();
[+] 	size_t count = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Metadata*> argTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Metadata*> argTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argTypeArray.setCount (count + 1);
[+] 	argTypeArray.setCount(count + 1);
[-] 	*dst = functionType->getReturnType ()->getLlvmDiType ();
[+] 	*dst = functionType->getReturnType()->getLlvmDiType();
[-] 		*dst = argArray [i]->getType ()->getLlvmDiType ();
[+] 		*dst = argArray[i]->getType()->getLlvmDiType();
[-] 	llvm::DIArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateArray (llvm::ArrayRef <llvm::Metadata*> (argTypeArray, count + 1));
[+] 	llvm::DIArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Metadata*> (argTypeArray, count + 1));
[-] 	return m_llvmDiBuilder->createSubroutineType (unit->getLlvmDiFile (), llvmDiTypeArray);
[+] 	return m_llvmDiBuilder->createSubroutineType(unit->getLlvmDiFile(), llvmDiTypeArray);
[-] 	llvm::DITypeArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray (llvm::ArrayRef <llvm::Metadata*> (argTypeArray, count + 1));
[+] 	llvm::DITypeArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray(llvm::ArrayRef<llvm::Metadata*> (argTypeArray, count + 1));
[-] 	return m_llvmDiBuilder->createSubroutineType (unit->getLlvmDiFile (), llvmDiTypeArray);
[+] 	return m_llvmDiBuilder->createSubroutineType(unit->getLlvmDiFile(), llvmDiTypeArray);
[-] 	llvm::DITypeRefArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray (llvm::ArrayRef <llvm::Metadata*> (argTypeArray, count + 1));
[+] 	llvm::DITypeRefArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray(llvm::ArrayRef<llvm::Metadata*> (argTypeArray, count + 1));
[-] 	return m_llvmDiBuilder->createSubroutineType (unit->getLlvmDiFile (), llvmDiTypeArray);
[+] 	return m_llvmDiBuilder->createSubroutineType(unit->getLlvmDiFile(), llvmDiTypeArray);
[-] 	llvm::DITypeRefArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray (llvm::ArrayRef <llvm::Metadata*> (argTypeArray, count + 1));
[+] 	llvm::DITypeRefArray llvmDiTypeArray = m_llvmDiBuilder->getOrCreateTypeArray(llvm::ArrayRef<llvm::Metadata*> (argTypeArray, count + 1));
[-] 	return m_llvmDiBuilder->createSubroutineType (llvmDiTypeArray);
[+] 	return m_llvmDiBuilder->createSubroutineType(llvmDiTypeArray);
[-] LlvmDiBuilder::createEmptyStructType (StructType* structType)
[+] LlvmDiBuilder::createEmptyStructType(StructType* structType)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	return m_llvmDiBuilder->createStructType (
[+] 	return m_llvmDiBuilder->createStructType(
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		structType->m_tag.sz (),
[+] 		structType->m_tag.sz(),
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		structType->getPos ()->m_line + 1,
[+] 		structType->getPos()->m_line + 1,
[-] 		structType->getSize () * 8,
[+] 		structType->getSize() * 8,
[-] 		structType->getAlignment () * 8,
[+] 		structType->getAlignment() * 8,
[-] 		llvm::DIType (),     // derived from
[+] 		llvm::DIType(),     // derived from
[-] 		llvm::DINodeArray () // elements -- set body later
[+] 		llvm::DINodeArray() // elements -- set body later
[-] LlvmDiBuilder::setStructTypeBody (StructType* structType)
[+] LlvmDiBuilder::setStructTypeBody(StructType* structType)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	sl::ConstList <BaseTypeSlot> baseTypeList = structType->getBaseTypeList ();
[+] 	sl::ConstList<BaseTypeSlot> baseTypeList = structType->getBaseTypeList();
[-] 	sl::Array <StructField*> fieldArray = structType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> fieldArray = structType->getMemberFieldArray();
[-] 	size_t baseTypeCount = baseTypeList.getCount ();
[+] 	size_t baseTypeCount = baseTypeList.getCount();
[-] 	size_t fieldCount = fieldArray.getCount ();
[+] 	size_t fieldCount = fieldArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Metadata*> fieldTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Metadata*> fieldTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	fieldTypeArray.setCount (count);
[+] 	fieldTypeArray.setCount(count);
[-] 	sl::ConstIterator <BaseTypeSlot> baseTypeIt = baseTypeList.getHead ();
[+] 	sl::ConstIterator<BaseTypeSlot> baseTypeIt = baseTypeList.getHead();
[-] 		sl::String name = baseType->getType ()->getQualifiedName ();
[+] 		sl::String name = baseType->getType()->getQualifiedName();
[-] 		fieldTypeArray [i] = m_llvmDiBuilder->createMemberType (
[+] 		fieldTypeArray[i] = m_llvmDiBuilder->createMemberType(
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			!name.isEmpty () ? name.sz () : "UnnamedBaseType",
[+] 			!name.isEmpty() ? name.sz() : "UnnamedBaseType",
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			baseType->getPos ()->m_line + 1,
[+] 			baseType->getPos()->m_line + 1,
[-] 			baseType->getType ()->getSize () * 8,
[+] 			baseType->getType()->getSize() * 8,
[-] 			baseType->getType ()->getAlignment () * 8,
[+] 			baseType->getType()->getAlignment() * 8,
[-] 			baseType->getOffset () * 8,
[+] 			baseType->getOffset() * 8,
[-] 			baseType->getType ()->getLlvmDiType ()
[+] 			baseType->getType()->getLlvmDiType()
[-] 		StructField* field = fieldArray [j];
[+] 		StructField* field = fieldArray[j];
[-] 		sl::String name = field->getName ();
[+] 		sl::String name = field->getName();
[-] 		fieldTypeArray [i] = m_llvmDiBuilder->createMemberType (
[+] 		fieldTypeArray[i] = m_llvmDiBuilder->createMemberType(
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			!name.isEmpty () ? name.sz () : "m_unnamedField",
[+] 			!name.isEmpty() ? name.sz() : "m_unnamedField",
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			field->getPos ()->m_line + 1,
[+] 			field->getPos()->m_line + 1,
[-] 			field->getType ()->getSize () * 8,
[+] 			field->getType()->getSize() * 8,
[-] 			field->getType ()->getAlignment () * 8,
[+] 			field->getType()->getAlignment() * 8,
[-] 			field->getOffset () * 8,
[+] 			field->getOffset() * 8,
[-] 			field->getType ()->getLlvmDiType ()
[+] 			field->getType()->getLlvmDiType()
[-] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray (llvm::ArrayRef <llvm::Metadata*> (fieldTypeArray, count));
[+] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Metadata*> (fieldTypeArray, count));
[-] 	llvm::DICompositeType llvmDiType (structType->getLlvmDiType ());
[+] 	llvm::DICompositeType llvmDiType(structType->getLlvmDiType());
[-] 	ASSERT (llvmDiType);
[+] 	ASSERT(llvmDiType);
[-] 	llvmDiType.setTypeArray (llvmDiArray);
[+] 	llvmDiType.setTypeArray(llvmDiArray);
[-] 	llvm::DICompositeType llvmDiType (structType->getLlvmDiType ());
[+] 	llvm::DICompositeType llvmDiType(structType->getLlvmDiType());
[-] 	ASSERT (llvmDiType);
[+] 	ASSERT(llvmDiType);
[-] 	llvmDiType->replaceOperandWith (4, llvmDiArray);
[+] 	llvmDiType->replaceOperandWith(4, llvmDiArray);
[-] 	llvm::DICompositeType* llvmDiType = (llvm::DICompositeType*) structType->getLlvmDiType ();
[+] 	llvm::DICompositeType* llvmDiType = (llvm::DICompositeType*)structType->getLlvmDiType();
[-] 	ASSERT (llvm::isa <llvm::DICompositeType> (llvmDiType));
[+] 	ASSERT(llvm::isa<llvm::DICompositeType> (llvmDiType));
[-] 	llvmDiType->replaceElements (llvmDiArray);
[+] 	llvmDiType->replaceElements(llvmDiArray);
[-] LlvmDiBuilder::createEmptyUnionType (UnionType* unionType)
[+] LlvmDiBuilder::createEmptyUnionType(UnionType* unionType)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	return m_llvmDiBuilder->createUnionType (
[+] 	return m_llvmDiBuilder->createUnionType(
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		unionType->m_tag.sz (),
[+] 		unionType->m_tag.sz(),
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		unionType->getPos ()->m_line + 1,
[+] 		unionType->getPos()->m_line + 1,
[-] 		unionType->getSize () * 8,
[+] 		unionType->getSize() * 8,
[-] 		unionType->getAlignment () * 8,
[+] 		unionType->getAlignment() * 8,
[-] 		llvm::DINodeArray () // elements -- set body later
[+] 		llvm::DINodeArray() // elements -- set body later
[-] LlvmDiBuilder::setUnionTypeBody (UnionType* unionType)
[+] LlvmDiBuilder::setUnionTypeBody(UnionType* unionType)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	sl::Array <StructField*> fieldArray = unionType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> fieldArray = unionType->getMemberFieldArray();
[-] 	size_t count = fieldArray.getCount ();
[+] 	size_t count = fieldArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Metadata*> fieldTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Metadata*> fieldTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	fieldTypeArray.setCount (count);
[+] 	fieldTypeArray.setCount(count);
[-] 		StructField* field = fieldArray [i];
[+] 		StructField* field = fieldArray[i];
[-] 		sl::String name = field->getName ();
[+] 		sl::String name = field->getName();
[-] 		fieldTypeArray [i] = m_llvmDiBuilder->createMemberType (
[+] 		fieldTypeArray[i] = m_llvmDiBuilder->createMemberType(
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			!name.isEmpty () ? name.sz () : "m_unnamedField",
[+] 			!name.isEmpty() ? name.sz() : "m_unnamedField",
[-] 			unit->getLlvmDiFile (),
[+] 			unit->getLlvmDiFile(),
[-] 			field->getPos ()->m_line + 1,
[+] 			field->getPos()->m_line + 1,
[-] 			field->getType ()->getSize () * 8,
[+] 			field->getType()->getSize() * 8,
[-] 			field->getType ()->getAlignment () * 8,
[+] 			field->getType()->getAlignment() * 8,
[-] 			field->getOffset () * 8,
[+] 			field->getOffset() * 8,
[-] 			field->getType ()->getLlvmDiType ()
[+] 			field->getType()->getLlvmDiType()
[-] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray (llvm::ArrayRef <llvm::Metadata*> (fieldTypeArray, count));
[+] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Metadata*> (fieldTypeArray, count));
[-] 	llvm::DICompositeType llvmDiType (unionType->getLlvmDiType ());
[+] 	llvm::DICompositeType llvmDiType(unionType->getLlvmDiType());
[-] 	ASSERT (llvmDiType);
[+] 	ASSERT(llvmDiType);
[-] 	llvmDiType.setTypeArray (llvmDiArray);
[+] 	llvmDiType.setTypeArray(llvmDiArray);
[-] 	llvm::DICompositeType llvmDiType (unionType->getLlvmDiType ());
[+] 	llvm::DICompositeType llvmDiType(unionType->getLlvmDiType());
[-] 	ASSERT (llvmDiType);
[+] 	ASSERT(llvmDiType);
[-] 	llvmDiType->replaceOperandWith (4, llvmDiArray);
[+] 	llvmDiType->replaceOperandWith(4, llvmDiArray);
[-] 	llvm::DICompositeType* llvmDiType = (llvm::DICompositeType*) unionType->getLlvmDiType ();
[+] 	llvm::DICompositeType* llvmDiType = (llvm::DICompositeType*)unionType->getLlvmDiType();
[-] 	ASSERT (llvm::isa <llvm::DICompositeType> (llvmDiType));
[+] 	ASSERT(llvm::isa<llvm::DICompositeType> (llvmDiType));
[-] 	llvmDiType->replaceElements (llvmDiArray);
[+] 	llvmDiType->replaceElements(llvmDiArray);
[-] LlvmDiBuilder::createArrayType (ArrayType* arrayType)
[+] LlvmDiBuilder::createArrayType(ArrayType* arrayType)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Metadata*> dimArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Metadata*> dimArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		Type* elementType = p->getElementType ();
[+] 		Type* elementType = p->getElementType();
[-] 		size_t elementCount = p->getElementCount ();
[+] 		size_t elementCount = p->getElementCount();
[-] 		ASSERT (elementCount);
[+] 		ASSERT(elementCount);
[-] 		AXL_TODO ("seems like a bug in LLVM DiBuilder (should be ElementCount - 1)")
[+] 		AXL_TODO("seems like a bug in LLVM DiBuilder (should be ElementCount - 1)")
[-] 		dimArray.append (m_llvmDiBuilder->getOrCreateSubrange (0, elementCount));
[+] 		dimArray.append(m_llvmDiBuilder->getOrCreateSubrange(0, elementCount));
[-] 		if (elementType->getTypeKind () != TypeKind_Array)
[+] 		if (elementType->getTypeKind() != TypeKind_Array)
[-] 		p = (ArrayType*) elementType;
[+] 		p = (ArrayType*)elementType;
[-] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray (llvm::ArrayRef <llvm::Metadata*> (dimArray, dimArray.getCount ()));
[+] 	llvm::DINodeArray llvmDiArray = m_llvmDiBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Metadata*> (dimArray, dimArray.getCount()));
[-] 	return m_llvmDiBuilder->createArrayType (
[+] 	return m_llvmDiBuilder->createArrayType(
[-] 		arrayType->getSize () * 8,
[+] 		arrayType->getSize() * 8,
[-] 		arrayType->getAlignment () * 8,
[+] 		arrayType->getAlignment() * 8,
[-] 		arrayType->getRootType ()->getLlvmDiType (),
[+] 		arrayType->getRootType()->getLlvmDiType(),
[-] LlvmDiBuilder::createPointerType (Type* type)
[+] LlvmDiBuilder::createPointerType(Type* type)
[-] 	return m_llvmDiBuilder->createPointerType (
[+] 	return m_llvmDiBuilder->createPointerType(
[-] 		type->getLlvmDiType (),
[+] 		type->getLlvmDiType(),
[-] 		type->getSize () * 8,
[+] 		type->getSize() * 8,
[-] 		type->getAlignment () * 8,
[+] 		type->getAlignment() * 8,
[-] 		type->getTypeString ().sz ()
[+] 		type->getTypeString().sz()
[-] LlvmDiBuilder::createGlobalVariable (Variable* variable)
[+] LlvmDiBuilder::createGlobalVariable(Variable* variable)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	llvm::GlobalVariable* llvmGlobalVariable = (llvm::GlobalVariable*) variable->getLlvmValue ();
[+] 	llvm::GlobalVariable* llvmGlobalVariable = (llvm::GlobalVariable*)variable->getLlvmValue();
[-] 	ASSERT (llvm::isa <llvm::GlobalVariable> (llvmGlobalVariable));
[+] 	ASSERT(llvm::isa<llvm::GlobalVariable> (llvmGlobalVariable));
[-] 	return m_llvmDiBuilder->createGlobalVariable (
[+] 	return m_llvmDiBuilder->createGlobalVariable(
[-] 		llvm::DIDescriptor (), // DIDescriptor Context
[+] 		llvm::DIDescriptor(), // DIDescriptor Context
[-] 		variable->getQualifiedName ().sz (), // StringRef Name
[+] 		variable->getQualifiedName().sz(), // StringRef Name
[-] 		variable->getQualifiedName ().sz (), // StringRef LinkageName
[+] 		variable->getQualifiedName().sz(), // StringRef LinkageName
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		variable->getPos ()->m_line + 1,
[+] 		variable->getPos()->m_line + 1,
[-] 		variable->getType ()->getLlvmDiType (),
[+] 		variable->getType()->getLlvmDiType(),
[-] LlvmDiBuilder::createParameterVariable (
[+] LlvmDiBuilder::createParameterVariable(
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (unit && scope);
[+] 	ASSERT(unit && scope);
[-] 	return m_llvmDiBuilder->createLocalVariable (
[+] 	return m_llvmDiBuilder->createLocalVariable(
[-] 		scope->getLlvmDiScope (),
[+] 		scope->getLlvmDiScope(),
[-] 		variable->getName ().sz (),
[+] 		variable->getName().sz(),
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		variable->getPos ()->m_line + 1,
[+] 		variable->getPos()->m_line + 1,
[-] 		variable->getType ()->getLlvmDiType (),
[+] 		variable->getType()->getLlvmDiType(),
[-] 	return m_llvmDiBuilder->createParameterVariable (
[+] 	return m_llvmDiBuilder->createParameterVariable(
[-] 		scope->getLlvmDiScope (),
[+] 		scope->getLlvmDiScope(),
[-] 		variable->getName ().sz (),
[+] 		variable->getName().sz(),
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		variable->getPos ()->m_line + 1,
[+] 		variable->getPos()->m_line + 1,
[-] 		variable->getType ()->getLlvmDiType (),
[+] 		variable->getType()->getLlvmDiType(),
[-] LlvmDiBuilder::createDeclare (Variable* variable)
[+] LlvmDiBuilder::createDeclare(Variable* variable)
[-] 	BasicBlock* block = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* block = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (block && scope);
[+] 	ASSERT(block && scope);
[-] 	llvm::Instruction* llvmInstruction = m_llvmDiBuilder->insertDeclare (
[+] 	llvm::Instruction* llvmInstruction = m_llvmDiBuilder->insertDeclare(
[-] 		variable->getLlvmValue (),
[+] 		variable->getLlvmValue(),
[-] 		variable->getLlvmDiDescriptor (),
[+] 		variable->getLlvmDiDescriptor(),
[-] 		m_llvmDiBuilder->createExpression (),
[+] 		m_llvmDiBuilder->createExpression(),
[-] 		block->getLlvmBlock ()
[+] 		block->getLlvmBlock()
[-] 	llvm::DebugLoc llvmDebugLoc = llvm::DebugLoc::get (
[+] 	llvm::DebugLoc llvmDebugLoc = llvm::DebugLoc::get(
[-] 		variable->getPos ()->m_line + 1, 0,
[+] 		variable->getPos()->m_line + 1, 0,
[-] 		scope->getLlvmDiScope ()
[+] 		scope->getLlvmDiScope()
[-] 	llvmInstruction->setDebugLoc (llvmDebugLoc);
[+] 	llvmInstruction->setDebugLoc(llvmDebugLoc);
[-] 	llvm::DILocalVariable* llvmDiLocalVariable = (llvm::DILocalVariable*) variable->getLlvmDiDescriptor ();
[+] 	llvm::DILocalVariable* llvmDiLocalVariable = (llvm::DILocalVariable*)variable->getLlvmDiDescriptor();
[-] 	ASSERT (llvm::isa <llvm::DILocalVariable> (llvmDiLocalVariable));
[+] 	ASSERT(llvm::isa<llvm::DILocalVariable> (llvmDiLocalVariable));
[-] 	const Token::Pos* pos = variable->getPos ();
[+] 	const Token::Pos* pos = variable->getPos();
[-] 	llvm::Instruction* llvmInstruction = m_llvmDiBuilder->insertDeclare (
[+] 	llvm::Instruction* llvmInstruction = m_llvmDiBuilder->insertDeclare(
[-] 		variable->getLlvmValue (),
[+] 		variable->getLlvmValue(),
[-] 		m_llvmDiBuilder->createExpression (),
[+] 		m_llvmDiBuilder->createExpression(),
[-] 		llvm::DebugLoc::get (pos->m_line, pos->m_col, scope->getLlvmDiScope()),
[+] 		llvm::DebugLoc::get(pos->m_line, pos->m_col, scope->getLlvmDiScope()),
[-] 		block->getLlvmBlock ()
[+] 		block->getLlvmBlock()
[-] LlvmDiBuilder::createFunction (Function* function)
[+] LlvmDiBuilder::createFunction(Function* function)
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	Token::Pos declPos = *function->getPos ();
[+] 	Token::Pos declPos = *function->getPos();
[-] 	Token::Pos scopePos = function->hasBody () ? function->getBody ().getHead ()->m_pos : declPos;
[+] 	Token::Pos scopePos = function->hasBody() ? function->getBody().getHead()->m_pos : declPos;
[-] 	llvm::DICompositeType llvmDiSubroutineType (function->getType ()->getLlvmDiType ());
[+] 	llvm::DICompositeType llvmDiSubroutineType(function->getType()->getLlvmDiType());
[-] 	ASSERT (llvmDiSubroutineType);
[+] 	ASSERT(llvmDiSubroutineType);
[-] 	return m_llvmDiBuilder->createFunction (
[+] 	return m_llvmDiBuilder->createFunction(
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		function->m_tag.sz (),
[+] 		function->m_tag.sz(),
[-] 		function->m_tag.sz (), // linkage name
[+] 		function->m_tag.sz(), // linkage name
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] 		function->getLlvmFunction (),
[+] 		function->getLlvmFunction(),
[-] 	llvm::DISubroutineType* llvmDiSubroutineType = (llvm::DISubroutineType*) function->getType ()->getLlvmDiType ();
[+] 	llvm::DISubroutineType* llvmDiSubroutineType = (llvm::DISubroutineType*)function->getType()->getLlvmDiType();
[-] 	ASSERT (llvm::isa <llvm::DISubroutineType> (llvmDiSubroutineType));
[+] 	ASSERT(llvm::isa<llvm::DISubroutineType> (llvmDiSubroutineType));
[-] 	return m_llvmDiBuilder->createFunction (
[+] 	return m_llvmDiBuilder->createFunction(
[-] 		function->m_tag.sz (),
[+] 		function->m_tag.sz(),
[-] 		function->m_tag.sz (), // linkage name
[+] 		function->m_tag.sz(), // linkage name
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
[-] LlvmDiBuilder::createLexicalBlock (
[+] LlvmDiBuilder::createLexicalBlock(
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 		llvmParentBlock = parentScope->getLlvmDiScope ();
[+] 		llvmParentBlock = parentScope->getLlvmDiScope();
[-] 		Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 		Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 		ASSERT (function);
[+] 		ASSERT(function);
[-] 		llvmParentBlock = function->getLlvmDiSubprogram ();
[+] 		llvmParentBlock = function->getLlvmDiSubprogram();
[-] 	return m_llvmDiBuilder->createLexicalBlock (
[+] 	return m_llvmDiBuilder->createLexicalBlock(
[-] 		unit->getLlvmDiFile (),
[+] 		unit->getLlvmDiFile(),
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_LlvmIrBuilder.cpp
----------------------
[-] LlvmIrBuilder::LlvmIrBuilder ()
[+] LlvmIrBuilder::LlvmIrBuilder()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] LlvmIrBuilder::create ()
[+] LlvmIrBuilder::create()
[-] 	ASSERT (!m_llvmIrBuilder);
[+] 	ASSERT(!m_llvmIrBuilder);
[-] 	m_llvmIrBuilder = new llvm::IRBuilder <> (*m_module->getLlvmContext ());
[+] 	m_llvmIrBuilder = new llvm::IRBuilder<> (*m_module->getLlvmContext());
[-] 	m_llvmAllocaIrBuilder = new llvm::IRBuilder <> (*m_module->getLlvmContext ());
[+] 	m_llvmAllocaIrBuilder = new llvm::IRBuilder<> (*m_module->getLlvmContext());
[-] LlvmIrBuilder::clear ()
[+] LlvmIrBuilder::clear()
[-] LlvmIrBuilder::setAllocaBlock (BasicBlock* block)
[+] LlvmIrBuilder::setAllocaBlock(BasicBlock* block)
[-] 	llvm::TerminatorInst* llvmJmp = block->getLlvmBlock ()->getTerminator ();
[+] 	llvm::TerminatorInst* llvmJmp = block->getLlvmBlock()->getTerminator();
[-] 	ASSERT (llvm::isa <llvm::BranchInst> (llvmJmp));
[+] 	ASSERT(llvm::isa<llvm::BranchInst> (llvmJmp));
[-] 	m_llvmAllocaIrBuilder->SetInsertPoint (llvmJmp);
[+] 	m_llvmAllocaIrBuilder->SetInsertPoint(llvmJmp);
[-] LlvmIrBuilder::createSwitch (
[+] LlvmIrBuilder::createSwitch(
[-] 	sl::HashTableIterator <intptr_t, BasicBlock*> firstCase,
[+] 	sl::HashTableIterator<intptr_t, BasicBlock*> firstCase,
[-] 	Type* type = value.getType ();
[+] 	Type* type = value.getType();
[-] 	ASSERT (type->getTypeKindFlags () & TypeKindFlag_Integer);
[+] 	ASSERT(type->getTypeKindFlags() & TypeKindFlag_Integer);
[-] 	llvm::SwitchInst* inst = m_llvmIrBuilder->CreateSwitch (
[+] 	llvm::SwitchInst* inst = m_llvmIrBuilder->CreateSwitch(
[-] 		value.getLlvmValue (),
[+] 		value.getLlvmValue(),
[-] 		defaultBlock->getLlvmBlock (),
[+] 		defaultBlock->getLlvmBlock(),
[-] 	sl::HashTableIterator <intptr_t, BasicBlock*> caseIt = firstCase;
[+] 	sl::HashTableIterator<intptr_t, BasicBlock*> caseIt = firstCase;
[-] 		Value constValue (caseIt->getKey (), type);
[+] 		Value constValue(caseIt->getKey(), type);
[-] 		inst->addCase ((llvm::ConstantInt*) constValue.getLlvmValue (), block->getLlvmBlock ());
[+] 		inst->addCase((llvm::ConstantInt*)constValue.getLlvmValue(), block->getLlvmBlock());
[-] LlvmIrBuilder::setInsertPoint (BasicBlock* block)
[+] LlvmIrBuilder::setInsertPoint(BasicBlock* block)
[-] 	if (!(block->getFlags () & BasicBlockFlag_Entry) || !block->hasTerminator ())
[+] 	if (!(block->getFlags() & BasicBlockFlag_Entry) || !block->hasTerminator())
[-] 		m_llvmIrBuilder->SetInsertPoint (block->getLlvmBlock ());
[+] 		m_llvmIrBuilder->SetInsertPoint(block->getLlvmBlock());
[-] 		m_llvmIrBuilder->SetInsertPoint (block->getLlvmBlock ()->getTerminator ());
[+] 		m_llvmIrBuilder->SetInsertPoint(block->getLlvmBlock()->getTerminator());
[-] LlvmIrBuilder::saveInsertPoint (LlvmIrInsertPoint* insertPoint)
[+] LlvmIrBuilder::saveInsertPoint(LlvmIrInsertPoint* insertPoint)
[-] 	insertPoint->m_llvmBlock = m_llvmIrBuilder->GetInsertBlock ();
[+] 	insertPoint->m_llvmBlock = m_llvmIrBuilder->GetInsertBlock();
[-] 	if (insertPoint->m_llvmBlock->empty ())
[+] 	if (insertPoint->m_llvmBlock->empty())
[-] 		llvm::BasicBlock::iterator llvmInstIt = m_llvmIrBuilder->GetInsertPoint ();
[+] 		llvm::BasicBlock::iterator llvmInstIt = m_llvmIrBuilder->GetInsertPoint();
[-] 		ASSERT (&*llvmInstIt);
[+] 		ASSERT(&*llvmInstIt);
[-] 			llvmInstIt == insertPoint->m_llvmBlock->begin () ?
[+] 			llvmInstIt == insertPoint->m_llvmBlock->begin() ?
[-] 			llvmInstIt == insertPoint->m_llvmBlock->end () ?
[+] 			llvmInstIt == insertPoint->m_llvmBlock->end() ?
[-] 				&insertPoint->m_llvmBlock->back () :
[+] 				&insertPoint->m_llvmBlock->back() :
[-] LlvmIrBuilder::restoreInsertPoint (
[+] LlvmIrBuilder::restoreInsertPoint(
[-] 	saveInsertPoint (prevInsertPoint);
[+] 	saveInsertPoint(prevInsertPoint);
[-] 	restoreInsertPoint (insertPoint);
[+] 	restoreInsertPoint(insertPoint);
[-] LlvmIrBuilder::restoreInsertPoint (const LlvmIrInsertPoint& insertPoint)
[+] LlvmIrBuilder::restoreInsertPoint(const LlvmIrInsertPoint& insertPoint)
[-] 	ASSERT (insertPoint);
[+] 	ASSERT(insertPoint);
[-] 		if (insertPoint.m_llvmBlock->empty ())
[+] 		if (insertPoint.m_llvmBlock->empty())
[-] 			m_llvmIrBuilder->SetInsertPoint (insertPoint.m_llvmBlock);
[+] 			m_llvmIrBuilder->SetInsertPoint(insertPoint.m_llvmBlock);
[-] 			m_llvmIrBuilder->SetInsertPoint (&insertPoint.m_llvmBlock->front ());
[+] 			m_llvmIrBuilder->SetInsertPoint(&insertPoint.m_llvmBlock->front());
[-] 		if (insertPoint.m_llvmInstruction == &insertPoint.m_llvmBlock->back ())
[+] 		if (insertPoint.m_llvmInstruction == &insertPoint.m_llvmBlock->back())
[-] 			m_llvmIrBuilder->SetInsertPoint (insertPoint.m_llvmBlock);
[+] 			m_llvmIrBuilder->SetInsertPoint(insertPoint.m_llvmBlock);
[-] 			m_llvmIrBuilder->SetInsertPoint (&*++llvm::BasicBlock::iterator (insertPoint.m_llvmInstruction));
[+] 			m_llvmIrBuilder->SetInsertPoint(&*++llvm::BasicBlock::iterator(insertPoint.m_llvmInstruction));
[-] LlvmIrBuilder::createIndirectBr (
[+] LlvmIrBuilder::createIndirectBr(
[-] 	llvm::IndirectBrInst* inst = m_llvmIrBuilder->CreateIndirectBr (value.getLlvmValue (), blockCount);
[+] 	llvm::IndirectBrInst* inst = m_llvmIrBuilder->CreateIndirectBr(value.getLlvmValue(), blockCount);
[-] 		inst->addDestination (blockArray [i]->getLlvmBlock ());
[+] 		inst->addDestination(blockArray[i]->getLlvmBlock());
[-] LlvmIrBuilder::createSwitch (
[+] LlvmIrBuilder::createSwitch(
[-] 	Type* type = value.getType ();
[+] 	Type* type = value.getType();
[-] 	ASSERT (type->getTypeKindFlags () & TypeKindFlag_Integer);
[+] 	ASSERT(type->getTypeKindFlags() & TypeKindFlag_Integer);
[-] 	llvm::SwitchInst* inst = m_llvmIrBuilder->CreateSwitch (
[+] 	llvm::SwitchInst* inst = m_llvmIrBuilder->CreateSwitch(
[-] 		value.getLlvmValue (),
[+] 		value.getLlvmValue(),
[-] 		defaultBlock->getLlvmBlock (),
[+] 		defaultBlock->getLlvmBlock(),
[-] 		Value constValue (constArray [i], type);
[+] 		Value constValue(constArray[i], type);
[-] 		BasicBlock* block = blockArray [i];
[+] 		BasicBlock* block = blockArray[i];
[-] 		inst->addCase ((llvm::ConstantInt*) constValue.getLlvmValue (), block->getLlvmBlock ());
[+] 		inst->addCase((llvm::ConstantInt*)constValue.getLlvmValue(), block->getLlvmBlock());
[-] LlvmIrBuilder::createPhi (
[+] LlvmIrBuilder::createPhi(
[-] 	if (valueArray->isEmpty ())
[+] 	if (valueArray->isEmpty())
[-] 		resultValue->setVoid (m_module);
[+] 		resultValue->setVoid(m_module);
[-] 	llvm::PHINode* phiNode = m_llvmIrBuilder->CreatePHI (valueArray->getType ()->getLlvmType (), count, "phi");
[+] 	llvm::PHINode* phiNode = m_llvmIrBuilder->CreatePHI(valueArray->getType()->getLlvmType(), count, "phi");
[-] 		phiNode->addIncoming (valueArray [i].getLlvmValue (), blockArray [i]->getLlvmBlock ());
[+] 		phiNode->addIncoming(valueArray[i].getLlvmValue(), blockArray[i]->getLlvmBlock());
[-] 	resultValue->setLlvmValue (phiNode, valueArray->getType ());
[+] 	resultValue->setLlvmValue(phiNode, valueArray->getType());
[-] LlvmIrBuilder::createPhi (
[+] LlvmIrBuilder::createPhi(
[-] 	if (value1.isEmpty ())
[+] 	if (value1.isEmpty())
[-] 		resultValue->setVoid (m_module);
[+] 		resultValue->setVoid(m_module);
[-] 	llvm::PHINode* phiNode = m_llvmIrBuilder->CreatePHI (value1.getLlvmValue ()->getType (), 2,  "phi");
[+] 	llvm::PHINode* phiNode = m_llvmIrBuilder->CreatePHI(value1.getLlvmValue()->getType(), 2,  "phi");
[-] 	phiNode->addIncoming (value1.getLlvmValue (), block1->getLlvmBlock ());
[+] 	phiNode->addIncoming(value1.getLlvmValue(), block1->getLlvmBlock());
[-] 	phiNode->addIncoming (value2.getLlvmValue (), block2->getLlvmBlock ());
[+] 	phiNode->addIncoming(value2.getLlvmValue(), block2->getLlvmBlock());
[-] 	resultValue->setLlvmValue (phiNode, value1.getType ());
[+] 	resultValue->setLlvmValue(phiNode, value1.getType());
[-] LlvmIrBuilder::createAlloca (
[+] LlvmIrBuilder::createAlloca(
[-] 	llvm::AllocaInst* inst = m_llvmAllocaIrBuilder->CreateAlloca (type->getLlvmType (), 0, name >> toLlvm);
[+] 	llvm::AllocaInst* inst = m_llvmAllocaIrBuilder->CreateAlloca(type->getLlvmType(), 0, name >> toLlvm);
[-] 	resultValue->setLlvmValue (inst, resultType);
[+] 	resultValue->setLlvmValue(inst, resultType);
[-] LlvmIrBuilder::createGep (
[+] LlvmIrBuilder::createGep(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Value*> llvmIndexArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Value*> llvmIndexArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmIndexArray.setCount (indexCount);
[+] 	llvmIndexArray.setCount(indexCount);
[-] 		llvmIndexArray [i] = indexArray [i].getLlvmValue ();
[+] 		llvmIndexArray[i] = indexArray[i].getLlvmValue();
[-] 	llvm::Value* inst = m_llvmIrBuilder->CreateGEP (
[+] 	llvm::Value* inst = m_llvmIrBuilder->CreateGEP(
[-] 			value.getLlvmValue (),
[+] 			value.getLlvmValue(),
[-] 			llvm::ArrayRef <llvm::Value*> (llvmIndexArray, indexCount),
[+] 			llvm::ArrayRef<llvm::Value*> (llvmIndexArray, indexCount),
[-] 	resultValue->setLlvmValue (inst, resultType);
[+] 	resultValue->setLlvmValue(inst, resultType);
[-] LlvmIrBuilder::createGep (
[+] LlvmIrBuilder::createGep(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Value*> llvmIndexArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Value*> llvmIndexArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmIndexArray.setCount (indexCount);
[+] 	llvmIndexArray.setCount(indexCount);
[-] 		indexValue.setConstInt32 (indexArray [i], m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32_u));
[+] 		indexValue.setConstInt32(indexArray[i], m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32_u));
[-] 		llvmIndexArray [i] = indexValue.getLlvmValue ();
[+] 		llvmIndexArray[i] = indexValue.getLlvmValue();
[-] 	llvm::Value* inst = m_llvmIrBuilder->CreateGEP (
[+] 	llvm::Value* inst = m_llvmIrBuilder->CreateGEP(
[-] 			value.getLlvmValue (),
[+] 			value.getLlvmValue(),
[-] 			llvm::ArrayRef <llvm::Value*> (llvmIndexArray, indexCount),
[+] 			llvm::ArrayRef<llvm::Value*> (llvmIndexArray, indexCount),
[-] 	resultValue->setLlvmValue (inst, resultType);
[+] 	resultValue->setLlvmValue(inst, resultType);
[-] LlvmIrBuilder::createCall (
[+] LlvmIrBuilder::createCall(
[-] 	if (resultType->getTypeKind () != TypeKind_Void)
[+] 	if (resultType->getTypeKind() != TypeKind_Void)
[-] 		inst = m_llvmIrBuilder->CreateCall (
[+] 		inst = m_llvmIrBuilder->CreateCall(
[-] 			calleeValue.getLlvmValue (),
[+] 			calleeValue.getLlvmValue(),
[-] 			llvm::ArrayRef <llvm::Value*> (llvmArgValueArray, argCount),
[+] 			llvm::ArrayRef<llvm::Value*> (llvmArgValueArray, argCount),
[-] 		ASSERT (resultValue);
[+] 		ASSERT(resultValue);
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 		inst = m_llvmIrBuilder->CreateCall (
[+] 		inst = m_llvmIrBuilder->CreateCall(
[-] 			calleeValue.getLlvmValue (),
[+] 			calleeValue.getLlvmValue(),
[-] 			llvm::ArrayRef <llvm::Value*> (llvmArgValueArray, argCount)
[+] 			llvm::ArrayRef<llvm::Value*> (llvmArgValueArray, argCount)
[-] 			resultValue->setVoid (m_module);
[+] 			resultValue->setVoid(m_module);
[-] 	llvm::CallingConv::ID llvmCallConv = callConv->getLlvmCallConv ();
[+] 	llvm::CallingConv::ID llvmCallConv = callConv->getLlvmCallConv();
[-] 		inst->setCallingConv (llvmCallConv);
[+] 		inst->setCallingConv(llvmCallConv);
[-] LlvmIrBuilder::createCall (
[+] LlvmIrBuilder::createCall(
[-] 	const sl::BoxList <Value>& argValueList,
[+] 	const sl::BoxList<Value>& argValueList,
[-] 	size_t argCount = argValueList.getCount ();
[+] 	size_t argCount = argValueList.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Value*> llvmArgValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Value*> llvmArgValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgValueArray.setCount (argCount);
[+] 	llvmArgValueArray.setCount(argCount);
[-] 	sl::ConstBoxIterator <Value> it = argValueList.getHead ();
[+] 	sl::ConstBoxIterator<Value> it = argValueList.getHead();
[-] 		ASSERT (it);
[+] 		ASSERT(it);
[-] 		llvmArgValueArray [i] = it->getLlvmValue ();
[+] 		llvmArgValueArray[i] = it->getLlvmValue();
[-] 	return createCall (calleeValue, callConv, llvmArgValueArray, argCount, resultType, resultValue);
[+] 	return createCall(calleeValue, callConv, llvmArgValueArray, argCount, resultType, resultValue);
[-] LlvmIrBuilder::createCall (
[+] LlvmIrBuilder::createCall(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Value*> llvmArgValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Value*> llvmArgValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	llvmArgValueArray.setCount (argCount);
[+] 	llvmArgValueArray.setCount(argCount);
[-] 		llvmArgValueArray [i] = argArray [i].getLlvmValue ();
[+] 		llvmArgValueArray[i] = argArray[i].getLlvmValue();
[-] 	return createCall (calleeValue, callConv, llvmArgValueArray, argCount, resultType, resultValue);
[+] 	return createCall(calleeValue, callConv, llvmArgValueArray, argCount, resultType, resultValue);
[-] LlvmIrBuilder::createClosureFunctionPtr (
[+] LlvmIrBuilder::createClosureFunctionPtr(
[-] 	createBitCast (rawPtrValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 	createBitCast(rawPtrValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 	createBitCast (rawClosureValue, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &closureValue);
[+] 	createBitCast(rawClosureValue, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &closureValue);
[-] 	Value functionPtrValue = resultType->getUndefValue ();
[+] 	Value functionPtrValue = resultType->getUndefValue();
[-] 	createInsertValue (functionPtrValue, ptrValue, 0, NULL, &functionPtrValue);
[+] 	createInsertValue(functionPtrValue, ptrValue, 0, NULL, &functionPtrValue);
[-] 	createInsertValue (functionPtrValue, closureValue, 1, resultType, resultValue);
[+] 	createInsertValue(functionPtrValue, closureValue, 1, resultType, resultValue);
[-] LlvmIrBuilder::createClosurePropertyPtr (
[+] LlvmIrBuilder::createClosurePropertyPtr(
[-] 	createBitCast (rawPtrValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 	createBitCast(rawPtrValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 	createBitCast (rawClosureValue, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &closureValue);
[+] 	createBitCast(rawClosureValue, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &closureValue);
[-] 	Value functionPtrValue = resultType->getUndefValue ();
[+] 	Value functionPtrValue = resultType->getUndefValue();
[-] 	createInsertValue (functionPtrValue, ptrValue, 0, NULL, &functionPtrValue);
[+] 	createInsertValue(functionPtrValue, ptrValue, 0, NULL, &functionPtrValue);
[-] 	createInsertValue (functionPtrValue, closureValue, 1, resultType, resultValue);
[+] 	createInsertValue(functionPtrValue, closureValue, 1, resultType, resultValue);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_Module.cpp
----------------------
[-] getTlsStringBuffer ()
[+] getTlsStringBuffer()
[-] 	sys::TlsSlot* slot = sl::getSimpleSingleton <sys::TlsSlot> (&flag);
[+] 	sys::TlsSlot* slot = sl::getSimpleSingleton<sys::TlsSlot> (&flag);
[-] 	sl::String* oldStringBuffer = (sl::String*) sys::getTlsMgr ()->getSlotValue (*slot).p ();
[+] 	sl::String* oldStringBuffer = (sl::String*)sys::getTlsMgr()->getSlotValue(*slot).p();
[-] 	ref::Ptr <sl::String> newStringBuffer = AXL_REF_NEW (ref::Box <sl::String>);
[+] 	ref::Ptr<sl::String> newStringBuffer = AXL_REF_NEW(ref::Box<sl::String>);
[-] 	sys::getTlsMgr ()->setSlotValue (*slot, newStringBuffer);
[+] 	sys::getTlsMgr()->setSlotValue(*slot, newStringBuffer);
[-] Module::Module ()
[+] Module::Module()
[-] 	finalizeConstruction ();
[+] 	finalizeConstruction();
[-] Module::clear ()
[+] Module::clear()
[-] 	m_typeMgr.clear ();
[+] 	m_typeMgr.clear();
[-] 	m_namespaceMgr.clear ();
[+] 	m_namespaceMgr.clear();
[-] 	m_functionMgr.clear ();
[+] 	m_functionMgr.clear();
[-] 	m_variableMgr.clear ();
[+] 	m_variableMgr.clear();
[-] 	m_constMgr.clear ();
[+] 	m_constMgr.clear();
[-] 	m_controlFlowMgr.clear ();
[+] 	m_controlFlowMgr.clear();
[-] 	m_operatorMgr.clear ();
[+] 	m_operatorMgr.clear();
[-] 	m_gcShadowStackMgr.clear ();
[+] 	m_gcShadowStackMgr.clear();
[-] 	m_regexMgr.clear ();
[+] 	m_regexMgr.clear();
[-] 	m_unitMgr.clear ();
[+] 	m_unitMgr.clear();
[-] 	m_importMgr.clear ();
[+] 	m_importMgr.clear();
[-] 	m_extensionLibMgr.clear ();
[+] 	m_extensionLibMgr.clear();
[-] 	m_doxyMgr.clear ();
[+] 	m_doxyMgr.clear();
[-] 	m_name.clear ();
[+] 	m_name.clear();
[-] 	m_llvmIrBuilder.clear ();
[+] 	m_llvmIrBuilder.clear();
[-] 	m_llvmDiBuilder.clear ();
[+] 	m_llvmDiBuilder.clear();
[-] 	m_calcLayoutArray.clear ();
[+] 	m_calcLayoutArray.clear();
[-] 	m_compileArray.clear ();
[+] 	m_compileArray.clear();
[-] 	m_sourceList.clear ();
[+] 	m_sourceList.clear();
[-] 	m_filePathSet.clear ();
[+] 	m_filePathSet.clear();
[-] 	m_functionMap.clear ();
[+] 	m_functionMap.clear();
[-] Module::initialize (
[+] Module::initialize(
[-] 	clear ();
[+] 	clear();
[-] 	m_llvmModule = new llvm::Module ("jncModule", *m_llvmContext);
[+] 	m_llvmModule = new llvm::Module("jncModule", *m_llvmContext);
[-] 	m_llvmIrBuilder.create ();
[+] 	m_llvmIrBuilder.create();
[-] 		m_llvmDiBuilder.create ();
[+] 		m_llvmDiBuilder.create();
[-] 		m_extensionLibMgr.addStaticLib (jnc_CoreLib_getLib ());
[+] 		m_extensionLibMgr.addStaticLib(jnc_CoreLib_getLib());
[-] 		m_variableMgr.createStdVariables ();
[+] 		m_variableMgr.createStdVariables();
[-] 		m_namespaceMgr.addStdItems ();
[+] 		m_namespaceMgr.addStdItems();
[-] Module::createLlvmExecutionEngine ()
[+] Module::createLlvmExecutionEngine()
[-] 	ASSERT (!m_llvmExecutionEngine);
[+] 	ASSERT(!m_llvmExecutionEngine);
[-] 	llvm::StringMap <llvm::cl::Option*> options;
[+] 	llvm::StringMap<llvm::cl::Option*> options;
[-] 	llvm::cl::getRegisteredOptions (options);
[+] 	llvm::cl::getRegisteredOptions(options);
[-] 	llvm::cl::opt <bool>* enableMerge = (llvm::cl::opt <bool>*) options.find ("global-merge")->second;
[+] 	llvm::cl::opt<bool>* enableMerge = (llvm::cl::opt<bool>*) options.find("global-merge")->second;
[-] 	ASSERT (llvm::isa <llvm::cl::opt <bool> > (enableMerge));
[+] 	ASSERT(llvm::isa<llvm::cl::opt<bool> > (enableMerge));
[-] 	enableMerge->setValue (false);
[+] 	enableMerge->setValue(false);
[-] 	llvm::EngineBuilder engineBuilder (m_llvmModule);
[+] 	llvm::EngineBuilder engineBuilder(m_llvmModule);
[-] 	llvm::EngineBuilder engineBuilder (std::move (std::unique_ptr <llvm::Module> (m_llvmModule)));
[+] 	llvm::EngineBuilder engineBuilder(std::move(std::unique_ptr<llvm::Module> (m_llvmModule)));
[-] 	engineBuilder.setErrorStr (&errorString);
[+] 	engineBuilder.setErrorStr(&errorString);
[-] 		JitMemoryMgr* jitMemoryMgr = new JitMemoryMgr (this);
[+] 		JitMemoryMgr* jitMemoryMgr = new JitMemoryMgr(this);
[-] 		engineBuilder.setUseMCJIT (true);
[+] 		engineBuilder.setUseMCJIT(true);
[-] 		engineBuilder.setMCJITMemoryManager (jitMemoryMgr);
[+] 		engineBuilder.setMCJITMemoryManager(jitMemoryMgr);
[-] 		engineBuilder.setMCJITMemoryManager (std::move (std::unique_ptr <JitMemoryMgr> (jitMemoryMgr)));
[+] 		engineBuilder.setMCJITMemoryManager(std::move(std::unique_ptr<JitMemoryMgr> (jitMemoryMgr)));
[-] 		engineBuilder.setMCJITMemoryManager (std::move (std::unique_ptr <JitMemoryMgr> (jitMemoryMgr)));
[+] 		engineBuilder.setMCJITMemoryManager(std::move(std::unique_ptr<JitMemoryMgr> (jitMemoryMgr)));
[-] 		m_functionMap ["memset"] = (void*) memset;
[+] 		m_functionMap["memset"] = (void*) memset;
[-] 		m_functionMap ["memcpy"] = (void*) memcpy;
[+] 		m_functionMap["memcpy"] = (void*) memcpy;
[-] 		m_functionMap ["memmove"] = (void*) memmove;
[+] 		m_functionMap["memmove"] = (void*) memmove;
[-] 		m_functionMap ["__divdi3"] = (void*) __divdi3;
[+] 		m_functionMap["__divdi3"] = (void*) __divdi3;
[-] 		m_functionMap ["__moddi3"] = (void*) __moddi3;
[+] 		m_functionMap["__moddi3"] = (void*) __moddi3;
[-] 		m_functionMap ["__udivdi3"] = (void*) __udivdi3;
[+] 		m_functionMap["__udivdi3"] = (void*) __udivdi3;
[-] 		m_functionMap ["__umoddi3"] = (void*) __umoddi3;
[+] 		m_functionMap["__umoddi3"] = (void*) __umoddi3;
[-] 		m_functionMap ["__aeabi_idiv"] = (void*) __aeabi_idiv;
[+] 		m_functionMap["__aeabi_idiv"] = (void*) __aeabi_idiv;
[-] 		m_functionMap ["__aeabi_uidiv"] = (void*) __aeabi_uidiv;
[+] 		m_functionMap["__aeabi_uidiv"] = (void*) __aeabi_uidiv;
[-] 		m_functionMap ["__aeabi_ldivmod"] = (void*) __aeabi_ldivmod;
[+] 		m_functionMap["__aeabi_ldivmod"] = (void*) __aeabi_ldivmod;
[-] 		m_functionMap ["__aeabi_uldivmod"] = (void*) __aeabi_uldivmod;
[+] 		m_functionMap["__aeabi_uldivmod"] = (void*) __aeabi_uldivmod;
[-] 		m_functionMap ["__aeabi_i2f"] = (void*) __aeabi_i2f;
[+] 		m_functionMap["__aeabi_i2f"] = (void*) __aeabi_i2f;
[-] 		m_functionMap ["__aeabi_l2f"] = (void*) __aeabi_l2f;
[+] 		m_functionMap["__aeabi_l2f"] = (void*) __aeabi_l2f;
[-] 		m_functionMap ["__aeabi_ui2f"] = (void*) __aeabi_ui2f;
[+] 		m_functionMap["__aeabi_ui2f"] = (void*) __aeabi_ui2f;
[-] 		m_functionMap ["__aeabi_ul2f"] = (void*) __aeabi_ul2f;
[+] 		m_functionMap["__aeabi_ul2f"] = (void*) __aeabi_ul2f;
[-] 		m_functionMap ["__aeabi_i2d"] = (void*) __aeabi_i2d;
[+] 		m_functionMap["__aeabi_i2d"] = (void*) __aeabi_i2d;
[-] 		m_functionMap ["__aeabi_l2d"] = (void*) __aeabi_l2d;
[+] 		m_functionMap["__aeabi_l2d"] = (void*) __aeabi_l2d;
[-] 		m_functionMap ["__aeabi_ui2d"] = (void*) __aeabi_ui2d;
[+] 		m_functionMap["__aeabi_ui2d"] = (void*) __aeabi_ui2d;
[-] 		m_functionMap ["__aeabi_ul2d"] = (void*) __aeabi_ul2d;
[+] 		m_functionMap["__aeabi_ul2d"] = (void*) __aeabi_ul2d;
[-] 		m_functionMap ["_alldiv"] = (void*) _alldiv;
[+] 		m_functionMap["_alldiv"] = (void*) _alldiv;
[-] 		m_functionMap ["_allrem"] = (void*) _allrem;
[+] 		m_functionMap["_allrem"] = (void*) _allrem;
[-] 		m_functionMap ["_aulldiv"] = (void*) _aulldiv;
[+] 		m_functionMap["_aulldiv"] = (void*) _aulldiv;
[-] 		m_functionMap ["_aullrem"] = (void*) _aullrem;
[+] 		m_functionMap["_aullrem"] = (void*) _aullrem;
[-] 		ASSERT (false); // should have been checked earlier
[+] 		ASSERT(false); // should have been checked earlier
[-] 		void* chkstk = ::GetProcAddress (::GetModuleHandleA ("ntdll.dll"), "__chkstk");
[+] 		void* chkstk = ::GetProcAddress(::GetModuleHandleA("ntdll.dll"), "__chkstk");
[-] 			err::setFormatStringError ("__chkstk is not found");
[+] 			err::setFormatStringError("__chkstk is not found");
[-] 		llvm::JITMemoryManager* jitMemoryMgr = llvm::JITMemoryManager::CreateDefaultMemManager ();
[+] 		llvm::JITMemoryManager* jitMemoryMgr = llvm::JITMemoryManager::CreateDefaultMemManager();
[-] 		engineBuilder.setJITMemoryManager (jitMemoryMgr);
[+] 		engineBuilder.setJITMemoryManager(jitMemoryMgr);
[-] 		uchar_t* p = jitMemoryMgr->allocateCodeSection (128, 0, 0, llvm::StringRef ());
[+] 		uchar_t* p = jitMemoryMgr->allocateCodeSection(128, 0, 0, llvm::StringRef());
[-] 		p [0] = 0x49;
[+] 		p[0] = 0x49;
[-] 		p [1] = 0xbb;
[+] 		p[1] = 0xbb;
[-] 		p [10] = 0x41;
[+] 		p[10] = 0x41;
[-] 		p [11] = 0xff;
[+] 		p[11] = 0xff;
[-] 		p [12] = 0xe3;
[+] 		p[12] = 0xe3;
[-] 		llvm::sys::DynamicLibrary::AddSymbol ("__chkstk", p);
[+] 		llvm::sys::DynamicLibrary::AddSymbol("__chkstk", p);
[-] 		engineBuilder.setUseMCJIT (false);
[+] 		engineBuilder.setUseMCJIT(false);
[-] 	engineBuilder.setTargetOptions (targetOptions);
[+] 	engineBuilder.setTargetOptions(targetOptions);
[-] 	engineBuilder.setMArch ("x86");
[+] 	engineBuilder.setMArch("x86");
[-] 	sys::ScopedTlsPtrSlot <Module> scopeModule (this); // for GcShadowStack
[+] 	sys::ScopedTlsPtrSlot<Module> scopeModule(this); // for GcShadowStack
[-] 	m_llvmExecutionEngine = engineBuilder.create ();
[+] 	m_llvmExecutionEngine = engineBuilder.create();
[-] 		err::setFormatStringError ("cannot create execution engine: %s", errorString.c_str());
[+] 		err::setFormatStringError("cannot create execution engine: %s", errorString.c_str());
[-] Module::mapVariable (
[+] Module::mapVariable(
[-] 	llvm::GlobalVariable* llvmVariable = variable->getLlvmGlobalVariable ();
[+] 	llvm::GlobalVariable* llvmVariable = variable->getLlvmGlobalVariable();
[-] 		err::setFormatStringError ("attempt to map non-global variable: %s", variable->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("attempt to map non-global variable: %s", variable->getQualifiedName ().sz ());
[-] 		std::string name = llvmVariable->getName ();
[+] 		std::string name = llvmVariable->getName();
[-] 		llvm::GlobalVariable* llvmMapping = new llvm::GlobalVariable (
[+] 		llvm::GlobalVariable* llvmMapping = new llvm::GlobalVariable(
[-] 			variable->getType ()->getLlvmType (),
[+] 			variable->getType()->getLlvmType(),
[-] 		llvmVariable->replaceAllUsesWith (llvmMapping);
[+] 		llvmVariable->replaceAllUsesWith(llvmMapping);
[-] 		llvmVariable->eraseFromParent ();
[+] 		llvmVariable->eraseFromParent();
[-] 		ASSERT (m_llvmExecutionEngine);
[+] 		ASSERT(m_llvmExecutionEngine);
[-] 		m_llvmExecutionEngine->addGlobalMapping (llvmMapping, p);
[+] 		m_llvmExecutionEngine->addGlobalMapping(llvmMapping, p);
[-] 		sl::StringHashTableIterator <void*> it = m_functionMap.visit (llvmMapping->getName ().data ());
[+] 		sl::StringHashTableIterator<void*> it = m_functionMap.visit(llvmMapping->getName().data());
[-] 			err::setFormatStringError ("attempt to re-map variable: %s", variable->getQualifiedName ().sz ());
[+] 			err::setFormatStringError("attempt to re-map variable: %s", variable->getQualifiedName ().sz ());
[-] 		ASSERT (m_llvmExecutionEngine);
[+] 		ASSERT(m_llvmExecutionEngine);
[-] 		m_llvmExecutionEngine->addGlobalMapping (llvmVariable, p);
[+] 		m_llvmExecutionEngine->addGlobalMapping(llvmVariable, p);
[-] Module::mapFunction (
[+] Module::mapFunction(
[-] 	llvm::Function* llvmFunction = function->getLlvmFunction ();
[+] 	llvm::Function* llvmFunction = function->getLlvmFunction();
[-] 		sl::StringHashTableIterator <void*> it = m_functionMap.visit (llvmFunction->getName ().data ());
[+] 		sl::StringHashTableIterator<void*> it = m_functionMap.visit(llvmFunction->getName().data());
[-] 			err::setFormatStringError ("attempt to re-map function: %s", function->getQualifiedName ().sz ());
[+] 			err::setFormatStringError("attempt to re-map function: %s", function->getQualifiedName ().sz ());
[-] 		ASSERT (m_llvmExecutionEngine);
[+] 		ASSERT(m_llvmExecutionEngine);
[-] 		m_llvmExecutionEngine->addGlobalMapping (llvmFunction, p);
[+] 		m_llvmExecutionEngine->addGlobalMapping(llvmFunction, p);
[-] Module::findFunctionMapping (const sl::StringRef& name)
[+] Module::findFunctionMapping(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <void*> it;
[+] 	sl::StringHashTableIterator<void*> it;
[-] 	bool isUnderscorePrefix = name.isPrefix (sl::StringRef ("_", 1, true));
[+] 	bool isUnderscorePrefix = name.isPrefix(sl::StringRef("_", 1, true));
[-] 	bool isUnderscorePrefix = name.isPrefix (sl::StringRef ("_?", 2, true));
[+] 	bool isUnderscorePrefix = name.isPrefix(sl::StringRef("_?", 2, true));
[-] 		m_functionMap.find (name.getSubString (1)) :
[+] 		m_functionMap.find(name.getSubString(1)) :
[-] 		m_functionMap.find (name);
[+] 		m_functionMap.find(name);
[-] Module::setFunctionPointer (
[+] Module::setFunctionPointer(
[-] 	Function* function = m_namespaceMgr.getGlobalNamespace ()->getFunctionByName (name);
[+] 	Function* function = m_namespaceMgr.getGlobalNamespace()->getFunctionByName(name);
[-] 	llvm::Function* llvmFunction = function->getLlvmFunction ();
[+] 	llvm::Function* llvmFunction = function->getLlvmFunction();
[-] 	llvmExecutionEngine->addGlobalMapping (llvmFunction, p);
[+] 	llvmExecutionEngine->addGlobalMapping(llvmFunction, p);
[-] Module::setFunctionPointer (
[+] Module::setFunctionPointer(
[-] 	ModuleItem* item = m_namespaceMgr.getGlobalNamespace ()->findItem (name);
[+] 	ModuleItem* item = m_namespaceMgr.getGlobalNamespace()->findItem(name);
[-] 	if (!item || item->getItemKind () != ModuleItemKind_Function)
[+] 	if (!item || item->getItemKind() != ModuleItemKind_Function)
[-] 	llvm::Function* llvmFunction = ((Function*) item)->getLlvmFunction ();
[+] 	llvm::Function* llvmFunction = ((Function*)item)->getLlvmFunction();
[-] 	llvmExecutionEngine->addGlobalMapping (llvmFunction, p);
[+] 	llvmExecutionEngine->addGlobalMapping(llvmFunction, p);
[-] Module::markForLayout (
[+] Module::markForLayout(
[-] 	m_calcLayoutArray.append (item);
[+] 	m_calcLayoutArray.append(item);
[-] Module::markForCompile (ModuleItem* item)
[+] Module::markForCompile(ModuleItem* item)
[-] 	m_compileArray.append (item);
[+] 	m_compileArray.append(item);
[-] Module::parse (
[+] Module::parse(
[-] 	Unit* unit = m_unitMgr.createUnit (lib, fileName);
[+] 	Unit* unit = m_unitMgr.createUnit(lib, fileName);
[-] 	m_unitMgr.setCurrentUnit (unit);
[+] 	m_unitMgr.setCurrentUnit(unit);
[-] 	lexer.create (fileName, source);
[+] 	lexer.create(fileName, source);
[-] 	Parser parser (this);
[+] 	Parser parser(this);
[-] 	parser.create (Parser::StartSymbol, true);
[+] 	parser.create(Parser::StartSymbol, true);
[-] 		const Token* token = lexer.getToken ();
[+] 		const Token* token = lexer.getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 			err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 			lex::pushSrcPosError (fileName, token->m_pos);
[+] 			lex::pushSrcPosError(fileName, token->m_pos);
[-] 				if (isSingleLine && !comment.isEmpty () && comment [0] == '<')
[+] 				if (isSingleLine && !comment.isEmpty() && comment[0] == '<')
[-] 					comment = comment.getSubString (1);
[+] 					comment = comment.getSubString(1);
[-] 				parser.m_doxyParser.addComment (
[+] 				parser.m_doxyParser.addComment(
[-] 			result = parser.parseToken (token);
[+] 			result = parser.parseToken(token);
[-] 				lex::ensureSrcPosError (fileName, token->m_pos);
[+] 				lex::ensureSrcPosError(fileName, token->m_pos);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 	m_namespaceMgr.getGlobalNamespace ()->getUsingSet ()->clear ();
[+] 	m_namespaceMgr.getGlobalNamespace()->getUsingSet()->clear();
[-] Module::parseFile (const sl::StringRef& fileName)
[+] Module::parseFile(const sl::StringRef& fileName)
[-] 	sl::String filePath = io::getFullFilePath (fileName);
[+] 	sl::String filePath = io::getFullFilePath(fileName);
[-] 	sl::StringHashTableIterator <bool> it = m_filePathSet.find (filePath);
[+] 	sl::StringHashTableIterator<bool> it = m_filePathSet.find(filePath);
[-] 	bool result = file.open (filePath, io::FileFlag_ReadOnly);
[+] 	bool result = file.open(filePath, io::FileFlag_ReadOnly);
[-] 	size_t length = file.getMappingSize ();
[+] 	size_t length = file.getMappingSize();
[-] 	sl::String source ((const char*) file.p (), length);
[+] 	sl::String source((const char*) file.p(), length);
[-] 	m_sourceList.insertTail (source);
[+] 	m_sourceList.insertTail(source);
[-] 	m_filePathSet.visit (filePath);
[+] 	m_filePathSet.visit(filePath);
[-] 	return parse (NULL, filePath, source);
[+] 	return parse(NULL, filePath, source);
[-] Module::parseImports ()
[+] Module::parseImports()
[-] 	sl::ConstList <Import> importList = m_importMgr.getImportList ();
[+] 	sl::ConstList<Import> importList = m_importMgr.getImportList();
[-] 	sl::ConstIterator <Import> importIt = importList.getHead ();
[+] 	sl::ConstIterator<Import> importIt = importList.getHead();
[-] 			parse (
[+] 			parse(
[-] 			parseFile (importIt->m_filePath);
[+] 			parseFile(importIt->m_filePath);
[-] Module::link ()
[+] Module::link()
[-] 	ASSERT (m_compileState < ModuleCompileState_Linked);
[+] 	ASSERT(m_compileState < ModuleCompileState_Linked);
[-] 		m_typeMgr.resolveImportTypes () &&
[+] 		m_typeMgr.resolveImportTypes() &&
[-] 		m_namespaceMgr.resolveImportUsingSets () &&
[+] 		m_namespaceMgr.resolveImportUsingSets() &&
[-] 		m_namespaceMgr.resolveOrphans ();
[+] 		m_namespaceMgr.resolveOrphans();
[-] Module::calcLayout ()
[+] Module::calcLayout()
[-] 	ASSERT (m_compileState < ModuleCompileState_LayoutCalculated);
[+] 	ASSERT(m_compileState < ModuleCompileState_LayoutCalculated);
[-] 		result = link ();
[+] 		result = link();
[-] 	result = processCalcLayoutArray ();
[+] 	result = processCalcLayoutArray();
[-] Module::compile ()
[+] Module::compile()
[-] 	ASSERT (m_compileState < ModuleCompileState_Compiled);
[+] 	ASSERT(m_compileState < ModuleCompileState_Compiled);
[-] 		result = calcLayout ();
[+] 		result = calcLayout();
[-] 		createConstructorDestructor () &&
[+] 		createConstructorDestructor() &&
[-] 		processCompileArray () &&
[+] 		processCompileArray() &&
[-] 		m_variableMgr.createTlsStructType ();
[+] 		m_variableMgr.createTlsStructType();
[-] 	m_functionMgr.injectTlsPrologues ();
[+] 	m_functionMgr.injectTlsPrologues();
[-] 	m_functionMgr.replaceAsyncAllocas ();
[+] 	m_functionMgr.replaceAsyncAllocas();
[-] 	result = m_controlFlowMgr.deleteUnreachableBlocks ();
[+] 	result = m_controlFlowMgr.deleteUnreachableBlocks();
[-] 		m_llvmDiBuilder.finalize ();
[+] 		m_llvmDiBuilder.finalize();
[-] Module::jit ()
[+] Module::jit()
[-] 	ASSERT (m_compileState < ModuleCompileState_Jitted);
[+] 	ASSERT(m_compileState < ModuleCompileState_Jitted);
[-] 		result = compile ();
[+] 		result = compile();
[-] 		createLlvmExecutionEngine () &&
[+] 		createLlvmExecutionEngine() &&
[-] 		m_extensionLibMgr.mapAddresses () &&
[+] 		m_extensionLibMgr.mapAddresses() &&
[-] 		m_functionMgr.jitFunctions ();
[+] 		m_functionMgr.jitFunctions();
[-] Module::processCalcLayoutArray ()
[+] Module::processCalcLayoutArray()
[-] 	while (!m_calcLayoutArray.isEmpty ()) // new items could be added in process
[+] 	while (!m_calcLayoutArray.isEmpty()) // new items could be added in process
[-] 		sl::Array <ModuleItem*> calcLayoutArray = m_calcLayoutArray;
[+] 		sl::Array<ModuleItem*> calcLayoutArray = m_calcLayoutArray;
[-] 		m_calcLayoutArray.clear ();
[+] 		m_calcLayoutArray.clear();
[-] 		size_t count = calcLayoutArray.getCount ();
[+] 		size_t count = calcLayoutArray.getCount();
[-] 		for (size_t i = 0; i < calcLayoutArray.getCount (); i++)
[+] 		for (size_t i = 0; i < calcLayoutArray.getCount(); i++)
[-] 			result = calcLayoutArray [i]->ensureLayout ();
[+] 			result = calcLayoutArray[i]->ensureLayout();
[-] Module::processCompileArray ()
[+] Module::processCompileArray()
[-] 	while (!m_compileArray.isEmpty ()) // new items could be added in process
[+] 	while (!m_compileArray.isEmpty()) // new items could be added in process
[-] 		sl::Array <ModuleItem*> compileArray = m_compileArray;
[+] 		sl::Array<ModuleItem*> compileArray = m_compileArray;
[-] 		m_compileArray.clear ();
[+] 		m_compileArray.clear();
[-] 		size_t count = compileArray.getCount ();
[+] 		size_t count = compileArray.getCount();
[-] 		for (size_t i = 0; i < compileArray.getCount (); i++)
[+] 		for (size_t i = 0; i < compileArray.getCount(); i++)
[-] 			result = compileArray [i]->compile ();
[+] 			result = compileArray[i]->compile();
[-] 			ASSERT (!m_namespaceMgr.getCurrentScope ());
[+] 			ASSERT(!m_namespaceMgr.getCurrentScope());
[-] Module::postParseStdItem ()
[+] Module::postParseStdItem()
[-] 	bool result = m_typeMgr.resolveImportTypes ();
[+] 	bool result = m_typeMgr.resolveImportTypes();
[-] 		result = processCalcLayoutArray ();
[+] 		result = processCalcLayoutArray();
[-] 			result = processCompileArray ();
[+] 			result = processCompileArray();
[-] Module::createConstructorDestructor ()
[+] Module::createConstructorDestructor()
[-] 	ASSERT (!m_constructor && !m_destructor);
[+] 	ASSERT(!m_constructor && !m_destructor);
[-] 	sl::ConstList <Unit> unitList = m_unitMgr.getUnitList ();
[+] 	sl::ConstList<Unit> unitList = m_unitMgr.getUnitList();
[-] 	FunctionType* type = (FunctionType*) m_typeMgr.getStdType (StdType_SimpleFunction);
[+] 	FunctionType* type = (FunctionType*)m_typeMgr.getStdType(StdType_SimpleFunction);
[-] 	Function* function = m_functionMgr.createFunction (FunctionKind_StaticConstructor, type);
[+] 	Function* function = m_functionMgr.createFunction(FunctionKind_StaticConstructor, type);
[-] 	m_functionMgr.internalPrologue (function);
[+] 	m_functionMgr.internalPrologue(function);
[-] 	result = m_variableMgr.allocateInitializeGlobalVariables ();
[+] 	result = m_variableMgr.allocateInitializeGlobalVariables();
[-] 	m_functionMgr.callStaticConstructors ();
[+] 	m_functionMgr.callStaticConstructors();
[-] 	sl::ConstIterator <Unit> it = unitList.getHead ();
[+] 	sl::ConstIterator<Unit> it = unitList.getHead();
[-] 		Function* constructor = it->getConstructor ();
[+] 		Function* constructor = it->getConstructor();
[-] 		Function* destructor = it->getDestructor ();
[+] 		Function* destructor = it->getDestructor();
[-] 			m_llvmIrBuilder.createCall (constructor, constructor->getType (), NULL);
[+] 			m_llvmIrBuilder.createCall(constructor, constructor->getType(), NULL);
[-] 	m_functionMgr.internalEpilogue ();
[+] 	m_functionMgr.internalEpilogue();
[-] 	function = m_functionMgr.createFunction (FunctionKind_StaticDestructor, type);
[+] 	function = m_functionMgr.createFunction(FunctionKind_StaticDestructor, type);
[-] 	m_functionMgr.internalPrologue (function);
[+] 	m_functionMgr.internalPrologue(function);
[-] 	it = unitList.getTail ();
[+] 	it = unitList.getTail();
[-] 		Function* destructor = it->getDestructor ();
[+] 		Function* destructor = it->getDestructor();
[-] 			m_llvmIrBuilder.createCall (destructor, destructor->getType (), NULL);
[+] 			m_llvmIrBuilder.createCall(destructor, destructor->getType(), NULL);
[-] 	m_functionMgr.internalEpilogue ();
[+] 	m_functionMgr.internalEpilogue();
[-] Module::getLlvmIrString ()
[+] Module::getLlvmIrString()
[-] 	llvm::raw_string_ostream stream (string);
[+] 	llvm::raw_string_ostream stream(string);
[-] 	m_llvmModule->print (stream, NULL);
[+] 	m_llvmModule->print(stream, NULL);
[-] 	return string.c_str ();
[+] 	return string.c_str();
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ModuleItem.cpp
----------------------
[-] ModuleItemInitializer::getInitializerString ()
[+] ModuleItemInitializer::getInitializerString()
[-] 	if (!m_initializer.isEmpty () && m_initializerString.isEmpty ())
[+] 	if (!m_initializer.isEmpty() && m_initializerString.isEmpty())
[-] 		m_initializerString = Token::getTokenListString (m_initializer);
[+] 		m_initializerString = Token::getTokenListString(m_initializer);
[-] ModuleItemDecl::ModuleItemDecl ()
[+] ModuleItemDecl::ModuleItemDecl()
[-] ModuleItemDecl::getDoxyLocationString ()
[+] ModuleItemDecl::getDoxyLocationString()
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	string.format ("<location file='%s' line='%d' col='%d'/>\n",
[+] 	string.format("<location file='%s' line='%d' col='%d'/>\n",
[-] 		m_parentUnit->getFileName ().sz (),
[+] 		m_parentUnit->getFileName().sz(),
[-] ModuleItemDecl::pushSrcPosError ()
[+] ModuleItemDecl::pushSrcPosError()
[-] 	lex::pushSrcPosError (m_parentUnit->getFilePath (), m_pos);
[+] 	lex::pushSrcPosError(m_parentUnit->getFilePath(), m_pos);
[-] ModuleItem::ModuleItem ()
[+] ModuleItem::ModuleItem()
[-] ModuleItem::getDecl ()
[+] ModuleItem::getDecl()
[-] 	switch (m_itemKind)
[+] 	switch(m_itemKind)
[-] 		return (GlobalNamespace*) this;
[+] 		return (GlobalNamespace*)this;
[-] 		return (Scope*) this;
[+] 		return (Scope*)this;
[-] 		return (((Type*) this)->getTypeKindFlags () & TypeKindFlag_Named) ?
[+] 		return (((Type*)this)->getTypeKindFlags() & TypeKindFlag_Named) ?
[-] 			(NamedType*) this :
[+] 			(NamedType*)this :
[-] 		return (Typedef*) this;
[+] 		return (Typedef*)this;
[-] 		return (Alias*) this;
[+] 		return (Alias*)this;
[-] 		return (Const*) this;
[+] 		return (Const*)this;
[-] 		return (Variable*) this;
[+] 		return (Variable*)this;
[-] 		return (FunctionArg*) this;
[+] 		return (FunctionArg*)this;
[-] 		return (Function*) this;
[+] 		return (Function*)this;
[-] 		return (Property*) this;
[+] 		return (Property*)this;
[-] 		return (PropertyTemplate*) this;
[+] 		return (PropertyTemplate*)this;
[-] 		return (EnumConst*) this;
[+] 		return (EnumConst*)this;
[-] 		return (StructField*) this;
[+] 		return (StructField*)this;
[-] 		return (BaseTypeSlot*) this;
[+] 		return (BaseTypeSlot*)this;
[-] 		return (Orphan*) this;
[+] 		return (Orphan*)this;
[-] ModuleItem::getNamespace ()
[+] ModuleItem::getNamespace()
[-] 	switch (m_itemKind)
[+] 	switch(m_itemKind)
[-] 		return (GlobalNamespace*) this;
[+] 		return (GlobalNamespace*)this;
[-] 		return (Scope*) this;
[+] 		return (Scope*)this;
[-] 		return ((Typedef*) this)->getType ()->getNamespace ();
[+] 		return ((Typedef*)this)->getType()->getNamespace();
[-] 		return (((Type*) this)->getTypeKindFlags () & TypeKindFlag_Named) ?
[+] 		return (((Type*)this)->getTypeKindFlags() & TypeKindFlag_Named) ?
[-] 			(NamedType*) this :
[+] 			(NamedType*)this :
[-] 		return (Property*) this;
[+] 		return (Property*)this;
[-] 		return (PropertyTemplate*) this;
[+] 		return (PropertyTemplate*)this;
[-] ModuleItem::getType ()
[+] ModuleItem::getType()
[-] 	switch (m_itemKind)
[+] 	switch(m_itemKind)
[-] 		return (ct::Type*) this;
[+] 		return (ct::Type*)this;
[-] 		return ((ct::Typedef*) this)->getType ();
[+] 		return ((ct::Typedef*)this)->getType();
[-] 		return ((ct::Const*) this)->getValue ().getType ();
[+] 		return ((ct::Const*)this)->getValue().getType();
[-] 		return ((ct::Variable*) this)->getType ();
[+] 		return ((ct::Variable*)this)->getType();
[-] 		return ((ct::FunctionArg*) this)->getType ();
[+] 		return ((ct::FunctionArg*)this)->getType();
[-] 		return ((ct::Function*) this)->getType ();
[+] 		return ((ct::Function*)this)->getType();
[-] 		return ((ct::Property*) this)->getType ();
[+] 		return ((ct::Property*)this)->getType();
[-] 		return ((ct::PropertyTemplate*) this)->calcType ();
[+] 		return ((ct::PropertyTemplate*)this)->calcType();
[-] 		return ((ct::EnumConst*) this)->getParentEnumType ();
[+] 		return ((ct::EnumConst*)this)->getParentEnumType();
[-] 		return ((ct::StructField*) this)->getType ();
[+] 		return ((ct::StructField*)this)->getType();
[-] 		return ((ct::BaseTypeSlot*) this)->getType ();
[+] 		return ((ct::BaseTypeSlot*)this)->getType();
[-] 		return ((ct::Orphan*) this)->getFunctionType ();
[+] 		return ((ct::Orphan*)this)->getFunctionType();
[-] 		return jnc_ModuleItem_getType (((ct::LazyModuleItem*) this)->getActualItem ());
[+] 		return jnc_ModuleItem_getType(((ct::LazyModuleItem*)this)->getActualItem());
[-] ModuleItem::ensureLayout ()
[+] ModuleItem::ensureLayout()
[-] 		err::setFormatStringError ("can't calculate layout of '%s' due to recursion", m_tag.sz ());
[+] 		err::setFormatStringError("can't calculate layout of '%s' due to recursion", m_tag.sz ());
[-] 	result = calcLayout ();
[+] 	result = calcLayout();
[-] ModuleItem::getDoxyBlock ()
[+] ModuleItem::getDoxyBlock()
[-] 	m_doxyBlock = m_module->m_doxyMgr.createBlock ();
[+] 	m_doxyBlock = m_module->m_doxyMgr.createBlock();
[-] ModuleItem::setDoxyBlock (DoxyBlock* block)
[+] ModuleItem::setDoxyBlock(DoxyBlock* block)
[-] ModuleItem::createDoxyRefId ()
[+] ModuleItem::createDoxyRefId()
[-] 	sl::String refId = getModuleItemKindString (m_itemKind);
[+] 	sl::String refId = getModuleItemKindString(m_itemKind);
[-] 	refId.replace ('-', '_');
[+] 	refId.replace('-', '_');
[-] 	if (!m_tag.isEmpty ())
[+] 	if (!m_tag.isEmpty())
[-] 		refId.appendFormat ("_%s", m_tag.sz ());
[+] 		refId.appendFormat("_%s", m_tag.sz ());
[-] 		refId.replace ('.', '_');
[+] 		refId.replace('.', '_');
[-] 	refId.makeLowerCase ();
[+] 	refId.makeLowerCase();
[-] 	return m_module->m_doxyMgr.adjustRefId (refId);
[+] 	return m_module->m_doxyMgr.adjustRefId(refId);
[-] verifyModuleItemKind (
[+] verifyModuleItemKind(
[-] 	if (item->getItemKind () != itemKind)
[+] 	if (item->getItemKind() != itemKind)
[-] 		err::setFormatStringError ("'%s' is not a %s", name.sz (), getModuleItemKindString (itemKind));
[+] 		err::setFormatStringError("'%s' is not a %s", name.sz (), getModuleItemKindString (itemKind));
[-] verifyModuleItemIsDerivableType (
[+] verifyModuleItemIsDerivableType(
[-] 	Type* type = (Type*) verifyModuleItemKind (item, ModuleItemKind_Type, name);
[+] 	Type* type = (Type*)verifyModuleItemKind(item, ModuleItemKind_Type, name);
[-] 	if (!(type->getTypeKindFlags () & TypeKindFlag_Derivable))
[+] 	if (!(type->getTypeKindFlags() & TypeKindFlag_Derivable))
[-] 		err::setFormatStringError ("'%s' is not a derivable type", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a derivable type", type->getTypeString ().sz ());
[-] 	return (DerivableType*) item;
[+] 	return (DerivableType*)item;
[-] verifyModuleItemIsClassType (
[+] verifyModuleItemIsClassType(
[-] 	Type* type = (Type*) verifyModuleItemKind (item, ModuleItemKind_Type, name);
[+] 	Type* type = (Type*)verifyModuleItemKind(item, ModuleItemKind_Type, name);
[-] 	if (type->getTypeKind () != TypeKind_Class)
[+] 	if (type->getTypeKind() != TypeKind_Class)
[-] 		err::setFormatStringError ("'%s' is not a class type", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a class type", type->getTypeString ().sz ());
[-] 	return (ClassType*) item;
[+] 	return (ClassType*)item;
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_RegexMgr.cpp
----------------------
[-] Dfa::Dfa ()
[+] Dfa::Dfa()
[-] Dfa::clear ()
[+] Dfa::clear()
[-] 	m_transitionTable.clear ();
[+] 	m_transitionTable.clear();
[-] 	m_stateInfoTable.clear ();
[+] 	m_stateInfoTable.clear();
[-] 	m_acceptInfoList.clear ();
[+] 	m_acceptInfoList.clear();
[-] 	m_groupSetList.clear ();
[+] 	m_groupSetList.clear();
[-] Dfa::build (fsm::Regex* regex)
[+] Dfa::build(fsm::Regex* regex)
[-] 	sl::Array <fsm::DfaState*> stateArray = regex->getDfaStateArray ();
[+] 	sl::Array<fsm::DfaState*> stateArray = regex->getDfaStateArray();
[-] 	m_stateCount = stateArray.getCount ();
[+] 	m_stateCount = stateArray.getCount();
[-] 	m_groupCount = regex->getGroupCount ();
[+] 	m_groupCount = regex->getGroupCount();
[-] 	m_stateInfoTable.setCount (m_stateCount);
[+] 	m_stateInfoTable.setCount(m_stateCount);
[-] 	m_transitionTable.setCount (m_stateCount * 256);
[+] 	m_transitionTable.setCount(m_stateCount * 256);
[-] 	memset (m_stateInfoTable, 0, m_stateCount * sizeof (DfaStateInfo));
[+] 	memset(m_stateInfoTable, 0, m_stateCount * sizeof(DfaStateInfo));
[-] 	memset (m_transitionTable, -1, m_stateCount * 256 * sizeof (uintptr_t));
[+] 	memset(m_transitionTable, -1, m_stateCount * 256 * sizeof(uintptr_t));
[-] 		fsm::DfaState* state = stateArray [i];
[+] 		fsm::DfaState* state = stateArray[i];
[-] 			ReSwitchAcceptContext* context = (ReSwitchAcceptContext*) state->m_acceptContext;
[+] 			ReSwitchAcceptContext* context = (ReSwitchAcceptContext*)state->m_acceptContext;
[-] 			ASSERT (context->m_firstGroupId + context->m_groupCount <= m_groupCount);
[+] 			ASSERT(context->m_firstGroupId + context->m_groupCount <= m_groupCount);
[-] 			DfaAcceptInfo* acceptInfo = AXL_MEM_NEW (DfaAcceptInfo);
[+] 			DfaAcceptInfo* acceptInfo = AXL_MEM_NEW(DfaAcceptInfo);
[-] 			m_acceptInfoList.insertTail (acceptInfo);
[+] 			m_acceptInfoList.insertTail(acceptInfo);
[-] 			if (state->m_transitionList.isEmpty ())
[+] 			if (state->m_transitionList.isEmpty())
[-] 		size_t j = state->m_openCaptureIdSet.findBit (0);
[+] 		size_t j = state->m_openCaptureIdSet.findBit(0);
[-] 		size_t k = state->m_closeCaptureIdSet.findBit (0);
[+] 		size_t k = state->m_closeCaptureIdSet.findBit(0);
[-] 			DfaGroupSet* groupSet = AXL_MEM_NEW (DfaGroupSet);
[+] 			DfaGroupSet* groupSet = AXL_MEM_NEW(DfaGroupSet);
[-] 				ASSERT (j < m_groupCount);
[+] 				ASSERT(j < m_groupCount);
[-] 				groupSet->m_openArray.append (j);
[+] 				groupSet->m_openArray.append(j);
[-] 				j = state->m_openCaptureIdSet.findBit (j + 1);
[+] 				j = state->m_openCaptureIdSet.findBit(j + 1);
[-] 				ASSERT (k < m_groupCount);
[+] 				ASSERT(k < m_groupCount);
[-] 				groupSet->m_closeArray.append (k);
[+] 				groupSet->m_closeArray.append(k);
[-] 				k = state->m_closeCaptureIdSet.findBit (k + 1);
[+] 				k = state->m_closeCaptureIdSet.findBit(k + 1);
[-] 			m_groupSetList.insertTail (groupSet);
[+] 			m_groupSetList.insertTail(groupSet);
[-] 		sl::Iterator <fsm::DfaTransition> transitionIt = state->m_transitionList.getHead ();
[+] 		sl::Iterator<fsm::DfaTransition> transitionIt = state->m_transitionList.getHead();
[-] 			switch (transition->m_matchCondition.m_conditionKind)
[+] 			switch(transition->m_matchCondition.m_conditionKind)
[-] 				ASSERT (transition->m_matchCondition.m_char < 256);
[+] 				ASSERT(transition->m_matchCondition.m_char < 256);
[-] 				transitionRow [transition->m_matchCondition.m_char] = transition->m_outState->m_id;
[+] 				transitionRow[transition->m_matchCondition.m_char] = transition->m_outState->m_id;
[-] 					if (transition->m_matchCondition.m_charSet.getBit (j))
[+] 					if (transition->m_matchCondition.m_charSet.getBit(j))
[-] 						transitionRow [j] = transition->m_outState->m_id;
[+] 						transitionRow[j] = transition->m_outState->m_id;
[-] 					transitionRow [j] = transition->m_outState->m_id;
[+] 					transitionRow[j] = transition->m_outState->m_id;
[-] RegexMgr::RegexMgr ()
[+] RegexMgr::RegexMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] RegexMgr::createDfa ()
[+] RegexMgr::createDfa()
[-] 	Dfa* attributeBlock = AXL_MEM_NEW (Dfa);
[+] 	Dfa* attributeBlock = AXL_MEM_NEW(Dfa);
[-] 	m_dfaList.insertTail (attributeBlock);
[+] 	m_dfaList.insertTail(attributeBlock);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_UnitMgr.cpp
----------------------
[-] Unit::Unit ()
[+] Unit::Unit()
[-] Unit::setConstructor (Function* function)
[+] Unit::setConstructor(Function* function)
[-] 	if (!function->getType ()->getArgArray ().isEmpty ())
[+] 	if (!function->getType()->getArgArray().isEmpty())
[-] 		err::setFormatStringError ("unit 'construct' cannot have arguments");
[+] 		err::setFormatStringError("unit 'construct' cannot have arguments");
[-] 		err::setFormatStringError ("unit already has 'construct' method");
[+] 		err::setFormatStringError("unit already has 'construct' method");
[-] Unit::setDestructor (Function* function)
[+] Unit::setDestructor(Function* function)
[-] 	ASSERT (function->getType ()->getArgArray ().isEmpty ());
[+] 	ASSERT(function->getType()->getArgArray().isEmpty());
[-] 		err::setFormatStringError ("unit already has 'destruct' method");
[+] 		err::setFormatStringError("unit already has 'destruct' method");
[-] UnitMgr::UnitMgr ()
[+] UnitMgr::UnitMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] UnitMgr::clear ()
[+] UnitMgr::clear()
[-] 	m_unitList.clear ();
[+] 	m_unitList.clear();
[-] UnitMgr::setCurrentUnit (Unit* unit)
[+] UnitMgr::setCurrentUnit(Unit* unit)
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] UnitMgr::getCoreLibUnit ()
[+] UnitMgr::getCoreLibUnit()
[-] 		m_coreLibUnit = createUnit (jnc_CoreLib_getLib (), "jnc_rtl.jnc");
[+] 		m_coreLibUnit = createUnit(jnc_CoreLib_getLib(), "jnc_rtl.jnc");
[-] UnitMgr::createUnit (
[+] UnitMgr::createUnit(
[-] 	Unit* unit = AXL_MEM_NEW (Unit);
[+] 	Unit* unit = AXL_MEM_NEW(Unit);
[-] 	unit->m_fileName = io::getFileName (filePath);
[+] 	unit->m_fileName = io::getFileName(filePath);
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_DebugInfo)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_DebugInfo)
[-] 		unit->m_llvmDiFile = m_module->m_llvmDiBuilder.createFile (unit->m_fileName, unit->m_dir);
[+] 		unit->m_llvmDiFile = m_module->m_llvmDiBuilder.createFile(unit->m_fileName, unit->m_dir);
[-] 	m_unitList.insertTail (unit);
[+] 	m_unitList.insertTail(unit);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_AttributeBlock.h
----------------------
[-] 	getValue ()
[+] 	getValue()
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	sl::List <Attribute> m_attributeList;
[+] 	sl::List<Attribute> m_attributeList;
[-] 	sl::Array <Attribute*> m_attributeArray;
[+] 	sl::Array<Attribute*> m_attributeArray;
[-] 	sl::StringHashTable <Attribute*> m_attributeMap;
[+] 	sl::StringHashTable<Attribute*> m_attributeMap;
[-] 	AttributeBlock ()
[+] 	AttributeBlock()
[-] 	getParentItem ()
[+] 	getParentItem()
[-] 	sl::Array <Attribute*>
[+] 	sl::Array<Attribute*>
[-] 	getAttributeArray ()
[+] 	getAttributeArray()
[-] 	findAttribute (const sl::StringRef& name)
[+] 	findAttribute(const sl::StringRef& name)
[-] 		sl::StringHashTableIterator <Attribute*> it = m_attributeMap.find (name);
[+] 		sl::StringHashTableIterator<Attribute*> it = m_attributeMap.find(name);
[-] 	createAttribute (
[+] 	createAttribute(
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_AttributeMgr.h
----------------------
[-] 	sl::List <AttributeBlock> m_attributeBlockList;
[+] 	sl::List<AttributeBlock> m_attributeBlockList;
[-] 	AttributeMgr ();
[+] 	AttributeMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ()
[+] 	clear()
[-] 		m_attributeBlockList.clear ();
[+] 		m_attributeBlockList.clear();
[-] 	createAttributeBlock ();
[+] 	createAttributeBlock();
[-] 	createAttribute (
[+] 	createAttribute(
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ExtensionLibMgr.h
----------------------
[-] 		sl::Array <ct::ModuleItem*> m_itemArray;
[+] 		sl::Array<ct::ModuleItem*> m_itemArray;
[-] 	typedef sl::DuckTypeHashTable <sl::Guid, ItemCacheEntry*> ItemCacheMap;
[+] 	typedef sl::DuckTypeHashTable<sl::Guid, ItemCacheEntry*> ItemCacheMap;
[-] 	sl::Array <ExtensionLib*> m_libArray;
[+] 	sl::Array<ExtensionLib*> m_libArray;
[-] 	sl::List <DynamicLibEntry> m_dynamicLibList;
[+] 	sl::List<DynamicLibEntry> m_dynamicLibList;
[-] 	sl::List <SourceFile> m_sourceFileList;
[+] 	sl::List<SourceFile> m_sourceFileList;
[-] 	sl::StringHashTable <SourceFile*> m_sourceFileMap;
[+] 	sl::StringHashTable<SourceFile*> m_sourceFileMap;
[-] 	sl::StringHashTable <const OpaqueClassTypeInfo*> m_opaqueClassTypeInfoMap;
[+] 	sl::StringHashTable<const OpaqueClassTypeInfo*> m_opaqueClassTypeInfoMap;
[-] 	sl::List <ItemCacheEntry> m_itemCache;
[+] 	sl::List<ItemCacheEntry> m_itemCache;
[-] 	ExtensionLibMgr ();
[+] 	ExtensionLibMgr();
[-] 	~ExtensionLibMgr ()
[+] 	~ExtensionLibMgr()
[-] 		clear ();
[+] 		clear();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	addStaticLib (ExtensionLib* lib);
[+] 	addStaticLib(ExtensionLib* lib);
[-] 	loadDynamicLib (const sl::StringRef& fileName);
[+] 	loadDynamicLib(const sl::StringRef& fileName);
[-] 	mapAddresses ();
[+] 	mapAddresses();
[-] 	findSourceFileContents (
[+] 	findSourceFileContents(
[-] 	findOpaqueClassTypeInfo (const sl::StringRef& qualifiedName)
[+] 	findOpaqueClassTypeInfo(const sl::StringRef& qualifiedName)
[-] 		sl::StringHashTableIterator <const OpaqueClassTypeInfo*> it = m_opaqueClassTypeInfoMap.find (qualifiedName);
[+] 		sl::StringHashTableIterator<const OpaqueClassTypeInfo*> it = m_opaqueClassTypeInfoMap.find(qualifiedName);
[-] 	findItem (
[+] 	findItem(
[-] 	addSource (
[+] 	addSource(
[-] 	addOpaqueClassTypeInfo (
[+] 	addOpaqueClassTypeInfo(
[-] 		m_opaqueClassTypeInfoMap [qualifiedName] = info;
[+] 		m_opaqueClassTypeInfoMap[qualifiedName] = info;
[-] getStdLib ();
[+] getStdLib();
[-] getSysLib ();
[+] getSysLib();
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_GcShadowStackMgr.h
----------------------
[-] 	sl::Array <intptr_t> m_gcRootArray;
[+] 	sl::Array<intptr_t> m_gcRootArray;
[-] 	sl::Array <Type*> m_gcRootTypeArray;
[+] 	sl::Array<Type*> m_gcRootTypeArray;
[-] 	GcShadowStackFrameMap ()
[+] 	GcShadowStackFrameMap()
[-] 	getPrev ()
[+] 	getPrev()
[-] 	getMapKind ()
[+] 	getMapKind()
[-] 	getGcRootCount ()
[+] 	getGcRootCount()
[-] 		return m_gcRootArray.getCount ();
[+] 		return m_gcRootArray.getCount();
[-] 	getGcRootIndexArray ()
[+] 	getGcRootIndexArray()
[-] 		ASSERT (m_mapKind == GcShadowStackFrameMapKind_Static);
[+] 		ASSERT(m_mapKind == GcShadowStackFrameMapKind_Static);
[-] 		return (const size_t*) m_gcRootArray.cp ();
[+] 		return (const size_t*) m_gcRootArray.cp();
[-] 	getGcRootTypeArray ()
[+] 	getGcRootTypeArray()
[-] 		ASSERT (m_mapKind == GcShadowStackFrameMapKind_Static);
[+] 		ASSERT(m_mapKind == GcShadowStackFrameMapKind_Static);
[-] 		return m_gcRootTypeArray.cp ();
[+] 		return m_gcRootTypeArray.cp();
[-] 	getBoxArray ()
[+] 	getBoxArray()
[-] 		ASSERT (m_mapKind == GcShadowStackFrameMapKind_Dynamic);
[+] 		ASSERT(m_mapKind == GcShadowStackFrameMapKind_Dynamic);
[-] 		return (Box* const*) m_gcRootArray.cp ();
[+] 		return (Box* const*) m_gcRootArray.cp();
[-] 	addBox (Box* box)
[+] 	addBox(Box* box)
[-] 		ASSERT (m_mapKind == GcShadowStackFrameMapKind_Dynamic);
[+] 		ASSERT(m_mapKind == GcShadowStackFrameMapKind_Dynamic);
[-] 		m_gcRootArray.append ((intptr_t) box);
[+] 		m_gcRootArray.append((intptr_t)box);
[-] 	sl::List <GcShadowStackFrameMap> m_frameMapList;
[+] 	sl::List<GcShadowStackFrameMap> m_frameMapList;
[-] 	sl::Array <GcShadowStackFrameMap*> m_functionFrameMapArray;
[+] 	sl::Array<GcShadowStackFrameMap*> m_functionFrameMapArray;
[-] 	GcShadowStackMgr ();
[+] 	GcShadowStackMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	bool hasFrame ()
[+] 	bool hasFrame()
[-] 	clear ();
[+] 	clear();
[-] 	finalizeFunction ();
[+] 	finalizeFunction();
[-] 	finalizeScope (Scope* scope);
[+] 	finalizeScope(Scope* scope);
[-] 	createTmpGcRoot (const Value& value);
[+] 	createTmpGcRoot(const Value& value);
[-] 	markGcRoot (
[+] 	markGcRoot(
[-] 	openFrameMap (Scope* scope);
[+] 	openFrameMap(Scope* scope);
[-] 	setFrameMap (
[+] 	setFrameMap(
[-] 	preCreateFrame ();
[+] 	preCreateFrame();
[-] 	finalizeFrame ();
[+] 	finalizeFrame();
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ImportMgr.h
----------------------
[-] 	sl::List <Import> m_importList;
[+] 	sl::List<Import> m_importList;
[-] 	sl::StringHashTable <bool> m_ignoredImportSet;
[+] 	sl::StringHashTable<bool> m_ignoredImportSet;
[-] 	sl::StringHashTable <bool> m_importFilePathMap;
[+] 	sl::StringHashTable<bool> m_importFilePathMap;
[-] 	sl::BoxList <sl::String> m_importDirList;
[+] 	sl::BoxList<sl::String> m_importDirList;
[-] 	ImportMgr ();
[+] 	ImportMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	sl::ConstList <Import>
[+] 	sl::ConstList<Import>
[-] 	getImportList ()
[+] 	getImportList()
[-] 	addImport (const sl::StringRef& fileName);
[+] 	addImport(const sl::StringRef& fileName);
[-] 	addImport (
[+] 	addImport(
[-] 	addIgnoredImport (const sl::StringRef& fileName)
[+] 	addIgnoredImport(const sl::StringRef& fileName)
[-] 		m_ignoredImportSet.visit (fileName);
[+] 		m_ignoredImportSet.visit(fileName);
[-] 	findImportFile (
[+] 	findImportFile(
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_JitMemoryMgr.h
----------------------
[-] 	JitMemoryMgr (Module* module)
[+] 	JitMemoryMgr(Module* module)
[-] 	getPointerToNamedFunction (
[+] 	getPointerToNamedFunction(
[-] 	getSymbolAddress (const std::string &name);
[+] 	getSymbolAddress(const std::string &name);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_LlvmDiBuilder.h
----------------------
[-] 	LlvmDiBuilder ();
[+] 	LlvmDiBuilder();
[-] 	~LlvmDiBuilder ()
[+] 	~LlvmDiBuilder()
[-] 		clear ();
[+] 		clear();
[-] 	getModule ()
[+] 	getModule()
[-] 	getLlvmDiBuilder ()
[+] 	getLlvmDiBuilder()
[-] 	create ();
[+] 	create();
[-] 	clear ();
[+] 	clear();
[-] 	finalize ()
[+] 	finalize()
[-] 		m_llvmDiBuilder->finalize ();
[+] 		m_llvmDiBuilder->finalize();
[-] 	getDebugLoc (
[+] 	getDebugLoc(
[-] 		return llvm::DebugLoc::get (pos.m_line + 1, 0, scope->getLlvmDiScope ());
[+] 		return llvm::DebugLoc::get(pos.m_line + 1, 0, scope->getLlvmDiScope());
[-] 	getEmptyDebugLoc ();
[+] 	getEmptyDebugLoc();
[-] 	createFile (
[+] 	createFile(
[-] 		return m_llvmDiBuilder->createFile (fileName >> toLlvm, dir >> toLlvm);
[+] 		return m_llvmDiBuilder->createFile(fileName >> toLlvm, dir >> toLlvm);
[-] 	createBasicType (
[+] 	createBasicType(
[-] 		return m_llvmDiBuilder->createBasicType (name >> toLlvm, size * 8, alignment * 8, code);
[+] 		return m_llvmDiBuilder->createBasicType(name >> toLlvm, size * 8, alignment * 8, code);
[-] 		return m_llvmDiBuilder->createBasicType (name >> toLlvm, size * 8, code);
[+] 		return m_llvmDiBuilder->createBasicType(name >> toLlvm, size * 8, code);
[-] 	createSubroutineType (FunctionType* functionType);
[+] 	createSubroutineType(FunctionType* functionType);
[-] 	createEmptyStructType (StructType* structType);
[+] 	createEmptyStructType(StructType* structType);
[-] 	setStructTypeBody (StructType* structType);
[+] 	setStructTypeBody(StructType* structType);
[-] 	createEmptyUnionType (UnionType* unionType);
[+] 	createEmptyUnionType(UnionType* unionType);
[-] 	setUnionTypeBody (UnionType* unionType);
[+] 	setUnionTypeBody(UnionType* unionType);
[-] 	createArrayType (ArrayType* arrayType);
[+] 	createArrayType(ArrayType* arrayType);
[-] 	createPointerType (Type* type);
[+] 	createPointerType(Type* type);
[-] 	createGlobalVariable (Variable* variable);
[+] 	createGlobalVariable(Variable* variable);
[-] 	createParameterVariable (
[+] 	createParameterVariable(
[-] 	createFunction (Function* function);
[+] 	createFunction(Function* function);
[-] 	createLexicalBlock (
[+] 	createLexicalBlock(
[-] 	createDeclare (Variable* variable);
[+] 	createDeclare(Variable* variable);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_LlvmIrBuilder.h
----------------------
[-] 	llvm::IRBuilder <>* m_llvmIrBuilder;
[+] 	llvm::IRBuilder<>* m_llvmIrBuilder;
[-] 	llvm::IRBuilder <>* m_llvmAllocaIrBuilder;
[+] 	llvm::IRBuilder<>* m_llvmAllocaIrBuilder;
[-] 	LlvmIrBuilder ();
[+] 	LlvmIrBuilder();
[-] 	~LlvmIrBuilder ()
[+] 	~LlvmIrBuilder()
[-] 		clear ();
[+] 		clear();
[-] 	getModule ()
[+] 	getModule()
[-] 	llvm::IRBuilder <>*
[+] 	llvm::IRBuilder<>*
[-] 	getLlvmIrBuilder ()
[+] 	getLlvmIrBuilder()
[-] 	llvm::IRBuilder <>*
[+] 	llvm::IRBuilder<>*
[-] 	getLlvmAllocaIrBuilder ()
[+] 	getLlvmAllocaIrBuilder()
[-] 	create ();
[+] 	create();
[-] 	clear ();
[+] 	clear();
[-] 	setAllocaBlock (BasicBlock* block);
[+] 	setAllocaBlock(BasicBlock* block);
[-] 	getCurrentDebugLoc ()
[+] 	getCurrentDebugLoc()
[-] 		return m_llvmIrBuilder->getCurrentDebugLocation ();
[+] 		return m_llvmIrBuilder->getCurrentDebugLocation();
[-] 	setCurrentDebugLoc (const llvm::DebugLoc& llvmDebugLoc)
[+] 	setCurrentDebugLoc(const llvm::DebugLoc& llvmDebugLoc)
[-] 		m_llvmIrBuilder->SetCurrentDebugLocation (llvmDebugLoc);
[+] 		m_llvmIrBuilder->SetCurrentDebugLocation(llvmDebugLoc);
[-] 	setInstDebugLoc (llvm::Instruction* llvmInst)
[+] 	setInstDebugLoc(llvm::Instruction* llvmInst)
[-] 		m_llvmIrBuilder->SetInstDebugLocation (llvmInst);
[+] 		m_llvmIrBuilder->SetInstDebugLocation(llvmInst);
[-] 	getInsertPoint ()
[+] 	getInsertPoint()
[-] 		return &*m_llvmIrBuilder->GetInsertPoint ();
[+] 		return &*m_llvmIrBuilder->GetInsertPoint();
[-] 	setInsertPoint (BasicBlock* block);
[+] 	setInsertPoint(BasicBlock* block);
[-] 	setInsertPoint (llvm::Instruction* llvmInst)
[+] 	setInsertPoint(llvm::Instruction* llvmInst)
[-] 		m_llvmIrBuilder->SetInsertPoint (llvmInst);
[+] 		m_llvmIrBuilder->SetInsertPoint(llvmInst);
[-] 	saveInsertPoint (LlvmIrInsertPoint* insertPoint);
[+] 	saveInsertPoint(LlvmIrInsertPoint* insertPoint);
[-] 	restoreInsertPoint (const LlvmIrInsertPoint& insertPoint);
[+] 	restoreInsertPoint(const LlvmIrInsertPoint& insertPoint);
[-] 	restoreInsertPoint (
[+] 	restoreInsertPoint(
[-] 	createUnreachable ()
[+] 	createUnreachable()
[-] 		return m_llvmIrBuilder->CreateUnreachable ();
[+] 		return m_llvmIrBuilder->CreateUnreachable();
[-] 	createBr (BasicBlock* block)
[+] 	createBr(BasicBlock* block)
[-] 		return m_llvmIrBuilder->CreateBr (block->getLlvmBlock ());
[+] 		return m_llvmIrBuilder->CreateBr(block->getLlvmBlock());
[-] 	createCondBr (
[+] 	createCondBr(
[-] 		return m_llvmIrBuilder->CreateCondBr (
[+] 		return m_llvmIrBuilder->CreateCondBr(
[-] 			value.getLlvmValue (),
[+] 			value.getLlvmValue(),
[-] 			trueBlock->getLlvmBlock (),
[+] 			trueBlock->getLlvmBlock(),
[-] 			falseBlock->getLlvmBlock ()
[+] 			falseBlock->getLlvmBlock()
[-] 	createIndirectBr (
[+] 	createIndirectBr(
[-] 	createSwitch (
[+] 	createSwitch(
[-] 		sl::HashTableIterator <intptr_t, BasicBlock*> firstCase,
[+] 		sl::HashTableIterator<intptr_t, BasicBlock*> firstCase,
[-] 	createSwitch (
[+] 	createSwitch(
[-] 	createRet ()
[+] 	createRet()
[-] 		return m_llvmIrBuilder->CreateRetVoid ();
[+] 		return m_llvmIrBuilder->CreateRetVoid();
[-] 	createRet (const Value& value)
[+] 	createRet(const Value& value)
[-] 		return m_llvmIrBuilder->CreateRet (value.getLlvmValue ());
[+] 		return m_llvmIrBuilder->CreateRet(value.getLlvmValue());
[-] 	createPhi (
[+] 	createPhi(
[-] 	createPhi (
[+] 	createPhi(
[-] 	createAlloca (
[+] 	createAlloca(
[-] 	createLoad (
[+] 	createLoad(
[-] 		llvm::LoadInst* inst = m_llvmIrBuilder->CreateLoad (value.getLlvmValue (), isVolatile, "loa");
[+] 		llvm::LoadInst* inst = m_llvmIrBuilder->CreateLoad(value.getLlvmValue(), isVolatile, "loa");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createStore (
[+] 	createStore(
[-] 		return m_llvmIrBuilder->CreateStore (srcValue.getLlvmValue (), dstValue.getLlvmValue (), isVolatile);
[+] 		return m_llvmIrBuilder->CreateStore(srcValue.getLlvmValue(), dstValue.getLlvmValue(), isVolatile);
[-] 	createGep (
[+] 	createGep(
[-] 	createGep (
[+] 	createGep(
[-] 	createGep (
[+] 	createGep(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateGEP (value.getLlvmValue (), indexValue.getLlvmValue (), "gep");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateGEP(value.getLlvmValue(), indexValue.getLlvmValue(), "gep");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createGep (
[+] 	createGep(
[-] 		indexValue.setConstInt32 (index, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue.setConstInt32(index, getSimpleType(TypeKind_Int32, m_module));
[-] 		return createGep (value, indexValue, resultType, resultValue);
[+] 		return createGep(value, indexValue, resultType, resultValue);
[-] 	createGep2 (
[+] 	createGep2(
[-] 		Value indexArray [] =
[+] 		Value indexArray[] =
[-] 		return createGep (value, indexArray, countof (indexArray), resultType, resultValue);
[+] 		return createGep(value, indexArray, countof(indexArray), resultType, resultValue);
[-] 	createGep2 (
[+] 	createGep2(
[-] 		indexValue1.setConstInt32 (index1, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue1.setConstInt32(index1, getSimpleType(TypeKind_Int32, m_module));
[-] 		indexValue2.setConstInt32 (index2, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue2.setConstInt32(index2, getSimpleType(TypeKind_Int32, m_module));
[-] 		return createGep2 (value, indexValue1, indexValue2, resultType, resultValue);
[+] 		return createGep2(value, indexValue1, indexValue2, resultType, resultValue);
[-] 	createGep2 (
[+] 	createGep2(
[-] 		indexValue1.setConstInt32 (0, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue1.setConstInt32(0, getSimpleType(TypeKind_Int32, m_module));
[-] 		return createGep2 (value, indexValue1, indexValue2, resultType, resultValue);
[+] 		return createGep2(value, indexValue1, indexValue2, resultType, resultValue);
[-] 	createGep2 (
[+] 	createGep2(
[-] 		indexValue1.setConstInt32 (0, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue1.setConstInt32(0, getSimpleType(TypeKind_Int32, m_module));
[-] 		indexValue2.setConstInt32 (index2, getSimpleType (TypeKind_Int32, m_module));
[+] 		indexValue2.setConstInt32(index2, getSimpleType(TypeKind_Int32, m_module));
[-] 		return createGep2 (value, indexValue1, indexValue2, resultType, resultValue);
[+] 		return createGep2(value, indexValue1, indexValue2, resultType, resultValue);
[-] 	createExtractValue (
[+] 	createExtractValue(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateExtractValue (value.getLlvmValue (), index, "extract");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateExtractValue(value.getLlvmValue(), index, "extract");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createExtractValue (
[+] 	createExtractValue(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateExtractValue (
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateExtractValue(
[-] 			value.getLlvmValue (),
[+] 			value.getLlvmValue(),
[-] 			llvm::ArrayRef <uint_t> ((uint_t*) indexArray, indexCount),
[+] 			llvm::ArrayRef<uint_t> ((uint_t*)indexArray, indexCount),
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createInsertValue (
[+] 	createInsertValue(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateInsertValue (
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateInsertValue(
[-] 			aggregateValue.getLlvmValue (),
[+] 			aggregateValue.getLlvmValue(),
[-] 			memberValue.getLlvmValue (),
[+] 			memberValue.getLlvmValue(),
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createInsertValue (
[+] 	createInsertValue(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateInsertValue (
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateInsertValue(
[-] 			aggregateValue.getLlvmValue (),
[+] 			aggregateValue.getLlvmValue(),
[-] 			memberValue.getLlvmValue (),
[+] 			memberValue.getLlvmValue(),
[-] 			llvm::ArrayRef <uint_t> ((uint_t*) indexArray, indexCount),
[+] 			llvm::ArrayRef<uint_t> ((uint_t*)indexArray, indexCount),
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createNeg_i (
[+] 	createNeg_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateNeg (opValue.getLlvmValue (), "neg_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateNeg(opValue.getLlvmValue(), "neg_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createNeg_f (
[+] 	createNeg_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFNeg (opValue.getLlvmValue (), "neg_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFNeg(opValue.getLlvmValue(), "neg_f");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createNot (
[+] 	createNot(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateNot (opValue.getLlvmValue (), "not");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateNot(opValue.getLlvmValue(), "not");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createAdd_i (
[+] 	createAdd_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateAdd (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "add_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateAdd(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "add_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createAdd_f (
[+] 	createAdd_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFAdd (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "add_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFAdd(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "add_f");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createSub_i (
[+] 	createSub_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateSub (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "sub_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateSub(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "sub_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createSub_f (
[+] 	createSub_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFSub (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "sub_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFSub(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "sub_f");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createMul_i (
[+] 	createMul_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateMul (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "mul_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateMul(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "mul_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createMul_f (
[+] 	createMul_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFMul (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "mul_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFMul(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "mul_f");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createDiv_i (
[+] 	createDiv_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateSDiv (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "div_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateSDiv(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "div_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createDiv_u (
[+] 	createDiv_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateUDiv (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "div_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateUDiv(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "div_u");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createDiv_f (
[+] 	createDiv_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFDiv (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "div_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFDiv(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "div_f");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createMod_i (
[+] 	createMod_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateSRem (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "mod_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateSRem(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "mod_i");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createMod_u (
[+] 	createMod_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateURem (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "mod_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateURem(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "mod_u");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createShl (
[+] 	createShl(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateShl (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "shl");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateShl(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "shl");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createShr (
[+] 	createShr(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateLShr (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "shr");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateLShr(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "shr");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createAnd (
[+] 	createAnd(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateAnd (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "and");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateAnd(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "and");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createOr (
[+] 	createOr(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateOr (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "or");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateOr(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "or");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createXor (
[+] 	createXor(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateXor (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "xor");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateXor(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "xor");
[-] 		resultValue->setLlvmValue (inst, resultType);
[+] 		resultValue->setLlvmValue(inst, resultType);
[-] 	createEq_i (
[+] 	createEq_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpEQ (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "eq_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpEQ(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "eq_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createEq_f (
[+] 	createEq_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOEQ (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "eq_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOEQ(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "eq_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createNe_i (
[+] 	createNe_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpNE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "ne_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpNE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "ne_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createNe_f (
[+] 	createNe_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpONE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "ne_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpONE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "ne_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLt_i (
[+] 	createLt_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSLT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "lt_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSLT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "lt_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLt_u (
[+] 	createLt_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpULT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "lt_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpULT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "lt_u");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLt_f (
[+] 	createLt_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOLT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "lt_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOLT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "lt_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLe_i (
[+] 	createLe_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSLE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "le_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSLE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "le_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLe_u (
[+] 	createLe_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpULE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "le_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpULE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "le_u");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createLe_f (
[+] 	createLe_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOLE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "le_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOLE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "le_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGt_i (
[+] 	createGt_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSGT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "gt_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSGT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "gt_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGt_u (
[+] 	createGt_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpUGT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "gt_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpUGT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "gt_u");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGt_f (
[+] 	createGt_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOGT (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "gt_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOGT(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "gt_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGe_i (
[+] 	createGe_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSGE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "ge_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpSGE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "ge_i");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGe_u (
[+] 	createGe_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpUGE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "ge_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateICmpUGE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "ge_u");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createGe_f (
[+] 	createGe_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOGE (opValue1.getLlvmValue (), opValue2.getLlvmValue (), "ge_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFCmpOGE(opValue1.getLlvmValue(), opValue2.getLlvmValue(), "ge_f");
[-] 		resultValue->setLlvmValue (inst, getSimpleType (TypeKind_Bool, m_module));
[+] 		resultValue->setLlvmValue(inst, getSimpleType(TypeKind_Bool, m_module));
[-] 	createCmpXchg (
[+] 	createCmpXchg(
[-] 		llvm::AtomicCmpXchgInst* inst = m_llvmIrBuilder->CreateAtomicCmpXchg (
[+] 		llvm::AtomicCmpXchgInst* inst = m_llvmIrBuilder->CreateAtomicCmpXchg(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] 			cmpValue.getLlvmValue (),
[+] 			cmpValue.getLlvmValue(),
[-] 			newValue.getLlvmValue (),
[+] 			newValue.getLlvmValue(),
[-] 		resultValue->setLlvmValue (inst, newValue.getType ());
[+] 		resultValue->setLlvmValue(inst, newValue.getType());
[-] 	createCmpXchg (
[+] 	createCmpXchg(
[-] 		llvm::AtomicCmpXchgInst* inst = m_llvmIrBuilder->CreateAtomicCmpXchg (
[+] 		llvm::AtomicCmpXchgInst* inst = m_llvmIrBuilder->CreateAtomicCmpXchg(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] 			cmpValue.getLlvmValue (),
[+] 			cmpValue.getLlvmValue(),
[-] 			newValue.getLlvmValue (),
[+] 			newValue.getLlvmValue(),
[-] 		resultValue->setLlvmValue (inst, newValue.getType ());
[+] 		resultValue->setLlvmValue(inst, newValue.getType());
[-] 	createRmw (
[+] 	createRmw(
[-] 		llvm::AtomicRMWInst* inst = m_llvmIrBuilder->CreateAtomicRMW (
[+] 		llvm::AtomicRMWInst* inst = m_llvmIrBuilder->CreateAtomicRMW(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] 			newValue.getLlvmValue (),
[+] 			newValue.getLlvmValue(),
[-] 		resultValue->setLlvmValue (inst, newValue.getType ());
[+] 		resultValue->setLlvmValue(inst, newValue.getType());
[-] 	createBitCast (
[+] 	createBitCast(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateBitCast (opValue.getLlvmValue (), type, "bitcast");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateBitCast(opValue.getLlvmValue(), type, "bitcast");
[-] 		resultValue->setLlvmValue (inst, NULL);
[+] 		resultValue->setLlvmValue(inst, NULL);
[-] 	createBitCast (
[+] 	createBitCast(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateBitCast (opValue.getLlvmValue (), type->getLlvmType (), "bitcast");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateBitCast(opValue.getLlvmValue(), type->getLlvmType(), "bitcast");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createIntToPtr (
[+] 	createIntToPtr(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateIntToPtr (opValue.getLlvmValue (), type->getLlvmType (), "int2ptr");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateIntToPtr(opValue.getLlvmValue(), type->getLlvmType(), "int2ptr");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createPtrToInt (
[+] 	createPtrToInt(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreatePtrToInt (opValue.getLlvmValue (), type->getLlvmType (), "ptr2int");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreatePtrToInt(opValue.getLlvmValue(), type->getLlvmType(), "ptr2int");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createTrunc_i (
[+] 	createTrunc_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateTrunc (opValue.getLlvmValue (), type->getLlvmType (), "trunc_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateTrunc(opValue.getLlvmValue(), type->getLlvmType(), "trunc_i");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createTrunc_f (
[+] 	createTrunc_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPTrunc (opValue.getLlvmValue (), type->getLlvmType (), "trunc_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPTrunc(opValue.getLlvmValue(), type->getLlvmType(), "trunc_f");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createExt_i (
[+] 	createExt_i(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateSExt (opValue.getLlvmValue (), type->getLlvmType (), "ext_i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateSExt(opValue.getLlvmValue(), type->getLlvmType(), "ext_i");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createExt_u (
[+] 	createExt_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateZExt (opValue.getLlvmValue (), type->getLlvmType (), "ext_u");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateZExt(opValue.getLlvmValue(), type->getLlvmType(), "ext_u");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createExt_f (
[+] 	createExt_f(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPExt (opValue.getLlvmValue (), type->getLlvmType (), "ext_f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPExt(opValue.getLlvmValue(), type->getLlvmType(), "ext_f");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createIntToFp (
[+] 	createIntToFp(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateSIToFP (opValue.getLlvmValue (), type->getLlvmType (), "i2f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateSIToFP(opValue.getLlvmValue(), type->getLlvmType(), "i2f");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createIntToFp_u (
[+] 	createIntToFp_u(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateUIToFP (opValue.getLlvmValue (), type->getLlvmType (), "u2f");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateUIToFP(opValue.getLlvmValue(), type->getLlvmType(), "u2f");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createFpToInt (
[+] 	createFpToInt(
[-] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPToSI (opValue.getLlvmValue (), type->getLlvmType (), "f2i");
[+] 		llvm::Value* inst = m_llvmIrBuilder->CreateFPToSI(opValue.getLlvmValue(), type->getLlvmType(), "f2i");
[-] 		resultValue->setLlvmValue (inst, type);
[+] 		resultValue->setLlvmValue(inst, type);
[-] 	createCall (
[+] 	createCall(
[-] 	createCall (
[+] 	createCall(
[-] 	createCall (
[+] 	createCall(
[-] 		const sl::BoxList <Value>& argValueList,
[+] 		const sl::BoxList<Value>& argValueList,
[-] 	createCall (
[+] 	createCall(
[-] 		return createCall (
[+] 		return createCall(
[-] 			functionType->getCallConv (),
[+] 			functionType->getCallConv(),
[-] 			functionType->getReturnType (),
[+] 			functionType->getReturnType(),
[-] 	createCall (
[+] 	createCall(
[-] 		const sl::BoxList <Value>& argValueList,
[+] 		const sl::BoxList<Value>& argValueList,
[-] 		return createCall (
[+] 		return createCall(
[-] 			functionType->getCallConv (),
[+] 			functionType->getCallConv(),
[-] 			functionType->getReturnType (),
[+] 			functionType->getReturnType(),
[-] 	createCall (
[+] 	createCall(
[-] 		return createCall (calleeValue, functionType, NULL, 0, resultValue);
[+] 		return createCall(calleeValue, functionType, NULL, 0, resultValue);
[-] 	createCall (
[+] 	createCall(
[-] 		return createCall (calleeValue, functionType, &argValue, 1, resultValue);
[+] 		return createCall(calleeValue, functionType, &argValue, 1, resultValue);
[-] 	createCall2 (
[+] 	createCall2(
[-] 		Value argArray [] =
[+] 		Value argArray[] =
[-] 		return createCall (calleeValue, functionType, argArray, countof (argArray), resultValue);
[+] 		return createCall(calleeValue, functionType, argArray, countof(argArray), resultValue);
[-] 	createCall3 (
[+] 	createCall3(
[-] 		Value argArray [] =
[+] 		Value argArray[] =
[-] 		return createCall (calleeValue, functionType, argArray, countof (argArray), resultValue);
[+] 		return createCall(calleeValue, functionType, argArray, countof(argArray), resultValue);
[-] 	createCall4 (
[+] 	createCall4(
[-] 		Value argArray [] =
[+] 		Value argArray[] =
[-] 		return createCall (calleeValue, functionType, argArray, countof (argArray), resultValue);
[+] 		return createCall(calleeValue, functionType, argArray, countof(argArray), resultValue);
[-] 	createClosureFunctionPtr (
[+] 	createClosureFunctionPtr(
[-] 	createClosurePropertyPtr (
[+] 	createClosurePropertyPtr(
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_LlvmIrInsertPoint.h
----------------------
[-] 	LlvmIrInsertPoint ()
[+] 	LlvmIrInsertPoint()
[-] 		clear ();
[+] 		clear();
[-] 	LlvmIrInsertPoint (
[+] 	LlvmIrInsertPoint(
[-] 		setup (llvmBlock, llvmInstruction);
[+] 		setup(llvmBlock, llvmInstruction);
[-] 	operator bool () const
[+] 	operator bool() const
[-] 		return !isEmpty ();
[+] 		return !isEmpty();
[-] 		return isEqual (insertPoint);
[+] 		return isEqual(insertPoint);
[-] 		return !isEqual (insertPoint);
[+] 		return !isEqual(insertPoint);
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	isEqual (const LlvmIrInsertPoint& insertPoint) const
[+] 	isEqual(const LlvmIrInsertPoint& insertPoint) const
[-] 	clear ()
[+] 	clear()
[-] 		setup (NULL, NULL);
[+] 		setup(NULL, NULL);
[-] 	setup (
[+] 	setup(
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_Module.h
----------------------
[-] 	PreModule ()
[+] 	PreModule()
[-] 		Module* prevModule = sys::setTlsPtrSlotValue <Module> ((Module*) this);
[+] 		Module* prevModule = sys::setTlsPtrSlotValue<Module> ((Module*)this);
[-] 		ASSERT (prevModule == NULL);
[+] 		ASSERT(prevModule == NULL);
[-] 	getCurrentConstructedModule ()
[+] 	getCurrentConstructedModule()
[-] 		return sys::getTlsPtrSlotValue <Module> ();
[+] 		return sys::getTlsPtrSlotValue<Module> ();
[-] 	finalizeConstruction ()
[+] 	finalizeConstruction()
[-] 		sys::setTlsPtrSlotValue <Module> (NULL);
[+] 		sys::setTlsPtrSlotValue<Module> (NULL);
[-] 	sl::Array <ModuleItem*> m_calcLayoutArray;
[+] 	sl::Array<ModuleItem*> m_calcLayoutArray;
[-] 	sl::Array <ModuleItem*> m_compileArray;
[+] 	sl::Array<ModuleItem*> m_compileArray;
[-] 	sl::BoxList <sl::String> m_sourceList; // need to keep all sources in-memory during compilation
[+] 	sl::BoxList<sl::String> m_sourceList; // need to keep all sources in-memory during compilation
[-] 	sl::StringHashTable <bool> m_filePathSet;
[+] 	sl::StringHashTable<bool> m_filePathSet;
[-] 	sl::StringHashTable <void*> m_functionMap;
[+] 	sl::StringHashTable<void*> m_functionMap;
[-] 	Module ();
[+] 	Module();
[-] 	~Module ()
[+] 	~Module()
[-] 		clear ();
[+] 		clear();
[-] 	getName ()
[+] 	getName()
[-] 	getCompileFlags ()
[+] 	getCompileFlags()
[-] 	getCompileState ()
[+] 	getCompileState()
[-] 	getLlvmContext ()
[+] 	getLlvmContext()
[-] 		ASSERT (m_llvmModule);
[+] 		ASSERT(m_llvmModule);
[-] 		return &m_llvmModule->getContext ();
[+] 		return &m_llvmModule->getContext();
[-] 	getLlvmModule ()
[+] 	getLlvmModule()
[-] 		ASSERT (m_llvmModule);
[+] 		ASSERT(m_llvmModule);
[-] 	getLlvmExecutionEngine ()
[+] 	getLlvmExecutionEngine()
[-] 		ASSERT (m_llvmExecutionEngine);
[+] 		ASSERT(m_llvmExecutionEngine);
[-] 	getConstructor ()
[+] 	getConstructor()
[-] 	getDestructor ()
[+] 	getDestructor()
[-] 	setFunctionPointer (
[+] 	setFunctionPointer(
[-] 		llvmExecutionEngine->addGlobalMapping (function->getLlvmFunction (), p);
[+] 		llvmExecutionEngine->addGlobalMapping(function->getLlvmFunction(), p);
[-] 	setFunctionPointer (
[+] 	setFunctionPointer(
[-] 		setFunctionPointer (llvmExecutionEngine, m_functionMgr.getStdFunction (funcKind), p);
[+] 		setFunctionPointer(llvmExecutionEngine, m_functionMgr.getStdFunction(funcKind), p);
[-] 	setFunctionPointer (
[+] 	setFunctionPointer(
[-] 	setFunctionPointer (
[+] 	setFunctionPointer(
[-] 	markForLayout (
[+] 	markForLayout(
[-] 	markForCompile (ModuleItem* item);
[+] 	markForCompile(ModuleItem* item);
[-] 	initialize (
[+] 	initialize(
[-] 	clear ();
[+] 	clear();
[-] 	parse (
[+] 	parse(
[-] 	parseFile (const sl::StringRef& fileName);
[+] 	parseFile(const sl::StringRef& fileName);
[-] 	parseImports ();
[+] 	parseImports();
[-] 	link ();
[+] 	link();
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	compile ();
[+] 	compile();
[-] 	jit ();
[+] 	jit();
[-] 	postParseStdItem ();
[+] 	postParseStdItem();
[-] 	mapVariable (
[+] 	mapVariable(
[-] 	mapFunction (
[+] 	mapFunction(
[-] 	findFunctionMapping (const sl::StringRef& name);
[+] 	findFunctionMapping(const sl::StringRef& name);
[-] 	getLlvmIrString ();
[+] 	getLlvmIrString();
[-] 	createLlvmExecutionEngine ();
[+] 	createLlvmExecutionEngine();
[-] 	createConstructorDestructor ();
[+] 	createConstructorDestructor();
[-] 	processCalcLayoutArray ();
[+] 	processCalcLayoutArray();
[-] 	processCompileArray ();
[+] 	processCompileArray();
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_ModuleItem.h
----------------------
[-] 	ModuleItemPos ()
[+] 	ModuleItemPos()
[-] 	getParentUnit () const
[+] 	getParentUnit() const
[-] 	getPos () const
[+] 	getPos() const
[-] 	sl::BoxList <Token> m_initializer;
[+] 	sl::BoxList<Token> m_initializer;
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getInitializer ()
[+] 	getInitializer()
[-] 	getInitializerString ();
[+] 	getInitializerString();
[-] 	ModuleItemDecl ();
[+] 	ModuleItemDecl();
[-] 	getStorageKind ()
[+] 	getStorageKind()
[-] 	getAccessKind ()
[+] 	getAccessKind()
[-] 	isNamed ()
[+] 	isNamed()
[-] 		return !m_name.isEmpty ();
[+] 		return !m_name.isEmpty();
[-] 	getName ()
[+] 	getName()
[-] 	getQualifiedName ()
[+] 	getQualifiedName()
[-] 	getParentNamespace ()
[+] 	getParentNamespace()
[-] 	getAttributeBlock ()
[+] 	getAttributeBlock()
[-] 	pushSrcPosError ();
[+] 	pushSrcPosError();
[-] 	getDoxyLocationString ();
[+] 	getDoxyLocationString();
[-] 	ModuleItem ();
[+] 	ModuleItem();
[-] 	getModule ()
[+] 	getModule()
[-] 	getItemKind ()
[+] 	getItemKind()
[-] 	getFlags ()
[+] 	getFlags()
[-] 	getDecl ();
[+] 	getDecl();
[-] 	getNamespace ();
[+] 	getNamespace();
[-] 	getType ();
[+] 	getType();
[-] 	ensureLayout ();
[+] 	ensureLayout();
[-] 	compile ()
[+] 	compile()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	createDoxyRefId ();
[+] 	createDoxyRefId();
[-] 	getDoxyBlock ();
[+] 	getDoxyBlock();
[-] 	setDoxyBlock (DoxyBlock* block);
[+] 	setDoxyBlock(DoxyBlock* block);
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	LazyModuleItem ()
[+] 	LazyModuleItem()
[-] 	getActualItem () = 0;
[+] 	getActualItem() = 0;
[-] verifyModuleItemKind (
[+] verifyModuleItemKind(
[-] verifyModuleItemIsType (
[+] verifyModuleItemIsType(
[-] 	return (Type*) verifyModuleItemKind (item, ModuleItemKind_Type, name);
[+] 	return (Type*)verifyModuleItemKind(item, ModuleItemKind_Type, name);
[-] verifyModuleItemIsDerivableType (
[+] verifyModuleItemIsDerivableType(
[-] verifyModuleItemIsClassType (
[+] verifyModuleItemIsClassType(
[-] verifyModuleItemIsVariable (
[+] verifyModuleItemIsVariable(
[-] 	return (Variable*) verifyModuleItemKind (item, ModuleItemKind_Variable, name);
[+] 	return (Variable*)verifyModuleItemKind(item, ModuleItemKind_Variable, name);
[-] verifyModuleItemIsFunction (
[+] verifyModuleItemIsFunction(
[-] 	return (Function*) verifyModuleItemKind (item, ModuleItemKind_Function, name);
[+] 	return (Function*)verifyModuleItemKind(item, ModuleItemKind_Function, name);
[-] verifyModuleItemIsProperty (
[+] verifyModuleItemIsProperty(
[-] 	return (Property*) verifyModuleItemKind (item, ModuleItemKind_Property, name);
[+] 	return (Property*)verifyModuleItemKind(item, ModuleItemKind_Property, name);
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_RegexMgr.h
----------------------
[-] 	sl::Array <size_t> m_openArray;
[+] 	sl::Array<size_t> m_openArray;
[-] 	sl::Array <size_t> m_closeArray;
[+] 	sl::Array<size_t> m_closeArray;
[-] 	sl::Array <uintptr_t> m_transitionTable;
[+] 	sl::Array<uintptr_t> m_transitionTable;
[-] 	sl::Array <DfaStateInfo> m_stateInfoTable;
[+] 	sl::Array<DfaStateInfo> m_stateInfoTable;
[-] 	sl::List <DfaAcceptInfo> m_acceptInfoList;
[+] 	sl::List<DfaAcceptInfo> m_acceptInfoList;
[-] 	sl::List <DfaGroupSet> m_groupSetList;
[+] 	sl::List<DfaGroupSet> m_groupSetList;
[-] 	Dfa ();
[+] 	Dfa();
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 	getGroupCount ()
[+] 	getGroupCount()
[-] 	getMaxSubMatchCount ()
[+] 	getMaxSubMatchCount()
[-] 	clear ();
[+] 	clear();
[-] 	build (fsm::Regex* regex);
[+] 	build(fsm::Regex* regex);
[-] 	getTransition (
[+] 	getTransition(
[-] 		ASSERT (stateId < m_stateCount);
[+] 		ASSERT(stateId < m_stateCount);
[-] 		return m_transitionTable [stateId * 256 + c];
[+] 		return m_transitionTable[stateId * 256 + c];
[-] 	getStateInfo (uintptr_t stateId)
[+] 	getStateInfo(uintptr_t stateId)
[-] 		return &m_stateInfoTable [stateId];
[+] 		return &m_stateInfoTable[stateId];
[-] 	sl::List <Dfa> m_dfaList;
[+] 	sl::List<Dfa> m_dfaList;
[-] 	RegexMgr ();
[+] 	RegexMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ()
[+] 	clear()
[-] 		m_dfaList.clear ();
[+] 		m_dfaList.clear();
[-] 	createDfa ();
[+] 	createDfa();
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Module\jnc_ct_UnitMgr.h
----------------------
[-] 	Unit ();
[+] 	Unit();
[-] 	getModule () const
[+] 	getModule() const
[-] 	getLib () const
[+] 	getLib() const
[-] 	getFilePath () const
[+] 	getFilePath() const
[-] 	getFileName () const
[+] 	getFileName() const
[-] 	getDir () const
[+] 	getDir() const
[-] 	getLlvmDiFile () const
[+] 	getLlvmDiFile() const
[-] 	getConstructor () const
[+] 	getConstructor() const
[-] 	setConstructor (Function* function);
[+] 	setConstructor(Function* function);
[-] 	getDestructor () const
[+] 	getDestructor() const
[-] 	setDestructor (Function* function);
[+] 	setDestructor(Function* function);
[-] 	sl::List <Unit> m_unitList;
[+] 	sl::List<Unit> m_unitList;
[-] 	UnitMgr ();
[+] 	UnitMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	sl::ConstList <Unit>
[+] 	sl::ConstList<Unit>
[-] 	getUnitList ()
[+] 	getUnitList()
[-] 	getCurrentUnit ()
[+] 	getCurrentUnit()
[-] 	setCurrentUnit (Unit* unit);
[+] 	setCurrentUnit(Unit* unit);
[-] 	getCoreLibUnit ();
[+] 	getCoreLibUnit();
[-] 	createUnit (
[+] 	createUnit(
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Alias.cpp
----------------------
[-] Alias::Alias ()
[+] Alias::Alias()
[-] Alias::calcLayout ()
[+] Alias::calcLayout()
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	result = parser.parseTokenList (SymbolKind_qualified_name_save_name, m_initializer);
[+] 	result = parser.parseTokenList(SymbolKind_qualified_name_save_name, m_initializer);
[-] 	m_targetItem = m_parentNamespace->findItemTraverse (parser.m_qualifiedName);
[+] 	m_targetItem = m_parentNamespace->findItemTraverse(parser.m_qualifiedName);
[-] 		err::setFormatStringError ("name '%s' is not found", parser.m_qualifiedName.getFullName ().sz ());
[+] 		err::setFormatStringError("name '%s' is not found", parser.m_qualifiedName.getFullName ().sz ());
[-] 	if (m_targetItem->getItemKind () == ModuleItemKind_Alias)
[+] 	if (m_targetItem->getItemKind() == ModuleItemKind_Alias)
[-] 		result = m_targetItem->ensureLayout ();
[+] 		result = m_targetItem->ensureLayout();
[-] 		m_targetItem = ((Alias*) m_targetItem)->getTargetItem ();
[+] 		m_targetItem = ((Alias*)m_targetItem)->getTargetItem();
[-] 		ASSERT (m_targetItem->getItemKind () != ModuleItemKind_Alias);
[+] 		ASSERT(m_targetItem->getItemKind() != ModuleItemKind_Alias);
[-] 	m_parentNamespace->replaceItem (m_name, m_targetItem);
[+] 	m_parentNamespace->replaceItem(m_name, m_targetItem);
[-] Alias::generateDocumentation (
[+] Alias::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	itemXml->format ("<memberdef kind='alias' id='%s'", doxyBlock->getRefId ().sz ());
[+] 	itemXml->format("<memberdef kind='alias' id='%s'", doxyBlock->getRefId ().sz ());
[-] 		itemXml->appendFormat (" prot='%s'", getAccessKindString (m_accessKind));
[+] 		itemXml->appendFormat(" prot='%s'", getAccessKindString (m_accessKind));
[-] 	itemXml->appendFormat (">\n<name>%s</name>\n", m_name.sz ());
[+] 	itemXml->appendFormat(">\n<name>%s</name>\n", m_name.sz ());
[-] 	itemXml->appendFormat (
[+] 	itemXml->appendFormat(
[-] 		getInitializerString ().sz ()
[+] 		getInitializerString().sz()
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
----------------------
27/02/2019 18:02:10 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Namespace.cpp
----------------------
[-] Namespace::clear ()
[+] Namespace::clear()
[-] 	m_itemArray.clear ();
[+] 	m_itemArray.clear();
[-] 	m_itemMap.clear ();
[+] 	m_itemMap.clear();
[-] 	m_friendSet.clear ();
[+] 	m_friendSet.clear();
[-] 	m_dualPtrTypeTupleMap.clear ();
[+] 	m_dualPtrTypeTupleMap.clear();
[-] 	m_usingSet.clear ();
[+] 	m_usingSet.clear();
[-] Namespace::createQualifiedName (const sl::StringRef& name)
[+] Namespace::createQualifiedName(const sl::StringRef& name)
[-] 	if (m_qualifiedName.isEmpty ())
[+] 	if (m_qualifiedName.isEmpty())
[-] 	if (!name.isEmpty ())
[+] 	if (!name.isEmpty())
[-] 		qualifiedName.append ('.');
[+] 		qualifiedName.append('.');
[-] 		qualifiedName.append (name);
[+] 		qualifiedName.append(name);
[-] Namespace::findItemByName (const sl::StringRef& name)
[+] Namespace::findItemByName(const sl::StringRef& name)
[-] 	if (name.find ('.') == -1)
[+] 	if (name.find('.') == -1)
[-] 		return findItem (name);
[+] 		return findItem(name);
[-] 	qualifiedName.parse (name);
[+] 	qualifiedName.parse(name);
[-] 	return findItem (qualifiedName);
[+] 	return findItem(qualifiedName);
[-] Namespace::getItemByName (const sl::StringRef& name)
[+] Namespace::getItemByName(const sl::StringRef& name)
[-] 	ModuleItem* item = findItemByName (name);
[+] 	ModuleItem* item = findItemByName(name);
[-] 		err::setFormatStringError ("'%s' not found", name.sz ());
[+] 		err::setFormatStringError("'%s' not found", name.sz ());
[-] Namespace::findItem (const sl::StringRef& name)
[+] Namespace::findItem(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <ModuleItem*> it = m_itemMap.find (name);
[+] 	sl::StringHashTableIterator<ModuleItem*> it = m_itemMap.find(name);
[-] 	if (!item || item->getItemKind () != ModuleItemKind_Lazy)
[+] 	if (!item || item->getItemKind() != ModuleItemKind_Lazy)
[-] 	LazyModuleItem* lazyItem = (LazyModuleItem*) item;
[+] 	LazyModuleItem* lazyItem = (LazyModuleItem*)item;
[-] 	ASSERT (!(lazyItem->m_flags & LazyModuleItemFlag_Touched));
[+] 	ASSERT(!(lazyItem->m_flags & LazyModuleItemFlag_Touched));
[-] 	item = lazyItem->getActualItem ();
[+] 	item = lazyItem->getActualItem();
[-] 		m_itemArray.append (item);
[+] 		m_itemArray.append(item);
[-] 	ASSERT (it->m_value == item);
[+] 	ASSERT(it->m_value == item);
[-] Namespace::findItem (const QualifiedName& name)
[+] Namespace::findItem(const QualifiedName& name)
[-] 	ModuleItem* item = findItem (name.getFirstName ());
[+] 	ModuleItem* item = findItem(name.getFirstName());
[-] 	sl::ConstBoxIterator <sl::String> nameIt = name.getNameList ().getHead ();
[+] 	sl::ConstBoxIterator<sl::String> nameIt = name.getNameList().getHead();
[-] 		Namespace* nspace = item->getNamespace ();
[+] 		Namespace* nspace = item->getNamespace();
[-] 		item = nspace->findItem (*nameIt);
[+] 		item = nspace->findItem(*nameIt);
[-] Namespace::findItemTraverse (
[+] Namespace::findItemTraverse(
[-] 	ModuleItem* item = findItemTraverse (name.getFirstName (), coord, flags);
[+] 	ModuleItem* item = findItemTraverse(name.getFirstName(), coord, flags);
[-] 	sl::ConstBoxIterator <sl::String> nameIt = name.getNameList ().getHead ();
[+] 	sl::ConstBoxIterator<sl::String> nameIt = name.getNameList().getHead();
[-] 		Namespace* nspace = item->getNamespace ();
[+] 		Namespace* nspace = item->getNamespace();
[-] 		item = nspace->findItem (*nameIt);
[+] 		item = nspace->findItem(*nameIt);
[-] Namespace::findItemTraverseImpl (
[+] Namespace::findItemTraverseImpl(
[-] 		item = findItem (name);
[+] 		item = findItem(name);
[-] 		item = m_usingSet.findItem (name);
[+] 		item = m_usingSet.findItem(name);
[-] 		item = m_parentNamespace->findItemTraverse (name, coord, flags & ~TraverseKind_NoThis);
[+] 		item = m_parentNamespace->findItemTraverse(name, coord, flags & ~TraverseKind_NoThis);
[-] Namespace::addItem (
[+] Namespace::addItem(
[-] 	sl::StringHashTableIterator <ModuleItem*> it = m_itemMap.visit (name);
[+] 	sl::StringHashTableIterator<ModuleItem*> it = m_itemMap.visit(name);
[-] 		setRedefinitionError (name);
[+] 		setRedefinitionError(name);
[-] 	if (item->getItemKind () != ModuleItemKind_Lazy)
[+] 	if (item->getItemKind() != ModuleItemKind_Lazy)
[-] 		m_itemArray.append (item);
[+] 		m_itemArray.append(item);
[-] Namespace::addFunction (Function* function)
[+] Namespace::addFunction(Function* function)
[-] 	ModuleItem* oldItem = findItem (function->m_name);
[+] 	ModuleItem* oldItem = findItem(function->m_name);
[-] 		addItem (function);
[+] 		addItem(function);
[-] 	if (oldItem->getItemKind () != ModuleItemKind_Function)
[+] 	if (oldItem->getItemKind() != ModuleItemKind_Function)
[-] 		setRedefinitionError (function->m_name);
[+] 		setRedefinitionError(function->m_name);
[-] 	return ((Function*) oldItem)->addOverload (function);
[+] 	return ((Function*)oldItem)->addOverload(function);
[-] Namespace::createConst (
[+] Namespace::createConst(
[-] 	ASSERT (value.getValueKind () == ValueKind_Const && value.getType ());
[+] 	ASSERT(value.getValueKind() == ValueKind_Const && value.getType());
[-] 	Module* module = value.getType ()->getModule ();
[+] 	Module* module = value.getType()->getModule();
[-] 	sl::String qualifiedName = createQualifiedName (name);
[+] 	sl::String qualifiedName = createQualifiedName(name);
[-] 	Const* cnst = module->m_constMgr.createConst (name, qualifiedName, value);
[+] 	Const* cnst = module->m_constMgr.createConst(name, qualifiedName, value);
[-] 	bool result = addItem (cnst);
[+] 	bool result = addItem(cnst);
[-] Namespace::exposeEnumConsts (EnumType* type)
[+] Namespace::exposeEnumConsts(EnumType* type)
[-] 	sl::Array <EnumConst*> constArray = type->getConstArray ();
[+] 	sl::Array<EnumConst*> constArray = type->getConstArray();
[-] 	size_t count = constArray.getCount ();
[+] 	size_t count = constArray.getCount();
[-] 		EnumConst* enumConst = constArray [i];
[+] 		EnumConst* enumConst = constArray[i];
[-] 		result = addItem (enumConst);
[+] 		result = addItem(enumConst);
[-] Namespace::generateMemberDocumentation (
[+] Namespace::generateMemberDocumentation(
[-] 	static char compoundFileHdr [] =
[+] 	static char compoundFileHdr[] =
[-] 	static char compoundFileTerm [] = "</doxygen>\n";
[+] 	static char compoundFileTerm[] = "</doxygen>\n";
[-] 	itemXml->clear ();
[+] 	itemXml->clear();
[-] 	sl::Array <EnumType*> unnamedEnumTypeArray;
[+] 	sl::Array<EnumType*> unnamedEnumTypeArray;
[-] 	size_t count = m_itemArray.getCount ();
[+] 	size_t count = m_itemArray.getCount();
[-] 		ModuleItem* item = m_itemArray [i];
[+] 		ModuleItem* item = m_itemArray[i];
[-] 		ModuleItemDecl* decl = item->getDecl ();
[+] 		ModuleItemDecl* decl = item->getDecl();
[-] 		Unit* unit = decl->getParentUnit ();
[+] 		Unit* unit = decl->getParentUnit();
[-] 		if (!unit || unit->getLib ()) // don't document imported libraries
[+] 		if (!unit || unit->getLib()) // don't document imported libraries
[-] 		Namespace* itemNamespace = item->getNamespace ();
[+] 		Namespace* itemNamespace = item->getNamespace();
[-] 		if (item->getItemKind () == ModuleItemKind_EnumConst)
[+] 		if (item->getItemKind() == ModuleItemKind_EnumConst)
[-] 			EnumType* enumType = ((EnumConst*) item)->getParentEnumType ();
[+] 			EnumType* enumType = ((EnumConst*)item)->getParentEnumType();
[-] 				if (!enumType->getName ().isEmpty ()) // exposed enum, not unnamed
[+] 				if (!enumType->getName().isEmpty()) // exposed enum, not unnamed
[-] 				unnamedEnumTypeArray.append (enumType);
[+] 				unnamedEnumTypeArray.append(enumType);
[-] 					item = m_itemArray [i];
[+] 					item = m_itemArray[i];
[-] 					if (item->getItemKind () != ModuleItemKind_EnumConst ||
[+] 					if (item->getItemKind() != ModuleItemKind_EnumConst ||
[-] 						((EnumConst*) item)->getParentEnumType () != enumType)
[+] 						((EnumConst*)item)->getParentEnumType() != enumType)
[-] 		result = item->generateDocumentation (outputDir, &memberXml, indexXml);
[+] 		result = item->generateDocumentation(outputDir, &memberXml, indexXml);
[-] 		if (memberXml.isEmpty ())
[+] 		if (memberXml.isEmpty())
[-] 		DoxyBlock* doxyBlock = item->getDoxyBlock ();
[+] 		DoxyBlock* doxyBlock = item->getDoxyBlock();
[-] 		DoxyGroup* doxyGroup = doxyBlock->getGroup ();
[+] 		DoxyGroup* doxyGroup = doxyBlock->getGroup();
[-] 			doxyGroup->addItem (item);
[+] 			doxyGroup->addItem(item);
[-] 		ModuleItemKind itemKind = item->getItemKind ();
[+] 		ModuleItemKind itemKind = item->getItemKind();
[-] 			itemKind == ModuleItemKind_Type && ((Type*) item)->getTypeKind () != TypeKind_Enum;
[+] 			itemKind == ModuleItemKind_Type && ((Type*)item)->getTypeKind() != TypeKind_Enum;
[-] 			sectionDef.append (memberXml);
[+] 			sectionDef.append(memberXml);
[-] 			sectionDef.append ('\n');
[+] 			sectionDef.append('\n');
[-] 			sl::String refId = doxyBlock->getRefId ();
[+] 			sl::String refId = doxyBlock->getRefId();
[-] 			sl::String fileName = sl::String (outputDir) + "/" + refId + ".xml";
[+] 			sl::String fileName = sl::String(outputDir) + "/" + refId + ".xml";
[-] 				compoundFile.open (fileName, io::FileFlag_Clear) &&
[+] 				compoundFile.open(fileName, io::FileFlag_Clear) &&
[-] 				compoundFile.write (compoundFileHdr, lengthof (compoundFileHdr)) != -1 &&
[+] 				compoundFile.write(compoundFileHdr, lengthof(compoundFileHdr)) != -1 &&
[-] 				compoundFile.write (memberXml, memberXml.getLength ()) != -1 &&
[+] 				compoundFile.write(memberXml, memberXml.getLength()) != -1 &&
[-] 				compoundFile.write (compoundFileTerm, lengthof (compoundFileTerm)) != -1;
[+] 				compoundFile.write(compoundFileTerm, lengthof(compoundFileTerm)) != -1;
[-] 			itemXml->appendFormat ("<%s refid='%s'/>", elemName, refId.sz ());
[+] 			itemXml->appendFormat("<%s refid='%s'/>", elemName, refId.sz ());
[-] 			itemXml->append ('\n');
[+] 			itemXml->append('\n');
[-] 	count = unnamedEnumTypeArray.getCount ();
[+] 	count = unnamedEnumTypeArray.getCount();
[-] 		ModuleItem* item = unnamedEnumTypeArray [i];
[+] 		ModuleItem* item = unnamedEnumTypeArray[i];
[-] 		result = item->generateDocumentation (outputDir, &memberXml, indexXml);
[+] 		result = item->generateDocumentation(outputDir, &memberXml, indexXml);
[-] 		ASSERT (!memberXml.isEmpty ());
[+] 		ASSERT(!memberXml.isEmpty());
[-] 		sectionDef.append (memberXml);
[+] 		sectionDef.append(memberXml);
[-] 		sectionDef.append ('\n');
[+] 		sectionDef.append('\n');
[-] 	if (!sectionDef.isEmpty ())
[+] 	if (!sectionDef.isEmpty())
[-] 			itemXml->append (sectionDef);
[+] 			itemXml->append(sectionDef);
[-] 			itemXml->append ("<sectiondef>\n");
[+] 			itemXml->append("<sectiondef>\n");
[-] 			itemXml->append (sectionDef);
[+] 			itemXml->append(sectionDef);
[-] 			itemXml->append ("</sectiondef>\n");
[+] 			itemXml->append("</sectiondef>\n");
[-] GlobalNamespace::createDoxyRefId ()
[+] GlobalNamespace::createDoxyRefId()
[-] 	if (this == m_module->m_namespaceMgr.getGlobalNamespace ())
[+] 	if (this == m_module->m_namespaceMgr.getGlobalNamespace())
[-] 		refId.format ("namespace_%s", m_qualifiedName.sz ());
[+] 		refId.format("namespace_%s", m_qualifiedName.sz ());
[-] 		refId.makeLowerCase ();
[+] 		refId.makeLowerCase();
[-] 	return m_module->m_doxyMgr.adjustRefId (refId);
[+] 	return m_module->m_doxyMgr.adjustRefId(refId);
[-] GlobalNamespace::generateDocumentation (
[+] GlobalNamespace::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	if (this == m_module->m_namespaceMgr.getGlobalNamespace ())
[+] 	if (this == m_module->m_namespaceMgr.getGlobalNamespace())
[-] 		name = getQualifiedName ();
[+] 		name = getQualifiedName();
[-] 	indexXml->appendFormat (
[+] 	indexXml->appendFormat(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 	Namespace::generateMemberDocumentation (outputDir, &memberXml, indexXml, true);
[+] 	Namespace::generateMemberDocumentation(outputDir, &memberXml, indexXml, true);
[-] 	itemXml->append (memberXml);
[+] 	itemXml->append(memberXml);
[-] 	sl::String footnoteXml = doxyBlock->getFootnoteString ();
[+] 	sl::String footnoteXml = doxyBlock->getFootnoteString();
[-] 	if (!footnoteXml.isEmpty ())
[+] 	if (!footnoteXml.isEmpty())
[-] 		itemXml->append ("<sectiondef>\n");
[+] 		itemXml->append("<sectiondef>\n");
[-] 		itemXml->append (footnoteXml);
[+] 		itemXml->append(footnoteXml);
[-] 		itemXml->append ("</sectiondef>\n");
[+] 		itemXml->append("</sectiondef>\n");
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</compounddef>\n");
[+] 	itemXml->append("</compounddef>\n");
[-] ExtensionNamespace::addMethod (Function* function)
[+] ExtensionNamespace::addMethod(Function* function)
[-] 	if (function->isVirtual ())
[+] 	if (function->isVirtual())
[-] 		err::setFormatStringError ("invalid storage '%s' in type extension", getStorageKindString (function->getStorageKind ()));
[+] 		err::setFormatStringError("invalid storage '%s' in type extension", getStorageKindString (function->getStorageKind ()));
[-] 	if (function->getFunctionKind () != FunctionKind_Normal)
[+] 	if (function->getFunctionKind() != FunctionKind_Normal)
[-] 		err::setFormatStringError ("'%s' cannot be a part of type extension", getFunctionKindString (function->getFunctionKind ()));
[+] 		err::setFormatStringError("'%s' cannot be a part of type extension", getFunctionKindString (function->getFunctionKind ()));
[-] 	bool result = addItem (function);
[+] 	bool result = addItem(function);
[-] 	if (m_type->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 	if (m_type->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 		fixupMethod (function);
[+] 		fixupMethod(function);
[-] 		m_fixupMethodArray.append (function);
[+] 		m_fixupMethodArray.append(function);
[-] ExtensionNamespace::addProperty (Property* prop)
[+] ExtensionNamespace::addProperty(Property* prop)
[-] 	if (prop->isVirtual ())
[+] 	if (prop->isVirtual())
[-] 		err::setFormatStringError ("invalid storage '%s' in type extension", getStorageKindString (prop->m_storageKind));
[+] 		err::setFormatStringError("invalid storage '%s' in type extension", getStorageKindString (prop->m_storageKind));
[-] 	bool result = addItem (prop);
[+] 	bool result = addItem(prop);
[-] 	if (m_type->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 	if (m_type->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 		fixupProperty (prop);
[+] 		fixupProperty(prop);
[-] 		m_fixupPropertyArray.append (prop);
[+] 		m_fixupPropertyArray.append(prop);
[-] ExtensionNamespace::calcLayout ()
[+] ExtensionNamespace::calcLayout()
[-] 	if (!(m_type->getTypeKindFlags () & TypeKindFlag_Derivable))
[+] 	if (!(m_type->getTypeKindFlags() & TypeKindFlag_Derivable))
[-] 		err::setFormatStringError ("'%s' cannot have a type extension", m_type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' cannot have a type extension", m_type->getTypeString ().sz ());
[-] 	sl::String qualifiedName = ((DerivableType*) m_type)->createQualifiedName (m_name);
[+] 	sl::String qualifiedName = ((DerivableType*)m_type)->createQualifiedName(m_name);
[-] 	size_t count = m_fixupMethodArray.getCount ();
[+] 	size_t count = m_fixupMethodArray.getCount();
[-] 		fixupMethod (m_fixupMethodArray [i]);
[+] 		fixupMethod(m_fixupMethodArray[i]);
[-] 	count = m_fixupPropertyArray.getCount ();
[+] 	count = m_fixupPropertyArray.getCount();
[-] 		fixupProperty (m_fixupPropertyArray [i]);
[+] 		fixupProperty(m_fixupPropertyArray[i]);
[-] ExtensionNamespace::fixupMethod (Function* function)
[+] ExtensionNamespace::fixupMethod(Function* function)
[-] 	ASSERT (m_type->getTypeKindFlags () & TypeKindFlag_Derivable);
[+] 	ASSERT(m_type->getTypeKindFlags() & TypeKindFlag_Derivable);
[-] 	DerivableType* derivableType = (DerivableType*) m_type;
[+] 	DerivableType* derivableType = (DerivableType*)m_type;
[-] 		function->convertToMemberMethod (derivableType);
[+] 		function->convertToMemberMethod(derivableType);
[-] ExtensionNamespace::fixupProperty (Property* prop)
[+] ExtensionNamespace::fixupProperty(Property* prop)
[-] 	ASSERT (m_type->getTypeKindFlags () & TypeKindFlag_Derivable);
[+] 	ASSERT(m_type->getTypeKindFlags() & TypeKindFlag_Derivable);
[-] 	DerivableType* derivableType = (DerivableType*) m_type;
[+] 	DerivableType* derivableType = (DerivableType*)m_type;
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_NamespaceMgr.cpp
----------------------
[-] NamespaceMgr::NamespaceMgr ()
[+] NamespaceMgr::NamespaceMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 	sl::String jncName ("jnc");
[+] 	sl::String jncName("jnc");
[-] 	GlobalNamespace* global = &m_stdNamespaceArray [StdNamespace_Global];
[+] 	GlobalNamespace* global = &m_stdNamespaceArray[StdNamespace_Global];
[-] 	GlobalNamespace* jnc = &m_stdNamespaceArray [StdNamespace_Jnc];
[+] 	GlobalNamespace* jnc = &m_stdNamespaceArray[StdNamespace_Jnc];
[-] 	GlobalNamespace* internal = &m_stdNamespaceArray [StdNamespace_Internal];
[+] 	GlobalNamespace* internal = &m_stdNamespaceArray[StdNamespace_Internal];
[-] 	if (!(m_module->getCompileFlags () & ModuleCompileFlag_StdLibDoc))
[+] 	if (!(m_module->getCompileFlags() & ModuleCompileFlag_StdLibDoc))
[-] NamespaceMgr::clear ()
[+] NamespaceMgr::clear()
[-] 		m_stdNamespaceArray [i].clear ();
[+] 		m_stdNamespaceArray[i].clear();
[-] 	m_globalNamespaceList.clear ();
[+] 	m_globalNamespaceList.clear();
[-] 	m_extensionNamespaceList.clear ();
[+] 	m_extensionNamespaceList.clear();
[-] 	m_dynamicLibNamespaceList.clear ();
[+] 	m_dynamicLibNamespaceList.clear();
[-] 	m_scopeList.clear ();
[+] 	m_scopeList.clear();
[-] 	m_orphanList.clear ();
[+] 	m_orphanList.clear();
[-] 	m_aliasList.clear ();
[+] 	m_aliasList.clear();
[-] 	m_namespaceStack.clear ();
[+] 	m_namespaceStack.clear();
[-] 	m_currentNamespace = &m_stdNamespaceArray [StdNamespace_Global];
[+] 	m_currentNamespace = &m_stdNamespaceArray[StdNamespace_Global];
[-] 	m_staticObjectValue.clear ();
[+] 	m_staticObjectValue.clear();
[-] 	m_importUsingSetArray.clear ();
[+] 	m_importUsingSetArray.clear();
[-] NamespaceMgr::addStdItems ()
[+] NamespaceMgr::addStdItems()
[-] 	GlobalNamespace* global = &m_stdNamespaceArray [StdNamespace_Global];
[+] 	GlobalNamespace* global = &m_stdNamespaceArray[StdNamespace_Global];
[-] 	GlobalNamespace* jnc = &m_stdNamespaceArray [StdNamespace_Jnc];
[+] 	GlobalNamespace* jnc = &m_stdNamespaceArray[StdNamespace_Jnc];
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uint_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uint_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_intptr_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_intptr_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uintptr_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uintptr_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_size_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_size_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_int8_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_int8_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_utf8_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_utf8_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uint8_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uint8_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uchar_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uchar_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_byte_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_byte_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_int16_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_int16_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_utf16_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_utf16_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uint16_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uint16_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_ushort_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_ushort_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_word_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_word_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_int32_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_int32_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_utf32_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_utf32_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uint32_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uint32_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_dword_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_dword_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_int64_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_int64_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_uint64_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_uint64_t)) &&
[-] 		global->addItem (m_module->m_typeMgr.getStdTypedef (StdTypedef_qword_t)) &&
[+] 		global->addItem(m_module->m_typeMgr.getStdTypedef(StdTypedef_qword_t)) &&
[-] 		global->addItem (jnc) &&
[+] 		global->addItem(jnc) &&
[-] 		jnc->addItem ("Scheduler", m_module->m_typeMgr.getLazyStdType (StdType_Scheduler)) &&
[+] 		jnc->addItem("Scheduler", m_module->m_typeMgr.getLazyStdType (StdType_Scheduler)) &&
[-] 		jnc->addItem ("RegexMatch", m_module->m_typeMgr.getLazyStdType (StdType_RegexMatch)) &&
[+] 		jnc->addItem("RegexMatch", m_module->m_typeMgr.getLazyStdType (StdType_RegexMatch)) &&
[-] 		jnc->addItem ("RegexState", m_module->m_typeMgr.getLazyStdType (StdType_RegexState)) &&
[+] 		jnc->addItem("RegexState", m_module->m_typeMgr.getLazyStdType (StdType_RegexState)) &&
[-] 		jnc->addItem ("RegexDfa", m_module->m_typeMgr.getLazyStdType (StdType_RegexDfa)) &&
[+] 		jnc->addItem("RegexDfa", m_module->m_typeMgr.getLazyStdType (StdType_RegexDfa)) &&
[-] 		jnc->addItem ("Promise", m_module->m_typeMgr.getLazyStdType (StdType_Promise)) &&
[+] 		jnc->addItem("Promise", m_module->m_typeMgr.getLazyStdType (StdType_Promise)) &&
[-] 		jnc->addItem ("Promisifier", m_module->m_typeMgr.getLazyStdType (StdType_Promisifier)) &&
[+] 		jnc->addItem("Promisifier", m_module->m_typeMgr.getLazyStdType (StdType_Promisifier)) &&
[-] 		jnc->addItem ("DynamicLib", m_module->m_typeMgr.getLazyStdType (StdType_DynamicLib));
[+] 		jnc->addItem("DynamicLib", m_module->m_typeMgr.getLazyStdType (StdType_DynamicLib));
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] NamespaceMgr::createOrphan (
[+] NamespaceMgr::createOrphan(
[-] 	Orphan* orphan = AXL_MEM_NEW (Orphan);
[+] 	Orphan* orphan = AXL_MEM_NEW(Orphan);
[-] 	m_orphanList.insertTail (orphan);
[+] 	m_orphanList.insertTail(orphan);
[-] NamespaceMgr::resolveOrphans ()
[+] NamespaceMgr::resolveOrphans()
[-] 	sl::Iterator <Orphan> it = m_orphanList.getHead ();
[+] 	sl::Iterator<Orphan> it = m_orphanList.getHead();
[-] 		result = it->resolveOrphan ();
[+] 		result = it->resolveOrphan();
[-] NamespaceMgr::resolveImportUsingSets ()
[+] NamespaceMgr::resolveImportUsingSets()
[-] 	size_t count = m_importUsingSetArray.getCount ();
[+] 	size_t count = m_importUsingSetArray.getCount();
[-] 		UsingSet* usingSet = m_importUsingSetArray [i];
[+] 		UsingSet* usingSet = m_importUsingSetArray[i];
[-] 		result = usingSet->resolveImportNamespaces ();
[+] 		result = usingSet->resolveImportNamespaces();
[-] NamespaceMgr::createAlias (
[+] NamespaceMgr::createAlias(
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	Alias* alias = AXL_MEM_NEW (Alias);
[+] 	Alias* alias = AXL_MEM_NEW(Alias);
[-] 	sl::takeOver (&alias->m_initializer, initializer);
[+] 	sl::takeOver(&alias->m_initializer, initializer);
[-] 	m_aliasList.insertTail (alias);
[+] 	m_aliasList.insertTail(alias);
[-] 	m_module->markForLayout (alias);
[+] 	m_module->markForLayout(alias);
[-] NamespaceMgr::setSourcePos (const Token::Pos& pos)
[+] NamespaceMgr::setSourcePos(const Token::Pos& pos)
[-] 	if (!(m_module->getCompileFlags () & ModuleCompileFlag_DebugInfo) ||
[+] 	if (!(m_module->getCompileFlags() & ModuleCompileFlag_DebugInfo) ||
[-] 	llvm::DebugLoc llvmDebugLoc = m_module->m_llvmDiBuilder.getDebugLoc (m_currentScope, pos);
[+] 	llvm::DebugLoc llvmDebugLoc = m_module->m_llvmDiBuilder.getDebugLoc(m_currentScope, pos);
[-] 	m_module->m_llvmIrBuilder.setCurrentDebugLoc (llvmDebugLoc);
[+] 	m_module->m_llvmIrBuilder.setCurrentDebugLoc(llvmDebugLoc);
[-] NamespaceMgr::openNamespace (Namespace* nspace)
[+] NamespaceMgr::openNamespace(Namespace* nspace)
[-] 	m_namespaceStack.append (entry);
[+] 	m_namespaceStack.append(entry);
[-] 		m_currentScope =  (Scope*) nspace;
[+] 		m_currentScope =  (Scope*)nspace;
[-] NamespaceMgr::closeNamespace ()
[+] NamespaceMgr::closeNamespace()
[-] 	if (m_namespaceStack.isEmpty ())
[+] 	if (m_namespaceStack.isEmpty())
[-] 	NamespaceStackEntry entry = m_namespaceStack.getBackAndPop ();
[+] 	NamespaceStackEntry entry = m_namespaceStack.getBackAndPop();
[-] 		m_currentNamespace->m_usingSet.clear ();
[+] 		m_currentNamespace->m_usingSet.clear();
[-] NamespaceMgr::openInternalScope ()
[+] NamespaceMgr::openInternalScope()
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function);
[+] 	ASSERT(function);
[-] 	Scope* scope = AXL_MEM_NEW (Scope);
[+] 	Scope* scope = AXL_MEM_NEW(Scope);
[-] 	m_module->m_llvmIrBuilder.saveInsertPoint (&scope->m_gcShadowStackFrameMapInsertPoint);
[+] 	m_module->m_llvmIrBuilder.saveInsertPoint(&scope->m_gcShadowStackFrameMapInsertPoint);
[-] 	m_scopeList.insertTail (scope);
[+] 	m_scopeList.insertTail(scope);
[-] 	openNamespace (scope);
[+] 	openNamespace(scope);
[-] NamespaceMgr::openScope (
[+] NamespaceMgr::openScope(
[-] 	Scope* scope = openInternalScope ();
[+] 	Scope* scope = openInternalScope();
[-] 	if (scope->m_parentNamespace == scope->m_function->getScope ())
[+] 	if (scope->m_parentNamespace == scope->m_function->getScope())
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_DebugInfo)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_DebugInfo)
[-] 		scope->m_llvmDiScope = (llvm::DIScope_vn) m_module->m_llvmDiBuilder.createLexicalBlock (parentScope, pos);
[+] 		scope->m_llvmDiScope = (llvm::DIScope_vn)m_module->m_llvmDiBuilder.createLexicalBlock(parentScope, pos);
[-] 	setSourcePos (pos);
[+] 	setSourcePos(pos);
[-] 		scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock ("dispose_block");
[+] 		scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock("dispose_block");
[-] 		m_module->m_controlFlowMgr.setJmpFinally (scope->m_finallyBlock, scope->m_sjljFrameIdx);
[+] 		m_module->m_controlFlowMgr.setJmpFinally(scope->m_finallyBlock, scope->m_sjljFrameIdx);
[-] 		Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
[+] 		Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int);
[-] 		scope->m_disposeLevelVariable = m_module->m_variableMgr.createSimpleStackVariable ("dispose_level", type);
[+] 		scope->m_disposeLevelVariable = m_module->m_variableMgr.createSimpleStackVariable("dispose_level", type);
[-] 		m_module->m_llvmIrBuilder.createStore (type->getZeroValue (), scope->m_disposeLevelVariable);
[+] 		m_module->m_llvmIrBuilder.createStore(type->getZeroValue(), scope->m_disposeLevelVariable);
[-] 		scope->m_catchBlock = m_module->m_controlFlowMgr.createBlock ("catch_block");
[+] 		scope->m_catchBlock = m_module->m_controlFlowMgr.createBlock("catch_block");
[-] 		m_module->m_controlFlowMgr.setJmp (scope->m_catchBlock, scope->m_sjljFrameIdx);
[+] 		m_module->m_controlFlowMgr.setJmp(scope->m_catchBlock, scope->m_sjljFrameIdx);
[-] 			scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock ("catch_finally_block");
[+] 			scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock("catch_finally_block");
[-] 		scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock ("finally_block");
[+] 		scope->m_finallyBlock = m_module->m_controlFlowMgr.createBlock("finally_block");
[-] 		m_module->m_controlFlowMgr.setJmpFinally (scope->m_finallyBlock, scope->m_sjljFrameIdx);
[+] 		m_module->m_controlFlowMgr.setJmpFinally(scope->m_finallyBlock, scope->m_sjljFrameIdx);
[-] 			err::setFormatStringError ("'nestedscope' can only be used before other scope labels");
[+] 			err::setFormatStringError("'nestedscope' can only be used before other scope labels");
[-] NamespaceMgr::closeScope ()
[+] NamespaceMgr::closeScope()
[-] 	ASSERT (m_currentScope);
[+] 	ASSERT(m_currentScope);
[-] 	m_module->m_gcShadowStackMgr.finalizeScope (m_currentScope);
[+] 	m_module->m_gcShadowStackMgr.finalizeScope(m_currentScope);
[-] 		m_module->m_controlFlowMgr.finalizeDisposableScope (m_currentScope);
[+] 		m_module->m_controlFlowMgr.finalizeDisposableScope(m_currentScope);
[-] 		m_module->m_controlFlowMgr.finalizeTryScope (m_currentScope);
[+] 		m_module->m_controlFlowMgr.finalizeTryScope(m_currentScope);
[-] 		m_module->m_controlFlowMgr.finalizeCatchScope (m_currentScope);
[+] 		m_module->m_controlFlowMgr.finalizeCatchScope(m_currentScope);
[-] 		m_module->m_controlFlowMgr.finalizeFinallyScope (m_currentScope);
[+] 		m_module->m_controlFlowMgr.finalizeFinallyScope(m_currentScope);
[-] 	closeNamespace ();
[+] 	closeNamespace();
[-] 		closeScope ();
[+] 		closeScope();
[-] NamespaceMgr::getAccessKind (Namespace* targetNamespace)
[+] NamespaceMgr::getAccessKind(Namespace* targetNamespace)
[-] 	if (!targetNamespace->isNamed ())
[+] 	if (!targetNamespace->isNamed())
[-] 			if (!nspace->isNamed ())
[+] 			if (!nspace->isNamed())
[-] 				targetNamespace->m_qualifiedName.cmp (nspace->m_qualifiedName) == 0 ||
[+] 				targetNamespace->m_qualifiedName.cmp(nspace->m_qualifiedName) == 0 ||
[-] 				targetNamespace->m_friendSet.find (nspace->m_qualifiedName))
[+] 				targetNamespace->m_friendSet.find(nspace->m_qualifiedName))
[-] 	NamedType* targetType = (NamedType*) targetNamespace;
[+] 	NamedType* targetType = (NamedType*)targetNamespace;
[-] 		if (!nspace->isNamed ())
[+] 		if (!nspace->isNamed())
[-] 			targetNamespace->m_qualifiedName.cmp (nspace->m_qualifiedName) == 0 ||
[+] 			targetNamespace->m_qualifiedName.cmp(nspace->m_qualifiedName) == 0 ||
[-] 			targetNamespace->m_friendSet.find (nspace->m_qualifiedName))
[+] 			targetNamespace->m_friendSet.find(nspace->m_qualifiedName))
[-] 			NamedType* type = (NamedType*) nspace;
[+] 			NamedType* type = (NamedType*)nspace;
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 				bool result = ((DerivableType*) type)->findBaseTypeTraverse (targetType);
[+] 				bool result = ((DerivableType*)type)->findBaseTypeTraverse(targetType);
[-] NamespaceMgr::createGlobalNamespace (
[+] NamespaceMgr::createGlobalNamespace(
[-] 		parentNamespace = &m_stdNamespaceArray [StdNamespace_Global];
[+] 		parentNamespace = &m_stdNamespaceArray[StdNamespace_Global];
[-] 	sl::String qualifiedName = parentNamespace->createQualifiedName (name);
[+] 	sl::String qualifiedName = parentNamespace->createQualifiedName(name);
[-] 	GlobalNamespace* nspace = AXL_MEM_NEW (GlobalNamespace);
[+] 	GlobalNamespace* nspace = AXL_MEM_NEW(GlobalNamespace);
[-] 	m_globalNamespaceList.insertTail (nspace);
[+] 	m_globalNamespaceList.insertTail(nspace);
[-] NamespaceMgr::createExtensionNamespace (
[+] NamespaceMgr::createExtensionNamespace(
[-] 		parentNamespace = &m_stdNamespaceArray [StdNamespace_Global];
[+] 		parentNamespace = &m_stdNamespaceArray[StdNamespace_Global];
[-] 	ExtensionNamespace* nspace = AXL_MEM_NEW (ExtensionNamespace);
[+] 	ExtensionNamespace* nspace = AXL_MEM_NEW(ExtensionNamespace);
[-] 	nspace->m_type = (DerivableType*) type; // force-cast
[+] 	nspace->m_type = (DerivableType*)type; // force-cast
[-] 	m_extensionNamespaceList.insertTail (nspace);
[+] 	m_extensionNamespaceList.insertTail(nspace);
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup (&nspace->m_type);
[+] 		((ImportType*)type)->addFixup(&nspace->m_type);
[-] 		m_module->markForLayout (nspace, true);
[+] 		m_module->markForLayout(nspace, true);
[-] 		bool result = nspace->ensureLayout ();
[+] 		bool result = nspace->ensureLayout();
[-] NamespaceMgr::createDynamicLibNamespace (ClassType* dynamicLibType)
[+] NamespaceMgr::createDynamicLibNamespace(ClassType* dynamicLibType)
[-] 	sl::String qualifiedName = dynamicLibType->getQualifiedName () + "." + name;
[+] 	sl::String qualifiedName = dynamicLibType->getQualifiedName() + "." + name;
[-] 	DynamicLibNamespace* nspace = AXL_MEM_NEW (DynamicLibNamespace);
[+] 	DynamicLibNamespace* nspace = AXL_MEM_NEW(DynamicLibNamespace);
[-] 	m_dynamicLibNamespaceList.insertTail (nspace);
[+] 	m_dynamicLibNamespaceList.insertTail(nspace);
[-] NamespaceMgr::findBreakScope (size_t level)
[+] NamespaceMgr::findBreakScope(size_t level)
[-] 	for (; scope; scope = scope->getParentScope ())
[+] 	for (; scope; scope = scope->getParentScope())
[-] NamespaceMgr::findContinueScope (size_t level)
[+] NamespaceMgr::findContinueScope(size_t level)
[-] 	for (; scope; scope = scope->getParentScope ())
[+] 	for (; scope; scope = scope->getParentScope())
[-] NamespaceMgr::findCatchScope ()
[+] NamespaceMgr::findCatchScope()
[-] 	for (; scope; scope = scope->getParentScope ())
[+] 	for (; scope; scope = scope->getParentScope())
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Orphan.cpp
----------------------
[-] Orphan::Orphan ()
[+] Orphan::Orphan()
[-] Orphan::setBody (sl::BoxList <Token>* tokenList)
[+] Orphan::setBody(sl::BoxList<Token>* tokenList)
[-] 	if (!m_body.isEmpty ())
[+] 	if (!m_body.isEmpty())
[-] 		err::setFormatStringError ("'%s' already has a body", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' already has a body", m_tag.sz ());
[-] 	sl::takeOver (&m_body, tokenList);
[+] 	sl::takeOver(&m_body, tokenList);
[-] Orphan::addUsingSet (Namespace* anchorNamespace)
[+] Orphan::addUsingSet(Namespace* anchorNamespace)
[-] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState () < ModuleCompileState_Linked ?
[+] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState() < ModuleCompileState_Linked ?
[-] 	for (Namespace* nspace = anchorNamespace; nspace; nspace = nspace->getParentNamespace ())
[+] 	for (Namespace* nspace = anchorNamespace; nspace; nspace = nspace->getParentNamespace())
[-] 		m_usingSet.append (importNamespaceMgr, nspace->getUsingSet ());
[+] 		m_usingSet.append(importNamespaceMgr, nspace->getUsingSet());
[-] Orphan::resolveOrphan ()
[+] Orphan::resolveOrphan()
[-] 	ModuleItem* item = m_parentNamespace->findItemTraverse (m_declaratorName);
[+] 	ModuleItem* item = m_parentNamespace->findItemTraverse(m_declaratorName);
[-] 		err::setFormatStringError ("unresolved orphan '%s'", m_tag.sz ());
[+] 		err::setFormatStringError("unresolved orphan '%s'", m_tag.sz ());
[-] 	switch (m_orphanKind)
[+] 	switch(m_orphanKind)
[-] 		return adoptOrphanFunction (item);
[+] 		return adoptOrphanFunction(item);
[-] 		return adoptOrphanReactor (item);
[+] 		return adoptOrphanReactor(item);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Orphan::getItemUnnamedMethod (ModuleItem* item)
[+] Orphan::getItemUnnamedMethod(ModuleItem* item)
[-] 	if (item->getItemKind () == ModuleItemKind_Property)
[+] 	if (item->getItemKind() == ModuleItemKind_Property)
[-] 		Property* prop = (Property*) item;
[+] 		Property* prop = (Property*)item;
[-] 		switch (m_functionKind)
[+] 		switch(m_functionKind)
[-] 			return prop->getConstructor ();
[+] 			return prop->getConstructor();
[-] 			return prop->getStaticConstructor ();
[+] 			return prop->getStaticConstructor();
[-] 			return prop->getDestructor ();
[+] 			return prop->getDestructor();
[-] 			return prop->getGetter ();
[+] 			return prop->getGetter();
[-] 			return prop->getSetter ();
[+] 			return prop->getSetter();
[-] 		item->getItemKind () == ModuleItemKind_Type &&
[+] 		item->getItemKind() == ModuleItemKind_Type &&
[-] 		(((Type*) item)->getTypeKindFlags () & TypeKindFlag_Derivable))
[+] 		(((Type*)item)->getTypeKindFlags() & TypeKindFlag_Derivable))
[-] 		DerivableType* type = (DerivableType*) item;
[+] 		DerivableType* type = (DerivableType*)item;
[-] 		switch (m_functionKind)
[+] 		switch(m_functionKind)
[-] 			return type->getPreConstructor ();
[+] 			return type->getPreConstructor();
[-] 			return type->getConstructor ();
[+] 			return type->getConstructor();
[-] 			return type->getStaticConstructor ();
[+] 			return type->getStaticConstructor();
[-] 			return type->getTypeKind () == TypeKind_Class ? ((ClassType*) type)->getDestructor () : NULL;
[+] 			return type->getTypeKind() == TypeKind_Class ? ((ClassType*)type)->getDestructor() : NULL;
[-] 			return type->getUnaryOperator (m_unOpKind);
[+] 			return type->getUnaryOperator(m_unOpKind);
[-] 			return type->getBinaryOperator (m_binOpKind);
[+] 			return type->getBinaryOperator(m_binOpKind);
[-] 			return type->getCallOperator ();
[+] 			return type->getCallOperator();
[-] Orphan::adoptOrphanFunction (ModuleItem* item)
[+] Orphan::adoptOrphanFunction(ModuleItem* item)
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 			err::setFormatStringError ("'%s' is not a function", m_tag.sz ());
[+] 			err::setFormatStringError("'%s' is not a function", m_tag.sz ());
[-] 		originFunction = (Function*) item;
[+] 		originFunction = (Function*)item;
[-] 		originFunction = getItemUnnamedMethod (item);
[+] 		originFunction = getItemUnnamedMethod(item);
[-] 			err::setFormatStringError ("'%s' has no '%s'", item->m_tag.sz (), getFunctionKindString (m_functionKind));
[+] 			err::setFormatStringError("'%s' has no '%s'", item->m_tag.sz (), getFunctionKindString (m_functionKind));
[-] 		m_functionType->ensureLayout () &&
[+] 		m_functionType->ensureLayout() &&
[-] 		originFunction->getTypeOverload ()->ensureLayout ();
[+] 		originFunction->getTypeOverload()->ensureLayout();
[-] 	originFunction = originFunction->findShortOverload (m_functionType);
[+] 	originFunction = originFunction->findShortOverload(m_functionType);
[-] 		err::setFormatStringError ("'%s': overload not found", m_tag.sz ());
[+] 		err::setFormatStringError("'%s': overload not found", m_tag.sz ());
[-] 		err::setFormatStringError ("'%s' is a compiler-generated function", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' is a compiler-generated function", m_tag.sz ());
[-] 	ASSERT (originFunction->m_functionKind == m_functionKind);
[+] 	ASSERT(originFunction->m_functionKind == m_functionKind);
[-] 	copySrcPos (originFunction);
[+] 	copySrcPos(originFunction);
[-] 	originFunction->addUsingSet (&m_usingSet);
[+] 	originFunction->addUsingSet(&m_usingSet);
[-] 		copyArgNames (originFunction->getType ()) &&
[+] 		copyArgNames(originFunction->getType()) &&
[-] 		originFunction->setBody (&m_body) &&
[+] 		originFunction->setBody(&m_body) &&
[-] 		verifyStorageKind (originFunction);
[+] 		verifyStorageKind(originFunction);
[-] Orphan::adoptOrphanReactor (ModuleItem* item)
[+] Orphan::adoptOrphanReactor(ModuleItem* item)
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		itemType = ((Variable*) item)->getType ();
[+] 		itemType = ((Variable*)item)->getType();
[-] 		itemType = ((StructField*) item)->getType ();
[+] 		itemType = ((StructField*)item)->getType();
[-] 	if (!itemType || !isClassType (itemType, ClassTypeKind_Reactor))
[+] 	if (!itemType || !isClassType(itemType, ClassTypeKind_Reactor))
[-] 		err::setFormatStringError ("'%s' is not a reactor", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' is not a reactor", m_tag.sz ());
[-] 	ReactorClassType* originType = (ReactorClassType*) itemType ;
[+] 	ReactorClassType* originType = (ReactorClassType*)itemType ;
[-] 	Function* originReaction = originType->getReaction ();
[+] 	Function* originReaction = originType->getReaction();
[-] 	copySrcPos (originType);
[+] 	copySrcPos(originType);
[-] 	copySrcPos (originReaction);
[+] 	copySrcPos(originReaction);
[-] 	originReaction->addUsingSet (&m_usingSet);
[+] 	originReaction->addUsingSet(&m_usingSet);
[-] 		originType->setBody (&m_body) &&
[+] 		originType->setBody(&m_body) &&
[-] 		verifyStorageKind (originReaction);
[+] 		verifyStorageKind(originReaction);
[-] Orphan::copyArgNames (FunctionType* targetFunctionType)
[+] Orphan::copyArgNames(FunctionType* targetFunctionType)
[-] 	sl::Array <FunctionArg*> dstArgArray = targetFunctionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> dstArgArray = targetFunctionType->getArgArray();
[-] 	sl::Array <FunctionArg*> srcArgArray = m_functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> srcArgArray = m_functionType->getArgArray();
[-] 	size_t argCount = dstArgArray.getCount ();
[+] 	size_t argCount = dstArgArray.getCount();
[-] 	if (targetFunctionType->isMemberMethodType ())
[+] 	if (targetFunctionType->isMemberMethodType())
[-] 		FunctionArg* dstArg = dstArgArray [iDst];
[+] 		FunctionArg* dstArg = dstArgArray[iDst];
[-] 		FunctionArg* srcArg = srcArgArray [iSrc];
[+] 		FunctionArg* srcArg = srcArgArray[iSrc];
[-] 		if (!srcArg->m_initializer.isEmpty ())
[+] 		if (!srcArg->m_initializer.isEmpty())
[-] 			err::setFormatStringError ("redefinition of default value for '%s'", srcArg->m_name.sz ());
[+] 			err::setFormatStringError("redefinition of default value for '%s'", srcArg->m_name.sz ());
[-] Orphan::verifyStorageKind (ModuleItemDecl* targetDecl)
[+] Orphan::verifyStorageKind(ModuleItemDecl* targetDecl)
[-] 	if (!m_storageKind || m_storageKind == targetDecl->getStorageKind ())
[+] 	if (!m_storageKind || m_storageKind == targetDecl->getStorageKind())
[-] 	err::setFormatStringError ("storage specifier mismatch for orphan '%s'", m_tag.sz ());
[+] 	err::setFormatStringError("storage specifier mismatch for orphan '%s'", m_tag.sz ());
[-] Orphan::copySrcPos (ModuleItemDecl* targetDecl)
[+] Orphan::copySrcPos(ModuleItemDecl* targetDecl)
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_QualifiedName.cpp
----------------------
[-] QualifiedName::addName (const sl::StringRef& name)
[+] QualifiedName::addName(const sl::StringRef& name)
[-] 	if (m_first.isEmpty ())
[+] 	if (m_first.isEmpty())
[-] 		m_list.insertTail (name);
[+] 		m_list.insertTail(name);
[-] QualifiedName::removeLastName ()
[+] QualifiedName::removeLastName()
[-] 	if (m_list.isEmpty ())
[+] 	if (m_list.isEmpty())
[-] 		m_first.clear ();
[+] 		m_first.clear();
[-] 		name = m_list.removeTail ();
[+] 		name = m_list.removeTail();
[-] QualifiedName::getFullName () const
[+] QualifiedName::getFullName() const
[-] 	if (m_list.isEmpty ())
[+] 	if (m_list.isEmpty())
[-] 	sl::ConstBoxIterator <sl::String> it = m_list.getHead ();
[+] 	sl::ConstBoxIterator<sl::String> it = m_list.getHead();
[-] 		name.append ('.');
[+] 		name.append('.');
[-] 		name.append (*it);
[+] 		name.append(*it);
[-] QualifiedName::parse (const sl::StringRef& name0)
[+] QualifiedName::parse(const sl::StringRef& name0)
[-] 	clear ();
[+] 	clear();
[-] 	const char* name = name0.sz ();
[+] 	const char* name = name0.sz();
[-] 		const char* dot = strchr (name, '.');
[+] 		const char* dot = strchr(name, '.');
[-] 			addName (name);
[+] 			addName(name);
[-] 		addName (sl::StringRef (name, dot - name));
[+] 		addName(sl::StringRef(name, dot - name));
[-] QualifiedName::copy (const QualifiedName& name)
[+] QualifiedName::copy(const QualifiedName& name)
[-] 	m_list.clear ();
[+] 	m_list.clear();
[-] 	sl::ConstBoxIterator <sl::String> it = name.m_list.getHead ();
[+] 	sl::ConstBoxIterator<sl::String> it = name.m_list.getHead();
[-] 		m_list.insertTail (*it);
[+] 		m_list.insertTail(*it);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Scope.cpp
----------------------
[-] Scope::Scope ()
[+] Scope::Scope()
[-] Scope::canStaticThrow ()
[+] Scope::canStaticThrow()
[-] 		(m_function->getType ()->getFlags () & FunctionTypeFlag_ErrorCode);
[+] 		(m_function->getType()->getFlags() & FunctionTypeFlag_ErrorCode);
[-] Scope::findGcShadowStackFrameMap ()
[+] Scope::findGcShadowStackFrameMap()
[-] 		Scope* scope = getParentScope ();
[+] 		Scope* scope = getParentScope();
[-] 		for (; scope; scope = scope->getParentScope ())
[+] 		for (; scope; scope = scope->getParentScope())
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_UsingSet.cpp
----------------------
[-] UsingSet::clear ()
[+] UsingSet::clear()
[-] 	m_globalNamespaceArray.clear ();
[+] 	m_globalNamespaceArray.clear();
[-] 	m_extensionNamespaceArray.clear ();
[+] 	m_extensionNamespaceArray.clear();
[-] 	m_importNamespaceList.clear ();
[+] 	m_importNamespaceList.clear();
[-] UsingSet::append (
[+] UsingSet::append(
[-] 	m_globalNamespaceArray.append (src->m_globalNamespaceArray);
[+] 	m_globalNamespaceArray.append(src->m_globalNamespaceArray);
[-] 	m_extensionNamespaceArray.append (src->m_extensionNamespaceArray);
[+] 	m_extensionNamespaceArray.append(src->m_extensionNamespaceArray);
[-] 	if (!src->m_importNamespaceList.isEmpty ())
[+] 	if (!src->m_importNamespaceList.isEmpty())
[-] 		ASSERT (importNamespaceMgr);
[+] 		ASSERT(importNamespaceMgr);
[-] 		if (m_importNamespaceList.isEmpty ())
[+] 		if (m_importNamespaceList.isEmpty())
[-] 			importNamespaceMgr->addImportUsingSet (this);
[+] 			importNamespaceMgr->addImportUsingSet(this);
[-] 		sl::ConstIterator <ImportNamespace> it = src->m_importNamespaceList.getHead ();
[+] 		sl::ConstIterator<ImportNamespace> it = src->m_importNamespaceList.getHead();
[-] 			ImportNamespace* importNamespace = AXL_MEM_NEW (ImportNamespace);
[+] 			ImportNamespace* importNamespace = AXL_MEM_NEW(ImportNamespace);
[-] 			m_importNamespaceList.insertTail (importNamespace);
[+] 			m_importNamespaceList.insertTail(importNamespace);
[-] ModuleItem* UsingSet::findItem (const sl::StringRef& name)
[+] ModuleItem* UsingSet::findItem(const sl::StringRef& name)
[-] 	size_t count = m_globalNamespaceArray.getCount ();
[+] 	size_t count = m_globalNamespaceArray.getCount();
[-] 		ModuleItem* item = m_globalNamespaceArray [i]->findItem (name);
[+] 		ModuleItem* item = m_globalNamespaceArray[i]->findItem(name);
[-] ModuleItem* UsingSet::findExtensionItem (
[+] ModuleItem* UsingSet::findExtensionItem(
[-] 	size_t count = m_extensionNamespaceArray.getCount ();
[+] 	size_t count = m_extensionNamespaceArray.getCount();
[-] 		ExtensionNamespace* nspace = m_extensionNamespaceArray [i];
[+] 		ExtensionNamespace* nspace = m_extensionNamespaceArray[i];
[-] 		if (nspace->getType ()->cmp (type) == 0)
[+] 		if (nspace->getType()->cmp(type) == 0)
[-] 			ModuleItem* item = nspace->findItem (name);
[+] 			ModuleItem* item = nspace->findItem(name);
[-] UsingSet::addNamespace (
[+] UsingSet::addNamespace(
[-] 	ModuleItem* item = anchorNamespace->findItemTraverse (name);
[+] 	ModuleItem* item = anchorNamespace->findItemTraverse(name);
[-] 			err::setFormatStringError ("undeclared identifier '%s'", name.getFullName ().sz ());
[+] 			err::setFormatStringError("undeclared identifier '%s'", name.getFullName ().sz ());
[-] 		if (m_importNamespaceList.isEmpty ())
[+] 		if (m_importNamespaceList.isEmpty())
[-] 			importNamespaceMgr->addImportUsingSet (this);
[+] 			importNamespaceMgr->addImportUsingSet(this);
[-] 		ImportNamespace* importNamespace = AXL_MEM_NEW (ImportNamespace);
[+] 		ImportNamespace* importNamespace = AXL_MEM_NEW(ImportNamespace);
[-] 		m_importNamespaceList.insertTail (importNamespace);
[+] 		m_importNamespaceList.insertTail(importNamespace);
[-] 	if (item->getItemKind () != ModuleItemKind_Namespace)
[+] 	if (item->getItemKind() != ModuleItemKind_Namespace)
[-] 		err::setFormatStringError ("'%s' is not a namespace", name.getFullName ().sz ());
[+] 		err::setFormatStringError("'%s' is not a namespace", name.getFullName ().sz ());
[-] 	GlobalNamespace* nspace = (GlobalNamespace*) item;
[+] 	GlobalNamespace* nspace = (GlobalNamespace*)item;
[-] 	if (nspace->getNamespaceKind () != namespaceKind)
[+] 	if (nspace->getNamespaceKind() != namespaceKind)
[-] 		err::setFormatStringError ("'%s' is not %s", name.getFullName ().sz (), getNamespaceKindString (namespaceKind));
[+] 		err::setFormatStringError("'%s' is not %s", name.getFullName ().sz (), getNamespaceKindString (namespaceKind));
[-] 	switch (namespaceKind)
[+] 	switch(namespaceKind)
[-] 		m_globalNamespaceArray.append (nspace);
[+] 		m_globalNamespaceArray.append(nspace);
[-] 		m_extensionNamespaceArray.append ((ExtensionNamespace*) nspace);
[+] 		m_extensionNamespaceArray.append((ExtensionNamespace*)nspace);
[-] 		err::setFormatStringError ("invalid using: %s", getNamespaceKindString (namespaceKind));
[+] 		err::setFormatStringError("invalid using: %s", getNamespaceKindString (namespaceKind));
[-] UsingSet::resolveImportNamespaces ()
[+] UsingSet::resolveImportNamespaces()
[-] 	while (!m_importNamespaceList.isEmpty ())
[+] 	while (!m_importNamespaceList.isEmpty())
[-] 		ImportNamespace* importNamespace = m_importNamespaceList.removeHead ();
[+] 		ImportNamespace* importNamespace = m_importNamespaceList.removeHead();
[-] 		addNamespace (
[+] 		addNamespace(
[-] 		AXL_MEM_DELETE (importNamespace);
[+] 		AXL_MEM_DELETE(importNamespace);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Alias.h
----------------------
[-] 	Alias ();
[+] 	Alias();
[-] 	getTargetItem ()
[+] 	getTargetItem()
[-] 		ASSERT (m_targetItem);
[+] 		ASSERT(m_targetItem);
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	calcLayout ();
[+] 	calcLayout();
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Namespace.h
----------------------
[-] 	sl::Array <ModuleItem*> m_itemArray;
[+] 	sl::Array<ModuleItem*> m_itemArray;
[-] 	sl::StringHashTable <ModuleItem*> m_itemMap;
[+] 	sl::StringHashTable<ModuleItem*> m_itemMap;
[-] 	sl::StringHashTable <bool> m_friendSet;
[+] 	sl::StringHashTable<bool> m_friendSet;
[-] 	sl::StringHashTable <DualPtrTypeTuple*> m_dualPtrTypeTupleMap;
[+] 	sl::StringHashTable<DualPtrTypeTuple*> m_dualPtrTypeTupleMap;
[-] 	Namespace ()
[+] 	Namespace()
[-] 	getNamespaceKind ()
[+] 	getNamespaceKind()
[-] 	getUsingSet ()
[+] 	getUsingSet()
[-] 	createQualifiedName (const sl::StringRef& name);
[+] 	createQualifiedName(const sl::StringRef& name);
[-] 	createQualifiedName (const QualifiedName& name)
[+] 	createQualifiedName(const QualifiedName& name)
[-] 		return createQualifiedName (name.getFullName ());
[+] 		return createQualifiedName(name.getFullName());
[-] 	isFriend (Namespace* nspace)
[+] 	isFriend(Namespace* nspace)
[-] 		return m_friendSet.find (nspace->m_qualifiedName) != NULL;
[+] 		return m_friendSet.find(nspace->m_qualifiedName) != NULL;
[-] 	findItemByName (const sl::StringRef& name);
[+] 	findItemByName(const sl::StringRef& name);
[-] 	getItemByName (const sl::StringRef& name);
[+] 	getItemByName(const sl::StringRef& name);
[-] 	findTypeByName (const sl::StringRef& name)
[+] 	findTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsType(item, name) : NULL;
[-] 	getTypeByName (const sl::StringRef& name)
[+] 	getTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsType(item, name) : NULL;
[-] 	findDerivableTypeByName (const sl::StringRef& name)
[+] 	findDerivableTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsDerivableType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsDerivableType(item, name) : NULL;
[-] 	getDerivableTypeByName (const sl::StringRef& name)
[+] 	getDerivableTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsDerivableType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsDerivableType(item, name) : NULL;
[-] 	findClassTypeByName (const sl::StringRef& name)
[+] 	findClassTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsClassType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsClassType(item, name) : NULL;
[-] 	getClassTypeByName (const sl::StringRef& name)
[+] 	getClassTypeByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsClassType (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsClassType(item, name) : NULL;
[-] 	findVariableByName (const sl::StringRef& name)
[+] 	findVariableByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsVariable (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsVariable(item, name) : NULL;
[-] 	getVariableByName (const sl::StringRef& name)
[+] 	getVariableByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsVariable (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsVariable(item, name) : NULL;
[-] 	findFunctionByName (const sl::StringRef& name)
[+] 	findFunctionByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsFunction (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsFunction(item, name) : NULL;
[-] 	getFunctionByName (const sl::StringRef& name)
[+] 	getFunctionByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsFunction (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsFunction(item, name) : NULL;
[-] 	findPropertyByName (const sl::StringRef& name)
[+] 	findPropertyByName(const sl::StringRef& name)
[-] 		ModuleItem* item = findItemByName (name);
[+] 		ModuleItem* item = findItemByName(name);
[-] 		return item ? verifyModuleItemIsProperty (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsProperty(item, name) : NULL;
[-] 	getPropertyByName (const sl::StringRef& name)
[+] 	getPropertyByName(const sl::StringRef& name)
[-] 		ModuleItem* item = getItemByName (name);
[+] 		ModuleItem* item = getItemByName(name);
[-] 		return item ? verifyModuleItemIsProperty (item, name) : NULL;
[+] 		return item ? verifyModuleItemIsProperty(item, name) : NULL;
[-] 	findItem (const sl::StringRef& name);
[+] 	findItem(const sl::StringRef& name);
[-] 	findItem (const QualifiedName& name);
[+] 	findItem(const QualifiedName& name);
[-] 	findItemTraverse (
[+] 	findItemTraverse(
[-] 		return findItemTraverseImpl (name, coord, flags);
[+] 		return findItemTraverseImpl(name, coord, flags);
[-] 	findItemTraverse (
[+] 	findItemTraverse(
[-] 	addItem (T* item)
[+] 	addItem(T* item)
[-] 		return addItem (item->m_name, item);
[+] 		return addItem(item->m_name, item);
[-] 	replaceItem (
[+] 	replaceItem(
[-] 		m_itemMap.visit (name)->m_value = item;
[+] 		m_itemMap.visit(name)->m_value = item;
[-] 	addFunction (Function* function); // returns overload idx or -1 on error
[+] 	addFunction(Function* function); // returns overload idx or -1 on error
[-] 	createConst (
[+] 	createConst(
[-] 	getItemCount ()
[+] 	getItemCount()
[-] 		return m_itemArray.getCount ();
[+] 		return m_itemArray.getCount();
[-] 	getItem (size_t index)
[+] 	getItem(size_t index)
[-] 		ASSERT (index < m_itemArray.getCount ());
[+] 		ASSERT(index < m_itemArray.getCount());
[-] 		return m_itemArray [index];
[+] 		return m_itemArray[index];
[-] 	exposeEnumConsts (EnumType* member);
[+] 	exposeEnumConsts(EnumType* member);
[-] 	clear ();
[+] 	clear();
[-] 	addItem (
[+] 	addItem(
[-] 	findItemTraverseImpl (
[+] 	findItemTraverseImpl(
[-] 	generateMemberDocumentation (
[+] 	generateMemberDocumentation(
[-] 	GlobalNamespace ()
[+] 	GlobalNamespace()
[-] 	createDoxyRefId ();
[+] 	createDoxyRefId();
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	sl::Array <Function*> m_fixupMethodArray;
[+] 	sl::Array<Function*> m_fixupMethodArray;
[-] 	sl::Array <Property*> m_fixupPropertyArray;
[+] 	sl::Array<Property*> m_fixupPropertyArray;
[-] 	ExtensionNamespace ()
[+] 	ExtensionNamespace()
[-] 	Type* getType ()
[+] 	Type* getType()
[-] 	addMethod (Function* function);
[+] 	addMethod(Function* function);
[-] 	addProperty (Property* prop);
[+] 	addProperty(Property* prop);
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	fixupMethod (Function* function);
[+] 	fixupMethod(Function* function);
[-] 	fixupProperty (Property* prop);
[+] 	fixupProperty(Property* prop);
[-] 	DynamicLibNamespace ()
[+] 	DynamicLibNamespace()
[-] 	ClassType* getLibraryType ()
[+] 	ClassType* getLibraryType()
[-] setRedefinitionError (const sl::StringRef& name)
[+] setRedefinitionError(const sl::StringRef& name)
[-] 	return err::setFormatStringError ("redefinition of '%s'", name.sz ());
[+] 	return err::setFormatStringError("redefinition of '%s'", name.sz ());
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_NamespaceMgr.h
----------------------
[-] 	GlobalNamespace m_stdNamespaceArray [StdNamespace__Count];
[+] 	GlobalNamespace m_stdNamespaceArray[StdNamespace__Count];
[-] 	sl::List <GlobalNamespace> m_globalNamespaceList;
[+] 	sl::List<GlobalNamespace> m_globalNamespaceList;
[-] 	sl::List <ExtensionNamespace> m_extensionNamespaceList;
[+] 	sl::List<ExtensionNamespace> m_extensionNamespaceList;
[-] 	sl::List <DynamicLibNamespace> m_dynamicLibNamespaceList;
[+] 	sl::List<DynamicLibNamespace> m_dynamicLibNamespaceList;
[-] 	sl::List <Scope> m_scopeList;
[+] 	sl::List<Scope> m_scopeList;
[-] 	sl::List <Orphan> m_orphanList;
[+] 	sl::List<Orphan> m_orphanList;
[-] 	sl::List <Alias> m_aliasList;
[+] 	sl::List<Alias> m_aliasList;
[-] 	sl::Array <NamespaceStackEntry> m_namespaceStack;
[+] 	sl::Array<NamespaceStackEntry> m_namespaceStack;
[-] 	sl::Array <UsingSet*> m_importUsingSetArray;
[+] 	sl::Array<UsingSet*> m_importUsingSetArray;
[-] 	NamespaceMgr ();
[+] 	NamespaceMgr();
[-] 	~NamespaceMgr ()
[+] 	~NamespaceMgr()
[-] 		clear ();
[+] 		clear();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	addStdItems ();
[+] 	addStdItems();
[-] 	createOrphan (
[+] 	createOrphan(
[-] 	resolveOrphans ();
[+] 	resolveOrphans();
[-] 	createAlias (
[+] 	createAlias(
[-] 		sl::BoxList <Token>* initializer
[+] 		sl::BoxList<Token>* initializer
[-] 	addImportUsingSet (UsingSet* usingSet)
[+] 	addImportUsingSet(UsingSet* usingSet)
[-] 		m_importUsingSetArray.append (usingSet);
[+] 		m_importUsingSetArray.append(usingSet);
[-] 	resolveImportUsingSets ();
[+] 	resolveImportUsingSets();
[-] 	lockSourcePos ()
[+] 	lockSourcePos()
[-] 	unlockSourcePos ()
[+] 	unlockSourcePos()
[-] 	setSourcePos (const Token::Pos& pos);
[+] 	setSourcePos(const Token::Pos& pos);
[-] 	getGlobalNamespace ()
[+] 	getGlobalNamespace()
[-] 		return &m_stdNamespaceArray [StdNamespace_Global];
[+] 		return &m_stdNamespaceArray[StdNamespace_Global];
[-] 	getStdNamespace (StdNamespace stdNamespace)
[+] 	getStdNamespace(StdNamespace stdNamespace)
[-] 		ASSERT (stdNamespace < StdNamespace__Count);
[+] 		ASSERT(stdNamespace < StdNamespace__Count);
[-] 		return &m_stdNamespaceArray [stdNamespace];
[+] 		return &m_stdNamespaceArray[stdNamespace];
[-] 	isGlobalNamespace ()
[+] 	isGlobalNamespace()
[-] 	getCurrentNamespace ()
[+] 	getCurrentNamespace()
[-] 	getCurrentScope ()
[+] 	getCurrentScope()
[-] 	getCurrentAccessKind ()
[+] 	getCurrentAccessKind()
[-] 	openNamespace (Namespace* nspace);
[+] 	openNamespace(Namespace* nspace);
[-] 	openStdNamespace (StdNamespace stdNamepace)
[+] 	openStdNamespace(StdNamespace stdNamepace)
[-] 		ASSERT (stdNamepace < StdNamespace__Count);
[+] 		ASSERT(stdNamepace < StdNamespace__Count);
[-] 		openNamespace (&m_stdNamespaceArray [stdNamepace]);
[+] 		openNamespace(&m_stdNamespaceArray[stdNamepace]);
[-] 	closeNamespace ();
[+] 	closeNamespace();
[-] 	openInternalScope ();
[+] 	openInternalScope();
[-] 	openScope (
[+] 	openScope(
[-] 	closeScope ();
[+] 	closeScope();
[-] 	getAccessKind (Namespace* nspace);
[+] 	getAccessKind(Namespace* nspace);
[-] 	createQualifiedName (const sl::StringRef& name)
[+] 	createQualifiedName(const sl::StringRef& name)
[-] 		return m_currentNamespace->createQualifiedName (name);
[+] 		return m_currentNamespace->createQualifiedName(name);
[-] 	createGlobalNamespace (
[+] 	createGlobalNamespace(
[-] 	createExtensionNamespace (
[+] 	createExtensionNamespace(
[-] 	createDynamicLibNamespace (ClassType* dynamicLibType);
[+] 	createDynamicLibNamespace(ClassType* dynamicLibType);
[-] 	findBreakScope (size_t level);
[+] 	findBreakScope(size_t level);
[-] 	findContinueScope (size_t level);
[+] 	findContinueScope(size_t level);
[-] 	findCatchScope ();
[+] 	findCatchScope();
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Orphan.h
----------------------
[-] 	sl::BoxList <Token> m_body;
[+] 	sl::BoxList<Token> m_body;
[-] 	Orphan ();
[+] 	Orphan();
[-] 	getOrphanKind ()
[+] 	getOrphanKind()
[-] 	getFunctionType ()
[+] 	getFunctionType()
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getBody ()
[+] 	getBody()
[-] 	setBody (sl::BoxList <Token>* tokenList);
[+] 	setBody(sl::BoxList<Token>* tokenList);
[-] 	addUsingSet (Namespace* anchorNamespace);
[+] 	addUsingSet(Namespace* anchorNamespace);
[-] 	resolveOrphan ();
[+] 	resolveOrphan();
[-] 	adoptOrphanFunction (ModuleItem* item);
[+] 	adoptOrphanFunction(ModuleItem* item);
[-] 	adoptOrphanReactor (ModuleItem* item);
[+] 	adoptOrphanReactor(ModuleItem* item);
[-] 	verifyStorageKind (ModuleItemDecl* targetDecl);
[+] 	verifyStorageKind(ModuleItemDecl* targetDecl);
[-] 	copySrcPos (ModuleItemDecl* targetDecl);
[+] 	copySrcPos(ModuleItemDecl* targetDecl);
[-] 	copyArgNames (FunctionType* targetFunctionType);
[+] 	copyArgNames(FunctionType* targetFunctionType);
[-] 	getItemUnnamedMethod (ModuleItem* item);
[+] 	getItemUnnamedMethod(ModuleItem* item);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_QualifiedName.h
----------------------
[-] 	sl::BoxList <sl::String> m_list;
[+] 	sl::BoxList<sl::String> m_list;
[-] 	QualifiedName ()
[+] 	QualifiedName()
[-] 	QualifiedName (const sl::StringRef& name)
[+] 	QualifiedName(const sl::StringRef& name)
[-] 	QualifiedName (const QualifiedName& name)
[+] 	QualifiedName(const QualifiedName& name)
[-] 		copy (name);
[+] 		copy(name);
[-] 		copy (name);
[+] 		copy(name);
[-] 	clear ()
[+] 	clear()
[-] 		m_first.clear ();
[+] 		m_first.clear();
[-] 		m_list.clear ();
[+] 		m_list.clear();
[-] 	parse (const sl::StringRef& name);
[+] 	parse(const sl::StringRef& name);
[-] 	addName (const sl::StringRef& name);
[+] 	addName(const sl::StringRef& name);
[-] 	removeLastName ();
[+] 	removeLastName();
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_first.isEmpty ();
[+] 		return m_first.isEmpty();
[-] 	isSimple () const
[+] 	isSimple() const
[-] 		return m_list.isEmpty ();
[+] 		return m_list.isEmpty();
[-] 	getFirstName () const
[+] 	getFirstName() const
[-] 	sl::ConstBoxList <sl::String>
[+] 	sl::ConstBoxList<sl::String>
[-] 	getNameList () const
[+] 	getNameList() const
[-] 	getShortName () const
[+] 	getShortName() const
[-] 		return !m_list.isEmpty () ? *m_list.getTail () : m_first;
[+] 		return !m_list.isEmpty() ? *m_list.getTail() : m_first;
[-] 	getFullName () const;
[+] 	getFullName() const;
[-] 	copy (const QualifiedName& name);
[+] 	copy(const QualifiedName& name);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_Scope.h
----------------------
[-] 	sl::Array <Variable*> m_disposableVariableArray;
[+] 	sl::Array<Variable*> m_disposableVariableArray;
[-] 	Scope ();
[+] 	Scope();
[-] 	getFunction ()
[+] 	getFunction()
[-] 	getParentScope ()
[+] 	getParentScope()
[-] 		return m_parentNamespace && m_parentNamespace->getNamespaceKind () == NamespaceKind_Scope ? (Scope*) m_parentNamespace : NULL;
[+] 		return m_parentNamespace && m_parentNamespace->getNamespaceKind() == NamespaceKind_Scope ? (Scope*)m_parentNamespace : NULL;
[-] 	findGcShadowStackFrameMap ();
[+] 	findGcShadowStackFrameMap();
[-] 	getDisposeLevelVariable ()
[+] 	getDisposeLevelVariable()
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getDisposableVariableArray ()
[+] 	getDisposableVariableArray()
[-] 	addDisposableVariable (Variable* variable)
[+] 	addDisposableVariable(Variable* variable)
[-] 		m_disposableVariableArray.append (variable);
[+] 		m_disposableVariableArray.append(variable);
[-] 		return m_disposableVariableArray.getCount ();
[+] 		return m_disposableVariableArray.getCount();
[-] 	getLlvmDiScope ()
[+] 	getLlvmDiScope()
[-] 	canStaticThrow ();
[+] 	canStaticThrow();
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_NamespaceMgr\jnc_ct_UsingSet.h
----------------------
[-] 	sl::Array <GlobalNamespace*> m_globalNamespaceArray;
[+] 	sl::Array<GlobalNamespace*> m_globalNamespaceArray;
[-] 	sl::Array <ExtensionNamespace*> m_extensionNamespaceArray;
[+] 	sl::Array<ExtensionNamespace*> m_extensionNamespaceArray;
[-] 	sl::List <ImportNamespace> m_importNamespaceList;
[+] 	sl::List<ImportNamespace> m_importNamespaceList;
[-] 	clear ();
[+] 	clear();
[-] 	append (
[+] 	append(
[-] 	addNamespace (
[+] 	addNamespace(
[-] 	addGlobalNamespace (GlobalNamespace* nspace)
[+] 	addGlobalNamespace(GlobalNamespace* nspace)
[-] 		m_globalNamespaceArray.append (nspace);
[+] 		m_globalNamespaceArray.append(nspace);
[-] 	addExtensionNamespace (ExtensionNamespace* nspace)
[+] 	addExtensionNamespace(ExtensionNamespace* nspace)
[-] 		m_extensionNamespaceArray.append (nspace);
[+] 		m_extensionNamespaceArray.append(nspace);
[-] 	resolveImportNamespaces ();
[+] 	resolveImportNamespaces();
[-] 	findItem (const sl::StringRef& name);
[+] 	findItem(const sl::StringRef& name);
[-] 	findExtensionItem (
[+] 	findExtensionItem(
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp.cpp
----------------------
[-] getBinOpKindString (BinOpKind opKind)
[+] getBinOpKindString(BinOpKind opKind)
[-] 	static const char* stringTable [BinOpKind__Count] =
[+] 	static const char* stringTable[BinOpKind__Count] =
[-] 	return (size_t) opKind < BinOpKind__Count ?
[+] 	return (size_t)opKind < BinOpKind__Count ?
[-] 		stringTable [opKind] :
[+] 		stringTable[opKind] :
[-] 		stringTable [BinOpKind_Undefined];
[+] 		stringTable[BinOpKind_Undefined];
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] BinaryOperator::getResultType (
[+] BinaryOperator::getResultType(
[-] 	Type* type = getResultType (opValue1, opValue2);
[+] 	Type* type = getResultType(opValue1, opValue2);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Arithmetic.cpp
----------------------
[-] dataPtrIncrementOperator (
[+] dataPtrIncrementOperator(
[-] 	ASSERT (opValue1.getType ()->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(opValue1.getType()->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* opType = (DataPtrType*) opValue1.getType ();
[+] 	DataPtrType* opType = (DataPtrType*)opValue1.getType();
[-] 	DataPtrType* resultType = opType->getUnCheckedPtrType ();
[+] 	DataPtrType* resultType = opType->getUnCheckedPtrType();
[-] 	Type* targetType = opType->getTargetType ();
[+] 	Type* targetType = opType->getTargetType();
[-] 	if (targetType->getStdType () == StdType_AbstractData)
[+] 	if (targetType->getStdType() == StdType_AbstractData)
[-] 		err::setError ("pointer arithmetic is not applicable to 'anydata' pointers");
[+] 		err::setError("pointer arithmetic is not applicable to 'anydata' pointers");
[-] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind();
[-] 	if (opValue1.getValueKind () == ValueKind_Const &&
[+] 	if (opValue1.getValueKind() == ValueKind_Const &&
[-] 		opValue2.getValueKind () == ValueKind_Const)
[+] 		opValue2.getValueKind() == ValueKind_Const)
[-] 		result = module->m_operatorMgr.castOperator (opValue2, TypeKind_IntPtr, &deltaValue);
[+] 		result = module->m_operatorMgr.castOperator(opValue2, TypeKind_IntPtr, &deltaValue);
[-] 		intptr_t delta = deltaValue.getIntPtr () * targetType->getSize ();
[+] 		intptr_t delta = deltaValue.getIntPtr() * targetType->getSize();
[-] 			char* p = *(char**) opValue1.getConstData () + delta;
[+] 			char* p = *(char**) opValue1.getConstData() + delta;
[-] 			resultValue->createConst (&p, opValue1.getType ());
[+] 			resultValue->createConst(&p, opValue1.getType());
[-] 			ASSERT (ptrTypeKind == DataPtrTypeKind_Normal); // lean is compile-time-only
[+] 			ASSERT(ptrTypeKind == DataPtrTypeKind_Normal); // lean is compile-time-only
[-] 			DataPtr ptr = *(DataPtr*) opValue1.getConstData ();
[+] 			DataPtr ptr = *(DataPtr*)opValue1.getConstData();
[-] 			ptr.m_p = (char*) ptr.m_p + delta;
[+] 			ptr.m_p = (char*)ptr.m_p + delta;
[-] 			resultValue->createConst (&ptr, opValue1.getType ());
[+] 			resultValue->createConst(&ptr, opValue1.getType());
[-] 		module->m_llvmIrBuilder.createGep (opValue1, opValue2, resultType, resultValue);
[+] 		module->m_llvmIrBuilder.createGep(opValue1, opValue2, resultType, resultValue);
[-] 		module->m_llvmIrBuilder.createGep (opValue1, opValue2, resultType, resultValue);
[+] 		module->m_llvmIrBuilder.createGep(opValue1, opValue2, resultType, resultValue);
[-] 		resultValue->setLeanDataPtr (resultValue->getLlvmValue (), resultType, opValue1);
[+] 		resultValue->setLeanDataPtr(resultValue->getLlvmValue(), resultType, opValue1);
[-] 	else if (!(targetType->getFlags () & TypeFlag_Dynamic)) // DataPtrTypeKind_Normal
[+] 	else if (!(targetType->getFlags() & TypeFlag_Dynamic)) // DataPtrTypeKind_Normal
[-] 		size_t size = targetType->getSize ();
[+] 		size_t size = targetType->getSize();
[-] 		Value sizeValue(size ? size : 1, module->m_typeMgr.getPrimitiveType (TypeKind_SizeT));
[+] 		Value sizeValue(size ? size : 1, module->m_typeMgr.getPrimitiveType(TypeKind_SizeT));
[-] 		module->m_operatorMgr.binaryOperator (BinOpKind_Mul, opValue2, sizeValue, &incValue);
[+] 		module->m_operatorMgr.binaryOperator(BinOpKind_Mul, opValue2, sizeValue, &incValue);
[-] 		module->m_llvmIrBuilder.createExtractValue (opValue1, 0, NULL, &ptrValue);
[+] 		module->m_llvmIrBuilder.createExtractValue(opValue1, 0, NULL, &ptrValue);
[-] 		module->m_llvmIrBuilder.createInsertValue (opValue1, ptrValue, 0, resultType, resultValue);
[+] 		module->m_llvmIrBuilder.createInsertValue(opValue1, ptrValue, 0, resultType, resultValue);
[-] 		if (targetType->getTypeKind () != TypeKind_Struct)
[+] 		if (targetType->getTypeKind() != TypeKind_Struct)
[-] 			err::setError ("pointer increments are only supported for dynamic structs");
[+] 			err::setError("pointer increments are only supported for dynamic structs");
[-] 		result = module->m_operatorMgr.castOperator (opValue2, TypeKind_SizeT, &incValue);
[+] 		result = module->m_operatorMgr.castOperator(opValue2, TypeKind_SizeT, &incValue);
[-] 		if (incValue.getValueKind () != ValueKind_Const || incValue.getSizeT () != 1)
[+] 		if (incValue.getValueKind() != ValueKind_Const || incValue.getSizeT() != 1)
[-] 			err::setError ("invalid pointer increment on a dynamic pointer (+1 only)");
[+] 			err::setError("invalid pointer increment on a dynamic pointer (+1 only)");
[-] 		Type* ptrType = module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		Type* ptrType = module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 		Function* getDynamicFieldFunc = module->m_functionMgr.getStdFunction (StdFunc_GetDynamicField);
[+] 		Function* getDynamicFieldFunc = module->m_functionMgr.getStdFunction(StdFunc_GetDynamicField);
[-] 		result = module->m_operatorMgr.callOperator (
[+] 		result = module->m_operatorMgr.callOperator(
[-] 			Value (&targetType, ptrType),
[+] 			Value(&targetType, ptrType),
[-] 			ptrType->getZeroValue (), // field = null
[+] 			ptrType->getZeroValue(), // field = null
[-] 		module->m_llvmIrBuilder.createInsertValue (opValue1, ptrValue, 0, resultType, resultValue);
[+] 		module->m_llvmIrBuilder.createInsertValue(opValue1, ptrValue, 0, resultType, resultValue);
[-] dataPtrDifferenceOperator (
[+] dataPtrDifferenceOperator(
[-] 	ASSERT (rawOpValue1.getType ()->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(rawOpValue1.getType()->getTypeKind() == TypeKind_DataPtr);
[-] 	ASSERT (rawOpValue2.getType ()->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(rawOpValue2.getType()->getTypeKind() == TypeKind_DataPtr);
[-] 	Type* targetType1 = ((DataPtrType*) rawOpValue1.getType ())->getTargetType ();
[+] 	Type* targetType1 = ((DataPtrType*)rawOpValue1.getType())->getTargetType();
[-] 	Type* targetType2 = ((DataPtrType*) rawOpValue2.getType ())->getTargetType ();
[+] 	Type* targetType2 = ((DataPtrType*)rawOpValue2.getType())->getTargetType();
[-] 	if (targetType1->cmp (targetType2) != 0)
[+] 	if (targetType1->cmp(targetType2) != 0)
[-] 		err::setFormatStringError ("pointer difference target types mismatch");
[+] 		err::setFormatStringError("pointer difference target types mismatch");
[-] 	else if (targetType1->getStdType () == StdType_AbstractData)
[+] 	else if (targetType1->getStdType() == StdType_AbstractData)
[-] 		err::setError ("pointer arithmetic is not applicable to 'anydata' pointers");
[+] 		err::setError("pointer arithmetic is not applicable to 'anydata' pointers");
[-] 	else if (targetType1->getFlags () & TypeFlag_Dynamic)
[+] 	else if (targetType1->getFlags() & TypeFlag_Dynamic)
[-] 		err::setError ("pointer subtraction is not applicable to dynamic pointers");
[+] 		err::setError("pointer subtraction is not applicable to dynamic pointers");
[-] 	Type* bytePtrType = module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType_c (TypeKind_DataPtr, PtrTypeFlag_Const);
[+] 	Type* bytePtrType = module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType_c(TypeKind_DataPtr, PtrTypeFlag_Const);
[-] 		module->m_operatorMgr.castOperator (rawOpValue1, bytePtrType, &opValue1) &&
[+] 		module->m_operatorMgr.castOperator(rawOpValue1, bytePtrType, &opValue1) &&
[-] 		module->m_operatorMgr.castOperator (rawOpValue2, bytePtrType, &opValue2);
[+] 		module->m_operatorMgr.castOperator(rawOpValue2, bytePtrType, &opValue2);
[-] 	size_t size = targetType1->getSize ();
[+] 	size_t size = targetType1->getSize();
[-] 	Type* type = module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr);
[+] 	Type* type = module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr);
[-] 	if (opValue1.getValueKind () == ValueKind_Const &&
[+] 	if (opValue1.getValueKind() == ValueKind_Const &&
[-] 		opValue2.getValueKind () == ValueKind_Const)
[+] 		opValue2.getValueKind() == ValueKind_Const)
[-] 		char* p1 = *(char**) opValue1.getConstData ();
[+] 		char* p1 = *(char**) opValue1.getConstData();
[-] 		char* p2 = *(char**) opValue2.getConstData ();
[+] 		char* p2 = *(char**) opValue2.getConstData();
[-] 		resultValue->setConstSizeT (diff, type);
[+] 		resultValue->setConstSizeT(diff, type);
[-] 		sizeValue.setConstSizeT (size, module);
[+] 		sizeValue.setConstSizeT(size, module);
[-] 		module->m_llvmIrBuilder.createPtrToInt (opValue1, type, &opValue1);
[+] 		module->m_llvmIrBuilder.createPtrToInt(opValue1, type, &opValue1);
[-] 		module->m_llvmIrBuilder.createPtrToInt (opValue2, type, &opValue2);
[+] 		module->m_llvmIrBuilder.createPtrToInt(opValue2, type, &opValue2);
[-] 		module->m_llvmIrBuilder.createSub_i (opValue1, opValue2, type, &diffValue);
[+] 		module->m_llvmIrBuilder.createSub_i(opValue1, opValue2, type, &diffValue);
[-] 		module->m_llvmIrBuilder.createDiv_i (diffValue, sizeValue, type, resultValue);
[+] 		module->m_llvmIrBuilder.createDiv_i(diffValue, sizeValue, type, resultValue);
[-] BinOp_Add::op (
[+] BinOp_Add::op(
[-] 	if (opValue1.getType ()->getTypeKind () == TypeKind_DataPtr &&
[+] 	if (opValue1.getType()->getTypeKind() == TypeKind_DataPtr &&
[-] 		(opValue2.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 		(opValue2.getType()->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		return dataPtrIncrementOperator (m_module, opValue1, opValue2, resultValue);
[+] 		return dataPtrIncrementOperator(m_module, opValue1, opValue2, resultValue);
[-] 		opValue2.getType ()->getTypeKind () == TypeKind_DataPtr &&
[+] 		opValue2.getType()->getTypeKind() == TypeKind_DataPtr &&
[-] 		(opValue1.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 		(opValue1.getType()->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		return dataPtrIncrementOperator (m_module, opValue2, opValue1, resultValue);
[+] 		return dataPtrIncrementOperator(m_module, opValue2, opValue1, resultValue);
[-] 		return BinOp_Arithmetic <BinOp_Add>::op (opValue1, opValue2, resultValue);
[+] 		return BinOp_Arithmetic<BinOp_Add>::op(opValue1, opValue2, resultValue);
[-] BinOp_Add::llvmOpInt (
[+] BinOp_Add::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createAdd_i (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createAdd_i(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Add::llvmOpFp (
[+] BinOp_Add::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createAdd_f (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createAdd_f(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Sub::op (
[+] BinOp_Sub::op(
[-] 	if (opValue1.getType ()->getTypeKind () == TypeKind_DataPtr &&
[+] 	if (opValue1.getType()->getTypeKind() == TypeKind_DataPtr &&
[-] 		(opValue2.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 		(opValue2.getType()->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 			m_module->m_operatorMgr.unaryOperator (UnOpKind_Minus, opValue2, &negOpValue2) &&
[+] 			m_module->m_operatorMgr.unaryOperator(UnOpKind_Minus, opValue2, &negOpValue2) &&
[-] 			dataPtrIncrementOperator (m_module, opValue1, negOpValue2, resultValue);
[+] 			dataPtrIncrementOperator(m_module, opValue1, negOpValue2, resultValue);
[-] 	if (opValue1.getType ()->getTypeKind () == TypeKind_DataPtr && opValue2.getType ()->getTypeKind () == TypeKind_DataPtr)
[+] 	if (opValue1.getType()->getTypeKind() == TypeKind_DataPtr && opValue2.getType()->getTypeKind() == TypeKind_DataPtr)
[-] 		return dataPtrDifferenceOperator (m_module, opValue1, opValue2, resultValue);
[+] 		return dataPtrDifferenceOperator(m_module, opValue1, opValue2, resultValue);
[-] 		return BinOp_Arithmetic <BinOp_Sub>::op (opValue1, opValue2, resultValue);
[+] 		return BinOp_Arithmetic<BinOp_Sub>::op(opValue1, opValue2, resultValue);
[-] BinOp_Sub::llvmOpInt (
[+] BinOp_Sub::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createSub_i (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createSub_i(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Sub::llvmOpFp (
[+] BinOp_Sub::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createSub_f (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createSub_f(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Mul::llvmOpInt (
[+] BinOp_Mul::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createMul_i (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createMul_i(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Mul::llvmOpFp (
[+] BinOp_Mul::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createMul_f (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createMul_f(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Div::llvmOpInt (
[+] BinOp_Div::llvmOpInt(
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckDivByZero)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckDivByZero)
[-] 		m_module->m_operatorMgr.checkDivByZero (opValue2);
[+] 		m_module->m_operatorMgr.checkDivByZero(opValue2);
[-] 		m_module->m_llvmIrBuilder.createDiv_u (opValue1, opValue2, resultType, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createDiv_u(opValue1, opValue2, resultType, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createDiv_i (opValue1, opValue2, resultType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createDiv_i(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Div::llvmOpFp (
[+] BinOp_Div::llvmOpFp(
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckDivByZero)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckDivByZero)
[-] 		m_module->m_operatorMgr.checkDivByZero (opValue2);
[+] 		m_module->m_operatorMgr.checkDivByZero(opValue2);
[-] 	return m_module->m_llvmIrBuilder.createDiv_f (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createDiv_f(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Mod::llvmOpInt (
[+] BinOp_Mod::llvmOpInt(
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckDivByZero)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckDivByZero)
[-] 		m_module->m_operatorMgr.checkDivByZero (opValue2);
[+] 		m_module->m_operatorMgr.checkDivByZero(opValue2);
[-] 		m_module->m_llvmIrBuilder.createMod_u (opValue1, opValue2, resultType, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createMod_u(opValue1, opValue2, resultType, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createMod_i (opValue1, opValue2, resultType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createMod_i(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Shl::llvmOpInt (
[+] BinOp_Shl::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createShl (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createShl(opValue1, opValue2, resultType, resultValue);
[-] BinOp_Shr::llvmOpInt (
[+] BinOp_Shr::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createShr (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createShr(opValue1, opValue2, resultType, resultValue);
[-] BinOp_BwAnd::BinOp_BwAnd ()
[+] BinOp_BwAnd::BinOp_BwAnd()
[-] BinOp_BwAnd::op (
[+] BinOp_BwAnd::op(
[-] 		isBitFlagEnumType (rawOpValue1.getType ()) ? (EnumType*) rawOpValue1.getType () :
[+] 		isBitFlagEnumType(rawOpValue1.getType()) ? (EnumType*)rawOpValue1.getType() :
[-] 		isBitFlagEnumType (rawOpValue2.getType ()) ? (EnumType*) rawOpValue2.getType () : NULL;
[+] 		isBitFlagEnumType(rawOpValue2.getType()) ? (EnumType*)rawOpValue2.getType() : NULL;
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue1, &opValue1) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue1, &opValue1) &&
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue2, &opValue2) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue2, &opValue2) &&
[-] 			BinOp_IntegerOnly <BinOp_BwAnd>::op (opValue1, opValue2, resultValue);
[+] 			BinOp_IntegerOnly<BinOp_BwAnd>::op(opValue1, opValue2, resultValue);
[-] 		m_module->m_operatorMgr.prepareOperand (rawOpValue1, &opValue1) &&
[+] 		m_module->m_operatorMgr.prepareOperand(rawOpValue1, &opValue1) &&
[-] 		m_module->m_operatorMgr.prepareOperand (rawOpValue2, &opValue2) &&
[+] 		m_module->m_operatorMgr.prepareOperand(rawOpValue2, &opValue2) &&
[-] 		BinOp_IntegerOnly <BinOp_BwAnd>::op (opValue1, opValue2, &tmpValue) &&
[+] 		BinOp_IntegerOnly<BinOp_BwAnd>::op(opValue1, opValue2, &tmpValue) &&
[-] 		m_module->m_operatorMgr.castOperator (tmpValue, enumType, resultValue);
[+] 		m_module->m_operatorMgr.castOperator(tmpValue, enumType, resultValue);
[-] BinOp_BwAnd::llvmOpInt (
[+] BinOp_BwAnd::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createAnd (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createAnd(opValue1, opValue2, resultType, resultValue);
[-] BinOp_BwOr::BinOp_BwOr ()
[+] BinOp_BwOr::BinOp_BwOr()
[-] BinOp_BwOr::op (
[+] BinOp_BwOr::op(
[-] 	if (!isBitFlagEnumOpType (rawOpValue1, rawOpValue2))
[+] 	if (!isBitFlagEnumOpType(rawOpValue1, rawOpValue2))
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue1, &opValue1) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue1, &opValue1) &&
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue2, &opValue2) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue2, &opValue2) &&
[-] 			BinOp_IntegerOnly <BinOp_BwOr>::op (opValue1, opValue2, resultValue);
[+] 			BinOp_IntegerOnly<BinOp_BwOr>::op(opValue1, opValue2, resultValue);
[-] 	EnumType* enumType = (EnumType*) rawOpValue1.getType ();
[+] 	EnumType* enumType = (EnumType*)rawOpValue1.getType();
[-] 	opValue1.overrideType (rawOpValue1, enumType->getBaseType ());
[+] 	opValue1.overrideType(rawOpValue1, enumType->getBaseType());
[-] 	opValue2.overrideType (rawOpValue2, enumType->getBaseType ());
[+] 	opValue2.overrideType(rawOpValue2, enumType->getBaseType());
[-] 		BinOp_IntegerOnly <BinOp_BwOr>::op (opValue1, opValue2, &tmpValue) &&
[+] 		BinOp_IntegerOnly<BinOp_BwOr>::op(opValue1, opValue2, &tmpValue) &&
[-] 		m_module->m_operatorMgr.castOperator (tmpValue, enumType, resultValue);
[+] 		m_module->m_operatorMgr.castOperator(tmpValue, enumType, resultValue);
[-] BinOp_BwOr::llvmOpInt (
[+] BinOp_BwOr::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createOr (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createOr(opValue1, opValue2, resultType, resultValue);
[-] BinOp_BwXor::BinOp_BwXor ()
[+] BinOp_BwXor::BinOp_BwXor()
[-] BinOp_BwXor::op (
[+] BinOp_BwXor::op(
[-] 	if (!isBitFlagEnumOpType (rawOpValue1, rawOpValue2))
[+] 	if (!isBitFlagEnumOpType(rawOpValue1, rawOpValue2))
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue1, &opValue1) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue1, &opValue1) &&
[-] 			m_module->m_operatorMgr.prepareOperand (rawOpValue2, &opValue2) &&
[+] 			m_module->m_operatorMgr.prepareOperand(rawOpValue2, &opValue2) &&
[-] 			BinOp_IntegerOnly <BinOp_BwXor>::op (opValue1, opValue2, resultValue);
[+] 			BinOp_IntegerOnly<BinOp_BwXor>::op(opValue1, opValue2, resultValue);
[-] 	EnumType* enumType = (EnumType*) rawOpValue1.getType ();
[+] 	EnumType* enumType = (EnumType*)rawOpValue1.getType();
[-] 	opValue1.overrideType (rawOpValue1, enumType->getBaseType ());
[+] 	opValue1.overrideType(rawOpValue1, enumType->getBaseType());
[-] 	opValue2.overrideType (rawOpValue2, enumType->getBaseType ());
[+] 	opValue2.overrideType(rawOpValue2, enumType->getBaseType());
[-] 		BinOp_IntegerOnly <BinOp_BwXor>::op (opValue1, opValue2, &tmpValue) &&
[+] 		BinOp_IntegerOnly<BinOp_BwXor>::op(opValue1, opValue2, &tmpValue) &&
[-] 		m_module->m_operatorMgr.castOperator (tmpValue, enumType, resultValue);
[+] 		m_module->m_operatorMgr.castOperator(tmpValue, enumType, resultValue);
[-] BinOp_BwXor::llvmOpInt (
[+] BinOp_BwXor::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createXor (opValue1, opValue2, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createXor(opValue1, opValue2, resultType, resultValue);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Assign.cpp
----------------------
[-] BinOp_Assign::op (
[+] BinOp_Assign::op(
[-] 	TypeKind dstTypeKind = opValue1.getType ()->getTypeKind ();
[+] 	TypeKind dstTypeKind = opValue1.getType()->getTypeKind();
[-] 	switch (dstTypeKind)
[+] 	switch(dstTypeKind)
[-] 		return m_module->m_operatorMgr.storeDataRef (opValue1, opValue2);
[+] 		return m_module->m_operatorMgr.storeDataRef(opValue1, opValue2);
[-] 		return m_module->m_operatorMgr.binaryOperator (BinOpKind_RefAssign, opValue1, opValue2, resultValue);
[+] 		return m_module->m_operatorMgr.binaryOperator(BinOpKind_RefAssign, opValue1, opValue2, resultValue);
[-] 		return m_module->m_operatorMgr.setProperty (opValue1, opValue2);
[+] 		return m_module->m_operatorMgr.setProperty(opValue1, opValue2);
[-] 		err::setFormatStringError ("left operand must be l-value");
[+] 		err::setFormatStringError("left operand must be l-value");
[-] BinOp_OpAssign::op (
[+] BinOp_OpAssign::op(
[-] 	ASSERT (m_opKind >= BinOpKind_AddAssign && m_opKind <= BinOpKind_AtAssign);
[+] 	ASSERT(m_opKind >= BinOpKind_AddAssign && m_opKind <= BinOpKind_AtAssign);
[-] 	BinOpKind opKind = (BinOpKind) (m_opKind - BinOpKind__OpAssignDelta);
[+] 	BinOpKind opKind = (BinOpKind)(m_opKind - BinOpKind__OpAssignDelta);
[-] 		m_module->m_operatorMgr.binaryOperator (opKind, opValue1, opValue2, &RValue) &&
[+] 		m_module->m_operatorMgr.binaryOperator(opKind, opValue1, opValue2, &RValue) &&
[-] 		m_module->m_operatorMgr.binaryOperator (BinOpKind_Assign, opValue1, RValue);
[+] 		m_module->m_operatorMgr.binaryOperator(BinOpKind_Assign, opValue1, RValue);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_At.cpp
----------------------
[-] BinOp_At::getResultType (
[+] BinOp_At::getResultType(
[-] 	return opValue1.getType ();
[+] 	return opValue1.getType();
[-] BinOp_At::op (
[+] BinOp_At::op(
[-] 	result = m_module->m_operatorMgr.castOperator (
[+] 	result = m_module->m_operatorMgr.castOperator(
[-] 		((ClassType*) m_module->m_typeMgr.getStdType (StdType_Scheduler))->getClassPtrType (),
[+] 		((ClassType*)m_module->m_typeMgr.getStdType(StdType_Scheduler))->getClassPtrType(),
[-] 	TypeKind opType1 = opValue1.getType ()->getTypeKind ();
[+] 	TypeKind opType1 = opValue1.getType()->getTypeKind();
[-] 		setOperatorError (opValue1, opValue2);
[+] 		setOperatorError(opValue1, opValue2);
[-] 	FunctionPtrType* targetPtrType = (FunctionPtrType*) opValue1.getType (); // not closure-aware!
[+] 	FunctionPtrType* targetPtrType = (FunctionPtrType*)opValue1.getType(); // not closure-aware!
[-] 	Function* launcher = m_module->m_functionMgr.getScheduleLauncherFunction (targetPtrType);
[+] 	Function* launcher = m_module->m_functionMgr.getScheduleLauncherFunction(targetPtrType);
[-] 	resultValue->setFunction (launcher);
[+] 	resultValue->setFunction(launcher);
[-] 	Closure* resultClosure = resultValue->createClosure ();
[+] 	Closure* resultClosure = resultValue->createClosure();
[-] 	resultClosure->getArgValueList ()->insertTail (opValue1);
[+] 	resultClosure->getArgValueList()->insertTail(opValue1);
[-] 	resultClosure->getArgValueList ()->insertTail (schedulerValue);
[+] 	resultClosure->getArgValueList()->insertTail(schedulerValue);
[-] 	Closure* opClosure = opValue1.getClosure ();
[+] 	Closure* opClosure = opValue1.getClosure();
[-] 		resultClosure->append (*opClosure->getArgValueList ());
[+] 		resultClosure->append(*opClosure->getArgValueList());
[-] 		size_t thisArgIdx = opClosure->getThisArgIdx ();
[+] 		size_t thisArgIdx = opClosure->getThisArgIdx();
[-] 			resultClosure->setThisArgIdx (thisArgIdx + 2);
[+] 			resultClosure->setThisArgIdx(thisArgIdx + 2);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Cmp.cpp
----------------------
[-] getPtrCmpOperatorOperandType (
[+] getPtrCmpOperatorOperandType(
[-] 	return opValue1.getType ()->getModule ()->m_typeMgr.getPrimitiveType (TypeKind_IntPtr);
[+] 	return opValue1.getType()->getModule()->m_typeMgr.getPrimitiveType(TypeKind_IntPtr);
[-] BinOp_Eq::llvmOpInt (
[+] BinOp_Eq::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createEq_i (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createEq_i(opValue1, opValue2, resultValue);
[-] BinOp_Eq::llvmOpFp (
[+] BinOp_Eq::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createEq_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createEq_f(opValue1, opValue2, resultValue);
[-] BinOp_Ne::llvmOpInt (
[+] BinOp_Ne::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createNe_i (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createNe_i(opValue1, opValue2, resultValue);
[-] BinOp_Ne::llvmOpFp (
[+] BinOp_Ne::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createNe_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createNe_f(opValue1, opValue2, resultValue);
[-] BinOp_Lt::llvmOpInt (
[+] BinOp_Lt::llvmOpInt(
[-] 		m_module->m_llvmIrBuilder.createLt_u (opValue1, opValue2, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createLt_u(opValue1, opValue2, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createLt_i (opValue1, opValue2, resultValue);
[+] 		m_module->m_llvmIrBuilder.createLt_i(opValue1, opValue2, resultValue);
[-] BinOp_Lt::llvmOpFp (
[+] BinOp_Lt::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createLt_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createLt_f(opValue1, opValue2, resultValue);
[-] BinOp_Le::llvmOpInt (
[+] BinOp_Le::llvmOpInt(
[-] 		m_module->m_llvmIrBuilder.createLe_u (opValue1, opValue2, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createLe_u(opValue1, opValue2, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createLe_i (opValue1, opValue2, resultValue);
[+] 		m_module->m_llvmIrBuilder.createLe_i(opValue1, opValue2, resultValue);
[-] BinOp_Le::llvmOpFp (
[+] BinOp_Le::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createLe_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createLe_f(opValue1, opValue2, resultValue);
[-] BinOp_Gt::llvmOpInt (
[+] BinOp_Gt::llvmOpInt(
[-] 		m_module->m_llvmIrBuilder.createGt_u (opValue1, opValue2, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createGt_u(opValue1, opValue2, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createGt_i (opValue1, opValue2, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGt_i(opValue1, opValue2, resultValue);
[-] BinOp_Gt::llvmOpFp (
[+] BinOp_Gt::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createGt_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createGt_f(opValue1, opValue2, resultValue);
[-] BinOp_Ge::llvmOpInt (
[+] BinOp_Ge::llvmOpInt(
[-] 		m_module->m_llvmIrBuilder.createGe_u (opValue1, opValue2, resultValue) :
[+] 		m_module->m_llvmIrBuilder.createGe_u(opValue1, opValue2, resultValue) :
[-] 		m_module->m_llvmIrBuilder.createGe_i (opValue1, opValue2, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGe_i(opValue1, opValue2, resultValue);
[-] BinOp_Ge::llvmOpFp (
[+] BinOp_Ge::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createGe_f (opValue1, opValue2, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createGe_f(opValue1, opValue2, resultValue);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Idx.cpp
----------------------
[-] BinOp_Idx::getResultType (
[+] BinOp_Idx::getResultType(
[-] 	Type* opType1 = opValue1.getType ();
[+] 	Type* opType1 = opValue1.getType();
[-] 	if (opType1->getTypeKind () == TypeKind_DataRef)
[+] 	if (opType1->getTypeKind() == TypeKind_DataRef)
[-] 		DataPtrType* ptrType = (DataPtrType*) opType1;
[+] 		DataPtrType* ptrType = (DataPtrType*)opType1;
[-] 		Type* targetType = ptrType->getTargetType ();
[+] 		Type* targetType = ptrType->getTargetType();
[-] 		TypeKind targetTypeKind = targetType->getTypeKind ();
[+] 		TypeKind targetTypeKind = targetType->getTypeKind();
[-] 		switch (targetTypeKind)
[+] 		switch(targetTypeKind)
[-] 			return ((ArrayType*) targetType)->getElementType ()->getDataPtrType (
[+] 			return ((ArrayType*)targetType)->getElementType()->getDataPtrType(
[-] 				ptrType->getPtrTypeKind (),
[+] 				ptrType->getPtrTypeKind(),
[-] 				ptrType->getFlags ()
[+] 				ptrType->getFlags()
[-] 			return m_module->m_typeMgr.getSimplePropertyType (targetType); // variant property
[+] 			return m_module->m_typeMgr.getSimplePropertyType(targetType); // variant property
[-] 	TypeKind typeKind = opType1->getTypeKind ();
[+] 	TypeKind typeKind = opType1->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		ptrType = (DataPtrType*) opType1;
[+] 		ptrType = (DataPtrType*)opType1;
[-] 		return ptrType->getTargetType ()->getDataPtrType (
[+] 		return ptrType->getTargetType()->getDataPtrType(
[-] 			ptrType->getPtrTypeKind (),
[+] 			ptrType->getPtrTypeKind(),
[-] 			ptrType->getFlags ()
[+] 			ptrType->getFlags()
[-] 		return ((ArrayType*) opType1)->getElementType ();
[+] 		return ((ArrayType*)opType1)->getElementType();
[-] 		return getPropertyIndexResultType (opValue1, opValue2);
[+] 		return getPropertyIndexResultType(opValue1, opValue2);
[-] 		return getDerivableTypeIndexResultType (((ClassPtrType*) opType1)->getTargetType (), opValue1, opValue2);
[+] 		return getDerivableTypeIndexResultType(((ClassPtrType*)opType1)->getTargetType(), opValue1, opValue2);
[-] 		if (opType1->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 		if (opType1->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 			return getDerivableTypeIndexResultType ((DerivableType*) opType1, opValue1, opValue2);
[+] 			return getDerivableTypeIndexResultType((DerivableType*)opType1, opValue1, opValue2);
[-] 		err::setFormatStringError ("cannot index '%s'", opType1->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot index '%s'", opType1->getTypeString ().sz ());
[-] BinOp_Idx::op (
[+] BinOp_Idx::op(
[-] 	Type* opType1 = rawOpValue1.getType ();
[+] 	Type* opType1 = rawOpValue1.getType();
[-] 	if (opType1->getTypeKind () == TypeKind_DataRef)
[+] 	if (opType1->getTypeKind() == TypeKind_DataRef)
[-] 		Type* targetType = ((DataPtrType*) opType1)->getTargetType ();
[+] 		Type* targetType = ((DataPtrType*)opType1)->getTargetType();
[-] 		TypeKind targetTypeKind = targetType->getTypeKind ();
[+] 		TypeKind targetTypeKind = targetType->getTypeKind();
[-] 		switch (targetTypeKind)
[+] 		switch(targetTypeKind)
[-] 				m_module->m_operatorMgr.castOperator (&opValue2, TypeKind_IntPtr) &&
[+] 				m_module->m_operatorMgr.castOperator(&opValue2, TypeKind_IntPtr) &&
[-] 				arrayIndexOperator (rawOpValue1, (ArrayType*) targetType, opValue2, resultValue);
[+] 				arrayIndexOperator(rawOpValue1, (ArrayType*)targetType, opValue2, resultValue);
[-] 			return variantIndexOperator (rawOpValue1, opValue2, resultValue);
[+] 			return variantIndexOperator(rawOpValue1, opValue2, resultValue);
[-] 		result = m_module->m_operatorMgr.loadDataRef (rawOpValue1, &opValue1);
[+] 		result = m_module->m_operatorMgr.loadDataRef(rawOpValue1, &opValue1);
[-] 		opType1 = opValue1.getType ();
[+] 		opType1 = opValue1.getType();
[-] 	TypeKind typeKind = opType1->getTypeKind ();
[+] 	TypeKind typeKind = opType1->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 			m_module->m_operatorMgr.castOperator (&opValue2, TypeKind_IntPtr) &&
[+] 			m_module->m_operatorMgr.castOperator(&opValue2, TypeKind_IntPtr) &&
[-] 			m_module->m_operatorMgr.binaryOperator (BinOpKind_Add, opValue1, opValue2, &opValue1) &&
[+] 			m_module->m_operatorMgr.binaryOperator(BinOpKind_Add, opValue1, opValue2, &opValue1) &&
[-] 			m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, opValue1, resultValue);
[+] 			m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, opValue1, resultValue);
[-] 			m_module->m_operatorMgr.castOperator (&opValue2, TypeKind_IntPtr) &&
[+] 			m_module->m_operatorMgr.castOperator(&opValue2, TypeKind_IntPtr) &&
[-] 			arrayIndexOperator (opValue1, (ArrayType*) opType1, opValue2, resultValue);
[+] 			arrayIndexOperator(opValue1, (ArrayType*)opType1, opValue2, resultValue);
[-] 		err::setFormatStringError ("r-value variant index is not implemented yet");
[+] 		err::setFormatStringError("r-value variant index is not implemented yet");
[-] 		return propertyIndexOperator (opValue1, opValue2, resultValue);
[+] 		return propertyIndexOperator(opValue1, opValue2, resultValue);
[-] 		return derivableTypeIndexOperator (((ClassPtrType*) opType1)->getTargetType (), opValue1, opValue2, resultValue);
[+] 		return derivableTypeIndexOperator(((ClassPtrType*)opType1)->getTargetType(), opValue1, opValue2, resultValue);
[-] 		if (opType1->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 		if (opType1->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 			return derivableTypeIndexOperator ((DerivableType*) opType1, opValue1, opValue2, resultValue);
[+] 			return derivableTypeIndexOperator((DerivableType*)opType1, opValue1, opValue2, resultValue);
[-] 		err::setFormatStringError ("cannot index '%s'", opType1->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot index '%s'", opType1->getTypeString ().sz ());
[-] BinOp_Idx::arrayIndexOperator (
[+] BinOp_Idx::arrayIndexOperator(
[-] 	Type* elementType = arrayType->getElementType ();
[+] 	Type* elementType = arrayType->getElementType();
[-] 	if (opValue1.getValueKind () == ValueKind_Const &&
[+] 	if (opValue1.getValueKind() == ValueKind_Const &&
[-] 		opValue2.getValueKind () == ValueKind_Const)
[+] 		opValue2.getValueKind() == ValueKind_Const)
[-] 		size_t elementOffset = opValue2.getSizeT () * elementType->getSize ();
[+] 		size_t elementOffset = opValue2.getSizeT() * elementType->getSize();
[-] 		Type* type = opValue1.getType ();
[+] 		Type* type = opValue1.getType();
[-] 		if (!(type->getTypeKindFlags () & TypeKindFlag_Ptr))
[+] 		if (!(type->getTypeKindFlags() & TypeKindFlag_Ptr))
[-] 			resultValue->createConst ((char*) opValue1.getConstData () + elementOffset, elementType);
[+] 			resultValue->createConst((char*)opValue1.getConstData() + elementOffset, elementType);
[-] 			ASSERT (type->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 			ASSERT(type->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 			DataPtrType* ptrType = (DataPtrType*) type;
[+] 			DataPtrType* ptrType = (DataPtrType*)type;
[-] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 				DataPtr ptr = *(DataPtr*) opValue1.getConstData ();
[+] 				DataPtr ptr = *(DataPtr*)opValue1.getConstData();
[-] 				ptr.m_p = (char*) ptr.m_p + elementOffset;
[+] 				ptr.m_p = (char*)ptr.m_p + elementOffset;
[-] 				resultValue->createConst (&ptr, elementType->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Normal, type->getFlags ()));
[+] 				resultValue->createConst(&ptr, elementType->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Normal, type->getFlags()));
[-] 				ASSERT (ptrTypeKind == DataPtrTypeKind_Thin);
[+] 				ASSERT(ptrTypeKind == DataPtrTypeKind_Thin);
[-] 				char* p = *(char**) opValue1.getConstData ();
[+] 				char* p = *(char**) opValue1.getConstData();
[-] 				resultValue->createConst (&p, elementType->getDataPtrType_c (TypeKind_DataRef, type->getFlags ()));
[+] 				resultValue->createConst(&p, elementType->getDataPtrType_c(TypeKind_DataRef, type->getFlags()));
[-] 	TypeKind opTypeKind1 = opValue1.getType ()->getTypeKind ();
[+] 	TypeKind opTypeKind1 = opValue1.getType()->getTypeKind();
[-] 		ASSERT (opTypeKind1 == TypeKind_Array);
[+] 		ASSERT(opTypeKind1 == TypeKind_Array);
[-] 		err::setFormatStringError ("indexing register-based arrays is not supported yet");
[+] 		err::setFormatStringError("indexing register-based arrays is not supported yet");
[-] 	DataPtrType* opType1 = (DataPtrType*) opValue1.getType ();
[+] 	DataPtrType* opType1 = (DataPtrType*)opValue1.getType();
[-] 	uint_t ptrTypeFlags = opType1->getFlags ();
[+] 	uint_t ptrTypeFlags = opType1->getFlags();
[-] 		if (opValue2.getValueKind () == ValueKind_Const)
[+] 		if (opValue2.getValueKind() == ValueKind_Const)
[-] 			bool result = m_module->m_operatorMgr.castOperator (opValue2, TypeKind_IntPtr, &idxValue);
[+] 			bool result = m_module->m_operatorMgr.castOperator(opValue2, TypeKind_IntPtr, &idxValue);
[-] 			intptr_t i = idxValue.getSizeT ();
[+] 			intptr_t i = idxValue.getSizeT();
[-] 			if (i < 0 || i >= (intptr_t) arrayType->getElementCount ())
[+] 			if (i < 0 || i >= (intptr_t)arrayType->getElementCount())
[-] 				err::setFormatStringError ("index '%d' is out of bounds in '%s'", i, arrayType->getTypeString ().sz ());
[+] 				err::setFormatStringError("index '%d' is out of bounds in '%s'", i, arrayType->getTypeString ().sz ());
[-] 	DataPtrTypeKind ptrTypeKind = opType1->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = opType1->getPtrTypeKind();
[-] 		ptrType = elementType->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Thin, ptrTypeFlags);
[+] 		ptrType = elementType->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Thin, ptrTypeFlags);
[-] 		m_module->m_llvmIrBuilder.createGep2 (opValue1, opValue2, ptrType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(opValue1, opValue2, ptrType, resultValue);
[-] 		ptrType = elementType->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Lean, ptrTypeFlags);
[+] 		ptrType = elementType->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Lean, ptrTypeFlags);
[-] 		m_module->m_llvmIrBuilder.createGep2 (opValue1, opValue2, ptrType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(opValue1, opValue2, ptrType, resultValue);
[-] 		resultValue->setLeanDataPtrValidator (opValue1.getLeanDataPtrValidator ());
[+] 		resultValue->setLeanDataPtrValidator(opValue1.getLeanDataPtrValidator());
[-] 		ptrType = elementType->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Lean, ptrTypeFlags);
[+] 		ptrType = elementType->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Lean, ptrTypeFlags);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (opValue1, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(opValue1, 0, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (ptrValue, ptrType, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(ptrValue, ptrType, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createGep (ptrValue, opValue2, ptrType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGep(ptrValue, opValue2, ptrType, resultValue);
[-] 		resultValue->setLeanDataPtrValidator (opValue1);
[+] 		resultValue->setLeanDataPtrValidator(opValue1);
[-] BinOp_Idx::variantIndexOperator (
[+] BinOp_Idx::variantIndexOperator(
[-] 	Property* prop = m_module->m_functionMgr.getStdProperty (StdProp_VariantIndex);
[+] 	Property* prop = m_module->m_functionMgr.getStdProperty(StdProp_VariantIndex);
[-] 	resultValue->setProperty (prop);
[+] 	resultValue->setProperty(prop);
[-] 	bool result = m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, opValue1, &variantValue);
[+] 	bool result = m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, opValue1, &variantValue);
[-] 	Closure* closure = resultValue->createClosure ();
[+] 	Closure* closure = resultValue->createClosure();
[-] 	closure->append (variantValue);
[+] 	closure->append(variantValue);
[-] 	closure->append (opValue2);
[+] 	closure->append(opValue2);
[-] BinOp_Idx::propertyIndexOperator (
[+] BinOp_Idx::propertyIndexOperator(
[-] 	Closure* closure = resultValue->getClosure ();
[+] 	Closure* closure = resultValue->getClosure();
[-] 		closure = resultValue->createClosure ();
[+] 		closure = resultValue->createClosure();
[-] 	closure->getArgValueList ()->insertTail (rawOpValue2);
[+] 	closure->getArgValueList()->insertTail(rawOpValue2);
[-] BinOp_Idx::getPropertyIndexResultType (
[+] BinOp_Idx::getPropertyIndexResultType(
[-] 	propertyIndexOperator (rawOpValue1, rawOpValue2, &resultValue);
[+] 	propertyIndexOperator(rawOpValue1, rawOpValue2, &resultValue);
[-] 	return resultValue.getClosure ()->getClosureType (rawOpValue1.getType ());
[+] 	return resultValue.getClosure()->getClosureType(rawOpValue1.getType());
[-] BinOp_Idx::getDerivableTypeIndexResultType (
[+] BinOp_Idx::getDerivableTypeIndexResultType(
[-] 	Property* prop = getDerivableTypeIndexerProperty (derivableType, opValue2);
[+] 	Property* prop = getDerivableTypeIndexerProperty(derivableType, opValue2);
[-] 	Closure* closure = resultValue.createClosure ();
[+] 	Closure* closure = resultValue.createClosure();
[-] 	closure->getArgValueList ()->insertTail (opValue1);
[+] 	closure->getArgValueList()->insertTail(opValue1);
[-] 	closure->getArgValueList ()->insertTail (opValue2);
[+] 	closure->getArgValueList()->insertTail(opValue2);
[-] 	return closure->getClosureType (prop->getType ());
[+] 	return closure->getClosureType(prop->getType());
[-] BinOp_Idx::derivableTypeIndexOperator (
[+] BinOp_Idx::derivableTypeIndexOperator(
[-] 	Property* prop = getDerivableTypeIndexerProperty (derivableType, opValue2);
[+] 	Property* prop = getDerivableTypeIndexerProperty(derivableType, opValue2);
[-] 	resultValue->setProperty (prop);
[+] 	resultValue->setProperty(prop);
[-] 	Closure* closure = resultValue->createClosure ();
[+] 	Closure* closure = resultValue->createClosure();
[-] 	closure->getArgValueList ()->insertTail (opValue1);
[+] 	closure->getArgValueList()->insertTail(opValue1);
[-] 	closure->getArgValueList ()->insertTail (opValue2);
[+] 	closure->getArgValueList()->insertTail(opValue2);
[-] BinOp_Idx::getDerivableTypeIndexerProperty (
[+] BinOp_Idx::getDerivableTypeIndexerProperty(
[-] 	if (derivableType->hasIndexerProperties ())
[+] 	if (derivableType->hasIndexerProperties())
[-] 		return derivableType->chooseIndexerProperty (opValue2);
[+] 		return derivableType->chooseIndexerProperty(opValue2);
[-] 	sl::Array <BaseTypeSlot*> baseTypeArray = derivableType->getBaseTypeArray ();
[+] 	sl::Array<BaseTypeSlot*> baseTypeArray = derivableType->getBaseTypeArray();
[-] 	size_t count = baseTypeArray.getCount ();
[+] 	size_t count = baseTypeArray.getCount();
[-] 		DerivableType* baseType = baseTypeArray [i]->getType ();
[+] 		DerivableType* baseType = baseTypeArray[i]->getType();
[-] 		if (baseType->hasIndexerProperties ())
[+] 		if (baseType->hasIndexerProperties())
[-] 			return baseType->chooseIndexerProperty (opValue2);
[+] 			return baseType->chooseIndexerProperty(opValue2);
[-] 	err::setFormatStringError ("'%s' has no indexer properties", derivableType->getTypeString ().sz ());
[+] 	err::setFormatStringError("'%s' has no indexer properties", derivableType->getTypeString ().sz ());
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Logic.cpp
----------------------
[-] BinOp_LogAnd::getResultType (
[+] BinOp_LogAnd::getResultType(
[-] 	return m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 	return m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] BinOp_LogOr::getResultType (
[+] BinOp_LogOr::getResultType(
[-] 	return m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 	return m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp.cpp
----------------------
[-] setCastError (
[+] setCastError(
[-] 	Type* srcType = opValue.getType ();
[+] 	Type* srcType = opValue.getType();
[-] 		ASSERT (opValue.getValueKind () == ValueKind_Function);
[+] 		ASSERT(opValue.getValueKind() == ValueKind_Function);
[-] 		Function* function = opValue.getFunction ();
[+] 		Function* function = opValue.getFunction();
[-] 		return err::setFormatStringError (
[+] 		return err::setFormatStringError(
[-] 			function->getOverloadCount (),
[+] 			function->getOverloadCount(),
[-] 			function->m_tag.sz ()
[+] 			function->m_tag.sz()
[-] 	switch (castKind)
[+] 	switch(castKind)
[-] 	return err::setFormatStringError (
[+] 	return err::setFormatStringError(
[-] 		opValue.getValueKind () == ValueKind_Null ? "null" : opValue.getType ()->getTypeString ().sz (),
[+] 		opValue.getValueKind() == ValueKind_Null ? "null" : opValue.getType ()->getTypeString ().sz (),
[-] 		dstType->getTypeString ().sz ()
[+] 		dstType->getTypeString().sz()
[-] setUnsafeCastError (
[+] setUnsafeCastError(
[-] 	return err::setFormatStringError (
[+] 	return err::setFormatStringError(
[-] 		srcType->getTypeString ().sz (),
[+] 		srcType->getTypeString().sz(),
[-] 		dstType->getTypeString ().sz ()
[+] 		dstType->getTypeString().sz()
[-] castOperator (
[+] castOperator(
[-] 	return module->m_operatorMgr.castOperator (opValue, type, resultValue);
[+] 	return module->m_operatorMgr.castOperator(opValue, type, resultValue);
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] CastOperator::cast (
[+] CastOperator::cast(
[-] 	if (opValue.getValueKind () != ValueKind_Const)
[+] 	if (opValue.getValueKind() != ValueKind_Const)
[-] 		return llvmCast (opValue, type, resultValue);
[+] 		return llvmCast(opValue, type, resultValue);
[-] 	if (type->getTypeKind () == TypeKind_Void)
[+] 	if (type->getTypeKind() == TypeKind_Void)
[-] 		resultValue->setVoid (m_module);
[+] 		resultValue->setVoid(m_module);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> constData (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> constData(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	constData.setCount (type->getSize ());
[+] 	constData.setCount(type->getSize());
[-] 	bool result = constCast (opValue, type, constData);
[+] 	bool result = constCast(opValue, type, constData);
[-] 		resultValue->createConst (constData, type);
[+] 		resultValue->createConst(constData, type);
[-] 	if (m_module->getCompileState () < ModuleCompileState_Compiled)
[+] 	if (m_module->getCompileState() < ModuleCompileState_Compiled)
[-] 		return llvmCast (opValue, type, resultValue);
[+] 		return llvmCast(opValue, type, resultValue);
[-] 	setCastError (opValue, type);
[+] 	setCastError(opValue, type);
[-] Cast_Copy::constCast (
[+] Cast_Copy::constCast(
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (srcSize == dstSize);
[+] 	ASSERT(srcSize == dstSize);
[-] 	memcpy (dst, opValue.getConstData (), dstSize);
[+] 	memcpy(dst, opValue.getConstData(), dstSize);
[-] Cast_Copy::llvmCast (
[+] Cast_Copy::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, type, resultValue);
[-] Cast_Master::getCastKind (
[+] Cast_Master::getCastKind(
[-] 	if (!rawOpValue.getType ())
[+] 	if (!rawOpValue.getType())
[-] 	CastOperator* op = getCastOperator (rawOpValue, type);
[+] 	CastOperator* op = getCastOperator(rawOpValue, type);
[-] 	uint_t opFlags = op->getOpFlags ();
[+] 	uint_t opFlags = op->getOpFlags();
[-] 		m_module->m_operatorMgr.prepareOperandType (&opValue, opFlags);
[+] 		m_module->m_operatorMgr.prepareOperandType(&opValue, opFlags);
[-] 	return op->getCastKind (opValue, type);
[+] 	return op->getCastKind(opValue, type);
[-] Cast_Master::constCast (
[+] Cast_Master::constCast(
[-] 	CastOperator* op = getCastOperator (rawOpValue, type);
[+] 	CastOperator* op = getCastOperator(rawOpValue, type);
[-] 	uint_t opFlags = op->getOpFlags ();
[+] 	uint_t opFlags = op->getOpFlags();
[-] 		bool result = m_module->m_operatorMgr.prepareOperand (&opValue, opFlags);
[+] 		bool result = m_module->m_operatorMgr.prepareOperand(&opValue, opFlags);
[-] 	return op->constCast (opValue, type, dst);
[+] 	return op->constCast(opValue, type, dst);
[-] Cast_Master::llvmCast (
[+] Cast_Master::llvmCast(
[-] 	CastOperator* op = getCastOperator (rawOpValue, type);
[+] 	CastOperator* op = getCastOperator(rawOpValue, type);
[-] 		setCastError (rawOpValue, type);
[+] 		setCastError(rawOpValue, type);
[-] 	uint_t opFlags = op->getOpFlags ();
[+] 	uint_t opFlags = op->getOpFlags();
[-] 		bool result = m_module->m_operatorMgr.prepareOperand (&opValue, opFlags);
[+] 		bool result = m_module->m_operatorMgr.prepareOperand(&opValue, opFlags);
[-] 	return op->llvmCast (opValue, type, resultValue);
[+] 	return op->llvmCast(opValue, type, resultValue);
[-] Cast_SuperMaster::getCastKind (
[+] Cast_SuperMaster::getCastKind(
[-] 	if (!rawOpValue.getType ())
[+] 	if (!rawOpValue.getType())
[-] 	bool result = getCastOperators (
[+] 	bool result = getCastOperators(
[-] 	ASSERT (operator1);
[+] 	ASSERT(operator1);
[-] 	uint_t opFlags1 = operator1->getOpFlags ();
[+] 	uint_t opFlags1 = operator1->getOpFlags();
[-] 		m_module->m_operatorMgr.prepareOperandType (&opValue, opFlags1);
[+] 		m_module->m_operatorMgr.prepareOperandType(&opValue, opFlags1);
[-] 		return operator1->getCastKind (opValue, type);
[+] 		return operator1->getCastKind(opValue, type);
[-] 	CastKind castKind1 = operator1->getCastKind (opValue, intermediateType);
[+] 	CastKind castKind1 = operator1->getCastKind(opValue, intermediateType);
[-] 	CastKind castKind2 = operator2->getCastKind (intermediateType, type);
[+] 	CastKind castKind2 = operator2->getCastKind(intermediateType, type);
[-] 	return AXL_MIN (castKind1, castKind2);
[+] 	return AXL_MIN(castKind1, castKind2);
[-] Cast_SuperMaster::constCast (
[+] Cast_SuperMaster::constCast(
[-] 	bool result = getCastOperators (
[+] 	bool result = getCastOperators(
[-] 	ASSERT (operator1);
[+] 	ASSERT(operator1);
[-] 	uint_t opFlags1 = operator1->getOpFlags ();
[+] 	uint_t opFlags1 = operator1->getOpFlags();
[-] 		bool result = m_module->m_operatorMgr.prepareOperand (&srcValue, opFlags1);
[+] 		bool result = m_module->m_operatorMgr.prepareOperand(&srcValue, opFlags1);
[-] 		return operator1->constCast (srcValue, type, dst);
[+] 		return operator1->constCast(srcValue, type, dst);
[-] 		tmpValue.createConst (NULL, intermediateType) &&
[+] 		tmpValue.createConst(NULL, intermediateType) &&
[-] 		operator1->constCast (srcValue, intermediateType, tmpValue.getConstData ()) &&
[+] 		operator1->constCast(srcValue, intermediateType, tmpValue.getConstData()) &&
[-] 		operator2->constCast (tmpValue, type, dst);
[+] 		operator2->constCast(tmpValue, type, dst);
[-] Cast_SuperMaster::llvmCast (
[+] Cast_SuperMaster::llvmCast(
[-] 	bool result = getCastOperators (
[+] 	bool result = getCastOperators(
[-] 		setCastError (rawOpValue, type);
[+] 		setCastError(rawOpValue, type);
[-] 	ASSERT (operator1);
[+] 	ASSERT(operator1);
[-] 	uint_t opFlags1 = operator1->getOpFlags ();
[+] 	uint_t opFlags1 = operator1->getOpFlags();
[-] 		bool result = m_module->m_operatorMgr.prepareOperand (&opValue, opFlags1);
[+] 		bool result = m_module->m_operatorMgr.prepareOperand(&opValue, opFlags1);
[-] 		return operator1->llvmCast (opValue, type, resultValue);
[+] 		return operator1->llvmCast(opValue, type, resultValue);
[-] 		operator1->llvmCast (opValue, intermediateType, &tmpValue) &&
[+] 		operator1->llvmCast(opValue, intermediateType, &tmpValue) &&
[-] 		operator2->llvmCast (tmpValue, type, resultValue);
[+] 		operator2->llvmCast(tmpValue, type, resultValue);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Array.cpp
----------------------
[-] Cast_Array::getCastKind (
[+] Cast_Array::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Array);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Array);
[-] 	ArrayType* dstArrayType = (ArrayType*) type;
[+] 	ArrayType* dstArrayType = (ArrayType*)type;
[-] 	Type* dstElementType = dstArrayType->getElementType ();
[+] 	Type* dstElementType = dstArrayType->getElementType();
[-] 	size_t dstElementCount = dstArrayType->getElementCount ();
[+] 	size_t dstElementCount = dstArrayType->getElementCount();
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	if (opType->getTypeKind () == TypeKind_DataRef)
[+] 	if (opType->getTypeKind() == TypeKind_DataRef)
[-] 		opType = ((DataPtrType*) opType)->getTargetType ();
[+] 		opType = ((DataPtrType*)opType)->getTargetType();
[-] 	if (opType->getTypeKind () != TypeKind_Array)
[+] 	if (opType->getTypeKind() != TypeKind_Array)
[-] 	ArrayType* srcArrayType = (ArrayType*) opType;
[+] 	ArrayType* srcArrayType = (ArrayType*)opType;
[-] 	Type* srcElementType = srcArrayType->getElementType ();
[+] 	Type* srcElementType = srcArrayType->getElementType();
[-] 	size_t srcElementCount = srcArrayType->getElementCount ();
[+] 	size_t srcElementCount = srcArrayType->getElementCount();
[-] 		dstElementType->cmp (srcElementType) == 0 ||
[+] 		dstElementType->cmp(srcElementType) == 0 ||
[-] 		(dstElementType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 		(dstElementType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		(srcElementType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 		(srcElementType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		dstElementType->getSize () == srcElementType->getSize() ?
[+] 		dstElementType->getSize() == srcElementType->getSize() ?
[-] Cast_Array::constCast (
[+] Cast_Array::constCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Array);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Array);
[-] 	ArrayType* dstArrayType = (ArrayType*) type;
[+] 	ArrayType* dstArrayType = (ArrayType*)type;
[-] 	Type* dstElementType = dstArrayType->getElementType ();
[+] 	Type* dstElementType = dstArrayType->getElementType();
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	if (opType->getTypeKind () != TypeKind_Array)
[+] 	if (opType->getTypeKind() != TypeKind_Array)
[-] 	ArrayType* srcArrayType = (ArrayType*) opType;
[+] 	ArrayType* srcArrayType = (ArrayType*)opType;
[-] 	Type* srcElementType = srcArrayType->getElementType ();
[+] 	Type* srcElementType = srcArrayType->getElementType();
[-] 	if (dstElementType->cmp (srcElementType) == 0 ||
[+] 	if (dstElementType->cmp(srcElementType) == 0 ||
[-] 		(dstElementType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 		(dstElementType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		(srcElementType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 		(srcElementType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		dstElementType->getSize () == srcElementType->getSize())
[+] 		dstElementType->getSize() == srcElementType->getSize())
[-] 		size_t dstSize = type->getSize ();
[+] 		size_t dstSize = type->getSize();
[-] 		size_t srcSize = srcArrayType->getSize ();
[+] 		size_t srcSize = srcArrayType->getSize();
[-] 		memcpy (dst, opValue.getConstData (), AXL_MIN (srcSize, dstSize));
[+] 		memcpy(dst, opValue.getConstData(), AXL_MIN(srcSize, dstSize));
[-] Cast_Array::llvmCast (
[+] Cast_Array::llvmCast(
[-] 	err::setFormatStringError ("CCast_Array::LlvmCast is not yet implemented");
[+] 	err::setFormatStringError("CCast_Array::LlvmCast is not yet implemented");
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Bool.cpp
----------------------
[-] Cast_BoolFromZeroCmp::constCast (
[+] Cast_BoolFromZeroCmp::constCast(
[-] 	const char* p = (const char*) opValue.getConstData ();
[+] 	const char* p = (const char*) opValue.getConstData();
[-] 	const char* end = p + opValue.getType ()->getSize ();
[+] 	const char* end = p + opValue.getType()->getSize();
[-] 	*(bool*) dst = result;
[+] 	*(bool*)dst = result;
[-] Cast_BoolFromZeroCmp::llvmCast (
[+] Cast_BoolFromZeroCmp::llvmCast(
[-] 	Value zeroValue = opValue.getType ()->getZeroValue ();
[+] 	Value zeroValue = opValue.getType()->getZeroValue();
[-] 	return m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, opValue, zeroValue, resultValue);
[+] 	return m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, opValue, zeroValue, resultValue);
[-] Cast_BoolFromPtr::llvmCast (
[+] Cast_BoolFromPtr::llvmCast(
[-] 	if (opValue.getType ()->getSize () == sizeof (void*))
[+] 	if (opValue.getType()->getSize() == sizeof(void*))
[-] 		return Cast_BoolFromZeroCmp::llvmCast (opValue, type, resultValue);
[+] 		return Cast_BoolFromZeroCmp::llvmCast(opValue, type, resultValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 	return Cast_BoolFromZeroCmp::llvmCast (ptrValue, type, resultValue);
[+] 	return Cast_BoolFromZeroCmp::llvmCast(ptrValue, type, resultValue);
[-] Cast_IntFromBool::constCast (
[+] Cast_IntFromBool::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Bool);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Bool);
[-] 	memset (dst, 0, type->getSize ());
[+] 	memset(dst, 0, type->getSize());
[-] 	if (*(bool*) opValue.getConstData ())
[+] 	if (*(bool*)opValue.getConstData())
[-] 		*(char*) dst = 1;
[+] 		*(char*)dst = 1;
[-] Cast_IntFromBool::llvmCast (
[+] Cast_IntFromBool::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Bool);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Bool);
[-] 	m_module->m_llvmIrBuilder.createExt_u (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createExt_u(opValue, type, resultValue);
[-] Cast_Bool::getCastOperator (
[+] Cast_Bool::getCastOperator(
[-] 	TypeKind srcTypeKind = opValue.getType ()->getTypeKind ();
[+] 	TypeKind srcTypeKind = opValue.getType()->getTypeKind();
[-] 	switch (srcTypeKind)
[+] 	switch(srcTypeKind)
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_ClassPtr.cpp
----------------------
[-] isMulticastToMulticast (
[+] isMulticastToMulticast(
[-] 	if (srcType->getTargetType ()->getClassTypeKind () != ClassTypeKind_Multicast ||
[+] 	if (srcType->getTargetType()->getClassTypeKind() != ClassTypeKind_Multicast ||
[-] 		dstType->getTargetType ()->getClassTypeKind () != ClassTypeKind_Multicast)
[+] 		dstType->getTargetType()->getClassTypeKind() != ClassTypeKind_Multicast)
[-] 	if ((srcType->getFlags () & PtrTypeFlag_Event) && !(dstType->getFlags () & PtrTypeFlag_Event))
[+] 	if ((srcType->getFlags() & PtrTypeFlag_Event) && !(dstType->getFlags() & PtrTypeFlag_Event))
[-] 	MulticastClassType* srcMcType = (MulticastClassType*) srcType->getTargetType ();
[+] 	MulticastClassType* srcMcType = (MulticastClassType*)srcType->getTargetType();
[-] 	MulticastClassType* dstMcType = (MulticastClassType*) dstType->getTargetType ();
[+] 	MulticastClassType* dstMcType = (MulticastClassType*)dstType->getTargetType();
[-] 	return srcMcType->getTargetType ()->cmp (dstMcType->getTargetType ()) == 0;
[+] 	return srcMcType->getTargetType()->cmp(dstMcType->getTargetType()) == 0;
[-] Cast_ClassPtr::getCastKind (
[+] Cast_ClassPtr::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_ClassPtr);
[-] 	if (opValue.getType ()->getTypeKind () != TypeKind_ClassPtr)
[+] 	if (opValue.getType()->getTypeKind() != TypeKind_ClassPtr)
[-] 	ClassPtrType* srcType = (ClassPtrType*) opValue.getType ();
[+] 	ClassPtrType* srcType = (ClassPtrType*)opValue.getType();
[-] 	ClassPtrType* dstType = (ClassPtrType*) type;
[+] 	ClassPtrType* dstType = (ClassPtrType*)type;
[-] 	if ((srcType->getFlags () & PtrTypeFlag_Const) &&
[+] 	if ((srcType->getFlags() & PtrTypeFlag_Const) &&
[-] 		!(dstType->getFlags () & PtrTypeFlag_Const))
[+] 		!(dstType->getFlags() & PtrTypeFlag_Const))
[-] 	ClassType* srcClassType = srcType->getTargetType ();
[+] 	ClassType* srcClassType = srcType->getTargetType();
[-] 	ClassType* dstClassType = dstType->getTargetType ();
[+] 	ClassType* dstClassType = dstType->getTargetType();
[-] 		(dstClassType->getClassTypeKind () == ClassTypeKind_Abstract) ||
[+] 		(dstClassType->getClassTypeKind() == ClassTypeKind_Abstract) ||
[-] 		srcClassType->cmp (dstClassType) == 0 ||
[+] 		srcClassType->cmp(dstClassType) == 0 ||
[-] 		isMulticastToMulticast (srcType, dstType) ||
[+] 		isMulticastToMulticast(srcType, dstType) ||
[-] 		srcClassType->findBaseTypeTraverse (dstClassType) ?
[+] 		srcClassType->findBaseTypeTraverse(dstClassType) ?
[-] Cast_ClassPtr::constCast (
[+] Cast_ClassPtr::constCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_ClassPtr);
[-] 	if (opValue.getType ()->getTypeKind () != TypeKind_ClassPtr)
[+] 	if (opValue.getType()->getTypeKind() != TypeKind_ClassPtr)
[-] 	IfaceHdr* srcIface = *(IfaceHdr**) opValue.getConstData ();
[+] 	IfaceHdr* srcIface = *(IfaceHdr**) opValue.getConstData();
[-] 	ClassType* srcClassType = (ClassType*) srcIface->m_box->m_type;
[+] 	ClassType* srcClassType = (ClassType*)srcIface->m_box->m_type;
[-] 	ClassPtrType* srcType = (ClassPtrType*) opValue.getType ();
[+] 	ClassPtrType* srcType = (ClassPtrType*)opValue.getType();
[-] 	ClassPtrType* dstType = (ClassPtrType*) type;
[+] 	ClassPtrType* dstType = (ClassPtrType*)type;
[-] 	ClassType* dstClassType = dstType->getTargetType ();
[+] 	ClassType* dstClassType = dstType->getTargetType();
[-] 	if (dstType->getFlags () & PtrTypeFlag_Safe)
[+] 	if (dstType->getFlags() & PtrTypeFlag_Safe)
[-] 		m_module->m_operatorMgr.checkNullPtr (opValue);
[+] 		m_module->m_operatorMgr.checkNullPtr(opValue);
[-] 		dstClassType->getClassTypeKind () == ClassTypeKind_Abstract ||
[+] 		dstClassType->getClassTypeKind() == ClassTypeKind_Abstract ||
[-] 		isMulticastToMulticast (srcType, dstType) ||
[+] 		isMulticastToMulticast(srcType, dstType) ||
[-] 		srcClassType->cmp (dstClassType) == 0)
[+] 		srcClassType->cmp(dstClassType) == 0)
[-] 	result = srcClassType->findBaseTypeTraverse (dstClassType, &coord);
[+] 	result = srcClassType->findBaseTypeTraverse(dstClassType, &coord);
[-] 	*(void**) dst = (char*) srcIface + coord.m_offset;
[+] 	*(void**) dst = (char*)srcIface + coord.m_offset;
[-] Cast_ClassPtr::llvmCast (
[+] Cast_ClassPtr::llvmCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_ClassPtr);
[-] 	if (rawOpValue.getType ()->getTypeKind () != TypeKind_ClassPtr)
[+] 	if (rawOpValue.getType()->getTypeKind() != TypeKind_ClassPtr)
[-] 		setCastError (rawOpValue, type);
[+] 		setCastError(rawOpValue, type);
[-] 	ClassPtrType* srcType = (ClassPtrType*) rawOpValue.getType ();
[+] 	ClassPtrType* srcType = (ClassPtrType*)rawOpValue.getType();
[-] 	ClassPtrType* dstType = (ClassPtrType*) type;
[+] 	ClassPtrType* dstType = (ClassPtrType*)type;
[-] 	if (srcType->getPtrTypeKind () == ClassPtrTypeKind_Weak &&
[+] 	if (srcType->getPtrTypeKind() == ClassPtrTypeKind_Weak &&
[-] 		dstType->getPtrTypeKind () != ClassPtrTypeKind_Weak)
[+] 		dstType->getPtrTypeKind() != ClassPtrTypeKind_Weak)
[-] 		Function* strengthen = m_module->m_functionMgr.getStdFunction (StdFunc_StrengthenClassPtr);
[+] 		Function* strengthen = m_module->m_functionMgr.getStdFunction(StdFunc_StrengthenClassPtr);
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &opValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &opValue);
[-] 		m_module->m_llvmIrBuilder.createCall (
[+] 		m_module->m_llvmIrBuilder.createCall(
[-] 			strengthen->getType (),
[+] 			strengthen->getType(),
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, srcType, &opValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, srcType, &opValue);
[-] 	ClassType* srcClassType = srcType->getTargetType ();
[+] 	ClassType* srcClassType = srcType->getTargetType();
[-] 	ClassType* dstClassType = dstType->getTargetType ();
[+] 	ClassType* dstClassType = dstType->getTargetType();
[-] 	if (dstType->getFlags () & PtrTypeFlag_Safe)
[+] 	if (dstType->getFlags() & PtrTypeFlag_Safe)
[-] 		m_module->m_operatorMgr.checkNullPtr (opValue);
[+] 		m_module->m_operatorMgr.checkNullPtr(opValue);
[-] 	if (dstClassType->getClassTypeKind () == ClassTypeKind_Abstract ||
[+] 	if (dstClassType->getClassTypeKind() == ClassTypeKind_Abstract ||
[-] 		isMulticastToMulticast (srcType, dstType))
[+] 		isMulticastToMulticast(srcType, dstType))
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, dstType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, dstType, resultValue);
[-] 	if (srcClassType->cmp (dstClassType) == 0)
[+] 	if (srcClassType->cmp(dstClassType) == 0)
[-] 		resultValue->overrideType (opValue, type);
[+] 		resultValue->overrideType(opValue, type);
[-] 	result = srcClassType->findBaseTypeTraverse (dstClassType, &coord);
[+] 	result = srcClassType->findBaseTypeTraverse(dstClassType, &coord);
[-] 		setCastError (opValue, type, CastKind_Dynamic);
[+] 		setCastError(opValue, type, CastKind_Dynamic);
[-] 	if (srcType->getFlags () & PtrTypeFlag_Safe) // non-null guarantee
[+] 	if (srcType->getFlags() & PtrTypeFlag_Safe) // non-null guarantee
[-] 		coord.m_llvmIndexArray.insert (0, 0);
[+] 		coord.m_llvmIndexArray.insert(0, 0);
[-] 		m_module->m_llvmIrBuilder.createGep (
[+] 		m_module->m_llvmIrBuilder.createGep(
[-] 			coord.m_llvmIndexArray.getCount (),
[+] 			coord.m_llvmIndexArray.getCount(),
[-] 	Value srcNullValue = srcType->getZeroValue ();
[+] 	Value srcNullValue = srcType->getZeroValue();
[-] 	Value dstNullValue = dstType->getZeroValue ();
[+] 	Value dstNullValue = dstType->getZeroValue();
[-] 	BasicBlock* cmpBlock = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* cmpBlock = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock ("iface_phi");
[+] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock("iface_phi");
[-] 	BasicBlock* noNullBlock = m_module->m_controlFlowMgr.createBlock ("iface_nonull");
[+] 	BasicBlock* noNullBlock = m_module->m_controlFlowMgr.createBlock("iface_nonull");
[-] 		m_module->m_operatorMgr.binaryOperator (BinOpKind_Eq, opValue, srcNullValue, &cmpValue) &&
[+] 		m_module->m_operatorMgr.binaryOperator(BinOpKind_Eq, opValue, srcNullValue, &cmpValue) &&
[-] 		m_module->m_controlFlowMgr.conditionalJump (cmpValue, phiBlock, noNullBlock, noNullBlock);
[+] 		m_module->m_controlFlowMgr.conditionalJump(cmpValue, phiBlock, noNullBlock, noNullBlock);
[-] 	coord.m_llvmIndexArray.insert (0, 0);
[+] 	coord.m_llvmIndexArray.insert(0, 0);
[-] 	m_module->m_llvmIrBuilder.createGep (
[+] 	m_module->m_llvmIrBuilder.createGep(
[-] 		coord.m_llvmIndexArray.getCount (),
[+] 		coord.m_llvmIndexArray.getCount(),
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	m_module->m_llvmIrBuilder.createPhi (ptrValue, noNullBlock, dstNullValue, cmpBlock, resultValue);
[+] 	m_module->m_llvmIrBuilder.createPhi(ptrValue, noNullBlock, dstNullValue, cmpBlock, resultValue);
[-] 	resultValue->overrideType (dstType);
[+] 	resultValue->overrideType(dstType);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_DataPtr.cpp
----------------------
[-] Cast_DataPtr_FromArray::getCastKind (
[+] Cast_DataPtr_FromArray::getCastKind(
[-] 	if (isArrayRefType (opValue.getType ()))
[+] 	if (isArrayRefType(opValue.getType()))
[-] 		Value ptrValue = m_module->m_operatorMgr.prepareOperandType (opValue, OpFlag_ArrayRefToPtr);
[+] 		Value ptrValue = m_module->m_operatorMgr.prepareOperandType(opValue, OpFlag_ArrayRefToPtr);
[-] 		return m_module->m_operatorMgr.getCastKind (ptrValue, type);
[+] 		return m_module->m_operatorMgr.getCastKind(ptrValue, type);
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Array);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Array);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	ArrayType* srcType = (ArrayType*) opValue.getType ();
[+] 	ArrayType* srcType = (ArrayType*)opValue.getType();
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	Type* arrayElementType = srcType->getElementType ();
[+] 	Type* arrayElementType = srcType->getElementType();
[-] 	Type* ptrDataType = dstType->getTargetType ();
[+] 	Type* ptrDataType = dstType->getTargetType();
[-] 		arrayElementType->cmp (ptrDataType) == 0 ? CastKind_Implicit :
[+] 		arrayElementType->cmp(ptrDataType) == 0 ? CastKind_Implicit :
[-] 		(arrayElementType->getFlags () & TypeFlag_Pod) ?
[+] 		(arrayElementType->getFlags() & TypeFlag_Pod) ?
[-] 			ptrDataType->getTypeKind () == TypeKind_Void ? CastKind_Implicit :
[+] 			ptrDataType->getTypeKind() == TypeKind_Void ? CastKind_Implicit :
[-] 			(ptrDataType->getFlags () & TypeFlag_Pod) ? CastKind_Explicit : CastKind_None : CastKind_None;
[+] 			(ptrDataType->getFlags() & TypeFlag_Pod) ? CastKind_Explicit : CastKind_None : CastKind_None;
[-] Cast_DataPtr_FromArray::constCast (
[+] Cast_DataPtr_FromArray::constCast(
[-] 	if (isArrayRefType (opValue.getType ()))
[+] 	if (isArrayRefType(opValue.getType()))
[-] 			m_module->m_operatorMgr.prepareOperand (opValue, &ptrValue, OpFlag_ArrayRefToPtr) &&
[+] 			m_module->m_operatorMgr.prepareOperand(opValue, &ptrValue, OpFlag_ArrayRefToPtr) &&
[-] 			m_module->m_operatorMgr.castOperator (&ptrValue, type);
[+] 			m_module->m_operatorMgr.castOperator(&ptrValue, type);
[-] 		const void* p = ptrValue.getConstData ();
[+] 		const void* p = ptrValue.getConstData();
[-] 		if (((DataPtrType*) type)->getPtrTypeKind () == DataPtrTypeKind_Normal)
[+] 		if (((DataPtrType*)type)->getPtrTypeKind() == DataPtrTypeKind_Normal)
[-] 			*(DataPtr*) dst = *(DataPtr*) p;
[+] 			*(DataPtr*)dst = *(DataPtr*)p;
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Array);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Array);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	ArrayType* srcType = (ArrayType*) opValue.getType ();
[+] 	ArrayType* srcType = (ArrayType*)opValue.getType();
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	const Value& savedOpValue = m_module->m_constMgr.saveValue (opValue);
[+] 	const Value& savedOpValue = m_module->m_constMgr.saveValue(opValue);
[-] 	const void* p = savedOpValue.getConstData ();
[+] 	const void* p = savedOpValue.getConstData();
[-] 	AXL_TODO ("create a global constant holding the array")
[+] 	AXL_TODO("create a global constant holding the array")
[-] 	if (dstType->getPtrTypeKind () == DataPtrTypeKind_Normal)
[+] 	if (dstType->getPtrTypeKind() == DataPtrTypeKind_Normal)
[-] 		DataPtr* ptr = (DataPtr*) dst;
[+] 		DataPtr* ptr = (DataPtr*)dst;
[-] 		ptr->m_p = (void*) p;
[+] 		ptr->m_p = (void*)p;
[-] 		ptr->m_validator = m_module->m_constMgr.createConstDataPtrValidator (p, srcType);
[+] 		ptr->m_validator = m_module->m_constMgr.createConstDataPtrValidator(p, srcType);
[-] Cast_DataPtr_FromArray::llvmCast (
[+] Cast_DataPtr_FromArray::llvmCast(
[-] 	if (isArrayRefType (opValue.getType ()))
[+] 	if (isArrayRefType(opValue.getType()))
[-] 			m_module->m_operatorMgr.prepareOperand (opValue, &ptrValue, OpFlag_ArrayRefToPtr) &&
[+] 			m_module->m_operatorMgr.prepareOperand(opValue, &ptrValue, OpFlag_ArrayRefToPtr) &&
[-] 			m_module->m_operatorMgr.castOperator (ptrValue, type, resultValue);
[+] 			m_module->m_operatorMgr.castOperator(ptrValue, type, resultValue);
[-] 	err::setFormatStringError ("casting from array to pointer is currently only implemented for constants");
[+] 	err::setFormatStringError("casting from array to pointer is currently only implemented for constants");
[-] Cast_DataPtr_FromClassPtr::getCastKind (
[+] Cast_DataPtr_FromClassPtr::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	ClassPtrType* srcType = (ClassPtrType*) opValue.getType ();
[+] 	ClassPtrType* srcType = (ClassPtrType*)opValue.getType();
[-] 		(srcType->getFlags () & PtrTypeFlag_Const) && !(srcType->getFlags () & PtrTypeFlag_Const) ? CastKind_None :
[+] 		(srcType->getFlags() & PtrTypeFlag_Const) && !(srcType->getFlags() & PtrTypeFlag_Const) ? CastKind_None :
[-] 		dstType->getPtrTypeKind () != DataPtrTypeKind_Thin ? CastKind_None :
[+] 		dstType->getPtrTypeKind() != DataPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getTargetType ()->getTypeKind () == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[+] 		dstType->getTargetType()->getTypeKind() == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[-] Cast_DataPtr_FromClassPtr::llvmCast (
[+] Cast_DataPtr_FromClassPtr::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	ClassPtrType* srcType = (ClassPtrType*) opValue.getType ();
[+] 	ClassPtrType* srcType = (ClassPtrType*)opValue.getType();
[-] 	if ((srcType->getFlags () & PtrTypeFlag_Const) && !(srcType->getFlags () & PtrTypeFlag_Const))
[+] 	if ((srcType->getFlags() & PtrTypeFlag_Const) && !(srcType->getFlags() & PtrTypeFlag_Const))
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	if (dstType->getPtrTypeKind () == DataPtrTypeKind_Thin)
[+] 	if (dstType->getPtrTypeKind() == DataPtrTypeKind_Thin)
[-] 		err::setFormatStringError ("casting from class pointer to fat data pointer is not yet implemented (thin only for now)");
[+] 		err::setFormatStringError("casting from class pointer to fat data pointer is not yet implemented (thin only for now)");
[-] 	if (!m_module->m_operatorMgr.isUnsafeRgn ())
[+] 	if (!m_module->m_operatorMgr.isUnsafeRgn())
[-] 		setUnsafeCastError (srcType, dstType);
[+] 		setUnsafeCastError(srcType, dstType);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, type, resultValue);
[-] Cast_DataPtr_FromFunctionPtr::getCastKind (
[+] Cast_DataPtr_FromFunctionPtr::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	FunctionPtrType* srcType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* srcType = (FunctionPtrType*)opValue.getType();
[-] 		srcType->getPtrTypeKind () != FunctionPtrTypeKind_Thin ? CastKind_None :
[+] 		srcType->getPtrTypeKind() != FunctionPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getPtrTypeKind () != DataPtrTypeKind_Thin ? CastKind_None :
[+] 		dstType->getPtrTypeKind() != DataPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getTargetType ()->getTypeKind () == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[+] 		dstType->getTargetType()->getTypeKind() == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[-] Cast_DataPtr_FromFunctionPtr::llvmCast (
[+] Cast_DataPtr_FromFunctionPtr::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	FunctionPtrType* srcType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* srcType = (FunctionPtrType*)opValue.getType();
[-] 	if (srcType->getPtrTypeKind () != FunctionPtrTypeKind_Thin ||
[+] 	if (srcType->getPtrTypeKind() != FunctionPtrTypeKind_Thin ||
[-] 		dstType->getPtrTypeKind () != DataPtrTypeKind_Thin)
[+] 		dstType->getPtrTypeKind() != DataPtrTypeKind_Thin)
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	if (!m_module->m_operatorMgr.isUnsafeRgn ())
[+] 	if (!m_module->m_operatorMgr.isUnsafeRgn())
[-] 		setUnsafeCastError (srcType, dstType);
[+] 		setUnsafeCastError(srcType, dstType);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, type, resultValue);
[-] Cast_DataPtr_FromPropertyPtr::getCastKind (
[+] Cast_DataPtr_FromPropertyPtr::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	PropertyPtrType* srcType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* srcType = (PropertyPtrType*)opValue.getType();
[-] 		srcType->getPtrTypeKind () != PropertyPtrTypeKind_Thin ? CastKind_None :
[+] 		srcType->getPtrTypeKind() != PropertyPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getPtrTypeKind () != DataPtrTypeKind_Thin ? CastKind_None :
[+] 		dstType->getPtrTypeKind() != DataPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getTargetType ()->getTypeKind () == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[+] 		dstType->getTargetType()->getTypeKind() == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[-] Cast_DataPtr_FromPropertyPtr::llvmCast (
[+] Cast_DataPtr_FromPropertyPtr::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	PropertyPtrType* srcType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* srcType = (PropertyPtrType*)opValue.getType();
[-] 	if (srcType->getPtrTypeKind () != PropertyPtrTypeKind_Thin ||
[+] 	if (srcType->getPtrTypeKind() != PropertyPtrTypeKind_Thin ||
[-] 		dstType->getPtrTypeKind () != DataPtrTypeKind_Thin)
[+] 		dstType->getPtrTypeKind() != DataPtrTypeKind_Thin)
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	if (!m_module->m_operatorMgr.isUnsafeRgn ())
[+] 	if (!m_module->m_operatorMgr.isUnsafeRgn())
[-] 		setUnsafeCastError (srcType, dstType);
[+] 		setUnsafeCastError(srcType, dstType);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, type, resultValue);
[-] Cast_DataPtr_Base::getCastKind (
[+] Cast_DataPtr_Base::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* srcType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcType = (DataPtrType*)opValue.getType();
[-] 	DataPtrType* dstType = (DataPtrType*) type;
[+] 	DataPtrType* dstType = (DataPtrType*)type;
[-] 	bool isSrcConst = (srcType->getFlags () & PtrTypeFlag_Const) != 0;
[+] 	bool isSrcConst = (srcType->getFlags() & PtrTypeFlag_Const) != 0;
[-] 	bool isDstConst = (dstType->getFlags () & PtrTypeFlag_Const) != 0;
[+] 	bool isDstConst = (dstType->getFlags() & PtrTypeFlag_Const) != 0;
[-] 	Type* srcDataType = srcType->getTargetType ();
[+] 	Type* srcDataType = srcType->getTargetType();
[-] 	Type* dstDataType = dstType->getTargetType ();
[+] 	Type* dstDataType = dstType->getTargetType();
[-] 	if (srcDataType->cmp (dstDataType) == 0)
[+] 	if (srcDataType->cmp(dstDataType) == 0)
[-] 	bool isSrcPod = (srcDataType->getFlags () & TypeFlag_Pod) != 0;
[+] 	bool isSrcPod = (srcDataType->getFlags() & TypeFlag_Pod) != 0;
[-] 	bool isDstPod = (dstDataType->getFlags () & TypeFlag_Pod) != 0;
[+] 	bool isDstPod = (dstDataType->getFlags() & TypeFlag_Pod) != 0;
[-] 	bool isDstDerivable = (dstDataType->getTypeKindFlags () & TypeKindFlag_Derivable) != 0;
[+] 	bool isDstDerivable = (dstDataType->getTypeKindFlags() & TypeKindFlag_Derivable) != 0;
[-] 	bool canCastToPod = isSrcPod || isDstConst || dstType->getPtrTypeKind () == DataPtrTypeKind_Thin;
[+] 	bool canCastToPod = isSrcPod || isDstConst || dstType->getPtrTypeKind() == DataPtrTypeKind_Thin;
[-] 	if (dstDataType->getStdType () == StdType_AbstractData ||
[+] 	if (dstDataType->getStdType() == StdType_AbstractData ||
[-] 		dstDataType->getTypeKind () == TypeKind_Void && canCastToPod)
[+] 		dstDataType->getTypeKind() == TypeKind_Void && canCastToPod)
[-] 	if (srcDataType->getTypeKind () == TypeKind_Void &&
[+] 	if (srcDataType->getTypeKind() == TypeKind_Void &&
[-] 		(dstDataType->getTypeKind () == TypeKind_Int8 || dstDataType->getTypeKind () == TypeKind_Int8_u))
[+] 		(dstDataType->getTypeKind() == TypeKind_Int8 || dstDataType->getTypeKind() == TypeKind_Int8_u))
[-] 	if ((srcDataType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 	if ((srcDataType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		(dstDataType->getTypeKindFlags () & TypeKindFlag_Integer) &&
[+] 		(dstDataType->getTypeKindFlags() & TypeKindFlag_Integer) &&
[-] 		srcDataType->getSize () == dstDataType->getSize ())
[+] 		srcDataType->getSize() == dstDataType->getSize())
[-] 		srcDataType->getTypeKind () == TypeKind_Struct &&
[+] 		srcDataType->getTypeKind() == TypeKind_Struct &&
[-] 		((StructType*) srcDataType)->findBaseTypeTraverse (dstDataType);
[+] 		((StructType*)srcDataType)->findBaseTypeTraverse(dstDataType);
[-] Cast_DataPtr_Base::getOffset (
[+] Cast_DataPtr_Base::getOffset(
[-] 	bool isSrcConst = (srcType->getFlags () & PtrTypeFlag_Const) != 0;
[+] 	bool isSrcConst = (srcType->getFlags() & PtrTypeFlag_Const) != 0;
[-] 	bool isDstConst = (dstType->getFlags () & PtrTypeFlag_Const) != 0;
[+] 	bool isDstConst = (dstType->getFlags() & PtrTypeFlag_Const) != 0;
[-] 		setCastError (srcType, dstType);
[+] 		setCastError(srcType, dstType);
[-] 	Type* srcDataType = srcType->getTargetType ();
[+] 	Type* srcDataType = srcType->getTargetType();
[-] 	Type* dstDataType = dstType->getTargetType ();
[+] 	Type* dstDataType = dstType->getTargetType();
[-] 	if (srcDataType->cmp (dstDataType) == 0)
[+] 	if (srcDataType->cmp(dstDataType) == 0)
[-] 	bool isSrcPod = (srcDataType->getFlags () & TypeFlag_Pod) != 0;
[+] 	bool isSrcPod = (srcDataType->getFlags() & TypeFlag_Pod) != 0;
[-] 	bool isDstPod = (dstDataType->getFlags () & TypeFlag_Pod) != 0;
[+] 	bool isDstPod = (dstDataType->getFlags() & TypeFlag_Pod) != 0;
[-] 	bool isDstDerivable = (dstDataType->getTypeKindFlags () & TypeKindFlag_Derivable) != 0;
[+] 	bool isDstDerivable = (dstDataType->getTypeKindFlags() & TypeKindFlag_Derivable) != 0;
[-] 	bool canCastToPod = isSrcPod || isDstConst || dstType->getPtrTypeKind () == DataPtrTypeKind_Thin;
[+] 	bool canCastToPod = isSrcPod || isDstConst || dstType->getPtrTypeKind() == DataPtrTypeKind_Thin;
[-] 	if (dstDataType->getStdType () == StdType_AbstractData ||
[+] 	if (dstDataType->getStdType() == StdType_AbstractData ||
[-] 		dstDataType->getTypeKind () == TypeKind_Void && canCastToPod)
[+] 		dstDataType->getTypeKind() == TypeKind_Void && canCastToPod)
[-] 		srcDataType->getTypeKind () == TypeKind_Struct &&
[+] 		srcDataType->getTypeKind() == TypeKind_Struct &&
[-] 		((StructType*) srcDataType)->findBaseTypeTraverse (dstDataType, coord);
[+] 		((StructType*)srcDataType)->findBaseTypeTraverse(dstDataType, coord);
[-] 	setCastError (srcType, dstType, castKind);
[+] 	setCastError(srcType, dstType, castKind);
[-] Cast_DataPtr_Base::getOffsetUnsafePtrValue (
[+] Cast_DataPtr_Base::getOffsetUnsafePtrValue(
[-] 	size_t offset = getOffset (srcType, dstType, &coord);
[+] 	size_t offset = getOffset(srcType, dstType, &coord);
[-] 		dstType = (DataPtrType*) m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 		dstType = (DataPtrType*)m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	else if (dstType->getPtrTypeKind () != DataPtrTypeKind_Thin)
[+] 	else if (dstType->getPtrTypeKind() != DataPtrTypeKind_Thin)
[-] 		dstType = dstType->getTargetType ()->getDataPtrType_c ();
[+] 		dstType = dstType->getTargetType()->getDataPtrType_c();
[-] 	if (!coord.m_llvmIndexArray.isEmpty ())
[+] 	if (!coord.m_llvmIndexArray.isEmpty())
[-] 		coord.m_llvmIndexArray.insert (0, 0);
[+] 		coord.m_llvmIndexArray.insert(0, 0);
[-] 		srcType = srcType->getTargetType ()->getDataPtrType_c ();
[+] 		srcType = srcType->getTargetType()->getDataPtrType_c();
[-] 		m_module->m_llvmIrBuilder.createBitCast (ptrValue, srcType, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(ptrValue, srcType, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createGep (
[+] 		m_module->m_llvmIrBuilder.createGep(
[-] 			coord.m_llvmIndexArray.getCount (),
[+] 			coord.m_llvmIndexArray.getCount(),
[-] 			m_module->m_llvmIrBuilder.createBitCast (tmpValue, dstType, resultValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(tmpValue, dstType, resultValue);
[-] 	ASSERT (offset == 0);
[+] 	ASSERT(offset == 0);
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, dstType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, dstType, resultValue);
[-] Cast_DataPtr_Normal2Normal::constCast (
[+] Cast_DataPtr_Normal2Normal::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	size_t offset = getOffset ((DataPtrType*) opValue.getType (), (DataPtrType*) type, NULL);
[+] 	size_t offset = getOffset((DataPtrType*)opValue.getType(), (DataPtrType*)type, NULL);
[-] 	DataPtr* dstPtr = (DataPtr*) dst;
[+] 	DataPtr* dstPtr = (DataPtr*)dst;
[-] 	DataPtr* srcPtr = (DataPtr*) opValue.getConstData ();
[+] 	DataPtr* srcPtr = (DataPtr*)opValue.getConstData();
[-] 	dstPtr->m_p = (char*) srcPtr->m_p + offset;
[+] 	dstPtr->m_p = (char*)srcPtr->m_p + offset;
[-] Cast_DataPtr_Normal2Normal::llvmCast (
[+] Cast_DataPtr_Normal2Normal::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	if (type->getFlags () & PtrTypeFlag_Safe)
[+] 	if (type->getFlags() & PtrTypeFlag_Safe)
[-] 		result = m_module->m_operatorMgr.checkDataPtrRange (opValue);
[+] 		result = m_module->m_operatorMgr.checkDataPtrRange(opValue);
[-] 	size_t offset = getOffset ((DataPtrType*) opValue.getType (), (DataPtrType*) type, &coord);
[+] 	size_t offset = getOffset((DataPtrType*)opValue.getType(), (DataPtrType*)type, &coord);
[-] 		resultValue->overrideType (opValue, type);
[+] 		resultValue->overrideType(opValue, type);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 	result = getOffsetUnsafePtrValue (ptrValue, (DataPtrType*) opValue.getType (), (DataPtrType*) type, true, &ptrValue);
[+] 	result = getOffsetUnsafePtrValue(ptrValue, (DataPtrType*)opValue.getType(), (DataPtrType*)type, true, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createInsertValue (opValue, ptrValue, 0, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createInsertValue(opValue, ptrValue, 0, type, resultValue);
[-] Cast_DataPtr_Lean2Normal::constCast (
[+] Cast_DataPtr_Lean2Normal::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* srcPtrType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcPtrType = (DataPtrType*)opValue.getType();
[-] 	ASSERT (srcPtrType->getPtrTypeKind () == DataPtrTypeKind_Lean);
[+] 	ASSERT(srcPtrType->getPtrTypeKind() == DataPtrTypeKind_Lean);
[-] 	size_t offset = getOffset (srcPtrType, (DataPtrType*) type, NULL);
[+] 	size_t offset = getOffset(srcPtrType, (DataPtrType*)type, NULL);
[-] 	DataPtr* dstPtr = (DataPtr*) dst;
[+] 	DataPtr* dstPtr = (DataPtr*)dst;
[-] 	const void* src = opValue.getConstData ();
[+] 	const void* src = opValue.getConstData();
[-] 	const void* p = (char*) src + offset;
[+] 	const void* p = (char*)src + offset;
[-] 	dstPtr->m_p = (void*) p;
[+] 	dstPtr->m_p = (void*)p;
[-] 	dstPtr->m_validator = m_module->m_constMgr.createConstDataPtrValidator (p, srcPtrType->getTargetType ());
[+] 	dstPtr->m_validator = m_module->m_constMgr.createConstDataPtrValidator(p, srcPtrType->getTargetType());
[-] Cast_DataPtr_Lean2Normal::llvmCast (
[+] Cast_DataPtr_Lean2Normal::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* srcPtrType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcPtrType = (DataPtrType*)opValue.getType();
[-] 	ASSERT (srcPtrType->getPtrTypeKind () == DataPtrTypeKind_Lean);
[+] 	ASSERT(srcPtrType->getPtrTypeKind() == DataPtrTypeKind_Lean);
[-] 	result = getOffsetUnsafePtrValue (opValue, (DataPtrType*) opValue.getType (), (DataPtrType*) type, true, &ptrValue);
[+] 	result = getOffsetUnsafePtrValue(opValue, (DataPtrType*)opValue.getType(), (DataPtrType*)type, true, &ptrValue);
[-] 	if (type->getFlags () & PtrTypeFlag_Safe)
[+] 	if (type->getFlags() & PtrTypeFlag_Safe)
[-] 		result = m_module->m_operatorMgr.checkDataPtrRange (opValue);
[+] 		result = m_module->m_operatorMgr.checkDataPtrRange(opValue);
[-] 	LeanDataPtrValidator* validator = opValue.getLeanDataPtrValidator ();
[+] 	LeanDataPtrValidator* validator = opValue.getLeanDataPtrValidator();
[-] 	Value validatorValue = validator->getValidatorValue ();
[+] 	Value validatorValue = validator->getValidatorValue();
[-] 	Value tmpValue = type->getUndefValue ();
[+] 	Value tmpValue = type->getUndefValue();
[-] 	m_module->m_llvmIrBuilder.createInsertValue (tmpValue, ptrValue, 0, NULL, &tmpValue);
[+] 	m_module->m_llvmIrBuilder.createInsertValue(tmpValue, ptrValue, 0, NULL, &tmpValue);
[-] 	m_module->m_llvmIrBuilder.createInsertValue (tmpValue, validatorValue, 1, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createInsertValue(tmpValue, validatorValue, 1, type, resultValue);
[-] Cast_DataPtr_Normal2Thin::constCast (
[+] Cast_DataPtr_Normal2Thin::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	size_t offset = getOffset ((DataPtrType*) opValue.getType (), (DataPtrType*) type, NULL);
[+] 	size_t offset = getOffset((DataPtrType*)opValue.getType(), (DataPtrType*)type, NULL);
[-] 	*(char**) dst = *(char**) opValue.getConstData () + offset;
[+] 	*(char**) dst = *(char**) opValue.getConstData() + offset;
[-] Cast_DataPtr_Normal2Thin::llvmCast (
[+] Cast_DataPtr_Normal2Thin::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 	return getOffsetUnsafePtrValue (ptrValue, (DataPtrType*) opValue.getType (), (DataPtrType*) type, false, resultValue);
[+] 	return getOffsetUnsafePtrValue(ptrValue, (DataPtrType*)opValue.getType(), (DataPtrType*)type, false, resultValue);
[-] Cast_DataPtr_Lean2Thin::llvmCast (
[+] Cast_DataPtr_Lean2Thin::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	return getOffsetUnsafePtrValue (opValue, (DataPtrType*) opValue.getType (), (DataPtrType*) type, false, resultValue);
[+] 	return getOffsetUnsafePtrValue(opValue, (DataPtrType*)opValue.getType(), (DataPtrType*)type, false, resultValue);
[-] Cast_DataPtr_Thin2Thin::constCast (
[+] Cast_DataPtr_Thin2Thin::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	size_t offset = getOffset ((DataPtrType*) opValue.getType (), (DataPtrType*) type, NULL);
[+] 	size_t offset = getOffset((DataPtrType*)opValue.getType(), (DataPtrType*)type, NULL);
[-] 	*(char**) dst = *(char**) opValue.getConstData () + offset;
[+] 	*(char**) dst = *(char**) opValue.getConstData() + offset;
[-] Cast_DataPtr::Cast_DataPtr ()
[+] Cast_DataPtr::Cast_DataPtr()
[-] 	memset (m_operatorTable, 0, sizeof (m_operatorTable));
[+] 	memset(m_operatorTable, 0, sizeof(m_operatorTable));
[-] 	m_operatorTable [DataPtrTypeKind_Normal] [DataPtrTypeKind_Normal] = &m_normal2Normal;
[+] 	m_operatorTable[DataPtrTypeKind_Normal] [DataPtrTypeKind_Normal] = &m_normal2Normal;
[-] 	m_operatorTable [DataPtrTypeKind_Normal] [DataPtrTypeKind_Thin]   = &m_normal2Thin;
[+] 	m_operatorTable[DataPtrTypeKind_Normal] [DataPtrTypeKind_Thin]   = &m_normal2Thin;
[-] 	m_operatorTable [DataPtrTypeKind_Lean] [DataPtrTypeKind_Normal]   = &m_lean2Normal;
[+] 	m_operatorTable[DataPtrTypeKind_Lean] [DataPtrTypeKind_Normal]   = &m_lean2Normal;
[-] 	m_operatorTable [DataPtrTypeKind_Lean] [DataPtrTypeKind_Thin]     = &m_lean2Thin;
[+] 	m_operatorTable[DataPtrTypeKind_Lean] [DataPtrTypeKind_Thin]     = &m_lean2Thin;
[-] 	m_operatorTable [DataPtrTypeKind_Thin] [DataPtrTypeKind_Thin]     = &m_thin2Thin;
[+] 	m_operatorTable[DataPtrTypeKind_Thin] [DataPtrTypeKind_Thin]     = &m_thin2Thin;
[-] Cast_DataPtr::getCastOperator (
[+] Cast_DataPtr::getCastOperator(
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataPtr);
[-] 	DataPtrType* dstPtrType = (DataPtrType*) type;
[+] 	DataPtrType* dstPtrType = (DataPtrType*)type;
[-] 	DataPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind ();
[+] 	DataPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind();
[-] 	Type* srcType = opValue.getType ();
[+] 	Type* srcType = opValue.getType();
[-] 	if (isArrayRefType (srcType))
[+] 	if (isArrayRefType(srcType))
[-] 	TypeKind typeKind = srcType->getTypeKind ();
[+] 	TypeKind typeKind = srcType->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 	DataPtrType* srcPtrType = (DataPtrType*) srcType;
[+] 	DataPtrType* srcPtrType = (DataPtrType*)srcType;
[-] 	DataPtrTypeKind srcPtrTypeKind = srcPtrType->getPtrTypeKind ();
[+] 	DataPtrTypeKind srcPtrTypeKind = srcPtrType->getPtrTypeKind();
[-] 		(srcPtrType->getFlags () & PtrTypeFlag_Const) &&
[+] 		(srcPtrType->getFlags() & PtrTypeFlag_Const) &&
[-] 		!(dstPtrType->getFlags () & PtrTypeFlag_Const))
[+] 		!(dstPtrType->getFlags() & PtrTypeFlag_Const))
[-] 	ASSERT ((size_t) srcPtrTypeKind < DataPtrTypeKind__Count);
[+] 	ASSERT((size_t)srcPtrTypeKind < DataPtrTypeKind__Count);
[-] 	ASSERT ((size_t) dstPtrTypeKind < DataPtrTypeKind__Count);
[+] 	ASSERT((size_t)dstPtrTypeKind < DataPtrTypeKind__Count);
[-] 	return m_operatorTable [srcPtrTypeKind] [dstPtrTypeKind];
[+] 	return m_operatorTable[srcPtrTypeKind] [dstPtrTypeKind];
[-] Cast_DataRef::getCastKind (
[+] Cast_DataRef::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataRef);
[-] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType (UnOpKind_Addr, opValue);
[+] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType(UnOpKind_Addr, opValue);
[-] 	DataPtrType* ptrType = (DataPtrType*) type;
[+] 	DataPtrType* ptrType = (DataPtrType*)type;
[-] 	DataPtrType* intermediateDstType = ptrType->getTargetType ()->getDataPtrType (
[+] 	DataPtrType* intermediateDstType = ptrType->getTargetType()->getDataPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 	return m_module->m_operatorMgr.getCastKind (intermediateSrcType, intermediateDstType);
[+] 	return m_module->m_operatorMgr.getCastKind(intermediateSrcType, intermediateDstType);
[-] Cast_DataRef::llvmCast (
[+] Cast_DataRef::llvmCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_DataRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_DataRef);
[-] 	DataPtrType* ptrType = (DataPtrType*) type;
[+] 	DataPtrType* ptrType = (DataPtrType*)type;
[-] 	DataPtrType* intermediateType = ptrType->getTargetType ()->getDataPtrType (
[+] 	DataPtrType* intermediateType = ptrType->getTargetType()->getDataPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, opValue, &intermediateValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, opValue, &intermediateValue) &&
[-] 		m_module->m_operatorMgr.castOperator (&intermediateValue, intermediateType) &&
[+] 		m_module->m_operatorMgr.castOperator(&intermediateValue, intermediateType) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, intermediateValue, resultValue);
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, intermediateValue, resultValue);
----------------------
27/02/2019 18:02:11 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Fp.cpp
----------------------
[-] Cast_FpTrunc::llvmCast (
[+] Cast_FpTrunc::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createTrunc_f (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createTrunc_f(opValue, type, resultValue);
[-] Cast_FpExt::llvmCast (
[+] Cast_FpExt::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createExt_f (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createExt_f(opValue, type, resultValue);
[-] Cast_FpFromInt::llvmCast (
[+] Cast_FpFromInt::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createIntToFp (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createIntToFp(opValue, type, resultValue);
[-] Cast_FpFromInt::constCast (
[+] Cast_FpFromInt::constCast(
[-] 	TypeKind dstTypeKind = type->getTypeKind ();
[+] 	TypeKind dstTypeKind = type->getTypeKind();
[-] 	switch (dstTypeKind)
[+] 	switch(dstTypeKind)
[-] 		constCast_Fp32 (opValue, (float*) dst);
[+] 		constCast_Fp32(opValue, (float*)dst);
[-] 		constCast_Fp64 (opValue, (double*) dst);
[+] 		constCast_Fp64(opValue, (double*)dst);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromInt::constCast_Fp32 (
[+] Cast_FpFromInt::constCast_Fp32(
[-] 	const void* src = opValue.getConstData ();
[+] 	const void* src = opValue.getConstData();
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	switch (srcSize)
[+] 	switch(srcSize)
[-] 		*fp32 = *(char*) src;
[+] 		*fp32 = *(char*)src;
[-] 		*fp32 = *(short*) src;
[+] 		*fp32 = *(short*)src;
[-] 		*fp32 = (float) *(int32_t*) src;
[+] 		*fp32 = (float)*(int32_t*)src;
[-] 		*fp32 = (float) *(int64_t*) src;
[+] 		*fp32 = (float)*(int64_t*)src;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromInt::constCast_Fp64 (
[+] Cast_FpFromInt::constCast_Fp64(
[-] 	const void* src = opValue.getConstData ();
[+] 	const void* src = opValue.getConstData();
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	switch (srcSize)
[+] 	switch(srcSize)
[-] 		*fp64 = *(char*) src;
[+] 		*fp64 = *(char*)src;
[-] 		*fp64 = *(short*) src;
[+] 		*fp64 = *(short*)src;
[-] 		*fp64 = *(int32_t*) src;
[+] 		*fp64 = *(int32_t*)src;
[-] 		*fp64 = (double) *(int64_t*) src;
[+] 		*fp64 = (double)*(int64_t*)src;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromInt_u::llvmCast (
[+] Cast_FpFromInt_u::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createIntToFp_u (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createIntToFp_u(opValue, type, resultValue);
[-] Cast_FpFromInt_u::constCast (
[+] Cast_FpFromInt_u::constCast(
[-] 	TypeKind dstTypeKind = type->getTypeKind ();
[+] 	TypeKind dstTypeKind = type->getTypeKind();
[-] 	switch (dstTypeKind)
[+] 	switch(dstTypeKind)
[-] 		constCast_Fp32 (opValue, (float*) dst);
[+] 		constCast_Fp32(opValue, (float*)dst);
[-] 		constCast_Fp64 (opValue, (double*) dst);
[+] 		constCast_Fp64(opValue, (double*)dst);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromInt_u::constCast_Fp32 (
[+] Cast_FpFromInt_u::constCast_Fp32(
[-] 	const void* src = opValue.getConstData ();
[+] 	const void* src = opValue.getConstData();
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	switch (srcSize)
[+] 	switch(srcSize)
[-] 		*fp32 = *(uint8_t*) src;
[+] 		*fp32 = *(uint8_t*)src;
[-] 		*fp32 = *(uint16_t*) src;
[+] 		*fp32 = *(uint16_t*)src;
[-] 		*fp32 = (float) *(uint32_t*) src;
[+] 		*fp32 = (float)*(uint32_t*)src;
[-] 		*fp32 = (float) *(uint64_t*) src;
[+] 		*fp32 = (float)*(uint64_t*)src;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromInt_u::constCast_Fp64 (
[+] Cast_FpFromInt_u::constCast_Fp64(
[-] 	const void* src = opValue.getConstData ();
[+] 	const void* src = opValue.getConstData();
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	switch (srcSize)
[+] 	switch(srcSize)
[-] 		*fp64 = *(uint8_t*) src;
[+] 		*fp64 = *(uint8_t*)src;
[-] 		*fp64 = *(uint16_t*) src;
[+] 		*fp64 = *(uint16_t*)src;
[-] 		*fp64 = *(uint32_t*) src;
[+] 		*fp64 = *(uint32_t*)src;
[-] 		*fp64 = (double) *(uint64_t*) src;
[+] 		*fp64 = (double)*(uint64_t*)src;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_FpFromBeInt::getCastOperators (
[+] Cast_FpFromBeInt::getCastOperators(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_BigEndian);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_BigEndian);
[-] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind (opValue.getType ()->getTypeKind ());
[+] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind(opValue.getType()->getTypeKind());
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_SwapByteOrder);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_SwapByteOrder);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Fp);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Fp);
[-] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType (intermediateTypeKind);
[+] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType(intermediateTypeKind);
[-] Cast_FpFromEnum::getCastOperators (
[+] Cast_FpFromEnum::getCastOperators(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Enum);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Enum);
[-] 	Type* intermediateType = ((EnumType*) opValue.getType ())->getBaseType ();
[+] 	Type* intermediateType = ((EnumType*)opValue.getType())->getBaseType();
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Fp);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Fp);
[-] Cast_Fp::getCastOperator (
[+] Cast_Fp::getCastOperator(
[-] 	Type* srcType = opValue.getType ();
[+] 	Type* srcType = opValue.getType();
[-] 	TypeKind srcTypeKind = srcType->getTypeKind ();
[+] 	TypeKind srcTypeKind = srcType->getTypeKind();
[-] 	TypeKind dstTypeKind = type->getTypeKind ();
[+] 	TypeKind dstTypeKind = type->getTypeKind();
[-] 	size_t srcSize = srcType->getSize ();
[+] 	size_t srcSize = srcType->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (dstTypeKind == TypeKind_Float || dstTypeKind == TypeKind_Double);
[+] 	ASSERT(dstTypeKind == TypeKind_Float || dstTypeKind == TypeKind_Double);
[-] 	switch (srcTypeKind)
[+] 	switch(srcTypeKind)
[-] 			srcSize == dstSize ? m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy) :
[+] 			srcSize == dstSize ? m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy) :
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_FunctionPtr.cpp
----------------------
[-] Cast_FunctionPtr_FromMulticast::getCastKind (
[+] Cast_FunctionPtr_FromMulticast::getCastKind(
[-] 	ASSERT (isClassPtrType (opValue.getType (), ClassTypeKind_Multicast));
[+] 	ASSERT(isClassPtrType(opValue.getType(), ClassTypeKind_Multicast));
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	if (opValue.getType ()->getFlags () & PtrTypeFlag_Event)
[+] 	if (opValue.getType()->getFlags() & PtrTypeFlag_Event)
[-] 	MulticastClassType* mcType = (MulticastClassType*) ((ClassPtrType*) opValue.getType ())->getTargetType ();
[+] 	MulticastClassType* mcType = (MulticastClassType*)((ClassPtrType*)opValue.getType())->getTargetType();
[-] 	return m_module->m_operatorMgr.getCastKind (mcType->getTargetType (), type);
[+] 	return m_module->m_operatorMgr.getCastKind(mcType->getTargetType(), type);
[-] Cast_FunctionPtr_FromMulticast::llvmCast (
[+] Cast_FunctionPtr_FromMulticast::llvmCast(
[-] 	ASSERT (isClassPtrType (opValue.getType (), ClassTypeKind_Multicast));
[+] 	ASSERT(isClassPtrType(opValue.getType(), ClassTypeKind_Multicast));
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 		m_module->m_operatorMgr.memberOperator (opValue, "call", &callValue) &&
[+] 		m_module->m_operatorMgr.memberOperator(opValue, "call", &callValue) &&
[-] 		m_module->m_operatorMgr.castOperator (callValue, type, resultValue);
[+] 		m_module->m_operatorMgr.castOperator(callValue, type, resultValue);
[-] Cast_FunctionPtr_FromDataPtr::getCastKind (
[+] Cast_FunctionPtr_FromDataPtr::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	FunctionPtrType* dstType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstType = (FunctionPtrType*)type;
[-] 	DataPtrType* srcType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcType = (DataPtrType*)opValue.getType();
[-] 		srcType->getPtrTypeKind () != DataPtrTypeKind_Thin ? CastKind_None :
[+] 		srcType->getPtrTypeKind() != DataPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getPtrTypeKind () != FunctionPtrTypeKind_Thin ? CastKind_None :
[+] 		dstType->getPtrTypeKind() != FunctionPtrTypeKind_Thin ? CastKind_None :
[-] 		dstType->getTargetType ()->getTypeKind () == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[+] 		dstType->getTargetType()->getTypeKind() == TypeKind_Void ? CastKind_ImplicitCrossFamily :
[-] Cast_FunctionPtr_FromDataPtr::llvmCast (
[+] Cast_FunctionPtr_FromDataPtr::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	FunctionPtrType* dstType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstType = (FunctionPtrType*)type;
[-] 	DataPtrType* srcType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcType = (DataPtrType*)opValue.getType();
[-] 	if (srcType->getPtrTypeKind () != DataPtrTypeKind_Thin ||
[+] 	if (srcType->getPtrTypeKind() != DataPtrTypeKind_Thin ||
[-] 		dstType->getPtrTypeKind () != FunctionPtrTypeKind_Thin)
[+] 		dstType->getPtrTypeKind() != FunctionPtrTypeKind_Thin)
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	if (!m_module->m_operatorMgr.isUnsafeRgn ())
[+] 	if (!m_module->m_operatorMgr.isUnsafeRgn())
[-] 		setUnsafeCastError (srcType, dstType);
[+] 		setUnsafeCastError(srcType, dstType);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, type, resultValue);
[-] Cast_FunctionPtr_Base::getCastKind (
[+] Cast_FunctionPtr_Base::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	if (!opValue.getType ())
[+] 	if (!opValue.getType())
[-] 		ASSERT (opValue.getValueKind () == ValueKind_Function && opValue.getFunction ()->isOverloaded ());
[+] 		ASSERT(opValue.getValueKind() == ValueKind_Function && opValue.getFunction()->isOverloaded());
[-] 	FunctionPtrType* srcPtrType = (FunctionPtrType*) opValue.getClosureAwareType ();
[+] 	FunctionPtrType* srcPtrType = (FunctionPtrType*)opValue.getClosureAwareType();
[-] 	FunctionPtrType* dstPtrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstPtrType = (FunctionPtrType*)type;
[-] 	CastKind castKind = m_module->m_operatorMgr.getFunctionCastKind (
[+] 	CastKind castKind = m_module->m_operatorMgr.getFunctionCastKind(
[-] 		srcPtrType->getTargetType (),
[+] 		srcPtrType->getTargetType(),
[-] 		dstPtrType->getTargetType ()
[+] 		dstPtrType->getTargetType()
[-] 	srcPtrType = (FunctionPtrType*) opValue.getType ();
[+] 	srcPtrType = (FunctionPtrType*)opValue.getType();
[-] 	return m_module->m_operatorMgr.getFunctionCastKind (
[+] 	return m_module->m_operatorMgr.getFunctionCastKind(
[-] 		srcPtrType->getTargetType (),
[+] 		srcPtrType->getTargetType(),
[-] 		dstPtrType->getTargetType ()
[+] 		dstPtrType->getTargetType()
[-] Cast_FunctionPtr_FromFat::llvmCast (
[+] Cast_FunctionPtr_FromFat::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	FunctionPtrType* srcPtrType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* srcPtrType = (FunctionPtrType*)opValue.getType();
[-] 	FunctionType* srcFunctionType = srcPtrType->getTargetType ();
[+] 	FunctionType* srcFunctionType = srcPtrType->getTargetType();
[-] 	FunctionPtrType* thinPtrType = srcFunctionType->getStdObjectMemberMethodType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin);
[+] 	FunctionPtrType* thinPtrType = srcFunctionType->getStdObjectMemberMethodType()->getFunctionPtrType(FunctionPtrTypeKind_Thin);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, thinPtrType, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, thinPtrType, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &closureValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &closureValue);
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		pfnValue.setClosure (closure);
[+] 		pfnValue.setClosure(closure);
[-] 		closure = pfnValue.createClosure ();
[+] 		closure = pfnValue.createClosure();
[-] 	closure->insertThisArgValue (closureValue);
[+] 	closure->insertThisArgValue(closureValue);
[-] 	return m_module->m_operatorMgr.castOperator (pfnValue, type, resultValue);
[+] 	return m_module->m_operatorMgr.castOperator(pfnValue, type, resultValue);
[-] Cast_FunctionPtr_Weak2Normal::llvmCast (
[+] Cast_FunctionPtr_Weak2Normal::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr && ((FunctionPtrType*) type)->getPtrTypeKind () == FunctionPtrTypeKind_Normal);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr && ((FunctionPtrType*)type)->getPtrTypeKind() == FunctionPtrTypeKind_Normal);
[-] 	BasicBlock* initialBlock = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* initialBlock = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	BasicBlock* strengthenBlock = m_module->m_controlFlowMgr.createBlock ("strengthen");
[+] 	BasicBlock* strengthenBlock = m_module->m_controlFlowMgr.createBlock("strengthen");
[-] 	BasicBlock* aliveBlock = m_module->m_controlFlowMgr.createBlock ("alive");
[+] 	BasicBlock* aliveBlock = m_module->m_controlFlowMgr.createBlock("alive");
[-] 	BasicBlock* deadBlock = m_module->m_controlFlowMgr.createBlock ("dead");
[+] 	BasicBlock* deadBlock = m_module->m_controlFlowMgr.createBlock("dead");
[-] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock ("phi");
[+] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock("phi");
[-] 	Type* closureType = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr);
[+] 	Type* closureType = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr);
[-] 	Value nullClosureValue = closureType->getZeroValue ();
[+] 	Value nullClosureValue = closureType->getZeroValue();
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, closureType, &closureValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, closureType, &closureValue);
[-] 	m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, closureValue, nullClosureValue, &cmpValue);
[+] 	m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, closureValue, nullClosureValue, &cmpValue);
[-] 	m_module->m_controlFlowMgr.conditionalJump (cmpValue, strengthenBlock, phiBlock);
[+] 	m_module->m_controlFlowMgr.conditionalJump(cmpValue, strengthenBlock, phiBlock);
[-] 	Function* strengthenFunction = m_module->m_functionMgr.getStdFunction (StdFunc_StrengthenClassPtr);
[+] 	Function* strengthenFunction = m_module->m_functionMgr.getStdFunction(StdFunc_StrengthenClassPtr);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		strengthenFunction->getType (),
[+] 		strengthenFunction->getType(),
[-] 	m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, strengthenedClosureValue, nullClosureValue, &cmpValue);
[+] 	m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, strengthenedClosureValue, nullClosureValue, &cmpValue);
[-] 	m_module->m_controlFlowMgr.conditionalJump (cmpValue, aliveBlock, deadBlock);
[+] 	m_module->m_controlFlowMgr.conditionalJump(cmpValue, aliveBlock, deadBlock);
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (deadBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(deadBlock);
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	Value valueArray [3] =
[+] 	Value valueArray[3] =
[-] 		opValue.getType ()->getZeroValue ()
[+] 		opValue.getType()->getZeroValue()
[-] 	BasicBlock* blockArray [3] =
[+] 	BasicBlock* blockArray[3] =
[-] 	m_module->m_llvmIrBuilder.createPhi (valueArray, blockArray, 3, &intermediateValue);
[+] 	m_module->m_llvmIrBuilder.createPhi(valueArray, blockArray, 3, &intermediateValue);
[-] 	FunctionPtrType* intermediateType = ((FunctionPtrType*) opValue.getType ())->getUnWeakPtrType ();
[+] 	FunctionPtrType* intermediateType = ((FunctionPtrType*)opValue.getType())->getUnWeakPtrType();
[-] 	intermediateValue.overrideType (intermediateType);
[+] 	intermediateValue.overrideType(intermediateType);
[-] 	return m_module->m_operatorMgr.castOperator (intermediateValue, type, resultValue);
[+] 	return m_module->m_operatorMgr.castOperator(intermediateValue, type, resultValue);
[-] Cast_FunctionPtr_Thin2Fat::llvmCast (
[+] Cast_FunctionPtr_Thin2Fat::llvmCast(
[-] 	ASSERT (rawOpValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(rawOpValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	FunctionPtrType* srcPtrType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* srcPtrType = (FunctionPtrType*)opValue.getType();
[-] 	FunctionPtrType* dstPtrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstPtrType = (FunctionPtrType*)type;
[-] 	FunctionType* srcFunctionType = srcPtrType->getTargetType ();
[+] 	FunctionType* srcFunctionType = srcPtrType->getTargetType();
[-] 	FunctionType* dstFunctionType = dstPtrType->getTargetType ();
[+] 	FunctionType* dstFunctionType = dstPtrType->getTargetType();
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 	bool isSimpleClosure = closure && closure->isSimpleClosure ();
[+] 	bool isSimpleClosure = closure && closure->isSimpleClosure();
[-] 		simpleClosureValue = *closure->getArgValueList ()->getHead ();
[+] 		simpleClosureValue = *closure->getArgValueList()->getHead();
[-] 	if (opValue.getValueKind () == ValueKind_Function && opValue.getFunction ()->isVirtual ())
[+] 	if (opValue.getValueKind() == ValueKind_Function && opValue.getFunction()->isVirtual())
[-] 		bool result = m_module->m_operatorMgr.getVirtualMethod (opValue.getFunction (), closure, &opValue);
[+] 		bool result = m_module->m_operatorMgr.getVirtualMethod(opValue.getFunction(), closure, &opValue);
[-] 		srcFunctionType->isMemberMethodType () &&
[+] 		srcFunctionType->isMemberMethodType() &&
[-] 		srcFunctionType->getShortType ()->cmp (dstFunctionType) == 0)
[+] 		srcFunctionType->getShortType()->cmp(dstFunctionType) == 0)
[-] 		return llvmCast_NoThunkSimpleClosure (
[+] 		return llvmCast_NoThunkSimpleClosure(
[-] 	if (opValue.getValueKind () == ValueKind_Function)
[+] 	if (opValue.getValueKind() == ValueKind_Function)
[-] 		Function* function = opValue.getFunction ();
[+] 		Function* function = opValue.getFunction();
[-] 		ASSERT (!function->isVirtual ());
[+] 		ASSERT(!function->isVirtual());
[-] 			return llvmCast_DirectThunkNoClosure (
[+] 			return llvmCast_DirectThunkNoClosure(
[-] 		if (isSimpleClosure && function->getType ()->isMemberMethodType ())
[+] 		if (isSimpleClosure && function->getType()->isMemberMethodType())
[-] 			return llvmCast_DirectThunkSimpleClosure (
[+] 			return llvmCast_DirectThunkSimpleClosure(
[-] 	return llvmCast_FullClosure (
[+] 	return llvmCast_FullClosure(
[-] Cast_FunctionPtr_Thin2Fat::llvmCast_NoThunkSimpleClosure (
[+] Cast_FunctionPtr_Thin2Fat::llvmCast_NoThunkSimpleClosure(
[-] 	Type* thisArgType = srcFunctionType->getThisArgType ();
[+] 	Type* thisArgType = srcFunctionType->getThisArgType();
[-] 	bool result = m_module->m_operatorMgr.castOperator (simpleClosureObjValue, thisArgType, &thisArgValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(simpleClosureObjValue, thisArgType, &thisArgValue);
[-] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr (opValue, thisArgValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr(opValue, thisArgValue, dstPtrType, resultValue);
[-] Cast_FunctionPtr_Thin2Fat::llvmCast_DirectThunkNoClosure (
[+] Cast_FunctionPtr_Thin2Fat::llvmCast_DirectThunkNoClosure(
[-] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction (
[+] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction(
[-] 		((FunctionPtrType*) dstPtrType)->getTargetType (),
[+] 		((FunctionPtrType*)dstPtrType)->getTargetType(),
[-] 	Value nullValue = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr)->getZeroValue ();
[+] 	Value nullValue = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr)->getZeroValue();
[-] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr (thunkFunction, nullValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr(thunkFunction, nullValue, dstPtrType, resultValue);
[-] Cast_FunctionPtr_Thin2Fat::llvmCast_DirectThunkSimpleClosure (
[+] Cast_FunctionPtr_Thin2Fat::llvmCast_DirectThunkSimpleClosure(
[-] 	Type* thisArgType = function->getType ()->getThisArgType ();
[+] 	Type* thisArgType = function->getType()->getThisArgType();
[-] 	DerivableType* thisTargetType = function->getType ()->getThisTargetType ();
[+] 	DerivableType* thisTargetType = function->getType()->getThisTargetType();
[-] 	bool result = m_module->m_operatorMgr.castOperator (simpleClosureObjValue, thisArgType, &thisArgValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(simpleClosureObjValue, thisArgType, &thisArgValue);
[-] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction (
[+] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction(
[-] 		m_module->m_typeMgr.getMemberMethodType (thisTargetType, dstPtrType->getTargetType ())
[+] 		m_module->m_typeMgr.getMemberMethodType(thisTargetType, dstPtrType->getTargetType())
[-] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr (thunkFunction, thisArgValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr(thunkFunction, thisArgValue, dstPtrType, resultValue);
[-] Cast_FunctionPtr_Thin2Fat::llvmCast_FullClosure (
[+] Cast_FunctionPtr_Thin2Fat::llvmCast_FullClosure(
[-] 	bool result = m_module->m_operatorMgr.createClosureObject (
[+] 	bool result = m_module->m_operatorMgr.createClosureObject(
[-] 		dstPtrType->getTargetType (),
[+] 		dstPtrType->getTargetType(),
[-] 		dstPtrType->getPtrTypeKind () == FunctionPtrTypeKind_Weak,
[+] 		dstPtrType->getPtrTypeKind() == FunctionPtrTypeKind_Weak,
[-] 	ASSERT (isClassPtrType (closureValue.getType (), ClassTypeKind_FunctionClosure));
[+] 	ASSERT(isClassPtrType(closureValue.getType(), ClassTypeKind_FunctionClosure));
[-] 	FunctionClosureClassType* closureType = (FunctionClosureClassType*) ((ClassPtrType*) closureValue.getType ())->getTargetType ();
[+] 	FunctionClosureClassType* closureType = (FunctionClosureClassType*)((ClassPtrType*)closureValue.getType())->getTargetType();
[-] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr (closureType->getThunkFunction (), closureValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosureFunctionPtr(closureType->getThunkFunction(), closureValue, dstPtrType, resultValue);
[-] Cast_FunctionPtr_Thin2Thin::llvmCast (
[+] Cast_FunctionPtr_Thin2Thin::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	if (opValue.getClosure ())
[+] 	if (opValue.getClosure())
[-] 		err::setFormatStringError ("cannot create thin function pointer to a closure");
[+] 		err::setFormatStringError("cannot create thin function pointer to a closure");
[-] 	FunctionPtrType* srcPtrType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* srcPtrType = (FunctionPtrType*)opValue.getType();
[-] 	FunctionPtrType* dstPtrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstPtrType = (FunctionPtrType*)type;
[-] 	if (srcPtrType->getTargetType ()->cmp (dstPtrType->getTargetType ()) == 0)
[+] 	if (srcPtrType->getTargetType()->cmp(dstPtrType->getTargetType()) == 0)
[-] 		resultValue->overrideType (opValue, type);
[+] 		resultValue->overrideType(opValue, type);
[-] 	if (opValue.getValueKind () != ValueKind_Function)
[+] 	if (opValue.getValueKind() != ValueKind_Function)
[-] 		err::setFormatStringError ("can only create thin pointer thunk to a function, not a function pointer");
[+] 		err::setFormatStringError("can only create thin pointer thunk to a function, not a function pointer");
[-] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction (
[+] 	Function* thunkFunction = m_module->m_functionMgr.getDirectThunkFunction(
[-] 		opValue.getFunction (),
[+] 		opValue.getFunction(),
[-] 		dstPtrType->getTargetType ()
[+] 		dstPtrType->getTargetType()
[-] 	resultValue->setFunction (thunkFunction);
[+] 	resultValue->setFunction(thunkFunction);
[-] 	resultValue->overrideType (type);
[+] 	resultValue->overrideType(type);
[-] Cast_FunctionPtr::Cast_FunctionPtr ()
[+] Cast_FunctionPtr::Cast_FunctionPtr()
[-] 	memset (m_operatorTable, 0, sizeof (m_operatorTable));
[+] 	memset(m_operatorTable, 0, sizeof(m_operatorTable));
[-] 	m_operatorTable [FunctionPtrTypeKind_Normal] [FunctionPtrTypeKind_Normal] = &m_fromFat;
[+] 	m_operatorTable[FunctionPtrTypeKind_Normal] [FunctionPtrTypeKind_Normal] = &m_fromFat;
[-] 	m_operatorTable [FunctionPtrTypeKind_Normal] [FunctionPtrTypeKind_Weak]   = &m_fromFat;
[+] 	m_operatorTable[FunctionPtrTypeKind_Normal] [FunctionPtrTypeKind_Weak]   = &m_fromFat;
[-] 	m_operatorTable [FunctionPtrTypeKind_Weak] [FunctionPtrTypeKind_Normal]   = &m_weak2Normal;
[+] 	m_operatorTable[FunctionPtrTypeKind_Weak] [FunctionPtrTypeKind_Normal]   = &m_weak2Normal;
[-] 	m_operatorTable [FunctionPtrTypeKind_Weak] [FunctionPtrTypeKind_Weak]     = &m_fromFat;
[+] 	m_operatorTable[FunctionPtrTypeKind_Weak] [FunctionPtrTypeKind_Weak]     = &m_fromFat;
[-] 	m_operatorTable [FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Normal]   = &m_thin2Fat;
[+] 	m_operatorTable[FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Normal]   = &m_thin2Fat;
[-] 	m_operatorTable [FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Weak]     = &m_thin2Fat;
[+] 	m_operatorTable[FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Weak]     = &m_thin2Fat;
[-] 	m_operatorTable [FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Thin]     = &m_thin2Thin;
[+] 	m_operatorTable[FunctionPtrTypeKind_Thin] [FunctionPtrTypeKind_Thin]     = &m_thin2Thin;
[-] Cast_FunctionPtr::getCastOperator (
[+] Cast_FunctionPtr::getCastOperator(
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionPtr);
[-] 	FunctionPtrType* dstPtrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* dstPtrType = (FunctionPtrType*)type;
[-] 	FunctionPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind ();
[+] 	FunctionPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind();
[-] 	Type* srcType = opValue.getType ();
[+] 	Type* srcType = opValue.getType();
[-] 		ASSERT (opValue.getValueKind () == ValueKind_Function && opValue.getFunction ()->isOverloaded ());
[+] 		ASSERT(opValue.getValueKind() == ValueKind_Function && opValue.getFunction()->isOverloaded());
[-] 		ASSERT (dstPtrTypeKind >= 0 && dstPtrTypeKind < 2);
[+] 		ASSERT(dstPtrTypeKind >= 0 && dstPtrTypeKind < 2);
[-] 		return m_operatorTable [FunctionPtrTypeKind_Thin] [dstPtrTypeKind];
[+] 		return m_operatorTable[FunctionPtrTypeKind_Thin] [dstPtrTypeKind];
[-] 	TypeKind typeKind = srcType->getTypeKind ();
[+] 	TypeKind typeKind = srcType->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return isClassPtrType (srcType, ClassTypeKind_Multicast) ? &m_fromMulticast : NULL;
[+] 		return isClassPtrType(srcType, ClassTypeKind_Multicast) ? &m_fromMulticast : NULL;
[-] 	FunctionPtrType* srcPtrType = (FunctionPtrType*) srcType;
[+] 	FunctionPtrType* srcPtrType = (FunctionPtrType*)srcType;
[-] 	FunctionPtrTypeKind srcPtrTypeKind = srcPtrType->getPtrTypeKind ();
[+] 	FunctionPtrTypeKind srcPtrTypeKind = srcPtrType->getPtrTypeKind();
[-] 	ASSERT ((size_t) srcPtrTypeKind < FunctionPtrTypeKind__Count);
[+] 	ASSERT((size_t)srcPtrTypeKind < FunctionPtrTypeKind__Count);
[-] 	ASSERT ((size_t) dstPtrTypeKind < FunctionPtrTypeKind__Count);
[+] 	ASSERT((size_t)dstPtrTypeKind < FunctionPtrTypeKind__Count);
[-] 	return m_operatorTable [srcPtrTypeKind] [dstPtrTypeKind];
[+] 	return m_operatorTable[srcPtrTypeKind] [dstPtrTypeKind];
[-] Cast_FunctionRef::getCastKind (
[+] Cast_FunctionRef::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionRef);
[-] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType (UnOpKind_Addr, opValue);
[+] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType(UnOpKind_Addr, opValue);
[-] 	FunctionPtrType* ptrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* ptrType = (FunctionPtrType*)type;
[-] 	FunctionPtrType* intermediateDstType = ptrType->getTargetType ()->getFunctionPtrType (
[+] 	FunctionPtrType* intermediateDstType = ptrType->getTargetType()->getFunctionPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 	return m_module->m_operatorMgr.getCastKind (intermediateSrcType, intermediateDstType);
[+] 	return m_module->m_operatorMgr.getCastKind(intermediateSrcType, intermediateDstType);
[-] Cast_FunctionRef::llvmCast (
[+] Cast_FunctionRef::llvmCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_FunctionRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_FunctionRef);
[-] 	FunctionPtrType* ptrType = (FunctionPtrType*) type;
[+] 	FunctionPtrType* ptrType = (FunctionPtrType*)type;
[-] 	FunctionPtrType* intermediateType = ptrType->getTargetType ()->getFunctionPtrType (
[+] 	FunctionPtrType* intermediateType = ptrType->getTargetType()->getFunctionPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, opValue, &intermediateValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, opValue, &intermediateValue) &&
[-] 		m_module->m_operatorMgr.castOperator (&intermediateValue, intermediateType) &&
[+] 		m_module->m_operatorMgr.castOperator(&intermediateValue, intermediateType) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, intermediateValue, resultValue);
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, intermediateValue, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Int.cpp
----------------------
[-] Cast_IntTrunc::constCast (
[+] Cast_IntTrunc::constCast(
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (srcSize > dstSize);
[+] 	ASSERT(srcSize > dstSize);
[-] 	memcpy (dst, opValue.getConstData (), dstSize);
[+] 	memcpy(dst, opValue.getConstData(), dstSize);
[-] Cast_IntTrunc::llvmCast (
[+] Cast_IntTrunc::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createTrunc_i (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createTrunc_i(opValue, type, resultValue);
[-] Cast_IntExt::constCast (
[+] Cast_IntExt::constCast(
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (srcSize < dstSize);
[+] 	ASSERT(srcSize < dstSize);
[-] 	char* src = (char*) opValue.getConstData ();
[+] 	char* src = (char*)opValue.getConstData();
[-] 	if (src [srcSize - 1] & 0x80)
[+] 	if (src[srcSize - 1] & 0x80)
[-] 		memset (dst, -1, dstSize);
[+] 		memset(dst, -1, dstSize);
[-] 		memset (dst, 0, dstSize);
[+] 		memset(dst, 0, dstSize);
[-] 	memcpy (dst, src, srcSize);
[+] 	memcpy(dst, src, srcSize);
[-] Cast_IntExt::llvmCast (
[+] Cast_IntExt::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createExt_i (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createExt_i(opValue, type, resultValue);
[-] Cast_IntExt_u::constCast (
[+] Cast_IntExt_u::constCast(
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (srcSize < dstSize);
[+] 	ASSERT(srcSize < dstSize);
[-] 	char* src = (char*) opValue.getConstData ();
[+] 	char* src = (char*)opValue.getConstData();
[-] 	memset (dst, 0, dstSize);
[+] 	memset(dst, 0, dstSize);
[-] 	memcpy (dst, src, srcSize);
[+] 	memcpy(dst, src, srcSize);
[-] Cast_IntExt_u::llvmCast (
[+] Cast_IntExt_u::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createExt_u (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createExt_u(opValue, type, resultValue);
[-] Cast_SwapByteOrder::constCast (
[+] Cast_SwapByteOrder::constCast(
[-] 	size_t srcSize = opValue.getType ()->getSize ();
[+] 	size_t srcSize = opValue.getType()->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (srcSize == dstSize);
[+] 	ASSERT(srcSize == dstSize);
[-] 	char* src = (char*) opValue.getConstData ();
[+] 	char* src = (char*)opValue.getConstData();
[-] 	sl::swapByteOrder (dst, src, srcSize);
[+] 	sl::swapByteOrder(dst, src, srcSize);
[-] Cast_SwapByteOrder::llvmCast (
[+] Cast_SwapByteOrder::llvmCast(
[-] 	llvm::Type* llvmType = type->getLlvmType ();
[+] 	llvm::Type* llvmType = type->getLlvmType();
[-] 	llvm::Function* llvmSwap = llvm::Intrinsic::getDeclaration (
[+] 	llvm::Function* llvmSwap = llvm::Intrinsic::getDeclaration(
[-] 		m_module->getLlvmModule (),
[+] 		m_module->getLlvmModule(),
[-] 		llvm::ArrayRef <llvm::Type*> (llvmType)
[+] 		llvm::ArrayRef<llvm::Type*> (llvmType)
[-] 	swapFunctionValue.setLlvmValue (llvmSwap, NULL);
[+] 	swapFunctionValue.setLlvmValue(llvmSwap, NULL);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		m_module->m_typeMgr.getCallConv (CallConvKind_Default),
[+] 		m_module->m_typeMgr.getCallConv(CallConvKind_Default),
[-] Cast_IntFromBeInt::getCastOperators (
[+] Cast_IntFromBeInt::getCastOperators(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_BigEndian);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_BigEndian);
[-] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind (opValue.getType ()->getTypeKind ());
[+] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind(opValue.getType()->getTypeKind());
[-] 	if (isEquivalentIntegerTypeKind (type->getTypeKind (), intermediateTypeKind))
[+] 	if (isEquivalentIntegerTypeKind(type->getTypeKind(), intermediateTypeKind))
[-] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_SwapByteOrder);
[+] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_SwapByteOrder);
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_SwapByteOrder);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_SwapByteOrder);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Int);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Int);
[-] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType (intermediateTypeKind);
[+] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType(intermediateTypeKind);
[-] Cast_BeInt::getCastOperators (
[+] Cast_BeInt::getCastOperators(
[-] 	ASSERT (type->getTypeKindFlags () & TypeKindFlag_BigEndian);
[+] 	ASSERT(type->getTypeKindFlags() & TypeKindFlag_BigEndian);
[-] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind (type->getTypeKind ());
[+] 	TypeKind intermediateTypeKind = getLittleEndianIntegerTypeKind(type->getTypeKind());
[-] 	if (isEquivalentIntegerTypeKind (opValue.getType ()->getTypeKind (), intermediateTypeKind))
[+] 	if (isEquivalentIntegerTypeKind(opValue.getType()->getTypeKind(), intermediateTypeKind))
[-] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_SwapByteOrder);
[+] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_SwapByteOrder);
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Int);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Int);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_SwapByteOrder);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_SwapByteOrder);
[-] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType (intermediateTypeKind);
[+] 	*intermediateType = m_module->m_typeMgr.getPrimitiveType(intermediateTypeKind);
[-] Cast_IntFromFp::llvmCast (
[+] Cast_IntFromFp::llvmCast(
[-] 	m_module->m_llvmIrBuilder.createFpToInt (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createFpToInt(opValue, type, resultValue);
[-] Cast_IntFromFp32::constCast (
[+] Cast_IntFromFp32::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Float);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Float);
[-] 	float fp32 = *(float*) opValue.getConstData ();
[+] 	float fp32 = *(float*)opValue.getConstData();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	switch (dstSize)
[+] 	switch(dstSize)
[-] 		*(int8_t*) dst = (int8_t) fp32;
[+] 		*(int8_t*)dst = (int8_t)fp32;
[-] 		*(int16_t*) dst = (int16_t) fp32;
[+] 		*(int16_t*)dst = (int16_t)fp32;
[-] 		*(int32_t*) dst = (int32_t) fp32;
[+] 		*(int32_t*)dst = (int32_t)fp32;
[-] 		*(int64_t*) dst = (int64_t) fp32;
[+] 		*(int64_t*)dst = (int64_t)fp32;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_IntFromFp64::constCast (
[+] Cast_IntFromFp64::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Double);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Double);
[-] 	double fp64 = *(double*) opValue.getConstData ();
[+] 	double fp64 = *(double*)opValue.getConstData();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	switch (dstSize)
[+] 	switch(dstSize)
[-] 		*(int8_t*) dst = (int8_t) fp64;
[+] 		*(int8_t*)dst = (int8_t)fp64;
[-] 		*(int16_t*) dst = (int16_t) fp64;
[+] 		*(int16_t*)dst = (int16_t)fp64;
[-] 		*(int32_t*) dst = (int32_t) fp64;
[+] 		*(int32_t*)dst = (int32_t)fp64;
[-] 		*(int64_t*) dst = (int64_t) fp64;
[+] 		*(int64_t*)dst = (int64_t)fp64;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Cast_IntFromPtr::constCast (
[+] Cast_IntFromPtr::constCast(
[-] 	ASSERT (opValue.getType ()->getSize () >= sizeof (intptr_t));
[+] 	ASSERT(opValue.getType()->getSize() >= sizeof(intptr_t));
[-] 	size_t size = type->getSize ();
[+] 	size_t size = type->getSize();
[-] 	if (size > sizeof (intptr_t))
[+] 	if (size > sizeof(intptr_t))
[-] 		size = sizeof (intptr_t);
[+] 		size = sizeof(intptr_t);
[-] 	memcpy (dst, opValue.getConstData (), size);
[+] 	memcpy(dst, opValue.getConstData(), size);
[-] Cast_IntFromPtr::llvmCast (
[+] Cast_IntFromPtr::llvmCast(
[-] 	if (opValue.getType ()->getSize () > sizeof (intptr_t))
[+] 	if (opValue.getType()->getSize() > sizeof(intptr_t))
[-] 		m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createPtrToInt (ptrValue, m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr), &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createPtrToInt(ptrValue, m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr), &ptrValue);
[-] 	return m_module->m_operatorMgr.castOperator (ptrValue, type, resultValue);
[+] 	return m_module->m_operatorMgr.castOperator(ptrValue, type, resultValue);
[-] Cast_PtrFromInt::constCast (
[+] Cast_PtrFromInt::constCast(
[-] 	bool result = m_module->m_operatorMgr.castOperator (rawOpValue, TypeKind_IntPtr, &opValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(rawOpValue, TypeKind_IntPtr, &opValue);
[-] 	ASSERT (opValue.getValueKind () == ValueKind_Const);
[+] 	ASSERT(opValue.getValueKind() == ValueKind_Const);
[-] 	ASSERT (opValue.getType ()->getSize () == sizeof (intptr_t));
[+] 	ASSERT(opValue.getType()->getSize() == sizeof(intptr_t));
[-] 	ASSERT (type->getSize () == sizeof (intptr_t));
[+] 	ASSERT(type->getSize() == sizeof(intptr_t));
[-] 	*(intptr_t*) dst = *(intptr_t*) opValue.getConstData ();
[+] 	*(intptr_t*)dst = *(intptr_t*)opValue.getConstData();
[-] Cast_PtrFromInt::llvmCast (
[+] Cast_PtrFromInt::llvmCast(
[-] 	bool result = m_module->m_operatorMgr.castOperator (rawOpValue, TypeKind_IntPtr, &opValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(rawOpValue, TypeKind_IntPtr, &opValue);
[-] 	m_module->m_llvmIrBuilder.createIntToPtr (opValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createIntToPtr(opValue, type, resultValue);
[-] Cast_IntFromEnum::getCastOperators (
[+] Cast_IntFromEnum::getCastOperators(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Enum);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Enum);
[-] 	Type* intermediateType = ((EnumType*) opValue.getType ())->getBaseType ();
[+] 	Type* intermediateType = ((EnumType*)opValue.getType())->getBaseType();
[-] 	if (isEquivalentIntegerTypeKind (type->getTypeKind (), intermediateType->getTypeKind ()))
[+] 	if (isEquivalentIntegerTypeKind(type->getTypeKind(), intermediateType->getTypeKind()))
[-] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy);
[+] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy);
[-] 	bool isBigEndian = (intermediateType->getTypeKindFlags () & TypeKindFlag_BigEndian) != 0;
[+] 	bool isBigEndian = (intermediateType->getTypeKindFlags() & TypeKindFlag_BigEndian) != 0;
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (isBigEndian ? StdCast_BeInt : StdCast_Int);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(isBigEndian ? StdCast_BeInt : StdCast_Int);
[-] Cast_Enum::getCastKind (
[+] Cast_Enum::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Enum);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Enum);
[-] 	ASSERT (type->cmp (opValue.getType ()) != 0); // identity should have been handled earlier
[+] 	ASSERT(type->cmp(opValue.getType()) != 0); // identity should have been handled earlier
[-] 		(((EnumType*) type)->getFlags () & EnumTypeFlag_BitFlag) &&
[+] 		(((EnumType*)type)->getFlags() & EnumTypeFlag_BitFlag) &&
[-] 		opValue.isZero () ? CastKind_Implicit : CastKind_Explicit;
[+] 		opValue.isZero() ? CastKind_Implicit : CastKind_Explicit;
[-] Cast_Enum::getCastOperators (
[+] Cast_Enum::getCastOperators(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Enum);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Enum);
[-] 	Type* intermediateType = ((EnumType*) type)->getBaseType ();
[+] 	Type* intermediateType = ((EnumType*)type)->getBaseType();
[-] 	if (isEquivalentIntegerTypeKind (opValue.getType ()->getTypeKind (), intermediateType->getTypeKind ()))
[+] 	if (isEquivalentIntegerTypeKind(opValue.getType()->getTypeKind(), intermediateType->getTypeKind()))
[-] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy);
[+] 		*firstOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy);
[-] 	bool isBigEndian = (intermediateType->getTypeKindFlags () & TypeKindFlag_BigEndian) != 0;
[+] 	bool isBigEndian = (intermediateType->getTypeKindFlags() & TypeKindFlag_BigEndian) != 0;
[-] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator (isBigEndian ? StdCast_BeInt : StdCast_Int);
[+] 	*firstOperator = m_module->m_operatorMgr.getStdCastOperator(isBigEndian ? StdCast_BeInt : StdCast_Int);
[-] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy);
[+] 	*secondOperator = m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy);
[-] Cast_Int::getCastOperator (
[+] Cast_Int::getCastOperator(
[-] 	Type* srcType = opValue.getType ();
[+] 	Type* srcType = opValue.getType();
[-] 	TypeKind srcTypeKind = srcType->getTypeKind ();
[+] 	TypeKind srcTypeKind = srcType->getTypeKind();
[-] 	TypeKind dstTypeKind = type->getTypeKind ();
[+] 	TypeKind dstTypeKind = type->getTypeKind();
[-] 	size_t srcSize = srcType->getSize ();
[+] 	size_t srcSize = srcType->getSize();
[-] 	size_t dstSize = type->getSize ();
[+] 	size_t dstSize = type->getSize();
[-] 	ASSERT (dstTypeKind >= TypeKind_Int8 && dstTypeKind <= TypeKind_Int64_u);
[+] 	ASSERT(dstTypeKind >= TypeKind_Int8 && dstTypeKind <= TypeKind_Int64_u);
[-] 	switch (srcTypeKind)
[+] 	switch(srcTypeKind)
[-] 			srcSize == dstSize ? m_module->m_operatorMgr.getStdCastOperator (StdCast_Copy) :
[+] 			srcSize == dstSize ? m_module->m_operatorMgr.getStdCastOperator(StdCast_Copy) :
[-] 			(getTypeKindFlags (srcTypeKind) & TypeKindFlag_Unsigned) ?
[+] 			(getTypeKindFlags(srcTypeKind) & TypeKindFlag_Unsigned) ?
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_PropertyPtr.cpp
----------------------
[-] Cast_PropertyPtr_FromDataPtr::getCastKind (
[+] Cast_PropertyPtr_FromDataPtr::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_DataPtr && type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_DataPtr && type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	DataPtrType* srcPtrType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* srcPtrType = (DataPtrType*)opValue.getType();
[-] 	PropertyPtrType* dstPtrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* dstPtrType = (PropertyPtrType*)type;
[-] 	PropertyType* propertyType = dstPtrType->getTargetType ();
[+] 	PropertyType* propertyType = dstPtrType->getTargetType();
[-] 	return !propertyType->isIndexed ()  ?
[+] 	return !propertyType->isIndexed()  ?
[-] 		m_module->m_operatorMgr.getCastKind (srcPtrType->getTargetType (), propertyType->getReturnType ()) :
[+] 		m_module->m_operatorMgr.getCastKind(srcPtrType->getTargetType(), propertyType->getReturnType()) :
[-] Cast_PropertyPtr_FromDataPtr::llvmCast (
[+] Cast_PropertyPtr_FromDataPtr::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_DataPtr && type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_DataPtr && type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	PropertyPtrType* dstPtrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* dstPtrType = (PropertyPtrType*)type;
[-] 	if (opValue.getValueKind () == ValueKind_Variable &&
[+] 	if (opValue.getValueKind() == ValueKind_Variable &&
[-] 		opValue.getVariable ()->getStorageKind () == StorageKind_Static &&
[+] 		opValue.getVariable()->getStorageKind() == StorageKind_Static &&
[-] 		opValue.getLlvmValue () == opValue.getVariable ()->getLlvmValue ())
[+] 		opValue.getLlvmValue() == opValue.getVariable()->getLlvmValue())
[-] 		return llvmCast_DirectThunk (opValue.getVariable (), dstPtrType, resultValue);
[+] 		return llvmCast_DirectThunk(opValue.getVariable(), dstPtrType, resultValue);
[-] 	if (dstPtrType->getPtrTypeKind () == PropertyPtrTypeKind_Thin)
[+] 	if (dstPtrType->getPtrTypeKind() == PropertyPtrTypeKind_Thin)
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	return llvmCast_FullClosure (opValue, dstPtrType, resultValue);
[+] 	return llvmCast_FullClosure(opValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_FromDataPtr::llvmCast_DirectThunk (
[+] Cast_PropertyPtr_FromDataPtr::llvmCast_DirectThunk(
[-] 	Property* thunkProperty = m_module->m_functionMgr.getDirectDataThunkProperty (
[+] 	Property* thunkProperty = m_module->m_functionMgr.getDirectDataThunkProperty(
[-] 		dstPtrType->getTargetType (),
[+] 		dstPtrType->getTargetType(),
[-] 		dstPtrType->hasClosure ()
[+] 		dstPtrType->hasClosure()
[-] 	m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, &propertyValue);
[+] 	m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, &propertyValue);
[-] 	if (dstPtrType->hasClosure ())
[+] 	if (dstPtrType->hasClosure())
[-] 		closureValue = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr)->getZeroValue ();
[+] 		closureValue = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr)->getZeroValue();
[-] 		Closure* closure = propertyValue.createClosure ();
[+] 		Closure* closure = propertyValue.createClosure();
[-] 		closure->insertThisArgValue (closureValue);
[+] 		closure->insertThisArgValue(closureValue);
[-] 	return m_module->m_operatorMgr.castOperator (propertyValue, dstPtrType, resultValue);
[+] 	return m_module->m_operatorMgr.castOperator(propertyValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_FromDataPtr::llvmCast_FullClosure (
[+] Cast_PropertyPtr_FromDataPtr::llvmCast_FullClosure(
[-] 	bool result = m_module->m_operatorMgr.createDataClosureObject (
[+] 	bool result = m_module->m_operatorMgr.createDataClosureObject(
[-] 		dstPtrType->getTargetType (),
[+] 		dstPtrType->getTargetType(),
[-] 	ASSERT (isClassPtrType (closureValue.getType (), ClassTypeKind_PropertyClosure));
[+] 	ASSERT(isClassPtrType(closureValue.getType(), ClassTypeKind_PropertyClosure));
[-] 	PropertyClosureClassType* closureType = (PropertyClosureClassType*) ((ClassPtrType*) closureValue.getType ())->getTargetType ();
[+] 	PropertyClosureClassType* closureType = (PropertyClosureClassType*)((ClassPtrType*)closureValue.getType())->getTargetType();
[-] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr (closureType->getThunkProperty (), closureValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr(closureType->getThunkProperty(), closureValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_Base::getCastKind (
[+] Cast_PropertyPtr_Base::getCastKind(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyPtr && type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyPtr && type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	PropertyPtrType* srcPtrType = (PropertyPtrType*) opValue.getClosureAwareType ();
[+] 	PropertyPtrType* srcPtrType = (PropertyPtrType*)opValue.getClosureAwareType();
[-] 	PropertyPtrType* dstPtrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* dstPtrType = (PropertyPtrType*)type;
[-] 	if ((srcPtrType->getFlags () & PtrTypeFlag_Const) &&
[+] 	if ((srcPtrType->getFlags() & PtrTypeFlag_Const) &&
[-] 		!(dstPtrType->getFlags () & PtrTypeFlag_Const))
[+] 		!(dstPtrType->getFlags() & PtrTypeFlag_Const))
[-] 	return m_module->m_operatorMgr.getPropertyCastKind (
[+] 	return m_module->m_operatorMgr.getPropertyCastKind(
[-] 		srcPtrType->getTargetType (),
[+] 		srcPtrType->getTargetType(),
[-] 		dstPtrType->getTargetType ()
[+] 		dstPtrType->getTargetType()
[-] Cast_PropertyPtr_FromFat::llvmCast (
[+] Cast_PropertyPtr_FromFat::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyPtr && type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyPtr && type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	PropertyPtrType* srcPtrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* srcPtrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyType* srcPropertyType = srcPtrType->getTargetType ();
[+] 	PropertyType* srcPropertyType = srcPtrType->getTargetType();
[-] 	PropertyPtrType* thinPtrType = srcPropertyType->getStdObjectMemberPropertyType ()->getPropertyPtrType (PropertyPtrTypeKind_Thin);
[+] 	PropertyPtrType* thinPtrType = srcPropertyType->getStdObjectMemberPropertyType()->getPropertyPtrType(PropertyPtrTypeKind_Thin);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, thinPtrType, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, thinPtrType, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &closureValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &closureValue);
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		pfnValue.setClosure (closure);
[+] 		pfnValue.setClosure(closure);
[-] 		closure = pfnValue.createClosure ();
[+] 		closure = pfnValue.createClosure();
[-] 	closure->insertThisArgValue (closureValue);
[+] 	closure->insertThisArgValue(closureValue);
[-] 	return m_module->m_operatorMgr.castOperator (pfnValue, type, resultValue);
[+] 	return m_module->m_operatorMgr.castOperator(pfnValue, type, resultValue);
[-] Cast_PropertyPtr_Thin2Fat::llvmCast (
[+] Cast_PropertyPtr_Thin2Fat::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyPtr && type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyPtr && type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	PropertyPtrType* srcPtrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* srcPtrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyPtrType* dstPtrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* dstPtrType = (PropertyPtrType*)type;
[-] 	PropertyType* srcPropertyType = srcPtrType->getTargetType ();
[+] 	PropertyType* srcPropertyType = srcPtrType->getTargetType();
[-] 	PropertyType* dstPropertyType = dstPtrType->getTargetType ();
[+] 	PropertyType* dstPropertyType = dstPtrType->getTargetType();
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 	bool isSimpleClosure = closure && closure->isSimpleClosure ();
[+] 	bool isSimpleClosure = closure && closure->isSimpleClosure();
[-] 		simpleClosureObjValue = *closure->getArgValueList ()->getHead ();
[+] 		simpleClosureObjValue = *closure->getArgValueList()->getHead();
[-] 		srcPropertyType->isMemberPropertyType () &&
[+] 		srcPropertyType->isMemberPropertyType() &&
[-] 		srcPropertyType->getShortType ()->cmp (dstPropertyType) == 0)
[+] 		srcPropertyType->getShortType()->cmp(dstPropertyType) == 0)
[-] 		return llvmCast_NoThunkSimpleClosure (
[+] 		return llvmCast_NoThunkSimpleClosure(
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		Property* prop = opValue.getProperty ();
[+] 		Property* prop = opValue.getProperty();
[-] 			return llvmCast_DirectThunkNoClosure (
[+] 			return llvmCast_DirectThunkNoClosure(
[-] 		if (isSimpleClosure && prop->getType ()->isMemberPropertyType ())
[+] 		if (isSimpleClosure && prop->getType()->isMemberPropertyType())
[-] 			return llvmCast_DirectThunkSimpleClosure (
[+] 			return llvmCast_DirectThunkSimpleClosure(
[-] 	return llvmCast_FullClosure (
[+] 	return llvmCast_FullClosure(
[-] Cast_PropertyPtr_Thin2Fat::llvmCast_NoThunkSimpleClosure (
[+] Cast_PropertyPtr_Thin2Fat::llvmCast_NoThunkSimpleClosure(
[-] 	Type* thisArgType = srcPropertyType->getThisArgType ();
[+] 	Type* thisArgType = srcPropertyType->getThisArgType();
[-] 	bool result = m_module->m_operatorMgr.castOperator (simpleClosureObjValue, thisArgType, &thisArgValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(simpleClosureObjValue, thisArgType, &thisArgValue);
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		return createClosurePropertyPtr (opValue.getProperty (), thisArgValue, dstPtrType, resultValue);
[+] 		return createClosurePropertyPtr(opValue.getProperty(), thisArgValue, dstPtrType, resultValue);
[-] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr (opValue, thisArgValue, dstPtrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr(opValue, thisArgValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_Thin2Fat::llvmCast_DirectThunkNoClosure (
[+] Cast_PropertyPtr_Thin2Fat::llvmCast_DirectThunkNoClosure(
[-] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty (
[+] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty(
[-] 		((PropertyPtrType*) dstPtrType)->getTargetType (),
[+] 		((PropertyPtrType*)dstPtrType)->getTargetType(),
[-] 	Value nullValue = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr)->getZeroValue ();
[+] 	Value nullValue = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr)->getZeroValue();
[-] 	return createClosurePropertyPtr (thunkProperty, nullValue, dstPtrType, resultValue);
[+] 	return createClosurePropertyPtr(thunkProperty, nullValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_Thin2Fat::llvmCast_DirectThunkSimpleClosure (
[+] Cast_PropertyPtr_Thin2Fat::llvmCast_DirectThunkSimpleClosure(
[-] 	Type* thisArgType = prop->getType ()->getThisArgType ();
[+] 	Type* thisArgType = prop->getType()->getThisArgType();
[-] 	DerivableType* thisTargetType = prop->getType ()->getThisTargetType ();
[+] 	DerivableType* thisTargetType = prop->getType()->getThisTargetType();
[-] 	bool result = m_module->m_operatorMgr.castOperator (simpleClosureObjValue, thisArgType, &thisArgValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(simpleClosureObjValue, thisArgType, &thisArgValue);
[-] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty (
[+] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty(
[-] 		m_module->m_typeMgr.getMemberPropertyType (thisTargetType, dstPtrType->getTargetType ())
[+] 		m_module->m_typeMgr.getMemberPropertyType(thisTargetType, dstPtrType->getTargetType())
[-] 	return createClosurePropertyPtr (thunkProperty, thisArgValue, dstPtrType, resultValue);
[+] 	return createClosurePropertyPtr(thunkProperty, thisArgValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_Thin2Fat::llvmCast_FullClosure (
[+] Cast_PropertyPtr_Thin2Fat::llvmCast_FullClosure(
[-] 	bool result = m_module->m_operatorMgr.createClosureObject (
[+] 	bool result = m_module->m_operatorMgr.createClosureObject(
[-] 		dstPtrType->getTargetType (),
[+] 		dstPtrType->getTargetType(),
[-] 		dstPtrType->getPtrTypeKind () == PropertyPtrTypeKind_Weak,
[+] 		dstPtrType->getPtrTypeKind() == PropertyPtrTypeKind_Weak,
[-] 	ASSERT (isClassPtrType (closureValue.getType (), ClassTypeKind_PropertyClosure));
[+] 	ASSERT(isClassPtrType(closureValue.getType(), ClassTypeKind_PropertyClosure));
[-] 	PropertyClosureClassType* closureType = (PropertyClosureClassType*) ((ClassPtrType*) closureValue.getType ())->getTargetType ();
[+] 	PropertyClosureClassType* closureType = (PropertyClosureClassType*)((ClassPtrType*)closureValue.getType())->getTargetType();
[-] 	return createClosurePropertyPtr (closureType->getThunkProperty (), closureValue, dstPtrType, resultValue);
[+] 	return createClosurePropertyPtr(closureType->getThunkProperty(), closureValue, dstPtrType, resultValue);
[-] Cast_PropertyPtr_Thin2Fat::createClosurePropertyPtr (
[+] Cast_PropertyPtr_Thin2Fat::createClosurePropertyPtr(
[-] 	bool result = m_module->m_operatorMgr.getPropertyThinPtr (prop, NULL, &thinPtrValue);
[+] 	bool result = m_module->m_operatorMgr.getPropertyThinPtr(prop, NULL, &thinPtrValue);
[-] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr (thinPtrValue, closureValue, ptrType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createClosurePropertyPtr(thinPtrValue, closureValue, ptrType, resultValue);
[-] Cast_PropertyPtr_Weak2Normal::llvmCast (
[+] Cast_PropertyPtr_Weak2Normal::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyPtr && ((PropertyPtrType*) type)->getPtrTypeKind () == PropertyPtrTypeKind_Normal);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyPtr && ((PropertyPtrType*)type)->getPtrTypeKind() == PropertyPtrTypeKind_Normal);
[-] 	BasicBlock* initialBlock = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* initialBlock = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	BasicBlock* strengthenBlock = m_module->m_controlFlowMgr.createBlock ("strengthen");
[+] 	BasicBlock* strengthenBlock = m_module->m_controlFlowMgr.createBlock("strengthen");
[-] 	BasicBlock* aliveBlock = m_module->m_controlFlowMgr.createBlock ("alive");
[+] 	BasicBlock* aliveBlock = m_module->m_controlFlowMgr.createBlock("alive");
[-] 	BasicBlock* deadBlock = m_module->m_controlFlowMgr.createBlock ("dead");
[+] 	BasicBlock* deadBlock = m_module->m_controlFlowMgr.createBlock("dead");
[-] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock ("phi");
[+] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock("phi");
[-] 	Type* closureType = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr);
[+] 	Type* closureType = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr);
[-] 	Value nullClosureValue = closureType->getZeroValue ();
[+] 	Value nullClosureValue = closureType->getZeroValue();
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, closureType, &closureValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, closureType, &closureValue);
[-] 	m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, closureValue, nullClosureValue, &cmpValue);
[+] 	m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, closureValue, nullClosureValue, &cmpValue);
[-] 	m_module->m_controlFlowMgr.conditionalJump (cmpValue, strengthenBlock, phiBlock);
[+] 	m_module->m_controlFlowMgr.conditionalJump(cmpValue, strengthenBlock, phiBlock);
[-] 	Function* strengthenFunction = m_module->m_functionMgr.getStdFunction (StdFunc_StrengthenClassPtr);
[+] 	Function* strengthenFunction = m_module->m_functionMgr.getStdFunction(StdFunc_StrengthenClassPtr);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		strengthenFunction->getType (),
[+] 		strengthenFunction->getType(),
[-] 	m_module->m_operatorMgr.binaryOperator (BinOpKind_Ne, strengthenedClosureValue, nullClosureValue, &cmpValue);
[+] 	m_module->m_operatorMgr.binaryOperator(BinOpKind_Ne, strengthenedClosureValue, nullClosureValue, &cmpValue);
[-] 	m_module->m_controlFlowMgr.conditionalJump (cmpValue, aliveBlock, deadBlock);
[+] 	m_module->m_controlFlowMgr.conditionalJump(cmpValue, aliveBlock, deadBlock);
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (deadBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(deadBlock);
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	Value valueArray [3] =
[+] 	Value valueArray[3] =
[-] 		opValue.getType ()->getZeroValue ()
[+] 		opValue.getType()->getZeroValue()
[-] 	BasicBlock* blockArray [3] =
[+] 	BasicBlock* blockArray[3] =
[-] 	m_module->m_llvmIrBuilder.createPhi (valueArray, blockArray, 3, &intermediateValue);
[+] 	m_module->m_llvmIrBuilder.createPhi(valueArray, blockArray, 3, &intermediateValue);
[-] 	PropertyPtrType* intermediateType = ((PropertyPtrType*) opValue.getType ())->getUnWeakPtrType ();
[+] 	PropertyPtrType* intermediateType = ((PropertyPtrType*)opValue.getType())->getUnWeakPtrType();
[-] 	intermediateValue.overrideType (intermediateType);
[+] 	intermediateValue.overrideType(intermediateType);
[-] 	return m_module->m_operatorMgr.castOperator (intermediateValue, type, resultValue);}
[+] 	return m_module->m_operatorMgr.castOperator(intermediateValue, type, resultValue);}
[-] Cast_PropertyPtr_Thin2Thin::llvmCast (
[+] Cast_PropertyPtr_Thin2Thin::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	if (opValue.getClosure ())
[+] 	if (opValue.getClosure())
[-] 		err::setFormatStringError ("cannot create thin property pointer to a closure");
[+] 		err::setFormatStringError("cannot create thin property pointer to a closure");
[-] 	if (opValue.getValueKind () != ValueKind_Property)
[+] 	if (opValue.getValueKind() != ValueKind_Property)
[-] 		err::setFormatStringError ("can only create thin pointer thunk to a property, not a property pointer");
[+] 		err::setFormatStringError("can only create thin pointer thunk to a property, not a property pointer");
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)type;
[-] 	PropertyType* targetType = ptrType->getTargetType ();
[+] 	PropertyType* targetType = ptrType->getTargetType();
[-] 	Property* prop = opValue.getProperty ();
[+] 	Property* prop = opValue.getProperty();
[-] 	if (prop->getType ()->cmp (targetType) == 0)
[+] 	if (prop->getType()->cmp(targetType) == 0)
[-] 		return m_module->m_operatorMgr.getPropertyThinPtr (prop, NULL, ptrType, resultValue);
[+] 		return m_module->m_operatorMgr.getPropertyThinPtr(prop, NULL, ptrType, resultValue);
[-] 	if (prop->getFlags () & PropertyTypeFlag_Bindable)
[+] 	if (prop->getFlags() & PropertyTypeFlag_Bindable)
[-] 		err::setFormatStringError ("bindable properties are not supported yet");
[+] 		err::setFormatStringError("bindable properties are not supported yet");
[-] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty (prop, targetType);
[+] 	Property* thunkProperty = m_module->m_functionMgr.getDirectThunkProperty(prop, targetType);
[-] 	return m_module->m_operatorMgr.getPropertyThinPtr (thunkProperty, NULL, ptrType, resultValue);
[+] 	return m_module->m_operatorMgr.getPropertyThinPtr(thunkProperty, NULL, ptrType, resultValue);
[-] Cast_PropertyPtr_Thin2Weak::llvmCast (
[+] Cast_PropertyPtr_Thin2Weak::llvmCast(
[-] 	AXL_TODO ("will only work for simple closures. redesign Thin2Normal to support 'weak'")
[+] 	AXL_TODO("will only work for simple closures. redesign Thin2Normal to support 'weak'")
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	if (opValue.getClosure () && !opValue.getClosure ()->isSimpleClosure ())
[+] 	if (opValue.getClosure() && !opValue.getClosure()->isSimpleClosure())
[-] 		err::setFormatStringError ("full weak closures are not implemented yet");
[+] 		err::setFormatStringError("full weak closures are not implemented yet");
[-] 	PropertyPtrType* intermediateType = ((PropertyPtrType*) type)->getTargetType ()->getPropertyPtrType (PropertyPtrTypeKind_Normal);
[+] 	PropertyPtrType* intermediateType = ((PropertyPtrType*)type)->getTargetType()->getPropertyPtrType(PropertyPtrTypeKind_Normal);
[-] 	bool result = m_module->m_operatorMgr.castOperator (opValue, intermediateType, resultValue);
[+] 	bool result = m_module->m_operatorMgr.castOperator(opValue, intermediateType, resultValue);
[-] 	resultValue->overrideType (type);
[+] 	resultValue->overrideType(type);
[-] Cast_PropertyPtr::Cast_PropertyPtr ()
[+] Cast_PropertyPtr::Cast_PropertyPtr()
[-] 	memset (m_operatorTable, 0, sizeof (m_operatorTable));
[+] 	memset(m_operatorTable, 0, sizeof(m_operatorTable));
[-] 	m_operatorTable [PropertyPtrTypeKind_Normal] [PropertyPtrTypeKind_Normal] = &m_fromFat;
[+] 	m_operatorTable[PropertyPtrTypeKind_Normal] [PropertyPtrTypeKind_Normal] = &m_fromFat;
[-] 	m_operatorTable [PropertyPtrTypeKind_Normal] [PropertyPtrTypeKind_Weak]   = &m_fromFat;
[+] 	m_operatorTable[PropertyPtrTypeKind_Normal] [PropertyPtrTypeKind_Weak]   = &m_fromFat;
[-] 	m_operatorTable [PropertyPtrTypeKind_Weak] [PropertyPtrTypeKind_Normal]   = &m_weak2Normal;
[+] 	m_operatorTable[PropertyPtrTypeKind_Weak] [PropertyPtrTypeKind_Normal]   = &m_weak2Normal;
[-] 	m_operatorTable [PropertyPtrTypeKind_Weak] [PropertyPtrTypeKind_Weak]     = &m_fromFat;
[+] 	m_operatorTable[PropertyPtrTypeKind_Weak] [PropertyPtrTypeKind_Weak]     = &m_fromFat;
[-] 	m_operatorTable [PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Normal]   = &m_thin2Fat;
[+] 	m_operatorTable[PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Normal]   = &m_thin2Fat;
[-] 	m_operatorTable [PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Weak]     = &m_thin2Fat;
[+] 	m_operatorTable[PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Weak]     = &m_thin2Fat;
[-] 	m_operatorTable [PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Thin]     = &m_thin2Thin;
[+] 	m_operatorTable[PropertyPtrTypeKind_Thin] [PropertyPtrTypeKind_Thin]     = &m_thin2Thin;
[-] Cast_PropertyPtr::getCastOperator (
[+] Cast_PropertyPtr::getCastOperator(
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyPtr);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyPtr);
[-] 	PropertyPtrType* dstPtrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* dstPtrType = (PropertyPtrType*)type;
[-] 	PropertyPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind ();
[+] 	PropertyPtrTypeKind dstPtrTypeKind = dstPtrType->getPtrTypeKind();
[-] 	ASSERT ((size_t) dstPtrTypeKind < PropertyPtrTypeKind__Count);
[+] 	ASSERT((size_t)dstPtrTypeKind < PropertyPtrTypeKind__Count);
[-] 	TypeKind srcTypeKind = opValue.getType ()->getTypeKind ();
[+] 	TypeKind srcTypeKind = opValue.getType()->getTypeKind();
[-] 	switch (srcTypeKind)
[+] 	switch(srcTypeKind)
[-] 		PropertyPtrTypeKind srcPtrTypeKind = ((PropertyPtrType*) opValue.getType ())->getPtrTypeKind ();
[+] 		PropertyPtrTypeKind srcPtrTypeKind = ((PropertyPtrType*)opValue.getType())->getPtrTypeKind();
[-] 		ASSERT ((size_t) srcPtrTypeKind < PropertyPtrTypeKind__Count);
[+] 		ASSERT((size_t)srcPtrTypeKind < PropertyPtrTypeKind__Count);
[-] 		return m_operatorTable [srcPtrTypeKind] [dstPtrTypeKind];
[+] 		return m_operatorTable[srcPtrTypeKind] [dstPtrTypeKind];
[-] Cast_PropertyRef::getCastKind (
[+] Cast_PropertyRef::getCastKind(
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyRef);
[-] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType (UnOpKind_Addr, opValue);
[+] 	Type* intermediateSrcType = m_module->m_operatorMgr.getUnaryOperatorResultType(UnOpKind_Addr, opValue);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)type;
[-] 	PropertyPtrType* intermediateDstType = ptrType->getTargetType ()->getPropertyPtrType (
[+] 	PropertyPtrType* intermediateDstType = ptrType->getTargetType()->getPropertyPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 	return m_module->m_operatorMgr.getCastKind (intermediateSrcType, intermediateDstType);
[+] 	return m_module->m_operatorMgr.getCastKind(intermediateSrcType, intermediateDstType);
[-] Cast_PropertyRef::llvmCast (
[+] Cast_PropertyRef::llvmCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_PropertyRef);
[+] 	ASSERT(type->getTypeKind() == TypeKind_PropertyRef);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) type;
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)type;
[-] 	PropertyPtrType* intermediateType = ptrType->getTargetType ()->getPropertyPtrType (
[+] 	PropertyPtrType* intermediateType = ptrType->getTargetType()->getPropertyPtrType(
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, opValue, &intermediateValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, opValue, &intermediateValue) &&
[-] 		m_module->m_operatorMgr.castOperator (&intermediateValue, intermediateType) &&
[+] 		m_module->m_operatorMgr.castOperator(&intermediateValue, intermediateType) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, intermediateValue, resultValue);
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, intermediateValue, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Struct.cpp
----------------------
[-] Cast_Struct::getCastKind (
[+] Cast_Struct::getCastKind(
[-] 	if (opValue.getType ()->getTypeKind () == TypeKind_Struct)
[+] 	if (opValue.getType()->getTypeKind() == TypeKind_Struct)
[-] 		StructType* srcStructType = (StructType*) opValue.getType ();
[+] 		StructType* srcStructType = (StructType*)opValue.getType();
[-] 		if (srcStructType->findBaseType (type))
[+] 		if (srcStructType->findBaseType(type))
[-] 	ASSERT (type->getTypeKind () == TypeKind_Struct);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Struct);
[-] 	StructType* structType = (StructType*) type;
[+] 	StructType* structType = (StructType*)type;
[-] 	Function* constructor = structType->getConstructor ();
[+] 	Function* constructor = structType->getConstructor();
[-] 		Value argValueArray [2];
[+] 		Value argValueArray[2];
[-] 		argValueArray [0].setType (structType->getDataPtrType ());
[+] 		argValueArray[0].setType(structType->getDataPtrType());
[-] 		argValueArray [1] = opValue;
[+] 		argValueArray[1] = opValue;
[-] 		Function* overload = constructor->chooseOverload (argValueArray, 2, &castKind);
[+] 		Function* overload = constructor->chooseOverload(argValueArray, 2, &castKind);
[-] 			return AXL_MIN (castKind, CastKind_ImplicitCrossFamily);
[+] 			return AXL_MIN(castKind, CastKind_ImplicitCrossFamily);
[-] Cast_Struct::constCast (
[+] Cast_Struct::constCast(
[-] 	if (opValue.getType ()->getTypeKind () != TypeKind_Struct)
[+] 	if (opValue.getType()->getTypeKind() != TypeKind_Struct)
[-] 	StructType* srcStructType = (StructType*) opValue.getType ();
[+] 	StructType* srcStructType = (StructType*)opValue.getType();
[-] 	bool result = srcStructType->findBaseTypeTraverse (type, &coord);
[+] 	bool result = srcStructType->findBaseTypeTraverse(type, &coord);
[-] 	memcpy (dst, (char*) opValue.getConstData () + coord.m_offset, type->getSize ());
[+] 	memcpy(dst, (char*)opValue.getConstData() + coord.m_offset, type->getSize());
[-] Cast_Struct::llvmCast (
[+] Cast_Struct::llvmCast(
[-] 	if (opValue.getType ()->getTypeKind () == TypeKind_Struct)
[+] 	if (opValue.getType()->getTypeKind() == TypeKind_Struct)
[-] 		StructType* srcStructType = (StructType*) opValue.getType ();
[+] 		StructType* srcStructType = (StructType*)opValue.getType();
[-] 		result = srcStructType->findBaseTypeTraverse (type, &coord);
[+] 		result = srcStructType->findBaseTypeTraverse(type, &coord);
[-] 			m_module->m_llvmIrBuilder.createExtractValue (
[+] 			m_module->m_llvmIrBuilder.createExtractValue(
[-] 				coord.m_llvmIndexArray.getCount (),
[+] 				coord.m_llvmIndexArray.getCount(),
[-] 	ASSERT (type->getTypeKind () == TypeKind_Struct);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Struct);
[-] 	StructType* structType = (StructType*) type;
[+] 	StructType* structType = (StructType*)type;
[-] 	Function* constructor = structType->getConstructor ();
[+] 	Function* constructor = structType->getConstructor();
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	Variable* tmpVariable = m_module->m_variableMgr.createSimpleStackVariable ("tmpStruct", type);
[+] 	Variable* tmpVariable = m_module->m_variableMgr.createSimpleStackVariable("tmpStruct", type);
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, tmpVariable, &tmpValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, tmpVariable, &tmpValue) &&
[-] 		m_module->m_operatorMgr.callOperator (constructor, tmpValue, opValue) &&
[+] 		m_module->m_operatorMgr.callOperator(constructor, tmpValue, opValue) &&
[-] 		m_module->m_operatorMgr.loadDataRef (tmpVariable, resultValue);
[+] 		m_module->m_operatorMgr.loadDataRef(tmpVariable, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Variant.cpp
----------------------
[-] Cast_Variant::constCast (
[+] Cast_Variant::constCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Variant);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Variant);
[-] 	Variant* variant = (Variant*) dst;
[+] 	Variant* variant = (Variant*)dst;
[-] 	memset (variant, 0, sizeof (Variant));
[+] 	memset(variant, 0, sizeof(Variant));
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	if (opType->getSize () <= sizeof (DataPtr))
[+] 	if (opType->getSize() <= sizeof(DataPtr))
[-] 		memcpy (variant, opValue.getConstData (), opType->getSize ());
[+] 		memcpy(variant, opValue.getConstData(), opType->getSize());
[-] 		const void* p = m_module->m_constMgr.saveValue (opValue).getConstData ();
[+] 		const void* p = m_module->m_constMgr.saveValue(opValue).getConstData();
[-] 		variant->m_dataPtr.m_p = (void*) p;
[+] 		variant->m_dataPtr.m_p = (void*)p;
[-] 		variant->m_dataPtr.m_validator = m_module->m_constMgr.createConstDataPtrValidator (p, opType);
[+] 		variant->m_dataPtr.m_validator = m_module->m_constMgr.createConstDataPtrValidator(p, opType);
[-] 		opType = opType->getDataPtrType (
[+] 		opType = opType->getDataPtrType(
[-] Cast_Variant::llvmCast (
[+] Cast_Variant::llvmCast(
[-] 	ASSERT (type->getTypeKind () == TypeKind_Variant);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Variant);
[-] 	Type* opType = rawOpValue.getType ();
[+] 	Type* opType = rawOpValue.getType();
[-] 	if ((opType->getTypeKindFlags () & TypeKindFlag_DataPtr) &&
[+] 	if ((opType->getTypeKindFlags() & TypeKindFlag_DataPtr) &&
[-] 		((DataPtrType*) opType)->getPtrTypeKind () == DataPtrTypeKind_Lean)
[+] 		((DataPtrType*)opType)->getPtrTypeKind() == DataPtrTypeKind_Lean)
[-] 		opType = ((DataPtrType*) opType)->getTargetType ()->getDataPtrType (
[+] 		opType = ((DataPtrType*)opType)->getTargetType()->getDataPtrType(
[-] 			opType->getTypeKind (),
[+] 			opType->getTypeKind(),
[-] 			opType->getFlags ()
[+] 			opType->getFlags()
[-] 		m_module->m_operatorMgr.castOperator (rawOpValue, opType, &opValue);
[+] 		m_module->m_operatorMgr.castOperator(rawOpValue, opType, &opValue);
[-] 	else if (opType->getSize () <= sizeof (DataPtr))
[+] 	else if (opType->getSize() <= sizeof(DataPtr))
[-] 		result = m_module->m_operatorMgr.gcHeapAllocate (opType, &opValue);
[+] 		result = m_module->m_operatorMgr.gcHeapAllocate(opType, &opValue);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (ptrValue, opType->getDataPtrType_c (), &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(ptrValue, opType->getDataPtrType_c(), &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createStore (rawOpValue, ptrValue);
[+] 		m_module->m_llvmIrBuilder.createStore(rawOpValue, ptrValue);
[-] 		opType = opType->getDataPtrType (
[+] 		opType = opType->getDataPtrType(
[-] 	Value opTypeValue (&opType, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value opTypeValue(&opType, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "tmpVariant", NULL, &variantValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "tmpVariant", NULL, &variantValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (variantValue, opType->getDataPtrType_c (), &castValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(variantValue, opType->getDataPtrType_c(), &castValue);
[-] 	m_module->m_llvmIrBuilder.createStore (opValue, castValue);
[+] 	m_module->m_llvmIrBuilder.createStore(opValue, castValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (variantValue, NULL, &variantValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(variantValue, NULL, &variantValue);
[-] 	m_module->m_llvmIrBuilder.createInsertValue (variantValue, opTypeValue, VariantField_Type, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createInsertValue(variantValue, opTypeValue, VariantField_Type, type, resultValue);
[-] Cast_FromVariant::constCast (
[+] Cast_FromVariant::constCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Variant);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Variant);
[-] 	Variant* variant = (Variant*) opValue.getConstData ();
[+] 	Variant* variant = (Variant*)opValue.getConstData();
[-] 		memset (dst, 0, type->getSize ());
[+] 		memset(dst, 0, type->getSize());
[-] 	if (variant->m_type->getSize () > sizeof (DataPtr))
[+] 	if (variant->m_type->getSize() > sizeof(DataPtr))
[-] 		err::setFormatStringError ("invalid variant type '%s'", variant->m_type->getTypeString ().sz ());
[+] 		err::setFormatStringError("invalid variant type '%s'", variant->m_type->getTypeString ().sz ());
[-] 	tmpValue.createConst (variant, variant->m_type);
[+] 	tmpValue.createConst(variant, variant->m_type);
[-] 	bool result = m_module->m_operatorMgr.castOperator (&tmpValue, type);
[+] 	bool result = m_module->m_operatorMgr.castOperator(&tmpValue, type);
[-] 	ASSERT (tmpValue.getValueKind () == ValueKind_Const);
[+] 	ASSERT(tmpValue.getValueKind() == ValueKind_Const);
[-] 	memcpy (dst, tmpValue.getConstData (), type->getSize ());
[+] 	memcpy(dst, tmpValue.getConstData(), type->getSize());
[-] Cast_FromVariant::llvmCast (
[+] Cast_FromVariant::llvmCast(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_Variant);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_Variant);
[-] 	Value typeValue (&type, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value typeValue(&type, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "tmpValue", type->getDataPtrType_c (), &tmpValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "tmpValue", type->getDataPtrType_c (), &tmpValue);
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicCastVariant);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicCastVariant);
[-] 	bool result = m_module->m_operatorMgr.callOperator (function, opValue, typeValue, tmpValue);
[+] 	bool result = m_module->m_operatorMgr.callOperator(function, opValue, typeValue, tmpValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (tmpValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(tmpValue, type, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr.cpp
----------------------
[-] OperatorMgr::OperatorMgr ()
[+] OperatorMgr::OperatorMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 	memset (m_unaryOperatorTable, 0, sizeof (m_unaryOperatorTable));
[+] 	memset(m_unaryOperatorTable, 0, sizeof(m_unaryOperatorTable));
[-] 	memset (m_binaryOperatorTable, 0, sizeof (m_binaryOperatorTable));
[+] 	memset(m_binaryOperatorTable, 0, sizeof(m_binaryOperatorTable));
[-] 	memset (m_castOperatorTable, 0, sizeof (m_castOperatorTable));
[+] 	memset(m_castOperatorTable, 0, sizeof(m_castOperatorTable));
[-] 	m_unaryOperatorTable [UnOpKind_Plus]     = &m_unOp_Plus;
[+] 	m_unaryOperatorTable[UnOpKind_Plus]     = &m_unOp_Plus;
[-] 	m_unaryOperatorTable [UnOpKind_Minus]    = &m_unOp_Minus;
[+] 	m_unaryOperatorTable[UnOpKind_Minus]    = &m_unOp_Minus;
[-] 	m_unaryOperatorTable [UnOpKind_BwNot]    = &m_unOp_BwNot;
[+] 	m_unaryOperatorTable[UnOpKind_BwNot]    = &m_unOp_BwNot;
[-] 	m_unaryOperatorTable [UnOpKind_LogNot]   = &m_unOp_LogNot;
[+] 	m_unaryOperatorTable[UnOpKind_LogNot]   = &m_unOp_LogNot;
[-] 	m_unaryOperatorTable [UnOpKind_Addr]     = &m_unOp_Addr;
[+] 	m_unaryOperatorTable[UnOpKind_Addr]     = &m_unOp_Addr;
[-] 	m_unaryOperatorTable [UnOpKind_Indir]    = &m_unOp_Indir;
[+] 	m_unaryOperatorTable[UnOpKind_Indir]    = &m_unOp_Indir;
[-] 	m_unaryOperatorTable [UnOpKind_Ptr]      = &m_unOp_Indir;
[+] 	m_unaryOperatorTable[UnOpKind_Ptr]      = &m_unOp_Indir;
[-] 	m_unaryOperatorTable [UnOpKind_PreInc]   = &m_unOp_PreInc;
[+] 	m_unaryOperatorTable[UnOpKind_PreInc]   = &m_unOp_PreInc;
[-] 	m_unaryOperatorTable [UnOpKind_PreDec]   = &m_unOp_PreDec;
[+] 	m_unaryOperatorTable[UnOpKind_PreDec]   = &m_unOp_PreDec;
[-] 	m_unaryOperatorTable [UnOpKind_PostInc]  = &m_unOp_PostInc;
[+] 	m_unaryOperatorTable[UnOpKind_PostInc]  = &m_unOp_PostInc;
[-] 	m_unaryOperatorTable [UnOpKind_PostDec]  = &m_unOp_PostDec;
[+] 	m_unaryOperatorTable[UnOpKind_PostDec]  = &m_unOp_PostDec;
[-] 	m_binaryOperatorTable [BinOpKind_Add]    = &m_binOp_Add;
[+] 	m_binaryOperatorTable[BinOpKind_Add]    = &m_binOp_Add;
[-] 	m_binaryOperatorTable [BinOpKind_Sub]    = &m_binOp_Sub;
[+] 	m_binaryOperatorTable[BinOpKind_Sub]    = &m_binOp_Sub;
[-] 	m_binaryOperatorTable [BinOpKind_Mul]    = &m_binOp_Mul;
[+] 	m_binaryOperatorTable[BinOpKind_Mul]    = &m_binOp_Mul;
[-] 	m_binaryOperatorTable [BinOpKind_Div]    = &m_binOp_Div;
[+] 	m_binaryOperatorTable[BinOpKind_Div]    = &m_binOp_Div;
[-] 	m_binaryOperatorTable [BinOpKind_Mod]    = &m_binOp_Mod;
[+] 	m_binaryOperatorTable[BinOpKind_Mod]    = &m_binOp_Mod;
[-] 	m_binaryOperatorTable [BinOpKind_Shl]    = &m_binOp_Shl;
[+] 	m_binaryOperatorTable[BinOpKind_Shl]    = &m_binOp_Shl;
[-] 	m_binaryOperatorTable [BinOpKind_Shr]    = &m_binOp_Shr;
[+] 	m_binaryOperatorTable[BinOpKind_Shr]    = &m_binOp_Shr;
[-] 	m_binaryOperatorTable [BinOpKind_BwAnd]  = &m_binOp_BwAnd;
[+] 	m_binaryOperatorTable[BinOpKind_BwAnd]  = &m_binOp_BwAnd;
[-] 	m_binaryOperatorTable [BinOpKind_BwXor]  = &m_binOp_BwXor;
[+] 	m_binaryOperatorTable[BinOpKind_BwXor]  = &m_binOp_BwXor;
[-] 	m_binaryOperatorTable [BinOpKind_BwOr]   = &m_binOp_BwOr;
[+] 	m_binaryOperatorTable[BinOpKind_BwOr]   = &m_binOp_BwOr;
[-] 	m_binaryOperatorTable [BinOpKind_At]     = &m_binOp_At;
[+] 	m_binaryOperatorTable[BinOpKind_At]     = &m_binOp_At;
[-] 	m_binaryOperatorTable [BinOpKind_LogAnd] = &m_binOp_LogAnd;
[+] 	m_binaryOperatorTable[BinOpKind_LogAnd] = &m_binOp_LogAnd;
[-] 	m_binaryOperatorTable [BinOpKind_LogOr]  = &m_binOp_LogOr;
[+] 	m_binaryOperatorTable[BinOpKind_LogOr]  = &m_binOp_LogOr;
[-] 	m_binaryOperatorTable [BinOpKind_Eq]     = &m_binOp_Eq;
[+] 	m_binaryOperatorTable[BinOpKind_Eq]     = &m_binOp_Eq;
[-] 	m_binaryOperatorTable [BinOpKind_Ne]     = &m_binOp_Ne;
[+] 	m_binaryOperatorTable[BinOpKind_Ne]     = &m_binOp_Ne;
[-] 	m_binaryOperatorTable [BinOpKind_Lt]     = &m_binOp_Lt;
[+] 	m_binaryOperatorTable[BinOpKind_Lt]     = &m_binOp_Lt;
[-] 	m_binaryOperatorTable [BinOpKind_Le]     = &m_binOp_Le;
[+] 	m_binaryOperatorTable[BinOpKind_Le]     = &m_binOp_Le;
[-] 	m_binaryOperatorTable [BinOpKind_Gt]     = &m_binOp_Gt;
[+] 	m_binaryOperatorTable[BinOpKind_Gt]     = &m_binOp_Gt;
[-] 	m_binaryOperatorTable [BinOpKind_Ge]     = &m_binOp_Ge;
[+] 	m_binaryOperatorTable[BinOpKind_Ge]     = &m_binOp_Ge;
[-] 	m_binaryOperatorTable [BinOpKind_Idx]    = &m_binOp_Idx;
[+] 	m_binaryOperatorTable[BinOpKind_Idx]    = &m_binOp_Idx;
[-] 	m_binaryOperatorTable [BinOpKind_Assign]      = &m_binOp_Assign;
[+] 	m_binaryOperatorTable[BinOpKind_Assign]      = &m_binOp_Assign;
[-] 	m_binaryOperatorTable [BinOpKind_RefAssign]   = &m_binOp_RefAssign;
[+] 	m_binaryOperatorTable[BinOpKind_RefAssign]   = &m_binOp_RefAssign;
[-] 	m_binaryOperatorTable [BinOpKind_AddAssign]   = &m_binOp_AddAssign;
[+] 	m_binaryOperatorTable[BinOpKind_AddAssign]   = &m_binOp_AddAssign;
[-] 	m_binaryOperatorTable [BinOpKind_SubAssign]   = &m_binOp_SubAssign;
[+] 	m_binaryOperatorTable[BinOpKind_SubAssign]   = &m_binOp_SubAssign;
[-] 	m_binaryOperatorTable [BinOpKind_MulAssign]   = &m_binOp_MulAssign;
[+] 	m_binaryOperatorTable[BinOpKind_MulAssign]   = &m_binOp_MulAssign;
[-] 	m_binaryOperatorTable [BinOpKind_DivAssign]   = &m_binOp_DivAssign;
[+] 	m_binaryOperatorTable[BinOpKind_DivAssign]   = &m_binOp_DivAssign;
[-] 	m_binaryOperatorTable [BinOpKind_ModAssign]   = &m_binOp_ModAssign;
[+] 	m_binaryOperatorTable[BinOpKind_ModAssign]   = &m_binOp_ModAssign;
[-] 	m_binaryOperatorTable [BinOpKind_ShlAssign]   = &m_binOp_ShlAssign;
[+] 	m_binaryOperatorTable[BinOpKind_ShlAssign]   = &m_binOp_ShlAssign;
[-] 	m_binaryOperatorTable [BinOpKind_ShrAssign]   = &m_binOp_ShrAssign;
[+] 	m_binaryOperatorTable[BinOpKind_ShrAssign]   = &m_binOp_ShrAssign;
[-] 	m_binaryOperatorTable [BinOpKind_AndAssign]   = &m_binOp_AndAssign;
[+] 	m_binaryOperatorTable[BinOpKind_AndAssign]   = &m_binOp_AndAssign;
[-] 	m_binaryOperatorTable [BinOpKind_XorAssign]   = &m_binOp_XorAssign;
[+] 	m_binaryOperatorTable[BinOpKind_XorAssign]   = &m_binOp_XorAssign;
[-] 	m_binaryOperatorTable [BinOpKind_OrAssign]    = &m_binOp_OrAssign;
[+] 	m_binaryOperatorTable[BinOpKind_OrAssign]    = &m_binOp_OrAssign;
[-] 	m_binaryOperatorTable [BinOpKind_AtAssign]    = &m_binOp_AtAssign;
[+] 	m_binaryOperatorTable[BinOpKind_AtAssign]    = &m_binOp_AtAssign;
[-] 	m_stdCastOperatorTable [StdCast_Copy] = &m_cast_Copy;
[+] 	m_stdCastOperatorTable[StdCast_Copy] = &m_cast_Copy;
[-] 	m_stdCastOperatorTable [StdCast_SwapByteOrder] = &m_cast_SwapByteOrder;
[+] 	m_stdCastOperatorTable[StdCast_SwapByteOrder] = &m_cast_SwapByteOrder;
[-] 	m_stdCastOperatorTable [StdCast_PtrFromInt] = &m_cast_PtrFromInt;
[+] 	m_stdCastOperatorTable[StdCast_PtrFromInt] = &m_cast_PtrFromInt;
[-] 	m_stdCastOperatorTable [StdCast_Int] = &m_cast_Int;
[+] 	m_stdCastOperatorTable[StdCast_Int] = &m_cast_Int;
[-] 	m_stdCastOperatorTable [StdCast_BeInt] = &m_cast_BeInt;
[+] 	m_stdCastOperatorTable[StdCast_BeInt] = &m_cast_BeInt;
[-] 	m_stdCastOperatorTable [StdCast_Fp] = &m_cast_Fp;
[+] 	m_stdCastOperatorTable[StdCast_Fp] = &m_cast_Fp;
[-] 	m_stdCastOperatorTable [StdCast_FromVariant] = &m_cast_FromVariant;
[+] 	m_stdCastOperatorTable[StdCast_FromVariant] = &m_cast_FromVariant;
[-] 		m_castOperatorTable [i] = &m_cast_Default;
[+] 		m_castOperatorTable[i] = &m_cast_Default;
[-] 	m_castOperatorTable [TypeKind_Bool] = &m_cast_Bool;
[+] 	m_castOperatorTable[TypeKind_Bool] = &m_cast_Bool;
[-] 		m_castOperatorTable [i] = &m_cast_Int;
[+] 		m_castOperatorTable[i] = &m_cast_Int;
[-] 		m_castOperatorTable [i] = &m_cast_BeInt;
[+] 		m_castOperatorTable[i] = &m_cast_BeInt;
[-] 	m_castOperatorTable [TypeKind_Void]        = &m_cast_Void;
[+] 	m_castOperatorTable[TypeKind_Void]        = &m_cast_Void;
[-] 	m_castOperatorTable [TypeKind_Float]       = &m_cast_Fp;
[+] 	m_castOperatorTable[TypeKind_Float]       = &m_cast_Fp;
[-] 	m_castOperatorTable [TypeKind_Double]      = &m_cast_Fp;
[+] 	m_castOperatorTable[TypeKind_Double]      = &m_cast_Fp;
[-] 	m_castOperatorTable [TypeKind_Variant]     = &m_cast_Variant;
[+] 	m_castOperatorTable[TypeKind_Variant]     = &m_cast_Variant;
[-] 	m_castOperatorTable [TypeKind_Array]       = &m_cast_Array;
[+] 	m_castOperatorTable[TypeKind_Array]       = &m_cast_Array;
[-] 	m_castOperatorTable [TypeKind_Enum]        = &m_cast_Enum;
[+] 	m_castOperatorTable[TypeKind_Enum]        = &m_cast_Enum;
[-] 	m_castOperatorTable [TypeKind_Struct]      = &m_cast_Struct;
[+] 	m_castOperatorTable[TypeKind_Struct]      = &m_cast_Struct;
[-] 	m_castOperatorTable [TypeKind_DataPtr]     = &m_cast_DataPtr;
[+] 	m_castOperatorTable[TypeKind_DataPtr]     = &m_cast_DataPtr;
[-] 	m_castOperatorTable [TypeKind_DataRef]     = &m_cast_DataRef;
[+] 	m_castOperatorTable[TypeKind_DataRef]     = &m_cast_DataRef;
[-] 	m_castOperatorTable [TypeKind_ClassPtr]    = &m_cast_ClassPtr;
[+] 	m_castOperatorTable[TypeKind_ClassPtr]    = &m_cast_ClassPtr;
[-] 	m_castOperatorTable [TypeKind_FunctionPtr] = &m_cast_FunctionPtr;
[+] 	m_castOperatorTable[TypeKind_FunctionPtr] = &m_cast_FunctionPtr;
[-] 	m_castOperatorTable [TypeKind_FunctionRef] = &m_cast_FunctionRef;
[+] 	m_castOperatorTable[TypeKind_FunctionRef] = &m_cast_FunctionRef;
[-] 	m_castOperatorTable [TypeKind_PropertyPtr] = &m_cast_PropertyPtr;
[+] 	m_castOperatorTable[TypeKind_PropertyPtr] = &m_cast_PropertyPtr;
[-] 	m_castOperatorTable [TypeKind_PropertyRef] = &m_cast_PropertyRef;
[+] 	m_castOperatorTable[TypeKind_PropertyRef] = &m_cast_PropertyRef;
[-] OperatorMgr::clear ()
[+] OperatorMgr::clear()
[-] OperatorMgr::getOverloadedUnaryOperator (
[+] OperatorMgr::getOverloadedUnaryOperator(
[-] 	Type* opType = prepareOperandType (opValue);
[+] 	Type* opType = prepareOperandType(opValue);
[-] 	if (opType->getTypeKind () == TypeKind_ClassPtr)
[+] 	if (opType->getTypeKind() == TypeKind_ClassPtr)
[-] 		ClassPtrType* ptrType = (ClassPtrType*) opType;
[+] 		ClassPtrType* ptrType = (ClassPtrType*)opType;
[-] 		return ptrType->getTargetType ()->getUnaryOperator (opKind);
[+] 		return ptrType->getTargetType()->getUnaryOperator(opKind);
[-] 	else if (opType->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 	else if (opType->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 		DerivableType* derivableType = (DerivableType*) opType;
[+] 		DerivableType* derivableType = (DerivableType*)opType;
[-] 		return derivableType->getUnaryOperator (opKind);
[+] 		return derivableType->getUnaryOperator(opKind);
[-] OperatorMgr::getUnaryOperatorResultType (
[+] OperatorMgr::getUnaryOperatorResultType(
[-] 	ASSERT ((size_t) opKind < UnOpKind__Count);
[+] 	ASSERT((size_t)opKind < UnOpKind__Count);
[-] 	Function* function = getOverloadedUnaryOperator (opKind, rawOpValue);
[+] 	Function* function = getOverloadedUnaryOperator(opKind, rawOpValue);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue);
[+] 		argList.insertTail(rawOpValue);
[-] 		return getCallOperatorResultType (function->getTypeOverload (), &argList);
[+] 		return getCallOperatorResultType(function->getTypeOverload(), &argList);
[-] 	UnaryOperator* op = m_unaryOperatorTable [opKind];
[+] 	UnaryOperator* op = m_unaryOperatorTable[opKind];
[-] 	ASSERT (op);
[+] 	ASSERT(op);
[-] 	prepareOperandType (rawOpValue, &opValue, op->getOpFlags ());
[+] 	prepareOperandType(rawOpValue, &opValue, op->getOpFlags());
[-] 	return opValue.getType ()->getTypeKind () == TypeKind_Variant && opKind <= UnOpKind_Indir ?
[+] 	return opValue.getType()->getTypeKind() == TypeKind_Variant && opKind <= UnOpKind_Indir ?
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant) :
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant) :
[-] 		op->getResultType (opValue);
[+] 		op->getResultType(opValue);
[-] OperatorMgr::getUnaryOperatorResultType (
[+] OperatorMgr::getUnaryOperatorResultType(
[-] 	Type* resultType = getUnaryOperatorResultType (opKind, rawOpValue);
[+] 	Type* resultType = getUnaryOperatorResultType(opKind, rawOpValue);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::unaryOperator (
[+] OperatorMgr::unaryOperator(
[-] 	ASSERT ((size_t) opKind < UnOpKind__Count);
[+] 	ASSERT((size_t)opKind < UnOpKind__Count);
[-] 	Function* function = getOverloadedUnaryOperator (opKind, rawOpValue);
[+] 	Function* function = getOverloadedUnaryOperator(opKind, rawOpValue);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue);
[+] 		argList.insertTail(rawOpValue);
[-] 		return callOperator (function, &argList, resultValue);
[+] 		return callOperator(function, &argList, resultValue);
[-] 	UnaryOperator* op = m_unaryOperatorTable [opKind];
[+] 	UnaryOperator* op = m_unaryOperatorTable[opKind];
[-] 	ASSERT (op);
[+] 	ASSERT(op);
[-] 	bool result = prepareOperand (rawOpValue, &opValue, op->getOpFlags ());
[+] 	bool result = prepareOperand(rawOpValue, &opValue, op->getOpFlags());
[-] 	if (opValue.getType ()->getTypeKind () == TypeKind_Variant && opKind <= UnOpKind_Indir)
[+] 	if (opValue.getType()->getTypeKind() == TypeKind_Variant && opKind <= UnOpKind_Indir)
[-] 		Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_VariantUnaryOperator);
[+] 		Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_VariantUnaryOperator);
[-] 		Value opKindValue (opKind, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int));
[+] 		Value opKindValue(opKind, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int));
[-] 		return callOperator (function, opKindValue, opValue, resultValue);
[+] 		return callOperator(function, opKindValue, opValue, resultValue);
[-] 	return op->op (opValue, resultValue);
[+] 	return op->op(opValue, resultValue);
[-] OperatorMgr::getBinaryOperatorResultType (
[+] OperatorMgr::getBinaryOperatorResultType(
[-] 	ASSERT ((size_t) opKind < BinOpKind__Count);
[+] 	ASSERT((size_t)opKind < BinOpKind__Count);
[-] 	Function* function = getOverloadedBinaryOperator (opKind, rawOpValue1);
[+] 	Function* function = getOverloadedBinaryOperator(opKind, rawOpValue1);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue1);
[+] 		argList.insertTail(rawOpValue1);
[-] 		argList.insertTail (rawOpValue2);
[+] 		argList.insertTail(rawOpValue2);
[-] 		return getCallOperatorResultType (function->getTypeOverload (), &argList);
[+] 		return getCallOperatorResultType(function->getTypeOverload(), &argList);
[-] 	BinaryOperator* op = m_binaryOperatorTable [opKind];
[+] 	BinaryOperator* op = m_binaryOperatorTable[opKind];
[-] 	ASSERT (op);
[+] 	ASSERT(op);
[-] 	prepareOperandType (rawOpValue1, &opValue1, op->getOpFlags1 ());
[+] 	prepareOperandType(rawOpValue1, &opValue1, op->getOpFlags1());
[-] 	prepareOperandType (rawOpValue2, &opValue2, op->getOpFlags2 ());
[+] 	prepareOperandType(rawOpValue2, &opValue2, op->getOpFlags2());
[-] 		return m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		return m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 	if ((opValue1.getType ()->getTypeKind () == TypeKind_Variant ||
[+] 	if ((opValue1.getType()->getTypeKind() == TypeKind_Variant ||
[-] 		opValue2.getType ()->getTypeKind () == TypeKind_Variant) && opKind < BinOpKind_Eq)
[+] 		opValue2.getType()->getTypeKind() == TypeKind_Variant) && opKind < BinOpKind_Eq)
[-] 		return m_module->m_typeMgr.getPrimitiveType (TypeKind_Variant);
[+] 		return m_module->m_typeMgr.getPrimitiveType(TypeKind_Variant);
[-] 	return op->getResultType (opValue1, opValue2);
[+] 	return op->getResultType(opValue1, opValue2);
[-] OperatorMgr::getBinaryOperatorResultType (
[+] OperatorMgr::getBinaryOperatorResultType(
[-] 	Type* resultType = getBinaryOperatorResultType (opKind, rawOpValue1, rawOpValue2);
[+] 	Type* resultType = getBinaryOperatorResultType(opKind, rawOpValue1, rawOpValue2);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::getOverloadedBinaryOperator (
[+] OperatorMgr::getOverloadedBinaryOperator(
[-] 	Type* opType = prepareOperandType (opValue);
[+] 	Type* opType = prepareOperandType(opValue);
[-] 	if (opType->getTypeKind () == TypeKind_ClassPtr)
[+] 	if (opType->getTypeKind() == TypeKind_ClassPtr)
[-] 		ClassPtrType* ptrType = (ClassPtrType*) opType;
[+] 		ClassPtrType* ptrType = (ClassPtrType*)opType;
[-] 		return ptrType->getTargetType ()->getBinaryOperator (opKind);
[+] 		return ptrType->getTargetType()->getBinaryOperator(opKind);
[-] 	else if (opType->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 	else if (opType->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 		DerivableType* derivableType = (DerivableType*) opType;
[+] 		DerivableType* derivableType = (DerivableType*)opType;
[-] 		return derivableType->getBinaryOperator (opKind);
[+] 		return derivableType->getBinaryOperator(opKind);
[-] OperatorMgr::binaryOperator (
[+] OperatorMgr::binaryOperator(
[-] 	ASSERT ((size_t) opKind < BinOpKind__Count);
[+] 	ASSERT((size_t)opKind < BinOpKind__Count);
[-] 	Function* function = getOverloadedBinaryOperator (opKind, rawOpValue1);
[+] 	Function* function = getOverloadedBinaryOperator(opKind, rawOpValue1);
[-] 		if (function->getFlags () & MulticastMethodFlag_InaccessibleViaEventPtr)
[+] 		if (function->getFlags() & MulticastMethodFlag_InaccessibleViaEventPtr)
[-] 			prepareOperandType (rawOpValue1, &opValue1);
[+] 			prepareOperandType(rawOpValue1, &opValue1);
[-] 			if (opValue1.getType ()->getTypeKind () == TypeKind_ClassPtr &&
[+] 			if (opValue1.getType()->getTypeKind() == TypeKind_ClassPtr &&
[-] 				(opValue1.getType ()->getFlags () & PtrTypeFlag_Event))
[+] 				(opValue1.getType()->getFlags() & PtrTypeFlag_Event))
[-] 				err::setFormatStringError ("'%s' is inaccessible via 'event' pointer", getBinOpKindString (function->getBinOpKind ()));
[+] 				err::setFormatStringError("'%s' is inaccessible via 'event' pointer", getBinOpKindString (function->getBinOpKind ()));
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue1);
[+] 		argList.insertTail(rawOpValue1);
[-] 		argList.insertTail (rawOpValue2);
[+] 		argList.insertTail(rawOpValue2);
[-] 		return callOperator (function, &argList, resultValue);
[+] 		return callOperator(function, &argList, resultValue);
[-] 	BinaryOperator* op = m_binaryOperatorTable [opKind];
[+] 	BinaryOperator* op = m_binaryOperatorTable[opKind];
[-] 	ASSERT (op);
[+] 	ASSERT(op);
[-] 		prepareOperand (rawOpValue1, &opValue1, op->getOpFlags1 ()) &&
[+] 		prepareOperand(rawOpValue1, &opValue1, op->getOpFlags1()) &&
[-] 		prepareOperand (rawOpValue2, &opValue2, op->getOpFlags2 ());
[+] 		prepareOperand(rawOpValue2, &opValue2, op->getOpFlags2());
[-] 		(opValue1.getType ()->getTypeKind () == TypeKind_Variant ||
[+] 		(opValue1.getType()->getTypeKind() == TypeKind_Variant ||
[-] 		opValue2.getType ()->getTypeKind () == TypeKind_Variant))
[+] 		opValue2.getType()->getTypeKind() == TypeKind_Variant))
[-] 		Function* function = m_module->m_functionMgr.getStdFunction (stdFunc);
[+] 		Function* function = m_module->m_functionMgr.getStdFunction(stdFunc);
[-] 		Value opKindValue (opKind, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int));
[+] 		Value opKindValue(opKind, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int));
[-] 		return callOperator (function, opKindValue, opValue1, opValue2, resultValue);
[+] 		return callOperator(function, opKindValue, opValue1, opValue2, resultValue);
[-] 	return op->op (opValue1, opValue2, resultValue);
[+] 	return op->op(opValue1, opValue2, resultValue);
[-] getConditionalNumericOperatorResultType (
[+] getConditionalNumericOperatorResultType(
[-] 	if (trueType->getTypeKind () == TypeKind_Enum &&
[+] 	if (trueType->getTypeKind() == TypeKind_Enum &&
[-] 		(trueType->getFlags () & EnumTypeFlag_BitFlag) &&
[+] 		(trueType->getFlags() & EnumTypeFlag_BitFlag) &&
[-] 		falseValue.isZero ())
[+] 		falseValue.isZero())
[-] 	if (falseType->getTypeKind () == TypeKind_Enum &&
[+] 	if (falseType->getTypeKind() == TypeKind_Enum &&
[-] 		(falseType->getFlags () & EnumTypeFlag_BitFlag) &&
[+] 		(falseType->getFlags() & EnumTypeFlag_BitFlag) &&
[-] 		trueValue.isZero ())
[+] 		trueValue.isZero())
[-] 	return getArithmeticOperatorResultType (trueType, falseType);
[+] 	return getArithmeticOperatorResultType(trueType, falseType);
[-] OperatorMgr::getConditionalOperatorResultType (
[+] OperatorMgr::getConditionalOperatorResultType(
[-] 	Type* trueType = trueValue.getClosureAwareType ();
[+] 	Type* trueType = trueValue.getClosureAwareType();
[-] 	Type* falseType = falseValue.getClosureAwareType ();
[+] 	Type* falseType = falseValue.getClosureAwareType();
[-] 	if (trueType->getTypeKind () == TypeKind_Array)
[+] 	if (trueType->getTypeKind() == TypeKind_Array)
[-] 		trueType = ((ArrayType*) trueType)->getElementType ()->getDataPtrType ();
[+] 		trueType = ((ArrayType*)trueType)->getElementType()->getDataPtrType();
[-] 	if (falseType->getTypeKind () == TypeKind_Array)
[+] 	if (falseType->getTypeKind() == TypeKind_Array)
[-] 		falseType = ((ArrayType*) falseType)->getElementType ()->getDataPtrType ();
[+] 		falseType = ((ArrayType*)falseType)->getElementType()->getDataPtrType();
[-] 	if (trueType->cmp (falseType) == 0)
[+] 	if (trueType->cmp(falseType) == 0)
[-] 		if (isArrayRefType (trueType))
[+] 		if (isArrayRefType(trueType))
[-] 		if (isArrayRefType (falseType))
[+] 		if (isArrayRefType(falseType))
[-] 		trueType = prepareOperandType (trueType, trueFlags);
[+] 		trueType = prepareOperandType(trueType, trueFlags);
[-] 		falseType = prepareOperandType (falseType, falseFlags);
[+] 		falseType = prepareOperandType(falseType, falseFlags);
[-] 			trueType->cmp (falseType) == 0 ? trueType :
[+] 			trueType->cmp(falseType) == 0 ? trueType :
[-] 			(trueType->getTypeKindFlags () & falseType->getTypeKindFlags () & TypeKindFlag_Numeric) ?
[+] 			(trueType->getTypeKindFlags() & falseType->getTypeKindFlags() & TypeKindFlag_Numeric) ?
[-] 				getConditionalNumericOperatorResultType (trueValue, trueType, falseValue, falseType) :
[+] 				getConditionalNumericOperatorResultType(trueValue, trueType, falseValue, falseType) :
[-] 				prepareOperandType (trueType);
[+] 				prepareOperandType(trueType);
[-] 	if ((resultType->getTypeKindFlags () & TypeKindFlag_DataPtr) &&
[+] 	if ((resultType->getTypeKindFlags() & TypeKindFlag_DataPtr) &&
[-] 		((DataPtrType*) resultType)->getPtrTypeKind () == DataPtrTypeKind_Lean)
[+] 		((DataPtrType*)resultType)->getPtrTypeKind() == DataPtrTypeKind_Lean)
[-] 		resultType = ((DataPtrType*) resultType)->getTargetType ()->getDataPtrType (
[+] 		resultType = ((DataPtrType*)resultType)->getTargetType()->getDataPtrType(
[-] 			resultType->getTypeKind (),
[+] 			resultType->getTypeKind(),
[-] 			resultType->getFlags ()
[+] 			resultType->getFlags()
[-] 		checkCastKind (trueValue, resultType) &&
[+] 		checkCastKind(trueValue, resultType) &&
[-] 		checkCastKind (falseValue, resultType);
[+] 		checkCastKind(falseValue, resultType);
[-] OperatorMgr::getConditionalOperatorResultType (
[+] OperatorMgr::getConditionalOperatorResultType(
[-] 	Type* resultType = getConditionalOperatorResultType (trueValue, falseValue);
[+] 	Type* resultType = getConditionalOperatorResultType(trueValue, falseValue);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::conditionalOperator (
[+] OperatorMgr::conditionalOperator(
[-] 	Type* resultType = getConditionalOperatorResultType (rawTrueValue, rawFalseValue);
[+] 	Type* resultType = getConditionalOperatorResultType(rawTrueValue, rawFalseValue);
[-] 	if (resultType->getTypeKind () != TypeKind_Void)
[+] 	if (resultType->getTypeKind() != TypeKind_Void)
[-] 		result = castOperator (rawFalseValue, resultType, &falseValue);
[+] 		result = castOperator(rawFalseValue, resultType, &falseValue);
[-] 	BasicBlock* elseBlock = m_module->m_controlFlowMgr.getCurrentBlock (); // might have changed
[+] 	BasicBlock* elseBlock = m_module->m_controlFlowMgr.getCurrentBlock(); // might have changed
[-] 	m_module->m_controlFlowMgr.jump (phiBlock, thenBlock);
[+] 	m_module->m_controlFlowMgr.jump(phiBlock, thenBlock);
[-] 	if (resultType->getTypeKind () != TypeKind_Void)
[+] 	if (resultType->getTypeKind() != TypeKind_Void)
[-] 		result = castOperator (rawTrueValue, resultType, &trueValue);
[+] 		result = castOperator(rawTrueValue, resultType, &trueValue);
[-] 	thenBlock = m_module->m_controlFlowMgr.getCurrentBlock (); // might have changed
[+] 	thenBlock = m_module->m_controlFlowMgr.getCurrentBlock(); // might have changed
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	if (resultType->getTypeKind () != TypeKind_Void)
[+] 	if (resultType->getTypeKind() != TypeKind_Void)
[-] 		m_module->m_llvmIrBuilder.createPhi (trueValue, thenBlock, falseValue, elseBlock, resultValue);
[+] 		m_module->m_llvmIrBuilder.createPhi(trueValue, thenBlock, falseValue, elseBlock, resultValue);
[-] 		resultValue->setVoid (m_module);
[+] 		resultValue->setVoid(m_module);
[-] OperatorMgr::forceCast (
[+] OperatorMgr::forceCast(
[-] 	Type* srcType = value.getType ();
[+] 	Type* srcType = value.getType();
[-] 	if (srcType->getSize () >= dstType->getSize ())
[+] 	if (srcType->getSize() >= dstType->getSize())
[-] 		m_module->m_llvmIrBuilder.createAlloca (srcType, "tmp", NULL, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createAlloca(srcType, "tmp", NULL, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createStore (value, tmpValue);
[+] 		m_module->m_llvmIrBuilder.createStore(value, tmpValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (tmpValue, dstType->getDataPtrType_c (), &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(tmpValue, dstType->getDataPtrType_c(), &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createLoad (tmpValue, dstType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(tmpValue, dstType, resultValue);
[-] 		m_module->m_llvmIrBuilder.createAlloca (dstType, "tmp", NULL, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createAlloca(dstType, "tmp", NULL, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (tmpValue, srcType->getDataPtrType_c (), &tmpValue2);
[+] 		m_module->m_llvmIrBuilder.createBitCast(tmpValue, srcType->getDataPtrType_c(), &tmpValue2);
[-] 		m_module->m_llvmIrBuilder.createStore (value, tmpValue2);
[+] 		m_module->m_llvmIrBuilder.createStore(value, tmpValue2);
[-] 		m_module->m_llvmIrBuilder.createLoad (tmpValue, dstType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(tmpValue, dstType, resultValue);
[-] OperatorMgr::castOperator (
[+] OperatorMgr::castOperator(
[-] 	if (rawOpValue.getValueKind () == ValueKind_Null)
[+] 	if (rawOpValue.getValueKind() == ValueKind_Null)
[-] 		if ((type->getTypeKindFlags () & TypeKindFlag_Ptr) && (type->getFlags () & PtrTypeFlag_Safe))
[+] 		if ((type->getTypeKindFlags() & TypeKindFlag_Ptr) && (type->getFlags() & PtrTypeFlag_Safe))
[-] 			setCastError (rawOpValue, type);
[+] 			setCastError(rawOpValue, type);
[-] 		if (type->getTypeKind () == TypeKind_Void)
[+] 		if (type->getTypeKind() == TypeKind_Void)
[-] 			resultValue->setNull (m_module);
[+] 			resultValue->setNull(m_module);
[-] 			*resultValue = type->getZeroValue ();
[+] 			*resultValue = type->getZeroValue();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	ASSERT ((size_t) typeKind < TypeKind__Count);
[+] 	ASSERT((size_t)typeKind < TypeKind__Count);
[-] 	CastOperator* op = m_castOperatorTable [typeKind];
[+] 	CastOperator* op = m_castOperatorTable[typeKind];
[-] 	ASSERT (op); // there is always a default
[+] 	ASSERT(op); // there is always a default
[-] 	result = prepareOperand (rawOpValue, &opValue, op->getOpFlags ());
[+] 	result = prepareOperand(rawOpValue, &opValue, op->getOpFlags());
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	if (opType->cmp (type) == 0) // identity, try to shortcut
[+] 	if (opType->cmp(type) == 0) // identity, try to shortcut
[-] 		if (opValue.hasLlvmValue ())
[+] 		if (opValue.hasLlvmValue())
[-] 		if (opValue.getValueKind () == ValueKind_Property)
[+] 		if (opValue.getValueKind() == ValueKind_Property)
[-] 			ASSERT (type->getTypeKind () == TypeKind_PropertyPtr);
[+] 			ASSERT(type->getTypeKind() == TypeKind_PropertyPtr);
[-] 			return getPropertyThinPtr (opValue.getProperty (), opValue.getClosure (), (PropertyPtrType*) type, resultValue);
[+] 			return getPropertyThinPtr(opValue.getProperty(), opValue.getClosure(), (PropertyPtrType*)type, resultValue);
[-] 	if (opType->getTypeKind () == TypeKind_Variant)
[+] 	if (opType->getTypeKind() == TypeKind_Variant)
[-] 		return m_stdCastOperatorTable [StdCast_FromVariant]->cast (opValue, type, resultValue);
[+] 		return m_stdCastOperatorTable[StdCast_FromVariant]->cast(opValue, type, resultValue);
[-] 		return op->cast (opValue, type, resultValue);
[+] 		return op->cast(opValue, type, resultValue);
[-] 	typeKind = type->getTypeKind ();
[+] 	typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return dynamicCastDataPtr (opValue, (DataPtrType*) type, resultValue);
[+] 		return dynamicCastDataPtr(opValue, (DataPtrType*)type, resultValue);
[-] 		return dynamicCastClassPtr (opValue, (ClassPtrType*) type, resultValue);
[+] 		return dynamicCastClassPtr(opValue, (ClassPtrType*)type, resultValue);
[-] 		err::setFormatStringError ("cannot dynamically cast to '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot dynamically cast to '%s'", type->getTypeString ().sz ());
[-] OperatorMgr::castOperator (
[+] OperatorMgr::castOperator(
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (typeKind);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(typeKind);
[-] 	return castOperator (dynamism, opValue, type, resultValue);
[+] 	return castOperator(dynamism, opValue, type, resultValue);
[-] OperatorMgr::dynamicCastDataPtr (
[+] OperatorMgr::dynamicCastDataPtr(
[-] 	if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr))
[+] 	if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr))
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			opValue.getType ()->getTypeString ().sz (),
[+] 			opValue.getType()->getTypeString().sz(),
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] 	if ((opValue.getType ()->getFlags () & PtrTypeFlag_Const) &&
[+] 	if ((opValue.getType()->getFlags() & PtrTypeFlag_Const) &&
[-] 		!(type->getFlags () & PtrTypeFlag_Const))
[+] 		!(type->getFlags() & PtrTypeFlag_Const))
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	bool result = castOperator (
[+] 	bool result = castOperator(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Void)->getDataPtrType (DataPtrTypeKind_Normal, PtrTypeFlag_Const),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Void)->getDataPtrType(DataPtrTypeKind_Normal, PtrTypeFlag_Const),
[-] 	Type* targetType = type->getTargetType ();
[+] 	Type* targetType = type->getTargetType();
[-] 	Value typeValue (&targetType, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value typeValue(&targetType, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicCastDataPtr);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicCastDataPtr);
[-] 	result = callOperator (function, ptrValue, typeValue, resultValue);
[+] 	result = callOperator(function, ptrValue, typeValue, resultValue);
[-] 	resultValue->overrideType (type);
[+] 	resultValue->overrideType(type);
[-] OperatorMgr::dynamicCastClassPtr (
[+] OperatorMgr::dynamicCastClassPtr(
[-] 	if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr))
[+] 	if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr))
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			opValue.getType ()->getTypeString ().sz (),
[+] 			opValue.getType()->getTypeString().sz(),
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] 	if ((opValue.getType ()->getFlags () & PtrTypeFlag_Const) &&
[+] 	if ((opValue.getType()->getFlags() & PtrTypeFlag_Const) &&
[-] 		!(type->getFlags () & PtrTypeFlag_Const))
[+] 		!(type->getFlags() & PtrTypeFlag_Const))
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &ptrValue);
[-] 	Type* targetType = type->getTargetType ();
[+] 	Type* targetType = type->getTargetType();
[-] 	Value typeValue (&targetType, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value typeValue(&targetType, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicCastClassPtr);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicCastClassPtr);
[-] 	m_module->m_llvmIrBuilder.createCall2 (
[+] 	m_module->m_llvmIrBuilder.createCall2(
[-] 		function->getType (),
[+] 		function->getType(),
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, type, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, type, resultValue);
[-] OperatorMgr::getCastKind (
[+] OperatorMgr::getCastKind(
[-] 	if (rawOpValue.getValueKind () == ValueKind_Null)
[+] 	if (rawOpValue.getValueKind() == ValueKind_Null)
[-] 		return (type->getTypeKindFlags () & TypeKindFlag_Nullable) ? CastKind_Implicit : CastKind_None;
[+] 		return (type->getTypeKindFlags() & TypeKindFlag_Nullable) ? CastKind_Implicit : CastKind_None;
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	ASSERT ((size_t) typeKind < TypeKind__Count);
[+] 	ASSERT((size_t)typeKind < TypeKind__Count);
[-] 	CastOperator* op = m_castOperatorTable [typeKind];
[+] 	CastOperator* op = m_castOperatorTable[typeKind];
[-] 	ASSERT (op); // there is always a default
[+] 	ASSERT(op); // there is always a default
[-] 	prepareOperandType (
[+] 	prepareOperandType(
[-] 		op->getOpFlags ()
[+] 		op->getOpFlags()
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 		opType->cmp (type) == 0 ? CastKind_Identitiy :
[+] 		opType->cmp(type) == 0 ? CastKind_Identitiy :
[-] 		opType->getTypeKind () == TypeKind_Variant ? CastKind_ImplicitCrossFamily :
[+] 		opType->getTypeKind() == TypeKind_Variant ? CastKind_ImplicitCrossFamily :
[-] 		op->getCastKind (opValue, type);
[+] 		op->getCastKind(opValue, type);
[-] OperatorMgr::getArgCastKind (
[+] OperatorMgr::getArgCastKind(
[-] 	sl::Array <FunctionArg*> formalArgArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> formalArgArray = functionType->getArgArray();
[-] 	size_t formalArgCount = formalArgArray.getCount ();
[+] 	size_t formalArgCount = formalArgArray.getCount();
[-] 	if (actualArgCount > formalArgCount && !(functionType->getFlags () & FunctionTypeFlag_VarArg))
[+] 	if (actualArgCount > formalArgCount && !(functionType->getFlags() & FunctionTypeFlag_VarArg))
[-] 		if (formalArgArray [argCount - 1]->getInitializer ().isEmpty ())
[+] 		if (formalArgArray[argCount - 1]->getInitializer().isEmpty())
[-] 		Type* formalArgType = formalArgArray [i]->getType ();
[+] 		Type* formalArgType = formalArgArray[i]->getType();
[-] 		Type* actualArgType = actualArgArray [i]->getType ();
[+] 		Type* actualArgType = actualArgArray[i]->getType();
[-] 		CastKind castKind = getCastKind (actualArgType, formalArgType);
[+] 		CastKind castKind = getCastKind(actualArgType, formalArgType);
[-] OperatorMgr::getArgCastKind (
[+] OperatorMgr::getArgCastKind(
[-] 	sl::Array <FunctionArg*> formalArgArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> formalArgArray = functionType->getArgArray();
[-] 	size_t formalArgCount = formalArgArray.getCount ();
[+] 	size_t formalArgCount = formalArgArray.getCount();
[-] 	if (actualArgCount > formalArgCount && !(functionType->getFlags () & FunctionTypeFlag_VarArg))
[+] 	if (actualArgCount > formalArgCount && !(functionType->getFlags() & FunctionTypeFlag_VarArg))
[-] 		if (formalArgArray [argCount - 1]->getInitializer ().isEmpty ())
[+] 		if (formalArgArray[argCount - 1]->getInitializer().isEmpty())
[-] 		Type* formalArgType = formalArgArray [i]->getType ();
[+] 		Type* formalArgType = formalArgArray[i]->getType();
[-] 		Type* actualArgType = argValueArray [i].getType ();
[+] 		Type* actualArgType = argValueArray[i].getType();
[-] 			return formalArgArray [i]->getInitializer ().isEmpty () ? CastKind_None : CastKind_Identitiy;
[+] 			return formalArgArray[i]->getInitializer().isEmpty() ? CastKind_None : CastKind_Identitiy;
[-] 		CastKind castKind = getCastKind (actualArgType, formalArgType);
[+] 		CastKind castKind = getCastKind(actualArgType, formalArgType);
[-] OperatorMgr::getArgCastKind (
[+] OperatorMgr::getArgCastKind(
[-] 	const sl::ConstBoxList <Value>& argList
[+] 	const sl::ConstBoxList<Value>& argList
[-] 	size_t actualArgCount = argList.getCount ();
[+] 	size_t actualArgCount = argList.getCount();
[-] 	sl::Array <FunctionArg*> formalArgArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> formalArgArray = functionType->getArgArray();
[-] 	size_t formalArgCount = formalArgArray.getCount ();
[+] 	size_t formalArgCount = formalArgArray.getCount();
[-] 	if (actualArgCount > formalArgCount && !(functionType->getFlags () & FunctionTypeFlag_VarArg))
[+] 	if (actualArgCount > formalArgCount && !(functionType->getFlags() & FunctionTypeFlag_VarArg))
[-] 		if (formalArgArray [argCount - 1]->getInitializer ().isEmpty ())
[+] 		if (formalArgArray[argCount - 1]->getInitializer().isEmpty())
[-] 	sl::ConstBoxIterator <Value> arg = argList.getHead ();
[+] 	sl::ConstBoxIterator<Value> arg = argList.getHead();
[-] 		Type* formalArgType = formalArgArray [i]->getType ();
[+] 		Type* formalArgType = formalArgArray[i]->getType();
[-] 		if (arg->isEmpty ())
[+] 		if (arg->isEmpty())
[-] 			return formalArgArray [i]->getInitializer ().isEmpty () ? CastKind_None : CastKind_Identitiy;
[+] 			return formalArgArray[i]->getInitializer().isEmpty() ? CastKind_None : CastKind_Identitiy;
[-] 		CastKind castKind = getCastKind (*arg, formalArgType);
[+] 		CastKind castKind = getCastKind(*arg, formalArgType);
[-] OperatorMgr::getFunctionCastKind (
[+] OperatorMgr::getFunctionCastKind(
[-] 	CastKind argCastKind = getArgCastKind (srcType, dstType->getArgArray ());
[+] 	CastKind argCastKind = getArgCastKind(srcType, dstType->getArgArray());
[-] 	Type* srcReturnType = srcType->getReturnType ();
[+] 	Type* srcReturnType = srcType->getReturnType();
[-] 	Type* dstReturnType = dstType->getReturnType ();
[+] 	Type* dstReturnType = dstType->getReturnType();
[-] 	if (dstReturnType->getTypeKind () == TypeKind_Void)
[+] 	if (dstReturnType->getTypeKind() == TypeKind_Void)
[-] 	CastKind returnCastKind = getCastKind (srcReturnType, dstReturnType);
[+] 	CastKind returnCastKind = getCastKind(srcReturnType, dstReturnType);
[-] 	return AXL_MIN (argCastKind, returnCastKind);
[+] 	return AXL_MIN(argCastKind, returnCastKind);
[-] OperatorMgr::getPropertyCastKind (
[+] OperatorMgr::getPropertyCastKind(
[-] 	CastKind castKind = getFunctionCastKind (srcType->getGetterType (), dstType->getGetterType ());
[+] 	CastKind castKind = getFunctionCastKind(srcType->getGetterType(), dstType->getGetterType());
[-] 	FunctionTypeOverload* srcSetterType = srcType->getSetterType ();
[+] 	FunctionTypeOverload* srcSetterType = srcType->getSetterType();
[-] 	FunctionTypeOverload* dstSetterType = dstType->getSetterType ();
[+] 	FunctionTypeOverload* dstSetterType = dstType->getSetterType();
[-] 	size_t count = dstSetterType->getOverloadCount ();
[+] 	size_t count = dstSetterType->getOverloadCount();
[-] 		FunctionType* dstOverload = dstSetterType->getOverload (i);
[+] 		FunctionType* dstOverload = dstSetterType->getOverload(i);
[-] 		size_t j = srcSetterType->chooseOverload (dstOverload->getArgArray (), &castKind);
[+] 		size_t j = srcSetterType->chooseOverload(dstOverload->getArgArray(), &castKind);
[-] OperatorMgr::checkCastKind (
[+] OperatorMgr::checkCastKind(
[-] 	CastKind castKind = getCastKind (opValue, type);
[+] 	CastKind castKind = getCastKind(opValue, type);
[-] 		setCastError (opValue, type, castKind);
[+] 		setCastError(opValue, type, castKind);
[-] OperatorMgr::sizeofOperator (
[+] OperatorMgr::sizeofOperator(
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKind () == TypeKind_DataRef)
[+] 	if (type->getTypeKind() == TypeKind_DataRef)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		if (type->getFlags () & TypeFlag_Dynamic)
[+] 		if (type->getFlags() & TypeFlag_Dynamic)
[-] 			DynamicFieldValueInfo* fieldInfo = opValue.getDynamicFieldInfo ();
[+] 			DynamicFieldValueInfo* fieldInfo = opValue.getDynamicFieldInfo();
[-] 				Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicFieldSizeOf);
[+] 				Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicFieldSizeOf);
[-] 				Value typeValue (&fieldInfo->m_parentType, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 				Value typeValue(&fieldInfo->m_parentType, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 				Value fieldValue (&fieldInfo->m_field, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 				Value fieldValue(&fieldInfo->m_field, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 				return callOperator (function, fieldInfo->m_parentValue, typeValue, fieldValue, resultValue);
[+] 				return callOperator(function, fieldInfo->m_parentValue, typeValue, fieldValue, resultValue);
[-] 				Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicTypeSizeOf);
[+] 				Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicTypeSizeOf);
[-] 				Value typeValue (&type, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 				Value typeValue(&type, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 				return callOperator (function, opValue, typeValue, resultValue);
[+] 				return callOperator(function, opValue, typeValue, resultValue);
[-] 		type = prepareOperandType (opValue);
[+] 		type = prepareOperandType(opValue);
[-] 		if (type->getTypeKind () != TypeKind_DataPtr)
[+] 		if (type->getTypeKind() != TypeKind_DataPtr)
[-] 			err::setFormatStringError ("'dynamic sizeof' operator is only applicable to data pointers, not to '%s'", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'dynamic sizeof' operator is only applicable to data pointers, not to '%s'", type->getTypeString ().sz ());
[-] 		Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicSizeOf);
[+] 		Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicSizeOf);
[-] 		return callOperator (function, opValue, resultValue);
[+] 		return callOperator(function, opValue, resultValue);
[-] 	if (type->getFlags () & TypeFlag_Dynamic)
[+] 	if (type->getFlags() & TypeFlag_Dynamic)
[-] 		err::setError ("use 'dynamic sizeof' to get size of a dynamic type");
[+] 		err::setError("use 'dynamic sizeof' to get size of a dynamic type");
[-] 	resultValue->setConstSizeT (type->getSize (), m_module);
[+] 	resultValue->setConstSizeT(type->getSize(), m_module);
[-] OperatorMgr::countofOperator (
[+] OperatorMgr::countofOperator(
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKind () == TypeKind_DataRef)
[+] 	if (type->getTypeKind() == TypeKind_DataRef)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		if (type->getFlags () & TypeFlag_Dynamic)
[+] 		if (type->getFlags() & TypeFlag_Dynamic)
[-] 			DynamicFieldValueInfo* fieldInfo = opValue.getDynamicFieldInfo ();
[+] 			DynamicFieldValueInfo* fieldInfo = opValue.getDynamicFieldInfo();
[-] 				err::setError ("invalid 'dynamic countof' operator");
[+] 				err::setError("invalid 'dynamic countof' operator");
[-] 			Type* fieldType = fieldInfo->m_field->getType ();
[+] 			Type* fieldType = fieldInfo->m_field->getType();
[-] 			if (fieldType->getTypeKind () != TypeKind_Array)
[+] 			if (fieldType->getTypeKind() != TypeKind_Array)
[-] 				err::setFormatStringError ("'dynamic countof' operator is only applicable to arrays, not to '%s'", type->getTypeString ().sz ());
[+] 				err::setFormatStringError("'dynamic countof' operator is only applicable to arrays, not to '%s'", type->getTypeString ().sz ());
[-] 			Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicFieldCountOf);
[+] 			Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicFieldCountOf);
[-] 			Value typeValue (&fieldInfo->m_parentType, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 			Value typeValue(&fieldInfo->m_parentType, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 			Value fieldValue (&fieldInfo->m_field, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 			Value fieldValue(&fieldInfo->m_field, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 			return callOperator (function, fieldInfo->m_parentValue, typeValue, fieldValue, resultValue);
[+] 			return callOperator(function, fieldInfo->m_parentValue, typeValue, fieldValue, resultValue);
[-] 		type = prepareOperandType (opValue);
[+] 		type = prepareOperandType(opValue);
[-] 		if (type->getTypeKind () != TypeKind_DataPtr)
[+] 		if (type->getTypeKind() != TypeKind_DataPtr)
[-] 			err::setFormatStringError ("'dynamic countof' operator is only applicable to data pointers, not to '%s'", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'dynamic countof' operator is only applicable to data pointers, not to '%s'", type->getTypeString ().sz ());
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		Value typeValue (&type, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 		Value typeValue(&type, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 		Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_DynamicCountOf);
[+] 		Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_DynamicCountOf);
[-] 		return callOperator (function, opValue, typeValue, resultValue);
[+] 		return callOperator(function, opValue, typeValue, resultValue);
[-] 	if (type->getTypeKind () != TypeKind_Array)
[+] 	if (type->getTypeKind() != TypeKind_Array)
[-] 		err::setFormatStringError ("'countof' operator is only applicable to arrays, not to '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'countof' operator is only applicable to arrays, not to '%s'", type->getTypeString ().sz ());
[-] 	if (type->getFlags () & TypeFlag_Dynamic)
[+] 	if (type->getFlags() & TypeFlag_Dynamic)
[-] 		err::setError ("use 'dynamic countof' to get element count of a dynamic array");
[+] 		err::setError("use 'dynamic countof' to get element count of a dynamic array");
[-] 	resultValue->setConstSizeT (((ArrayType*) type)->getElementCount (), m_module);
[+] 	resultValue->setConstSizeT(((ArrayType*)type)->getElementCount(), m_module);
[-] OperatorMgr::typeofOperator (
[+] OperatorMgr::typeofOperator(
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKind () == TypeKind_DataRef)
[+] 	if (type->getTypeKind() == TypeKind_DataRef)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 	resultValue->setNull (m_module);
[+] 	resultValue->setNull(m_module);
[-] OperatorMgr::prepareOperandType (
[+] OperatorMgr::prepareOperandType(
[-] 	if (opValue.isEmpty ())
[+] 	if (opValue.isEmpty())
[-] 		Type* type = value.getType ();
[+] 		Type* type = value.getType();
[-] 		TypeKind typeKind = type->getTypeKind ();
[+] 		TypeKind typeKind = type->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 				DataPtrType* ptrType = (DataPtrType*) type;
[+] 				DataPtrType* ptrType = (DataPtrType*)type;
[-] 				Type* targetType = ptrType->getTargetType ();
[+] 				Type* targetType = ptrType->getTargetType();
[-] 				TypeKind targetTypeKind = targetType->getTypeKind ();
[+] 				TypeKind targetTypeKind = targetType->getTypeKind();
[-] 					BitFieldType* bitFieldType = (BitFieldType*) targetType;
[+] 					BitFieldType* bitFieldType = (BitFieldType*)targetType;
[-] 					value = bitFieldType->getBaseType ();
[+] 					value = bitFieldType->getBaseType();
[-] 					bool b1 = (targetType->getTypeKindFlags () & TypeKindFlag_Derivable) && (opFlags & OpFlag_KeepDerivableRef);
[+] 					bool b1 = (targetType->getTypeKindFlags() & TypeKindFlag_Derivable) && (opFlags & OpFlag_KeepDerivableRef);
[-] 						value = ((DataPtrType*) type)->getTargetType ();
[+] 						value = ((DataPtrType*)type)->getTargetType();
[-] 					value = ((DataPtrType*) type)->getTargetType ();
[+] 					value = ((DataPtrType*)type)->getTargetType();
[-] 					ArrayType* arrayType = (ArrayType*) targetType;
[+] 					ArrayType* arrayType = (ArrayType*)targetType;
[-] 					value = arrayType->getElementType ()->getDataPtrType (
[+] 					value = arrayType->getElementType()->getDataPtrType(
[-] 						ptrType->getPtrTypeKind (),
[+] 						ptrType->getPtrTypeKind(),
[-] 						ptrType->getFlags ()
[+] 						ptrType->getFlags()
[-] 				ClassPtrType* ptrType = (ClassPtrType*) type;
[+] 				ClassPtrType* ptrType = (ClassPtrType*)type;
[-] 				ClassType* targetType = ptrType->getTargetType ();
[+] 				ClassType* targetType = ptrType->getTargetType();
[-] 				value = targetType->getClassPtrType (
[+] 				value = targetType->getClassPtrType(
[-] 					ptrType->getPtrTypeKind (),
[+] 					ptrType->getPtrTypeKind(),
[-] 					ptrType->getFlags ()
[+] 					ptrType->getFlags()
[-] 				FunctionPtrType* ptrType = (FunctionPtrType*) value.getClosureAwareType (); // important: take closure into account!
[+] 				FunctionPtrType* ptrType = (FunctionPtrType*)value.getClosureAwareType(); // important: take closure into account!
[-] 				FunctionType* targetType = ptrType->getTargetType ();
[+] 				FunctionType* targetType = ptrType->getTargetType();
[-] 				value = targetType->getFunctionPtrType (ptrType->getPtrTypeKind (), ptrType->getFlags ());
[+] 				value = targetType->getFunctionPtrType(ptrType->getPtrTypeKind(), ptrType->getFlags());
[-] 				PropertyPtrType* ptrType = (PropertyPtrType*) value.getClosureAwareType ();
[+] 				PropertyPtrType* ptrType = (PropertyPtrType*)value.getClosureAwareType();
[-] 				PropertyType* targetType = ptrType->getTargetType ();
[+] 				PropertyType* targetType = ptrType->getTargetType();
[-] 				if (!targetType->isIndexed ())
[+] 				if (!targetType->isIndexed())
[-] 					value = targetType->getReturnType ();
[+] 					value = targetType->getReturnType();
[-] 				value = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int8);
[+] 				value = m_module->m_typeMgr.getPrimitiveType(TypeKind_Int8);
[-] 				value = ((EnumType*) type)->getBaseType ();
[+] 				value = ((EnumType*)type)->getBaseType();
[-] 		if (value.getType () == type)
[+] 		if (value.getType() == type)
[-] OperatorMgr::prepareOperandType (
[+] OperatorMgr::prepareOperandType(
[-] 	prepareOperandType (opValue, &resultValue, opFlags);
[+] 	prepareOperandType(opValue, &resultValue, opFlags);
[-] 	return resultValue.getType ();
[+] 	return resultValue.getType();
[-] OperatorMgr::prepareArrayRef (
[+] OperatorMgr::prepareArrayRef(
[-] 	ASSERT (isArrayRefType (value.getType ()));
[+] 	ASSERT(isArrayRefType(value.getType()));
[-] 	DataPtrType* ptrType = (DataPtrType*) value.getType ();
[+] 	DataPtrType* ptrType = (DataPtrType*)value.getType();
[-] 	DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 	ArrayType* arrayType = (ArrayType*) ptrType->getTargetType ();
[+] 	ArrayType* arrayType = (ArrayType*)ptrType->getTargetType();
[-] 	Type* elementType = arrayType->getElementType ();
[+] 	Type* elementType = arrayType->getElementType();
[-] 	DataPtrType* resultType = elementType->getDataPtrType (
[+] 	DataPtrType* resultType = elementType->getDataPtrType(
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] 	if (value.getValueKind () == ValueKind_Const || ptrTypeKind == DataPtrTypeKind_Normal)
[+] 	if (value.getValueKind() == ValueKind_Const || ptrTypeKind == DataPtrTypeKind_Normal)
[-] 		resultValue->overrideType (value, resultType);
[+] 		resultValue->overrideType(value, resultType);
[-] 		m_module->m_llvmIrBuilder.createGep2 (value, 0, resultType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(value, 0, resultType, resultValue);
[-] 		LeanDataPtrValidator* validator = value.getLeanDataPtrValidator ();
[+] 		LeanDataPtrValidator* validator = value.getLeanDataPtrValidator();
[-] 		m_module->m_llvmIrBuilder.createGep2 (value, 0, resultType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createGep2(value, 0, resultType, resultValue);
[-] 		resultValue->setLeanDataPtrValidator (validator);
[+] 		resultValue->setLeanDataPtrValidator(validator);
[-] OperatorMgr::prepareOperand (
[+] OperatorMgr::prepareOperand(
[-] 	if (opValue.isEmpty ())
[+] 	if (opValue.isEmpty())
[-] 		Type* type = value.getType ();
[+] 		Type* type = value.getType();
[-] 		TypeKind typeKind = type->getTypeKind ();
[+] 		TypeKind typeKind = type->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 				DataPtrType* ptrType = (DataPtrType*) type;
[+] 				DataPtrType* ptrType = (DataPtrType*)type;
[-] 				Type* targetType = ptrType->getTargetType ();
[+] 				Type* targetType = ptrType->getTargetType();
[-] 				TypeKind targetTypeKind = targetType->getTypeKind ();
[+] 				TypeKind targetTypeKind = targetType->getTypeKind();
[-] 					bool b1 = (targetType->getTypeKindFlags () & TypeKindFlag_Derivable) && (opFlags & OpFlag_KeepDerivableRef);
[+] 					bool b1 = (targetType->getTypeKindFlags() & TypeKindFlag_Derivable) && (opFlags & OpFlag_KeepDerivableRef);
[-] 						result = loadDataRef (&value);
[+] 						result = loadDataRef(&value);
[-] 					result = loadDataRef (&value);
[+] 					result = loadDataRef(&value);
[-] 					prepareArrayRef (&value);
[+] 					prepareArrayRef(&value);
[-] 				ClassPtrType* ptrType = (ClassPtrType*) type;
[+] 				ClassPtrType* ptrType = (ClassPtrType*)type;
[-] 				ClassType* targetType = ptrType->getTargetType ();
[+] 				ClassType* targetType = ptrType->getTargetType();
[-] 				value.overrideType (targetType->getClassPtrType (
[+] 				value.overrideType(targetType->getClassPtrType(
[-] 					ptrType->getPtrTypeKind (),
[+] 					ptrType->getPtrTypeKind(),
[-] 					ptrType->getFlags ())
[+] 					ptrType->getFlags())
[-] 				FunctionPtrType* ptrType = (FunctionPtrType*) type;
[+] 				FunctionPtrType* ptrType = (FunctionPtrType*)type;
[-] 				FunctionType* targetType = ptrType->getTargetType ();
[+] 				FunctionType* targetType = ptrType->getTargetType();
[-] 				value.overrideType (targetType->getFunctionPtrType (ptrType->getPtrTypeKind (), ptrType->getFlags ()));
[+] 				value.overrideType(targetType->getFunctionPtrType(ptrType->getPtrTypeKind(), ptrType->getFlags()));
[-] 				PropertyPtrType* ptrType = (PropertyPtrType*) value.getClosureAwareType ();
[+] 				PropertyPtrType* ptrType = (PropertyPtrType*)value.getClosureAwareType();
[-] 				PropertyType* targetType = ptrType->getTargetType ();
[+] 				PropertyType* targetType = ptrType->getTargetType();
[-] 				if (!targetType->isIndexed ())
[+] 				if (!targetType->isIndexed())
[-] 					result = getProperty (value, &value);
[+] 					result = getProperty(value, &value);
[-] 				result = m_castIntFromBool.cast (value, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int8), &value);
[+] 				result = m_castIntFromBool.cast(value, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int8), &value);
[-] 				value.overrideType (((EnumType*) type)->getBaseType ());
[+] 				value.overrideType(((EnumType*)type)->getBaseType());
[-] 		if (value.getType () == type)
[+] 		if (value.getType() == type)
[-] OperatorMgr::awaitOperator (
[+] OperatorMgr::awaitOperator(
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	if (function->getFunctionKind () != FunctionKind_Async)
[+] 	if (function->getFunctionKind() != FunctionKind_Async)
[-] 		err::setError ("await can only be used in async functions");
[+] 		err::setError("await can only be used in async functions");
[-] 	Value thisPromiseValue = m_module->m_functionMgr.getPromiseValue ();
[+] 	Value thisPromiseValue = m_module->m_functionMgr.getPromiseValue();
[-] 	ASSERT (thisPromiseValue);
[+] 	ASSERT(thisPromiseValue);
[-] 	size_t stateId = m_module->m_controlFlowMgr.getAsyncBlockArray ().getCount ();
[+] 	size_t stateId = m_module->m_controlFlowMgr.getAsyncBlockArray().getCount();
[-] 	stateIdValue.setConstSizeT (stateId, m_module);
[+] 	stateIdValue.setConstSizeT(stateId, m_module);
[-] 		castOperator (value, m_module->m_typeMgr.getStdType (StdType_PromisePtr), &opPromiseValue) &&
[+] 		castOperator(value, m_module->m_typeMgr.getStdType(StdType_PromisePtr), &opPromiseValue) &&
[-] 		memberOperator (opPromiseValue, "wait", &waitValue) &&
[+] 		memberOperator(opPromiseValue, "wait", &waitValue) &&
[-] 		getPromiseField (thisPromiseValue, "m_state", &stateFieldValue);
[+] 		getPromiseField(thisPromiseValue, "m_state", &stateFieldValue);
[-] 		storeDataRef (stateFieldValue, stateIdValue) &&
[+] 		storeDataRef(stateFieldValue, stateIdValue) &&
[-] 		getPromiseField (thisPromiseValue, "m_pendingPromise", &pendingPromiseFieldValue) &&
[+] 		getPromiseField(thisPromiseValue, "m_pendingPromise", &pendingPromiseFieldValue) &&
[-] 		storeDataRef (pendingPromiseFieldValue, opPromiseValue) &&
[+] 		storeDataRef(pendingPromiseFieldValue, opPromiseValue) &&
[-] 		closureOperator (function, thisPromiseValue, &resumeValue) &&
[+] 		closureOperator(function, thisPromiseValue, &resumeValue) &&
[-] 		callOperator (waitValue, resumeValue);
[+] 		callOperator(waitValue, resumeValue);
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	BasicBlock* block = m_module->m_controlFlowMgr.createAsyncBlock (scope);
[+] 	BasicBlock* block = m_module->m_controlFlowMgr.createAsyncBlock(scope);
[-] 	m_module->m_controlFlowMgr.asyncRet (block);
[+] 	m_module->m_controlFlowMgr.asyncRet(block);
[-] 		getPromiseField (thisPromiseValue, "m_pendingPromise", &pendingPromiseFieldValue) &&
[+] 		getPromiseField(thisPromiseValue, "m_pendingPromise", &pendingPromiseFieldValue) &&
[-] 		loadDataRef (pendingPromiseFieldValue, &opPromiseValue) &&
[+] 		loadDataRef(pendingPromiseFieldValue, &opPromiseValue) &&
[-] 		memberOperator (opPromiseValue, "blockingWait", &waitValue) &&
[+] 		memberOperator(opPromiseValue, "blockingWait", &waitValue) &&
[-] 		callOperator (waitValue, resultValue);
[+] 		callOperator(waitValue, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Call.cpp
----------------------
[-] OperatorMgr::callTraceFunction (
[+] OperatorMgr::callTraceFunction(
[-] 	ModuleItem* item = m_module->m_namespaceMgr.getGlobalNamespace ()->findItem (functionName);
[+] 	ModuleItem* item = m_module->m_namespaceMgr.getGlobalNamespace()->findItem(functionName);
[-] 	if (item && item->getItemKind () == ModuleItemKind_Function)
[+] 	if (item && item->getItemKind() == ModuleItemKind_Function)
[-] 		literalValue.setCharArray (string, m_module);
[+] 		literalValue.setCharArray(string, m_module);
[-] 		m_module->m_operatorMgr.callOperator ((Function*) item, literalValue);
[+] 		m_module->m_operatorMgr.callOperator((Function*)item, literalValue);
[-] OperatorMgr::traceBlock (BasicBlock* block)
[+] OperatorMgr::traceBlock(BasicBlock* block)
[-] 	llvm::BasicBlock* llvmBlock = block->getLlvmBlock ();
[+] 	llvm::BasicBlock* llvmBlock = block->getLlvmBlock();
[-] 	llvm::BasicBlock::iterator it = llvmBlock->begin ();
[+] 	llvm::BasicBlock::iterator it = llvmBlock->begin();
[-] 	m_module->m_llvmIrBuilder.setInsertPoint (it);
[+] 	m_module->m_llvmIrBuilder.setInsertPoint(it);
[-] 	m_module->m_operatorMgr.callTraceFunction ("print_u", block->getName () + "\n------------\n");
[+] 	m_module->m_operatorMgr.callTraceFunction("print_u", block->getName () + "\n------------\n");
[-] 	for (; it != llvmBlock->end () && !it->isTerminator (); it++)
[+] 	for (; it != llvmBlock->end() && !it->isTerminator(); it++)
[-] 		llvm::raw_string_ostream stream (s);
[+] 		llvm::raw_string_ostream stream(s);
[-] 		it->print (stream);
[+] 		it->print(stream);
[-] 		m_module->m_llvmIrBuilder.setInsertPoint (it);
[+] 		m_module->m_llvmIrBuilder.setInsertPoint(it);
[-] 		m_module->m_operatorMgr.callTraceFunction ("print_u", s.c_str ());
[+] 		m_module->m_operatorMgr.callTraceFunction("print_u", s.c_str ());
[-] OperatorMgr::getFunctionType (
[+] OperatorMgr::getFunctionType(
[-] 	FunctionPtrType* functionPtrType = functionType->getFunctionPtrType (
[+] 	FunctionPtrType* functionPtrType = functionType->getFunctionPtrType(
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 	return getClosureOperatorResultType (functionPtrType, closure->getArgValueList ());
[+] 	return getClosureOperatorResultType(functionPtrType, closure->getArgValueList());
[-] OperatorMgr::getClosureOperatorResultType (
[+] OperatorMgr::getClosureOperatorResultType(
[-] 	sl::BoxList <Value>* argValueList
[+] 	sl::BoxList<Value>* argValueList
[-] 	bool result = prepareOperand (rawOpValue, &opValue);
[+] 	bool result = prepareOperand(rawOpValue, &opValue);
[-] 	TypeKind typeKind = opValue.getType ()->getTypeKind ();
[+] 	TypeKind typeKind = opValue.getType()->getTypeKind();
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			opValue.getType ()->getTypeString ().sz ()
[+] 			opValue.getType()->getTypeString().sz()
[-] 	ref::Ptr <Closure> closure = AXL_REF_NEW (Closure);
[+] 	ref::Ptr<Closure> closure = AXL_REF_NEW(Closure);
[-] 	closure->append (*argValueList);
[+] 	closure->append(*argValueList);
[-] 	return closure->getClosureType (opValue.getType ());
[+] 	return closure->getClosureType(opValue.getType());
[-] OperatorMgr::getClosureOperatorResultType (
[+] OperatorMgr::getClosureOperatorResultType(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* resultType = getClosureOperatorResultType (rawOpValue, argValueList);
[+] 	Type* resultType = getClosureOperatorResultType(rawOpValue, argValueList);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::closureOperator (
[+] OperatorMgr::closureOperator(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	bool result = prepareOperand (rawOpValue, &opValue);
[+] 	bool result = prepareOperand(rawOpValue, &opValue);
[-] 	TypeKind typeKind = opValue.getType ()->getTypeKind ();
[+] 	TypeKind typeKind = opValue.getType()->getTypeKind();
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			opValue.getType ()->getTypeString ().sz ()
[+] 			opValue.getType()->getTypeString().sz()
[-] 	Closure* closure = resultValue->getClosure ();
[+] 	Closure* closure = resultValue->getClosure();
[-] 		closure = resultValue->createClosure ();
[+] 		closure = resultValue->createClosure();
[-] 	closure->append (*argValueList);
[+] 	closure->append(*argValueList);
[-] OperatorMgr::getCdeclVarArgType (Type* type)
[+] OperatorMgr::getCdeclVarArgType(Type* type)
[-] 		TypeKind typeKind = type->getTypeKind ();
[+] 		TypeKind typeKind = type->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 			type = ((PropertyPtrType*) type)->getTargetType ()->getReturnType ();
[+] 			type = ((PropertyPtrType*)type)->getTargetType()->getReturnType();
[-] 			type = ((DataPtrType*) type)->getTargetType ();
[+] 			type = ((DataPtrType*)type)->getTargetType();
[-] 			type = ((ClassPtrType*) type)->getTargetType ()->getClassPtrType (
[+] 			type = ((ClassPtrType*)type)->getTargetType()->getClassPtrType(
[-] 				((ClassPtrType*) type)->getPtrTypeKind (),
[+] 				((ClassPtrType*)type)->getPtrTypeKind(),
[-] 				type->getFlags ()
[+] 				type->getFlags()
[-] 			type = ((BitFieldType*) type)->getBaseType ();
[+] 			type = ((BitFieldType*)type)->getBaseType();
[-] 			type = ((EnumType*) type)->getBaseType ();
[+] 			type = ((EnumType*)type)->getBaseType();
[-] 			type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Double);
[+] 			type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Double);
[-] 			type = ((ArrayType*) type)->getElementType ()->getDataPtrType_c (TypeKind_DataPtr, PtrTypeFlag_Const);
[+] 			type = ((ArrayType*)type)->getElementType()->getDataPtrType_c(TypeKind_DataPtr, PtrTypeFlag_Const);
[-] 			type = ((DataPtrType*) type)->getTargetType ()->getDataPtrType_c (TypeKind_DataPtr, PtrTypeFlag_Const);
[+] 			type = ((DataPtrType*)type)->getTargetType()->getDataPtrType_c(TypeKind_DataPtr, PtrTypeFlag_Const);
[-] 			if (type->getTypeKindFlags () & TypeKindFlag_Integer)
[+] 			if (type->getTypeKindFlags() & TypeKindFlag_Integer)
[-] 				type = type->getSize () > 4 ?
[+] 				type = type->getSize() > 4 ?
[-] 					m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64) :
[+] 					m_module->m_typeMgr.getPrimitiveType(TypeKind_Int64) :
[-] 					m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 					m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] OperatorMgr::getCallOperatorResultType (
[+] OperatorMgr::getCallOperatorResultType(
[-] 	sl::BoxList <Value>* argValueList
[+] 	sl::BoxList<Value>* argValueList
[-] 	prepareOperandType (rawOpValue, &opValue);
[+] 	prepareOperandType(rawOpValue, &opValue);
[-] 	if (opValue.getType ()->getTypeKind () == TypeKind_ClassPtr)
[+] 	if (opValue.getType()->getTypeKind() == TypeKind_ClassPtr)
[-] 		Function* callOperator = ((ClassPtrType*) opValue.getType ())->getTargetType ()->getCallOperator ();
[+] 		Function* callOperator = ((ClassPtrType*)opValue.getType())->getTargetType()->getCallOperator();
[-] 			err::setFormatStringError ("cannot call '%s'", opValue.getType ()->getTypeString ().sz ());
[+] 			err::setFormatStringError("cannot call '%s'", opValue.getType ()->getTypeString ().sz ());
[-] 		opValue.setFunctionTypeOverload (callOperator->getTypeOverload ());
[+] 		opValue.setFunctionTypeOverload(callOperator->getTypeOverload());
[-] 		Closure* closure = opValue.createClosure ();
[+] 		Closure* closure = opValue.createClosure();
[-] 		closure->insertThisArgValue (objValue);
[+] 		closure->insertThisArgValue(objValue);
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		result = closure->apply (argValueList);
[+] 		result = closure->apply(argValueList);
[-] 	if (rawOpValue.getValueKind () == ValueKind_FunctionTypeOverload)
[+] 	if (rawOpValue.getValueKind() == ValueKind_FunctionTypeOverload)
[-] 		size_t i = rawOpValue.getFunctionTypeOverload ()->chooseOverload (*argValueList);
[+] 		size_t i = rawOpValue.getFunctionTypeOverload()->chooseOverload(*argValueList);
[-] 		FunctionType* functionType = rawOpValue.getFunctionTypeOverload ()->getOverload (i);
[+] 		FunctionType* functionType = rawOpValue.getFunctionTypeOverload()->getOverload(i);
[-] 		return functionType->getReturnType ();
[+] 		return functionType->getReturnType();
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	TypeKind typeKind = opType->getTypeKind ();
[+] 	TypeKind typeKind = opType->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		functionType = (FunctionType*) opType;
[+] 		functionType = (FunctionType*)opType;
[-] 		functionType = ((FunctionPtrType*) opType)->getTargetType ();
[+] 		functionType = ((FunctionPtrType*)opType)->getTargetType();
[-] 		err::setFormatStringError ("cannot call '%s'", opType->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot call '%s'", opType->getTypeString ().sz ());
[-] 	return functionType->getReturnType ();
[+] 	return functionType->getReturnType();
[-] OperatorMgr::getCallOperatorResultType (
[+] OperatorMgr::getCallOperatorResultType(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	Type* resultType = getCallOperatorResultType (rawOpValue, argValueList);
[+] 	Type* resultType = getCallOperatorResultType(rawOpValue, argValueList);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::callOperator (
[+] OperatorMgr::callOperator(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	sl::BoxList <Value> emptyArgValueList;
[+] 	sl::BoxList<Value> emptyArgValueList;
[-] 	result = prepareOperand (rawOpValue, &opValue, 0);
[+] 	result = prepareOperand(rawOpValue, &opValue, 0);
[-] 	if (opValue.getType ()->getTypeKind () == TypeKind_ClassPtr)
[+] 	if (opValue.getType()->getTypeKind() == TypeKind_ClassPtr)
[-] 		ClassPtrType* ptrType = (ClassPtrType*) opValue.getType ();
[+] 		ClassPtrType* ptrType = (ClassPtrType*)opValue.getType();
[-] 		Function* callOperator = ptrType->getTargetType ()->getCallOperator ();
[+] 		Function* callOperator = ptrType->getTargetType()->getCallOperator();
[-] 			err::setFormatStringError ("cannot call '%s'", ptrType->getTypeString ().sz ());
[+] 			err::setFormatStringError("cannot call '%s'", ptrType->getTypeString ().sz ());
[-] 		if ((callOperator->getFlags () & MulticastMethodFlag_InaccessibleViaEventPtr) &&
[+] 		if ((callOperator->getFlags() & MulticastMethodFlag_InaccessibleViaEventPtr) &&
[-] 			(ptrType->getFlags () & PtrTypeFlag_Event))
[+] 			(ptrType->getFlags() & PtrTypeFlag_Event))
[-] 			err::setFormatStringError ("'call' is inaccessible via 'event' pointer");
[+] 			err::setFormatStringError("'call' is inaccessible via 'event' pointer");
[-] 		opValue.setFunction (callOperator);
[+] 		opValue.setFunction(callOperator);
[-] 		Closure* closure = opValue.createClosure ();
[+] 		Closure* closure = opValue.createClosure();
[-] 		closure->insertThisArgValue (objValue);
[+] 		closure->insertThisArgValue(objValue);
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		result = closure->apply (argValueList);
[+] 		result = closure->apply(argValueList);
[-] 	if (opValue.getValueKind () == ValueKind_Function && opValue.getFunction ()->isOverloaded ())
[+] 	if (opValue.getValueKind() == ValueKind_Function && opValue.getFunction()->isOverloaded())
[-] 		Function* function = opValue.getFunction ()->chooseOverload (*argValueList);
[+] 		Function* function = opValue.getFunction()->chooseOverload(*argValueList);
[-] 		opValue.setFunction (function);
[+] 		opValue.setFunction(function);
[-] 		opValue.setClosure (closure);
[+] 		opValue.setClosure(closure);
[-] 	if (opValue.getValueKind () == ValueKind_Function)
[+] 	if (opValue.getValueKind() == ValueKind_Function)
[-] 		Function* function = opValue.getFunction ();
[+] 		Function* function = opValue.getFunction();
[-] 		if (function->isVirtual ())
[+] 		if (function->isVirtual())
[-] 			result = getVirtualMethod (function, closure, &opValue);
[+] 			result = getVirtualMethod(function, closure, &opValue);
[-] 		return callImpl (opValue, function->getType (), argValueList, resultValue);
[+] 		return callImpl(opValue, function->getType(), argValueList, resultValue);
[-] 	Type* opType = opValue.getType ();
[+] 	Type* opType = opValue.getType();
[-] 	if (!(opType->getTypeKindFlags () & TypeKindFlag_FunctionPtr) ||
[+] 	if (!(opType->getTypeKindFlags() & TypeKindFlag_FunctionPtr) ||
[-] 		((FunctionPtrType*) opType)->getPtrTypeKind () == FunctionPtrTypeKind_Weak)
[+] 		((FunctionPtrType*)opType)->getPtrTypeKind() == FunctionPtrTypeKind_Weak)
[-] 		err::setFormatStringError ("cannot call '%s'", opType->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot call '%s'", opType->getTypeString ().sz ());
[-] 	FunctionPtrType* functionPtrType = ((FunctionPtrType*) opType);
[+] 	FunctionPtrType* functionPtrType = ((FunctionPtrType*)opType);
[-] 	return functionPtrType->hasClosure () ?
[+] 	return functionPtrType->hasClosure() ?
[-] 		callClosureFunctionPtr (opValue, argValueList, resultValue) :
[+] 		callClosureFunctionPtr(opValue, argValueList, resultValue) :
[-] 		callImpl (opValue, functionPtrType->getTargetType (), argValueList, resultValue);
[+] 		callImpl(opValue, functionPtrType->getTargetType(), argValueList, resultValue);
[-] OperatorMgr::callOperatorVararg (
[+] OperatorMgr::callOperatorVararg(
[-] 	Type* valueType = value.getType ();
[+] 	Type* valueType = value.getType();
[-] 	if (valueType->getTypeKind () == TypeKind_DataRef &&
[+] 	if (valueType->getTypeKind() == TypeKind_DataRef &&
[-] 		((DataPtrType*) valueType)->getTargetType () == type)
[+] 		((DataPtrType*)valueType)->getTargetType() == type)
[-] 			unaryOperator (UnOpKind_Addr, value, &tmpValue) &&
[+] 			unaryOperator(UnOpKind_Addr, value, &tmpValue) &&
[-] 			callOperator (operatorVararg, tmpValue, resultValue);
[+] 			callOperator(operatorVararg, tmpValue, resultValue);
[-] 		Variable* tmpVariable = m_module->m_variableMgr.createSimpleStackVariable ("tmpStruct", type);
[+] 		Variable* tmpVariable = m_module->m_variableMgr.createSimpleStackVariable("tmpStruct", type);
[-] 			storeDataRef (tmpVariable, value) &&
[+] 			storeDataRef(tmpVariable, value) &&
[-] 			unaryOperator (UnOpKind_Addr, tmpVariable, &tmpValue) &&
[+] 			unaryOperator(UnOpKind_Addr, tmpVariable, &tmpValue) &&
[-] 			callOperator (operatorVararg, tmpValue, resultValue);
[+] 			callOperator(operatorVararg, tmpValue, resultValue);
[-] OperatorMgr::castArgValueList (
[+] OperatorMgr::castArgValueList(
[-] 	sl::BoxList <Value>* argValueList
[+] 	sl::BoxList<Value>* argValueList
[-] 	sl::Array <FunctionArg*> argArray = functionType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = functionType->getArgArray();
[-] 	size_t formalArgCount = argArray.getCount ();
[+] 	size_t formalArgCount = argArray.getCount();
[-] 	size_t actualArgCount = argValueList->getCount ();
[+] 	size_t actualArgCount = argValueList->getCount();
[-] 	bool isVarArg = (functionType->getFlags () & FunctionTypeFlag_VarArg) != 0;
[+] 	bool isVarArg = (functionType->getFlags() & FunctionTypeFlag_VarArg) != 0;
[-] 	bool isCdeclVarArg = (functionType->getCallConv ()->getFlags () & CallConvFlag_Cdecl) != 0;
[+] 	bool isCdeclVarArg = (functionType->getCallConv()->getFlags() & CallConvFlag_Cdecl) != 0;
[-] 		err::setFormatStringError ("too many arguments in a call to '%s'", functionType->getTypeString ().sz ());
[+] 		err::setFormatStringError("too many arguments in a call to '%s'", functionType->getTypeString ().sz ());
[-] 	sl::BoxIterator <Value> argValueIt = argValueList->getHead ();
[+] 	sl::BoxIterator<Value> argValueIt = argValueList->getHead();
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		if (argValue.isEmpty ())
[+] 		if (argValue.isEmpty())
[-] 			sl::ConstBoxList <Token> initializer = arg->getInitializer ();
[+] 			sl::ConstBoxList<Token> initializer = arg->getInitializer();
[-] 			if (initializer.isEmpty ())
[+] 			if (initializer.isEmpty())
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					functionType->getTypeString ().sz ()
[+] 					functionType->getTypeString().sz()
[-] 			result = parseFunctionArgDefaultValue (arg, closure, initializer, &argValue);
[+] 			result = parseFunctionArgDefaultValue(arg, closure, initializer, &argValue);
[-] 		Type* formalArgType = arg->getType ();
[+] 		Type* formalArgType = arg->getType();
[-] 			checkCastKind (argValue, formalArgType) &&
[+] 			checkCastKind(argValue, formalArgType) &&
[-] 			castOperator (argValue, formalArgType, &*argValueIt); // store it in the same list entry
[+] 			castOperator(argValue, formalArgType, &*argValueIt); // store it in the same list entry
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		sl::ConstBoxList <Token> initializer = arg->getInitializer ();
[+] 		sl::ConstBoxList<Token> initializer = arg->getInitializer();
[-] 		if (initializer.isEmpty ())
[+] 		if (initializer.isEmpty())
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				functionType->getTypeString ().sz ()
[+] 				functionType->getTypeString().sz()
[-] 		result = parseFunctionArgDefaultValue (arg, closure, initializer, &argValue);
[+] 		result = parseFunctionArgDefaultValue(arg, closure, initializer, &argValue);
[-] 		Type* formalArgType = arg->getType ();
[+] 		Type* formalArgType = arg->getType();
[-] 			checkCastKind (argValue, formalArgType) &&
[+] 			checkCastKind(argValue, formalArgType) &&
[-] 			castOperator (&argValue, formalArgType);
[+] 			castOperator(&argValue, formalArgType);
[-] 		argValueList->insertTail (argValue);
[+] 		argValueList->insertTail(argValue);
[-] 		err::setFormatStringError ("only 'cdecl' vararg is currently supported");
[+] 		err::setFormatStringError("only 'cdecl' vararg is currently supported");
[-] 		if (argValue.isEmpty ())
[+] 		if (argValue.isEmpty())
[-] 			err::setFormatStringError ("vararg arguments cannot be skipped");
[+] 			err::setFormatStringError("vararg arguments cannot be skipped");
[-] 		Type* type = prepareOperandType (argValue);
[+] 		Type* type = prepareOperandType(argValue);
[-] 		if (type->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 		if (type->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 			DerivableType* derivableType = (DerivableType*) type;
[+] 			DerivableType* derivableType = (DerivableType*)type;
[-] 			Function* operatorVararg = derivableType->getOperatorCdeclVararg ();
[+] 			Function* operatorVararg = derivableType->getOperatorCdeclVararg();
[-] 				operatorVararg = derivableType->getOperatorVararg ();
[+] 				operatorVararg = derivableType->getOperatorVararg();
[-] 				result = callOperatorVararg (operatorVararg, derivableType, &argValue);
[+] 				result = callOperatorVararg(operatorVararg, derivableType, &argValue);
[-] 		Type* formalArgType = getCdeclVarArgType (argValue.getType ());
[+] 		Type* formalArgType = getCdeclVarArgType(argValue.getType());
[-] 		result = castOperator (argValue, formalArgType, &*argValueIt); // store it in the same list entry
[+] 		result = castOperator(argValue, formalArgType, &*argValueIt); // store it in the same list entry
[-] OperatorMgr::callClosureFunctionPtr (
[+] OperatorMgr::callClosureFunctionPtr(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr);
[-] 	FunctionPtrType* functionPtrType = (FunctionPtrType*) opValue.getType ();
[+] 	FunctionPtrType* functionPtrType = (FunctionPtrType*)opValue.getType();
[-] 	FunctionType* functionType = functionPtrType->getTargetType ();
[+] 	FunctionType* functionType = functionPtrType->getTargetType();
[-] 	FunctionType* abstractMethodType = functionType->getStdObjectMemberMethodType ();
[+] 	FunctionType* abstractMethodType = functionType->getStdObjectMemberMethodType();
[-] 	FunctionPtrType* functionThinPtrType = abstractMethodType->getFunctionPtrType (FunctionPtrTypeKind_Thin);
[+] 	FunctionPtrType* functionThinPtrType = abstractMethodType->getFunctionPtrType(FunctionPtrTypeKind_Thin);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &ifaceValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &ifaceValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (pfnValue, functionThinPtrType, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(pfnValue, functionThinPtrType, &pfnValue);
[-] 	argValueList->insertHead (ifaceValue);
[+] 	argValueList->insertHead(ifaceValue);
[-] 	return callImpl (pfnValue, abstractMethodType, argValueList, resultValue);
[+] 	return callImpl(pfnValue, abstractMethodType, argValueList, resultValue);
[-] OperatorMgr::callImpl (
[+] OperatorMgr::callImpl(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	uint_t flags = functionType->getFlags ();
[+] 	uint_t flags = functionType->getFlags();
[-] 	if ((flags & FunctionTypeFlag_Unsafe) && !isUnsafeRgn ())
[+] 	if ((flags & FunctionTypeFlag_Unsafe) && !isUnsafeRgn())
[-] 		err::setFormatStringError ("can only call unsafe functions from unsafe regions");
[+] 		err::setFormatStringError("can only call unsafe functions from unsafe regions");
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckNullPtr)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckNullPtr)
[-] 		checkNullPtr (pfnValue);
[+] 		checkNullPtr(pfnValue);
[-] 	bool result = castArgValueList (functionType, pfnValue.getClosure (), argValueList);
[+] 	bool result = castArgValueList(functionType, pfnValue.getClosure(), argValueList);
[-] 	functionType->getCallConv ()->call (
[+] 	functionType->getCallConv()->call(
[-] 	if (resultValue->getType ()->getFlags () & TypeFlag_GcRoot)
[+] 	if (resultValue->getType()->getFlags() & TypeFlag_GcRoot)
[-] 		m_module->m_gcShadowStackMgr.createTmpGcRoot (*resultValue);
[+] 		m_module->m_gcShadowStackMgr.createTmpGcRoot(*resultValue);
[-] 	if (functionType->getFlags () & FunctionTypeFlag_ErrorCode)
[+] 	if (functionType->getFlags() & FunctionTypeFlag_ErrorCode)
[-] 		result = m_module->m_controlFlowMgr.throwExceptionIf (*resultValue, functionType);
[+] 		result = m_module->m_controlFlowMgr.throwExceptionIf(*resultValue, functionType);
[-] OperatorMgr::gcSafePoint ()
[+] OperatorMgr::gcSafePoint()
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleGcSafePoint)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleGcSafePoint)
[-] 		Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_GcSafePoint);
[+] 		Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_GcSafePoint);
[-] 		m_module->m_llvmIrBuilder.createCall (function, function->getType (), NULL);
[+] 		m_module->m_llvmIrBuilder.createCall(function, function->getType(), NULL);
[-] 		Variable* variable = m_module->m_variableMgr.getStdVariable (StdVariable_GcSafePointTrigger);
[+] 		Variable* variable = m_module->m_variableMgr.getStdVariable(StdVariable_GcSafePointTrigger);
[-] 		Value value = m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr)->getZeroValue ();
[+] 		Value value = m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr)->getZeroValue();
[-] 		m_module->m_llvmIrBuilder.createLoad (variable, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(variable, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createRmw (
[+] 		m_module->m_llvmIrBuilder.createRmw(
[-] OperatorMgr::checkStackOverflow ()
[+] OperatorMgr::checkStackOverflow()
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (StdFunc_CheckStackOverflow);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(StdFunc_CheckStackOverflow);
[-] 	m_module->m_llvmIrBuilder.createCall (function, function->getType (), NULL);
[+] 	m_module->m_llvmIrBuilder.createCall(function, function->getType(), NULL);
[-] OperatorMgr::checkDivByZero (const Value& value)
[+] OperatorMgr::checkDivByZero(const Value& value)
[-] 	Type* type = value.getType ();
[+] 	Type* type = value.getType();
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Integer)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Integer)
[-] 		checkFunc = type->getSize () <= sizeof (uint32_t) ?
[+] 		checkFunc = type->getSize() <= sizeof(uint32_t) ?
[-] 	else if (type->getTypeKindFlags () & TypeKindFlag_Fp)
[+] 	else if (type->getTypeKindFlags() & TypeKindFlag_Fp)
[-] 		checkFunc = type->getSize () <= sizeof (float) ?
[+] 		checkFunc = type->getSize() <= sizeof(float) ?
[-] 	Function* function = m_module->m_functionMgr.getStdFunction (checkFunc);
[+] 	Function* function = m_module->m_functionMgr.getStdFunction(checkFunc);
[-] 	bool result = m_module->m_operatorMgr.callOperator (function, value);
[+] 	bool result = m_module->m_operatorMgr.callOperator(function, value);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_CheckPtr.cpp
----------------------
[-] OperatorMgr::checkPtr (
[+] OperatorMgr::checkPtr(
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (scope);
[+] 	ASSERT(scope);
[-] 	if (!scope->canStaticThrow ())
[+] 	if (!scope->canStaticThrow())
[-] 		Function* checkFunction = m_module->m_functionMgr.getStdFunction (stdCheckFunction);
[+] 		Function* checkFunction = m_module->m_functionMgr.getStdFunction(stdCheckFunction);
[-] 		m_module->m_llvmIrBuilder.createCall (
[+] 		m_module->m_llvmIrBuilder.createCall(
[-] 			checkFunction->getType (),
[+] 			checkFunction->getType(),
[-] 		Function* checkFunction = m_module->m_functionMgr.getStdFunction (stdTryCheckFunction);
[+] 		Function* checkFunction = m_module->m_functionMgr.getStdFunction(stdTryCheckFunction);
[-] 		FunctionType* checkFunctionType = checkFunction->getType ();
[+] 		FunctionType* checkFunctionType = checkFunction->getType();
[-] 		m_module->m_llvmIrBuilder.createCall (
[+] 		m_module->m_llvmIrBuilder.createCall(
[-] 		bool result = m_module->m_controlFlowMgr.throwExceptionIf (returnValue, checkFunctionType);
[+] 		bool result = m_module->m_controlFlowMgr.throwExceptionIf(returnValue, checkFunctionType);
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] OperatorMgr::checkDataPtrRange (const Value& value)
[+] OperatorMgr::checkDataPtrRange(const Value& value)
[-] 	ASSERT (value.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(value.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	DataPtrType* type = (DataPtrType*) value.getType ();
[+] 	DataPtrType* type = (DataPtrType*)value.getType();
[-] 	DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind();
[-] 	if (m_module->m_operatorMgr.isUnsafeRgn () ||
[+] 	if (m_module->m_operatorMgr.isUnsafeRgn() ||
[-] 		(type->getFlags () & PtrTypeFlag_Safe) ||
[+] 		(type->getFlags() & PtrTypeFlag_Safe) ||
[-] 	size_t targetSize = type->getTargetType ()->getSize ();
[+] 	size_t targetSize = type->getTargetType()->getSize();
[-] 		m_module->m_llvmIrBuilder.createExtractValue (value, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(value, 0, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (value, 1, NULL, &validatorValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(value, 1, NULL, &validatorValue);
[-] 		ASSERT (ptrTypeKind == DataPtrTypeKind_Lean);
[+] 		ASSERT(ptrTypeKind == DataPtrTypeKind_Lean);
[-] 		m_module->m_llvmIrBuilder.createBitCast (value, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(value, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 		LeanDataPtrValidator* validator = value.getLeanDataPtrValidator ();
[+] 		LeanDataPtrValidator* validator = value.getLeanDataPtrValidator();
[-] 		if (validator->isDynamicRange () || validator->hasValidatorValue ())
[+] 		if (validator->isDynamicRange() || validator->hasValidatorValue())
[-] 			validatorValue = validator->getValidatorValue ();
[+] 			validatorValue = validator->getValidatorValue();
[-] 			size_t rangeLength = validator->getRangeLength ();
[+] 			size_t rangeLength = validator->getRangeLength();
[-] 				err::setFormatStringError ("'%s' fails range check", type->getTypeString ().sz ());
[+] 				err::setFormatStringError("'%s' fails range check", type->getTypeString ().sz ());
[-] 			Value rangeBeginValue = validator->getRangeBeginValue ();
[+] 			Value rangeBeginValue = validator->getRangeBeginValue();
[-] 			m_module->m_llvmIrBuilder.createBitCast (rangeBeginValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &rangeBeginValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(rangeBeginValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &rangeBeginValue);
[-] 			Value argValueArray [] =
[+] 			Value argValueArray[] =
[-] 				Value (rangeLength, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT)),
[+] 				Value(rangeLength, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT)),
[-] 			checkPtr (
[+] 			checkPtr(
[-] 				countof (argValueArray)
[+] 				countof(argValueArray)
[-] 	Value argValueArray [] =
[+] 	Value argValueArray[] =
[-] 		Value (targetSize, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT)),
[+] 		Value(targetSize, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT)),
[-] 	checkPtr (
[+] 	checkPtr(
[-] 		countof (argValueArray)
[+] 		countof(argValueArray)
[-] OperatorMgr::checkNullPtr (const Value& value)
[+] OperatorMgr::checkNullPtr(const Value& value)
[-] 	Type* type = value.getType ();
[+] 	Type* type = value.getType();
[-] 	if (m_module->m_operatorMgr.isUnsafeRgn () || (type->getFlags () & PtrTypeFlag_Safe))
[+] 	if (m_module->m_operatorMgr.isUnsafeRgn() || (type->getFlags() & PtrTypeFlag_Safe))
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	if (!(m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckNullPtr))
[+] 	if (!(m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckNullPtr))
[-] 		ASSERT (typeKind == TypeKind_ClassPtr || typeKind == TypeKind_ClassRef);
[+] 		ASSERT(typeKind == TypeKind_ClassPtr || typeKind == TypeKind_ClassRef);
[-] 		Variable* nullPtrCheckSink = m_module->m_variableMgr.getStdVariable (StdVariable_NullPtrCheckSink);
[+] 		Variable* nullPtrCheckSink = m_module->m_variableMgr.getStdVariable(StdVariable_NullPtrCheckSink);
[-] 		m_module->m_llvmIrBuilder.createBitCast (value, m_module->m_typeMgr.getStdType (StdType_BytePtr), &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(value, m_module->m_typeMgr.getStdType(StdType_BytePtr), &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createLoad (tmpValue, NULL, &tmpValue);
[+] 		m_module->m_llvmIrBuilder.createLoad(tmpValue, NULL, &tmpValue);
[-] 		m_module->m_llvmIrBuilder.createStore (tmpValue, nullPtrCheckSink);
[+] 		m_module->m_llvmIrBuilder.createStore(tmpValue, nullPtrCheckSink);
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		isThin = ((FunctionPtrType*) type)->getPtrTypeKind () == FunctionPtrTypeKind_Thin;
[+] 		isThin = ((FunctionPtrType*)type)->getPtrTypeKind() == FunctionPtrTypeKind_Thin;
[-] 		isThin = ((PropertyPtrType*) type)->getPtrTypeKind () == PropertyPtrTypeKind_Thin;
[+] 		isThin = ((PropertyPtrType*)type)->getPtrTypeKind() == PropertyPtrTypeKind_Thin;
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	Value typeKindValue (typeKind, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int));
[+] 	Value typeKindValue(typeKind, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int));
[-] 		m_module->m_llvmIrBuilder.createBitCast (value, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(value, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (value, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(value, 0, NULL, &ptrValue);
[-] 	Value argValueArray [] =
[+] 	Value argValueArray[] =
[-] 	checkPtr (
[+] 	checkPtr(
[-] 		countof (argValueArray)
[+] 		countof(argValueArray)
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Closure.cpp
----------------------
[-] OperatorMgr::createClosureObject (
[+] OperatorMgr::createClosureObject(
[-] 	ASSERT (thunkType->getTypeKind () == TypeKind_Function || thunkType->getTypeKind () == TypeKind_Property);
[+] 	ASSERT(thunkType->getTypeKind() == TypeKind_Function || thunkType->getTypeKind() == TypeKind_Property);
[-] 	if (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_FunctionPtr)
[+] 	if (opValue.getType()->getTypeKindFlags() & TypeKindFlag_FunctionPtr)
[-] 		ASSERT (((FunctionPtrType*) opValue.getType ())->getPtrTypeKind () == FunctionPtrTypeKind_Thin);
[+] 		ASSERT(((FunctionPtrType*)opValue.getType())->getPtrTypeKind() == FunctionPtrTypeKind_Thin);
[-] 		srcFunctionType = ((FunctionPtrType*) opValue.getType ())->getTargetType ();
[+] 		srcFunctionType = ((FunctionPtrType*)opValue.getType())->getTargetType();
[-] 		ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 		ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 		ASSERT (((PropertyPtrType*) opValue.getType ())->getPtrTypeKind () == PropertyPtrTypeKind_Thin);
[+] 		ASSERT(((PropertyPtrType*)opValue.getType())->getPtrTypeKind() == PropertyPtrTypeKind_Thin);
[-] 		srcFunctionType = ((PropertyPtrType*) opValue.getType ())->getTargetType ()->getGetterType ();
[+] 		srcFunctionType = ((PropertyPtrType*)opValue.getType())->getTargetType()->getGetterType();
[-] 	char buffer1 [256];
[+] 	char buffer1[256];
[-] 	char buffer2 [256];
[+] 	char buffer2[256];
[-] 	sl::Array <Type*> closureArgTypeArray (ref::BufKind_Stack, buffer1, sizeof (buffer1));
[+] 	sl::Array<Type*> closureArgTypeArray(ref::BufKind_Stack, buffer1, sizeof(buffer1));
[-] 	sl::Array <size_t> closureMap (ref::BufKind_Stack, buffer2, sizeof (buffer2));
[+] 	sl::Array<size_t> closureMap(ref::BufKind_Stack, buffer2, sizeof(buffer2));
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		closureArgCount = closure->getArgValueList ()->getCount ();
[+] 		closureArgCount = closure->getArgValueList()->getCount();
[-] 		closureThisArgIdx = closure->getThisArgIdx ();
[+] 		closureThisArgIdx = closure->getThisArgIdx();
[-] 		sl::Array <FunctionArg*> srcArgArray = srcFunctionType->getArgArray ();
[+] 		sl::Array<FunctionArg*> srcArgArray = srcFunctionType->getArgArray();
[-] 		size_t srcArgCount = srcArgArray.getCount ();
[+] 		size_t srcArgCount = srcArgArray.getCount();
[-] 			err::setFormatStringError ("closure is too big for '%s'", srcFunctionType->getTypeString ().sz ());
[+] 			err::setFormatStringError("closure is too big for '%s'", srcFunctionType->getTypeString ().sz ());
[-] 		closureArgTypeArray.setCount (closureArgCount);
[+] 		closureArgTypeArray.setCount(closureArgCount);
[-] 		closureMap.setCount (closureArgCount);
[+] 		closureMap.setCount(closureArgCount);
[-] 		sl::BoxIterator <Value> closureArgValue = closure->getArgValueList ()->getHead ();
[+] 		sl::BoxIterator<Value> closureArgValue = closure->getArgValueList()->getHead();
[-] 			if (closureArgValue->isEmpty ())
[+] 			if (closureArgValue->isEmpty())
[-] 			closureArgTypeArray [j] = srcArgArray [i]->getType ();
[+] 			closureArgTypeArray[j] = srcArgArray[i]->getType();
[-] 			closureMap [j] = i;
[+] 			closureMap[j] = i;
[-] 	if (thunkType->getTypeKind () == TypeKind_Function)
[+] 	if (thunkType->getTypeKind() == TypeKind_Function)
[-] 		closureType = m_module->m_typeMgr.getFunctionClosureClassType (
[+] 		closureType = m_module->m_typeMgr.getFunctionClosureClassType(
[-] 			((FunctionPtrType*) opValue.getType ())->getTargetType (),
[+] 			((FunctionPtrType*)opValue.getType())->getTargetType(),
[-] 			(FunctionType*) thunkType,
[+] 			(FunctionType*)thunkType,
[-] 		ASSERT (thunkType->getTypeKind () == TypeKind_Property);
[+] 		ASSERT(thunkType->getTypeKind() == TypeKind_Property);
[-] 		closureType = m_module->m_typeMgr.getPropertyClosureClassType (
[+] 		closureType = m_module->m_typeMgr.getPropertyClosureClassType(
[-] 			((PropertyPtrType*) opValue.getType ())->getTargetType (),
[+] 			((PropertyPtrType*)opValue.getType())->getTargetType(),
[-] 			(PropertyType*) thunkType,
[+] 			(PropertyType*)thunkType,
[-] 	result = m_module->m_operatorMgr.newOperator (closureType, NULL, &closureValue);
[+] 	result = m_module->m_operatorMgr.newOperator(closureType, NULL, &closureValue);
[-] 	sl::Array <StructField*> fieldArray = closureType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> fieldArray = closureType->getMemberFieldArray();
[-] 	pfnValue.clearClosure ();
[+] 	pfnValue.clearClosure();
[-] 		getClassField (closureValue, fieldArray [fieldIdx], NULL, &fieldValue) &&
[+] 		getClassField(closureValue, fieldArray[fieldIdx], NULL, &fieldValue) &&
[-] 		binaryOperator (BinOpKind_Assign, fieldValue, pfnValue);
[+] 		binaryOperator(BinOpKind_Assign, fieldValue, pfnValue);
[-] 		sl::BoxIterator <Value> closureArgValue = closure->getArgValueList ()->getHead ();
[+] 		sl::BoxIterator<Value> closureArgValue = closure->getArgValueList()->getHead();
[-] 			if (closureArgValue->isEmpty ())
[+] 			if (closureArgValue->isEmpty())
[-] 				getClassField (closureValue, fieldArray [fieldIdx], NULL, &fieldValue) &&
[+] 				getClassField(closureValue, fieldArray[fieldIdx], NULL, &fieldValue) &&
[-] 				binaryOperator (BinOpKind_Assign, fieldValue, *closureArgValue);
[+] 				binaryOperator(BinOpKind_Assign, fieldValue, *closureArgValue);
[-] OperatorMgr::createDataClosureObject (
[+] OperatorMgr::createDataClosureObject(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_DataPtr);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_DataPtr);
[-] 	DataClosureClassType* closureType = m_module->m_typeMgr.getDataClosureClassType (
[+] 	DataClosureClassType* closureType = m_module->m_typeMgr.getDataClosureClassType(
[-] 		((DataPtrType*) opValue.getType ())->getTargetType (),
[+] 		((DataPtrType*)opValue.getType())->getTargetType(),
[-] 	result = m_module->m_operatorMgr.newOperator (closureType, NULL, &closureValue);
[+] 	result = m_module->m_operatorMgr.newOperator(closureType, NULL, &closureValue);
[-] 	sl::Array <StructField*> fieldArray = closureType->getMemberFieldArray ();
[+] 	sl::Array<StructField*> fieldArray = closureType->getMemberFieldArray();
[-] 	ASSERT (!fieldArray.isEmpty ());
[+] 	ASSERT(!fieldArray.isEmpty());
[-] 		getClassField (closureValue, fieldArray [0], NULL, &fieldValue) &&
[+] 		getClassField(closureValue, fieldArray[0], NULL, &fieldValue) &&
[-] 		binaryOperator (BinOpKind_Assign, fieldValue, opValue);
[+] 		binaryOperator(BinOpKind_Assign, fieldValue, opValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_DataRef.cpp
----------------------
[-] tryCheckDataPtrRangeIndirect (
[+] tryCheckDataPtrRangeIndirect(
[-] OperatorMgr::prepareDataPtr (
[+] OperatorMgr::prepareDataPtr(
[-] 	ASSERT (value.getType ()->getTypeKind () == TypeKind_DataPtr || value.getType ()->getTypeKind () == TypeKind_DataRef);
[+] 	ASSERT(value.getType()->getTypeKind() == TypeKind_DataPtr || value.getType()->getTypeKind() == TypeKind_DataRef);
[-] 	bool result = checkDataPtrRange (value);
[+] 	bool result = checkDataPtrRange(value);
[-] 	DataPtrType* type = (DataPtrType*) value.getType ();
[+] 	DataPtrType* type = (DataPtrType*)value.getType();
[-] 	DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind();
[-] 	DataPtrType* resultType = type->getTargetType ()->getDataPtrType_c ();
[+] 	DataPtrType* resultType = type->getTargetType()->getDataPtrType_c();
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 		resultValue->overrideType (value, resultType);
[+] 		resultValue->overrideType(value, resultType);
[-] 		if (value.getValueKind () == ValueKind_Const)
[+] 		if (value.getValueKind() == ValueKind_Const)
[-] 			void* p = ((DataPtr*) value.getConstData ())->m_p;
[+] 			void* p = ((DataPtr*)value.getConstData())->m_p;
[-] 			resultValue->createConst (&p, resultType);
[+] 			resultValue->createConst(&p, resultType);
[-] 			m_module->m_llvmIrBuilder.createExtractValue (value, 0, NULL, resultValue);
[+] 			m_module->m_llvmIrBuilder.createExtractValue(value, 0, NULL, resultValue);
[-] 			m_module->m_llvmIrBuilder.createBitCast (*resultValue, resultType, resultValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(*resultValue, resultType, resultValue);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] OperatorMgr::loadDataRef (
[+] OperatorMgr::loadDataRef(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_DataRef);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_DataRef);
[-] 	DataPtrType* type = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* type = (DataPtrType*)opValue.getType();
[-] 	Type* targetType = type->getTargetType ();
[+] 	Type* targetType = type->getTargetType();
[-] 	if (targetType->getFlags () & TypeFlag_Dynamic)
[+] 	if (targetType->getFlags() & TypeFlag_Dynamic)
[-] 		err::setFormatStringError ("invalid usage of dynamic type '%s'", targetType->getTypeString ().sz ());
[+] 		err::setFormatStringError("invalid usage of dynamic type '%s'", targetType->getTypeString ().sz ());
[-] 	if (opValue.getValueKind () != ValueKind_Const)
[+] 	if (opValue.getValueKind() != ValueKind_Const)
[-] 		result = prepareDataPtr (opValue, &ptrValue);
[+] 		result = prepareDataPtr(opValue, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createLoad (
[+] 		m_module->m_llvmIrBuilder.createLoad(
[-] 			(type->getFlags () & PtrTypeFlag_Volatile) != 0
[+] 			(type->getFlags() & PtrTypeFlag_Volatile) != 0
[-] 		DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind ();
[+] 		DataPtrTypeKind ptrTypeKind = type->getPtrTypeKind();
[-] 			p = *(void**) opValue.getConstData ();
[+] 			p = *(void**) opValue.getConstData();
[-] 			DataPtr* ptr = (DataPtr*) opValue.getConstData ();
[+] 			DataPtr* ptr = (DataPtr*)opValue.getConstData();
[-] 			result = rtl::tryCheckDataPtrRangeIndirect (ptr->m_p, targetType->getSize (), ptr->m_validator);
[+] 			result = rtl::tryCheckDataPtrRangeIndirect(ptr->m_p, targetType->getSize(), ptr->m_validator);
[-] 		resultValue->createConst (p, targetType);
[+] 		resultValue->createConst(p, targetType);
[-] 	if (targetType->getTypeKind () == TypeKind_BitField)
[+] 	if (targetType->getTypeKind() == TypeKind_BitField)
[-] 		result = extractBitField (
[+] 		result = extractBitField(
[-] 			(BitFieldType*) targetType,
[+] 			(BitFieldType*)targetType,
[-] OperatorMgr::storeDataRef (
[+] OperatorMgr::storeDataRef(
[-] 	ASSERT (dstValue.getType ()->getTypeKind () == TypeKind_DataRef);
[+] 	ASSERT(dstValue.getType()->getTypeKind() == TypeKind_DataRef);
[-] 	DataPtrType* dstType = (DataPtrType*) dstValue.getType ();
[+] 	DataPtrType* dstType = (DataPtrType*)dstValue.getType();
[-] 	if (dstType->getFlags () & PtrTypeFlag_Const)
[+] 	if (dstType->getFlags() & PtrTypeFlag_Const)
[-] 		err::setError ("cannot store into const location");
[+] 		err::setError("cannot store into const location");
[-] 	Type* targetType = dstType->getTargetType ();
[+] 	Type* targetType = dstType->getTargetType();
[-] 	if (targetType->getFlags () & TypeFlag_Dynamic)
[+] 	if (targetType->getFlags() & TypeFlag_Dynamic)
[-] 		err::setFormatStringError ("invalid usage of dynamic type '%s'", targetType->getTypeString ().sz ());
[+] 		err::setFormatStringError("invalid usage of dynamic type '%s'", targetType->getTypeString ().sz ());
[-] 	TypeKind targetTypeKind = targetType->getTypeKind ();
[+] 	TypeKind targetTypeKind = targetType->getTypeKind();
[-] 		((BitFieldType*) targetType)->getBaseType () :
[+] 		((BitFieldType*)targetType)->getBaseType() :
[-] 		checkCastKind (rawSrcValue, castType) &&
[+] 		checkCastKind(rawSrcValue, castType) &&
[-] 		castOperator (rawSrcValue, castType, &srcValue);
[+] 		castOperator(rawSrcValue, castType, &srcValue);
[-] 	if (srcValue.getValueKind () != ValueKind_Const ||
[+] 	if (srcValue.getValueKind() != ValueKind_Const ||
[-] 		dstValue.getValueKind () != ValueKind_Const)
[+] 		dstValue.getValueKind() != ValueKind_Const)
[-] 		result = prepareDataPtr (dstValue, &ptrValue);
[+] 		result = prepareDataPtr(dstValue, &ptrValue);
[-] 			m_module->m_llvmIrBuilder.createLoad (
[+] 			m_module->m_llvmIrBuilder.createLoad(
[-] 				(dstType->getFlags () & PtrTypeFlag_Volatile) != 0
[+] 				(dstType->getFlags() & PtrTypeFlag_Volatile) != 0
[-] 			result = mergeBitField (
[+] 			result = mergeBitField(
[-] 				(BitFieldType*) targetType,
[+] 				(BitFieldType*)targetType,
[-] 		m_module->m_llvmIrBuilder.createStore (
[+] 		m_module->m_llvmIrBuilder.createStore(
[-] 			(dstType->getFlags () & PtrTypeFlag_Volatile) != 0
[+] 			(dstType->getFlags() & PtrTypeFlag_Volatile) != 0
[-] 		DataPtrTypeKind ptrTypeKind = dstType->getPtrTypeKind ();
[+] 		DataPtrTypeKind ptrTypeKind = dstType->getPtrTypeKind();
[-] 			p = *(void**) dstValue.getConstData ();
[+] 			p = *(void**) dstValue.getConstData();
[-] 			DataPtr* ptr = (DataPtr*) dstValue.getConstData ();
[+] 			DataPtr* ptr = (DataPtr*)dstValue.getConstData();
[-] 			result = rtl::tryCheckDataPtrRangeIndirect (ptr->m_p, targetType->getSize (), ptr->m_validator);
[+] 			result = rtl::tryCheckDataPtrRangeIndirect(ptr->m_p, targetType->getSize(), ptr->m_validator);
[-] 			bfShadowValue.createConst (p, castType);
[+] 			bfShadowValue.createConst(p, castType);
[-] 			result = mergeBitField (
[+] 			result = mergeBitField(
[-] 				(BitFieldType*) targetType,
[+] 				(BitFieldType*)targetType,
[-] 		memcpy (p, srcValue.getConstData (), targetType->getSize ());
[+] 		memcpy(p, srcValue.getConstData(), targetType->getSize());
[-] OperatorMgr::extractBitField (
[+] OperatorMgr::extractBitField(
[-] 	Type* baseType = bitFieldType->getBaseType ();
[+] 	Type* baseType = bitFieldType->getBaseType();
[-] 	size_t bitOffset = bitFieldType->getBitOffset ();
[+] 	size_t bitOffset = bitFieldType->getBitOffset();
[-] 	size_t bitCount = bitFieldType->getBitCount ();
[+] 	size_t bitCount = bitFieldType->getBitCount();
[-] 	TypeKind typeKind = baseType->getSize () <= 4 ? TypeKind_Int32_u : TypeKind_Int64_u;
[+] 	TypeKind typeKind = baseType->getSize() <= 4 ? TypeKind_Int32_u : TypeKind_Int64_u;
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (typeKind);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(typeKind);
[-] 	Value value (rawValue, baseType);
[+] 	Value value(rawValue, baseType);
[-] 	Value maskValue (mask, type);
[+] 	Value maskValue(mask, type);
[-] 	Value offsetValue (bitOffset, type);
[+] 	Value offsetValue(bitOffset, type);
[-] 		binaryOperator (BinOpKind_Shr, &value, offsetValue) &&
[+] 		binaryOperator(BinOpKind_Shr, &value, offsetValue) &&
[-] 		binaryOperator (BinOpKind_BwAnd, &value, maskValue);
[+] 		binaryOperator(BinOpKind_BwAnd, &value, maskValue);
[-] 	if (!(baseType->getTypeKindFlags () & TypeKindFlag_Unsigned)) // extend with sign bit
[+] 	if (!(baseType->getTypeKindFlags() & TypeKindFlag_Unsigned)) // extend with sign bit
[-] 		Value signBitValue (signBit, type);
[+] 		Value signBitValue(signBit, type);
[-] 		Value oneValue (1, type);
[+] 		Value oneValue(1, type);
[-] 			binaryOperator (BinOpKind_BwAnd, &signBitValue, value) &&
[+] 			binaryOperator(BinOpKind_BwAnd, &signBitValue, value) &&
[-] 			binaryOperator (BinOpKind_Sub, signBitValue, oneValue, &signExtValue) &&
[+] 			binaryOperator(BinOpKind_Sub, signBitValue, oneValue, &signExtValue) &&
[-] 			unaryOperator (UnOpKind_BwNot, &signExtValue) &&
[+] 			unaryOperator(UnOpKind_BwNot, &signExtValue) &&
[-] 			binaryOperator (BinOpKind_BwOr, &value, signExtValue);
[+] 			binaryOperator(BinOpKind_BwOr, &value, signExtValue);
[-] 	return castOperator (value, baseType, resultValue);
[+] 	return castOperator(value, baseType, resultValue);
[-] OperatorMgr::mergeBitField (
[+] OperatorMgr::mergeBitField(
[-] 	Type* baseType = bitFieldType->getBaseType ();
[+] 	Type* baseType = bitFieldType->getBaseType();
[-] 	size_t bitOffset = bitFieldType->getBitOffset ();
[+] 	size_t bitOffset = bitFieldType->getBitOffset();
[-] 	size_t bitCount = bitFieldType->getBitCount ();
[+] 	size_t bitCount = bitFieldType->getBitCount();
[-] 	TypeKind typeKind = baseType->getSize () <= 4 ? TypeKind_Int32_u : TypeKind_Int64_u;
[+] 	TypeKind typeKind = baseType->getSize() <= 4 ? TypeKind_Int32_u : TypeKind_Int64_u;
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (typeKind);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(typeKind);
[-] 	Value value (rawValue, baseType);
[+] 	Value value(rawValue, baseType);
[-] 	Value shadowValue (rawShadowValue, baseType);
[+] 	Value shadowValue(rawShadowValue, baseType);
[-] 	Value maskValue (mask, type);
[+] 	Value maskValue(mask, type);
[-] 	Value offsetValue (bitOffset, type);
[+] 	Value offsetValue(bitOffset, type);
[-] 		binaryOperator (BinOpKind_Shl, &value, offsetValue) &&
[+] 		binaryOperator(BinOpKind_Shl, &value, offsetValue) &&
[-] 		binaryOperator (BinOpKind_BwAnd, value, maskValue, resultValue);
[+] 		binaryOperator(BinOpKind_BwAnd, value, maskValue, resultValue);
[-] 	maskValue.setConstInt64 (mask, type);
[+] 	maskValue.setConstInt64(mask, type);
[-] 		binaryOperator (BinOpKind_BwAnd, &shadowValue, maskValue) &&
[+] 		binaryOperator(BinOpKind_BwAnd, &shadowValue, maskValue) &&
[-] 		binaryOperator (BinOpKind_BwOr, &value, shadowValue) &&
[+] 		binaryOperator(BinOpKind_BwOr, &value, shadowValue) &&
[-] 		castOperator (value, baseType, resultValue);
[+] 		castOperator(value, baseType, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Field.cpp
----------------------
[-] OperatorMgr::getField (
[+] OperatorMgr::getField(
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_DataPtr)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_DataPtr)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 	else if (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr)
[+] 	else if (opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr)
[-] 		type = ((ClassPtrType*) opValue.getType ())->getTargetType ();
[+] 		type = ((ClassPtrType*)opValue.getType())->getTargetType();
[-] 	if (type->getFlags () & TypeFlag_Dynamic)
[+] 	if (type->getFlags() & TypeFlag_Dynamic)
[-] 		ASSERT (type->getTypeKindFlags () & TypeKindFlag_Derivable);
[+] 		ASSERT(type->getTypeKindFlags() & TypeKindFlag_Derivable);
[-] 		return getDynamicStructField (opValue, (DerivableType*) type, field, resultValue);
[+] 		return getDynamicStructField(opValue, (DerivableType*)type, field, resultValue);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return getStructField (opValue, field, coord, resultValue);
[+] 		return getStructField(opValue, field, coord, resultValue);
[-] 			getStructField (opValue, field, coord, resultValue) :
[+] 			getStructField(opValue, field, coord, resultValue) :
[-] 			getUnionField (opValue, field, resultValue);
[+] 			getUnionField(opValue, field, resultValue);
[-] 		return getClassField (opValue, field, coord, resultValue);
[+] 		return getClassField(opValue, field, coord, resultValue);
[-] 		err::setFormatStringError ("cannot get a field '%s' of '%s'", field->getName ().sz (), type->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot get a field '%s' of '%s'", field->getName ().sz (), type->getTypeString ().sz ());
[-] OperatorMgr::getPromiseField (
[+] OperatorMgr::getPromiseField(
[-] 	ASSERT (((ClassPtrType*) promiseValue.getType ())->getTargetType ()->getBaseTypeArray () [0]->getType ()->getStdType () == StdType_Promise);
[+] 	ASSERT(((ClassPtrType*)promiseValue.getType())->getTargetType()->getBaseTypeArray() [0]->getType()->getStdType() == StdType_Promise);
[-] 	ClassType* promiseType = (ClassType*) m_module->m_typeMgr.getStdType (StdType_Promise);
[+] 	ClassType* promiseType = (ClassType*)m_module->m_typeMgr.getStdType(StdType_Promise);
[-] 	StructField* stateField = (StructField*) promiseType->findItemByName (name);
[+] 	StructField* stateField = (StructField*)promiseType->findItemByName(name);
[-] 	ASSERT (stateField);
[+] 	ASSERT(stateField);
[-] 	coord.m_llvmIndexArray.append (0); // account for base type jnc.Promise
[+] 	coord.m_llvmIndexArray.append(0); // account for base type jnc.Promise
[-] 	return getField (promiseValue, stateField, &coord, resultValue);
[+] 	return getField(promiseValue, stateField, &coord, resultValue);
[-] OperatorMgr::getFieldPtrImpl (
[+] OperatorMgr::getFieldPtrImpl(
[-] 	AXL_TODO ("double check multiple levels of nested unnamed structs/unions")
[+] 	AXL_TODO("double check multiple levels of nested unnamed structs/unions")
[-] 	if (coord->m_unionCoordArray.isEmpty ())
[+] 	if (coord->m_unionCoordArray.isEmpty())
[-] 		m_module->m_llvmIrBuilder.createGep (
[+] 		m_module->m_llvmIrBuilder.createGep(
[-] 			coord->m_llvmIndexArray.getCount (),
[+] 			coord->m_llvmIndexArray.getCount(),
[-] 	int32_t* llvmIndexEnd = llvmIndex + coord->m_llvmIndexArray.getCount ();
[+] 	int32_t* llvmIndexEnd = llvmIndex + coord->m_llvmIndexArray.getCount();
[-] 	size_t unionCount = coord->m_unionCoordArray.getCount ();
[+] 	size_t unionCount = coord->m_unionCoordArray.getCount();
[-] 		ASSERT (unionCoord->m_level >= unionLevel);
[+] 		ASSERT(unionCoord->m_level >= unionLevel);
[-] 			m_module->m_llvmIrBuilder.createGep (
[+] 			m_module->m_llvmIrBuilder.createGep(
[-] 		StructField* field = unionCoord->m_type->getFieldByIndex (llvmIndex [llvmIndexDelta]);
[+] 		StructField* field = unionCoord->m_type->getFieldByIndex(llvmIndex[llvmIndexDelta]);
[-] 		Type* type = field->getType ()->getDataPtrType_c ();
[+] 		Type* type = field->getType()->getDataPtrType_c();
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, type, &opValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, type, &opValue);
[-] 		ASSERT (llvmIndex > coord->m_llvmIndexArray);
[+] 		ASSERT(llvmIndex > coord->m_llvmIndexArray);
[-] 		m_module->m_llvmIrBuilder.createGep (
[+] 		m_module->m_llvmIrBuilder.createGep(
[-] 		resultValue->overrideType (opValue, resultType);
[+] 		resultValue->overrideType(opValue, resultType);
[-] OperatorMgr::getStructField (
[+] OperatorMgr::getStructField(
[-] 	coord->m_llvmIndexArray.append (field->getLlvmIndex ());
[+] 	coord->m_llvmIndexArray.append(field->getLlvmIndex());
[-] 	coord->m_offset += field->getOffset ();
[+] 	coord->m_offset += field->getOffset();
[-] 	ValueKind opValueKind = opValue.getValueKind ();
[+] 	ValueKind opValueKind = opValue.getValueKind();
[-] 		Type* type = opValue.getType ();
[+] 		Type* type = opValue.getType();
[-] 		if (!(type->getTypeKindFlags () & TypeKindFlag_Ptr))
[+] 		if (!(type->getTypeKindFlags() & TypeKindFlag_Ptr))
[-] 			resultValue->createConst (
[+] 			resultValue->createConst(
[-] 				(char*) opValue.getConstData () + coord->m_offset,
[+] 				(char*)opValue.getConstData() + coord->m_offset,
[-] 				field->getType ()
[+] 				field->getType()
[-] 			ASSERT (type->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 			ASSERT(type->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 			DataPtrType* ptrType = (DataPtrType*) type;
[+] 			DataPtrType* ptrType = (DataPtrType*)type;
[-] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 				DataPtr ptr = *(DataPtr*) opValue.getConstData ();
[+] 				DataPtr ptr = *(DataPtr*)opValue.getConstData();
[-] 				ptr.m_p = (char*) ptr.m_p + field->getOffset ();
[+] 				ptr.m_p = (char*)ptr.m_p + field->getOffset();
[-] 				resultValue->createConst (&ptr, field->getType ()->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Normal, type->getFlags ()));
[+] 				resultValue->createConst(&ptr, field->getType()->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Normal, type->getFlags()));
[-] 				ASSERT (ptrTypeKind == DataPtrTypeKind_Thin);
[+] 				ASSERT(ptrTypeKind == DataPtrTypeKind_Thin);
[-] 				char* p = *(char**) opValue.getConstData ();
[+] 				char* p = *(char**) opValue.getConstData();
[-] 				p += field->getOffset ();
[+] 				p += field->getOffset();
[-] 				resultValue->createConst (&p, field->getType ()->getDataPtrType_c (TypeKind_DataRef, type->getFlags ()));
[+] 				resultValue->createConst(&p, field->getType()->getDataPtrType_c(TypeKind_DataRef, type->getFlags()));
[-] 	if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr))
[+] 	if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr))
[-] 		if (!coord->m_unionCoordArray.isEmpty ())
[+] 		if (!coord->m_unionCoordArray.isEmpty())
[-] 			err::setFormatStringError ("union member operator on registers is not implemented yet");
[+] 			err::setFormatStringError("union member operator on registers is not implemented yet");
[-] 		m_module->m_llvmIrBuilder.createExtractValue (
[+] 		m_module->m_llvmIrBuilder.createExtractValue(
[-] 			coord->m_llvmIndexArray.getCount (),
[+] 			coord->m_llvmIndexArray.getCount(),
[-] 			field->getType (),
[+] 			field->getType(),
[-] 	DataPtrType* opType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* opType = (DataPtrType*)opValue.getType();
[-] 	coord->m_llvmIndexArray.insert (0, 0);
[+] 	coord->m_llvmIndexArray.insert(0, 0);
[-] 	uint_t ptrTypeFlags = opType->getFlags () | field->getPtrTypeFlags ();
[+] 	uint_t ptrTypeFlags = opType->getFlags() | field->getPtrTypeFlags();
[-] 	if (field->getStorageKind () == StorageKind_Mutable)
[+] 	if (field->getStorageKind() == StorageKind_Mutable)
[-] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind();
[-] 		DataPtrType* resultType = field->getType ()->getDataPtrType (
[+] 		DataPtrType* resultType = field->getType()->getDataPtrType(
[-] 		getFieldPtrImpl (opValue, coord, resultType, resultValue);
[+] 		getFieldPtrImpl(opValue, coord, resultType, resultValue);
[-] 		getFieldPtrImpl (opValue, coord, NULL, &ptrValue);
[+] 		getFieldPtrImpl(opValue, coord, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (ptrValue, opType->getTargetType ()->getDataPtrType_c (), &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(ptrValue, opType->getTargetType()->getDataPtrType_c(), &ptrValue);
[-] 		getFieldPtrImpl (ptrValue, coord, NULL, &ptrValue);
[+] 		getFieldPtrImpl(ptrValue, coord, NULL, &ptrValue);
[-] 	if (opType->getTargetType ()->getFlags () & TypeFlag_Pod)
[+] 	if (opType->getTargetType()->getFlags() & TypeFlag_Pod)
[-] 		DataPtrType* resultType = field->getType ()->getDataPtrType (
[+] 		DataPtrType* resultType = field->getType()->getDataPtrType(
[-] 		resultValue->setLeanDataPtr (ptrValue.getLlvmValue (), resultType, opValue);
[+] 		resultValue->setLeanDataPtr(ptrValue.getLlvmValue(), resultType, opValue);
[-] 		bool result = checkDataPtrRange (opValue);
[+] 		bool result = checkDataPtrRange(opValue);
[-] 		DataPtrType* resultType = field->getType ()->getDataPtrType (
[+] 		DataPtrType* resultType = field->getType()->getDataPtrType(
[-] 		resultValue->setLeanDataPtr (
[+] 		resultValue->setLeanDataPtr(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] 			field->getType ()->getSize ()
[+] 			field->getType()->getSize()
[-] OperatorMgr::getDynamicStructField (
[+] OperatorMgr::getDynamicStructField(
[-] 	Function* getDynamicFieldFunc = m_module->m_functionMgr.getStdFunction (StdFunc_GetDynamicField);
[+] 	Function* getDynamicFieldFunc = m_module->m_functionMgr.getStdFunction(StdFunc_GetDynamicField);
[-] 	Value typeValue (&type, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value typeValue(&type, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	Value fieldValue (&field, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value fieldValue(&field, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	result = m_module->m_operatorMgr.callOperator (
[+] 	result = m_module->m_operatorMgr.callOperator(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr); // otherwise, getDynamicFieldFunc fails
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr); // otherwise, getDynamicFieldFunc fails
[-] 	DataPtrType* opType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* opType = (DataPtrType*)opValue.getType();
[-] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind();
[-] 	ASSERT (ptrTypeKind != DataPtrTypeKind_Thin); // otherwise, getDynamicFieldFunc fails
[+] 	ASSERT(ptrTypeKind != DataPtrTypeKind_Thin); // otherwise, getDynamicFieldFunc fails
[-] 	uint_t ptrTypeFlags = opType->getFlags () | field->getPtrTypeFlags ();
[+] 	uint_t ptrTypeFlags = opType->getFlags() | field->getPtrTypeFlags();
[-] 	if (field->getStorageKind () == StorageKind_Mutable)
[+] 	if (field->getStorageKind() == StorageKind_Mutable)
[-] 	ASSERT (opType->getTargetType ()->getFlags () & TypeFlag_Pod); // dynamic struct must be POD
[+] 	ASSERT(opType->getTargetType()->getFlags() & TypeFlag_Pod); // dynamic struct must be POD
[-] 	DataPtrType* resultType = field->getType ()->getDataPtrType (
[+] 	DataPtrType* resultType = field->getType()->getDataPtrType(
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, resultType, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, resultType, &ptrValue);
[-] 	resultValue->setLeanDataPtr (ptrValue.getLlvmValue (), resultType, opValue);
[+] 	resultValue->setLeanDataPtr(ptrValue.getLlvmValue(), resultType, opValue);
[-] 	resultValue->setDynamicFieldInfo (opValue, type, field);
[+] 	resultValue->setDynamicFieldInfo(opValue, type, field);
[-] OperatorMgr::getUnionField (
[+] OperatorMgr::getUnionField(
[-] 	ValueKind opValueKind = opValue.getValueKind ();
[+] 	ValueKind opValueKind = opValue.getValueKind();
[-] 		resultValue->createConst (opValue.getConstData (), field->getType ());
[+] 		resultValue->createConst(opValue.getConstData(), field->getType());
[-] 	if (opValue.getType ()->getTypeKind () != TypeKind_DataRef)
[+] 	if (opValue.getType()->getTypeKind() != TypeKind_DataRef)
[-] 		err::setFormatStringError ("union member operator on registers is not implemented yet");
[+] 		err::setFormatStringError("union member operator on registers is not implemented yet");
[-] 	DataPtrType* opType = (DataPtrType*) opValue.getType ();
[+] 	DataPtrType* opType = (DataPtrType*)opValue.getType();
[-] 	uint_t ptrTypeFlags = opType->getFlags () | field->getPtrTypeFlags ();
[+] 	uint_t ptrTypeFlags = opType->getFlags() | field->getPtrTypeFlags();
[-] 	if (field->getStorageKind () == StorageKind_Mutable)
[+] 	if (field->getStorageKind() == StorageKind_Mutable)
[-] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind ();
[+] 	DataPtrTypeKind ptrTypeKind = opType->getPtrTypeKind();
[-] 	DataPtrType* ptrType = field->getType ()->getDataPtrType (
[+] 	DataPtrType* ptrType = field->getType()->getDataPtrType(
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, ptrType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, ptrType, resultValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, ptrType, resultValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, ptrType, resultValue);
[-] 		if (opValue.getValueKind () == ValueKind_Variable)
[+] 		if (opValue.getValueKind() == ValueKind_Variable)
[-] 			resultValue->setLeanDataPtrValidator (opValue);
[+] 			resultValue->setLeanDataPtrValidator(opValue);
[-] 			resultValue->setLeanDataPtrValidator (opValue.getLeanDataPtrValidator ());
[+] 			resultValue->setLeanDataPtrValidator(opValue.getLeanDataPtrValidator());
[-] 		m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &ptrValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (opValue, field->getType ()->getDataPtrType_c (), &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(opValue, field->getType()->getDataPtrType_c(), &ptrValue);
[-] 		resultValue->setLeanDataPtr (
[+] 		resultValue->setLeanDataPtr(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] OperatorMgr::getClassField (
[+] OperatorMgr::getClassField(
[-] 	bool result = prepareOperand (rawOpValue, &opValue);
[+] 	bool result = prepareOperand(rawOpValue, &opValue);
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr);
[-] 	ClassPtrType* opType = (ClassPtrType*) opValue.getType ();
[+] 	ClassPtrType* opType = (ClassPtrType*)opValue.getType();
[-] 	checkNullPtr (opValue);
[+] 	checkNullPtr(opValue);
[-] 	ClassType* classType = (ClassType*) field->getParentNamespace ();
[+] 	ClassType* classType = (ClassType*)field->getParentNamespace();
[-] 	coord->m_llvmIndexArray.insert (0, 0);
[+] 	coord->m_llvmIndexArray.insert(0, 0);
[-] 	coord->m_llvmIndexArray.append (field->getLlvmIndex ());
[+] 	coord->m_llvmIndexArray.append(field->getLlvmIndex());
[-] 	if (field->getType ()->getTypeKind () == TypeKind_Class)
[+] 	if (field->getType()->getTypeKind() == TypeKind_Class)
[-] 		coord->m_llvmIndexArray.append (1);
[+] 		coord->m_llvmIndexArray.append(1);
[-] 	m_module->m_llvmIrBuilder.createGep (
[+] 	m_module->m_llvmIrBuilder.createGep(
[-] 		coord->m_llvmIndexArray.getCount (),
[+] 		coord->m_llvmIndexArray.getCount(),
[-] 	uint_t ptrTypeFlags = opType->getFlags () | field->getPtrTypeFlags () | PtrTypeFlag_Safe;
[+] 	uint_t ptrTypeFlags = opType->getFlags() | field->getPtrTypeFlags() | PtrTypeFlag_Safe;
[-] 	if (field->getStorageKind () == StorageKind_Mutable)
[+] 	if (field->getStorageKind() == StorageKind_Mutable)
[-] 	if (field->getType ()->getTypeKind () == TypeKind_Class)
[+] 	if (field->getType()->getTypeKind() == TypeKind_Class)
[-] 		ClassPtrType* ptrType = ((ClassType*) field->getType ())->getClassPtrType (
[+] 		ClassPtrType* ptrType = ((ClassType*)field->getType())->getClassPtrType(
[-] 		resultValue->setLlvmValue (ptrValue.getLlvmValue (), ptrType);
[+] 		resultValue->setLlvmValue(ptrValue.getLlvmValue(), ptrType);
[-] 		DataPtrType* ptrType = field->getType ()->getDataPtrType (
[+] 		DataPtrType* ptrType = field->getType()->getDataPtrType(
[-] 		resultValue->setLeanDataPtr (
[+] 		resultValue->setLeanDataPtr(
[-] 			ptrValue.getLlvmValue (),
[+] 			ptrValue.getLlvmValue(),
[-] 			field->getType ()->getSize ()
[+] 			field->getType()->getSize()
[-] OperatorMgr::getPropertyField (
[+] OperatorMgr::getPropertyField(
[-] 	ModuleItemKind itemKind = member->getItemKind ();
[+] 	ModuleItemKind itemKind = member->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		resultValue->setVariable ((Variable*) member);
[+] 		resultValue->setVariable((Variable*)member);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	ASSERT (opValue.getValueKind () == ValueKind_Property);
[+] 	ASSERT(opValue.getValueKind() == ValueKind_Property);
[-] 	ASSERT (member->getItemKind () == ModuleItemKind_StructField);
[+] 	ASSERT(member->getItemKind() == ModuleItemKind_StructField);
[-] 	Property* prop = opValue.getProperty ();
[+] 	Property* prop = opValue.getProperty();
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 	ASSERT (closure);
[+] 	ASSERT(closure);
[-] 	Value parentValue = *closure->getArgValueList ()->getHead ();
[+] 	Value parentValue = *closure->getArgValueList()->getHead();
[-] 	Type* parentValueType = parentValue.getType ();
[+] 	Type* parentValueType = parentValue.getType();
[-] 	DerivableType* parentType = prop->getParentType ();
[+] 	DerivableType* parentType = prop->getParentType();
[-] 	ASSERT (parentType);
[+] 	ASSERT(parentType);
[-] 	if (parentType->getTypeKind () == TypeKind_Class)
[+] 	if (parentType->getTypeKind() == TypeKind_Class)
[-] 		parentPtrType = ((ClassType*) parentType)->getClassPtrType (
[+] 		parentPtrType = ((ClassType*)parentType)->getClassPtrType(
[-] 			parentValueType->getFlags ()
[+] 			parentValueType->getFlags()
[-] 		DataPtrTypeKind ptrTypeKind = (parentValueType->getTypeKindFlags () & TypeKindFlag_DataPtr) ?
[+] 		DataPtrTypeKind ptrTypeKind = (parentValueType->getTypeKindFlags() & TypeKindFlag_DataPtr) ?
[-] 			((DataPtrType*) parentValueType)->getPtrTypeKind () :
[+] 			((DataPtrType*)parentValueType)->getPtrTypeKind() :
[-] 		parentPtrType = parentType->getDataPtrType (
[+] 		parentPtrType = parentType->getDataPtrType(
[-] 			parentValueType->getFlags ()
[+] 			parentValueType->getFlags()
[-] 		castOperator (&parentValue, parentPtrType) &&
[+] 		castOperator(&parentValue, parentPtrType) &&
[-] 		getField (parentValue, (StructField*) member, resultValue);
[+] 		getField(parentValue, (StructField*)member, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Logic.cpp
----------------------
[-] OperatorMgr::logicalOrOperator (
[+] OperatorMgr::logicalOrOperator(
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (opBlock1);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(opBlock1);
[-] 	Function* function = getOverloadedBinaryOperator (BinOpKind_LogOr, rawOpValue1);
[+] 	Function* function = getOverloadedBinaryOperator(BinOpKind_LogOr, rawOpValue1);
[-] 		m_module->m_controlFlowMgr.follow (opBlock2);
[+] 		m_module->m_controlFlowMgr.follow(opBlock2);
[-] 		m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 		m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue1);
[+] 		argList.insertTail(rawOpValue1);
[-] 		argList.insertTail (rawOpValue2);
[+] 		argList.insertTail(rawOpValue2);
[-] 		return callOperator (function, &argList, resultValue);
[+] 		return callOperator(function, &argList, resultValue);
[-] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock ("and_phi");
[+] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock("and_phi");
[-] 	BasicBlock* falseBlock2 = m_module->m_controlFlowMgr.createBlock ("op2_false");
[+] 	BasicBlock* falseBlock2 = m_module->m_controlFlowMgr.createBlock("op2_false");
[-] 	result = m_module->m_operatorMgr.castOperator (rawOpValue1, TypeKind_Bool, &opValue1);
[+] 	result = m_module->m_operatorMgr.castOperator(rawOpValue1, TypeKind_Bool, &opValue1);
[-] 	BasicBlock* jumpBlock1 = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* jumpBlock1 = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	result = m_module->m_controlFlowMgr.conditionalJump (opValue1, phiBlock, opBlock2, prevBlock);
[+] 	result = m_module->m_controlFlowMgr.conditionalJump(opValue1, phiBlock, opBlock2, prevBlock);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	result = m_module->m_operatorMgr.castOperator (rawOpValue2, TypeKind_Bool, &opValue2);
[+] 	result = m_module->m_operatorMgr.castOperator(rawOpValue2, TypeKind_Bool, &opValue2);
[-] 	BasicBlock* jumpBlock2 = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* jumpBlock2 = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	result = m_module->m_controlFlowMgr.conditionalJump (opValue2, phiBlock, falseBlock2, falseBlock2);
[+] 	result = m_module->m_controlFlowMgr.conditionalJump(opValue2, phiBlock, falseBlock2, falseBlock2);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 	Value trueValue (true, type);
[+] 	Value trueValue(true, type);
[-] 	Value falseValue ((int64_t) false, type);
[+] 	Value falseValue((int64_t)false, type);
[-] 	Value valueArray [] =
[+] 	Value valueArray[] =
[-] 	BasicBlock* blockArray [] =
[+] 	BasicBlock* blockArray[] =
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	m_module->m_llvmIrBuilder.createPhi (valueArray, blockArray, 3, resultValue);
[+] 	m_module->m_llvmIrBuilder.createPhi(valueArray, blockArray, 3, resultValue);
[-] OperatorMgr::logicalAndOperator (
[+] OperatorMgr::logicalAndOperator(
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (opBlock1);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(opBlock1);
[-] 	Function* function = getOverloadedBinaryOperator (BinOpKind_LogAnd, rawOpValue1);
[+] 	Function* function = getOverloadedBinaryOperator(BinOpKind_LogAnd, rawOpValue1);
[-] 		m_module->m_controlFlowMgr.follow (opBlock2);
[+] 		m_module->m_controlFlowMgr.follow(opBlock2);
[-] 		m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 		m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
[-] 		sl::BoxList <Value> argList;
[+] 		sl::BoxList<Value> argList;
[-] 		argList.insertTail (rawOpValue1);
[+] 		argList.insertTail(rawOpValue1);
[-] 		argList.insertTail (rawOpValue2);
[+] 		argList.insertTail(rawOpValue2);
[-] 		return callOperator (function, &argList, resultValue);
[+] 		return callOperator(function, &argList, resultValue);
[-] 	BasicBlock* lastBlock = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* lastBlock = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock ("and_phi");
[+] 	BasicBlock* phiBlock = m_module->m_controlFlowMgr.createBlock("and_phi");
[-] 	BasicBlock* trueBlock2 = m_module->m_controlFlowMgr.createBlock ("op2_true");
[+] 	BasicBlock* trueBlock2 = m_module->m_controlFlowMgr.createBlock("op2_true");
[-] 	result = m_module->m_operatorMgr.castOperator (rawOpValue1, TypeKind_Bool, &opValue1);
[+] 	result = m_module->m_operatorMgr.castOperator(rawOpValue1, TypeKind_Bool, &opValue1);
[-] 	BasicBlock* jumpBlock1 = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* jumpBlock1 = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	result = m_module->m_controlFlowMgr.conditionalJump (opValue1, opBlock2, phiBlock, prevBlock);
[+] 	result = m_module->m_controlFlowMgr.conditionalJump(opValue1, opBlock2, phiBlock, prevBlock);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	result = m_module->m_operatorMgr.castOperator (rawOpValue2, TypeKind_Bool, &opValue2);
[+] 	result = m_module->m_operatorMgr.castOperator(rawOpValue2, TypeKind_Bool, &opValue2);
[-] 	BasicBlock* jumpBlock2 = m_module->m_controlFlowMgr.getCurrentBlock ();
[+] 	BasicBlock* jumpBlock2 = m_module->m_controlFlowMgr.getCurrentBlock();
[-] 	result = m_module->m_controlFlowMgr.conditionalJump (opValue2, trueBlock2, phiBlock);
[+] 	result = m_module->m_controlFlowMgr.conditionalJump(opValue2, trueBlock2, phiBlock);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	Type* type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 	Type* type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 	Value trueValue (true, type);
[+] 	Value trueValue(true, type);
[-] 	Value falseValue ((int64_t) false, type);
[+] 	Value falseValue((int64_t)false, type);
[-] 	Value valueArray [] =
[+] 	Value valueArray[] =
[-] 	BasicBlock* blockArray [] =
[+] 	BasicBlock* blockArray[] =
[-] 	m_module->m_controlFlowMgr.follow (phiBlock);
[+] 	m_module->m_controlFlowMgr.follow(phiBlock);
[-] 	m_module->m_llvmIrBuilder.createPhi (valueArray, blockArray, 3, resultValue);
[+] 	m_module->m_llvmIrBuilder.createPhi(valueArray, blockArray, 3, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Member.cpp
----------------------
[-] OperatorMgr::createMemberClosure (
[+] OperatorMgr::createMemberClosure(
[-] 	bool result = value->getValueKind () == ValueKind_Type ?
[+] 	bool result = value->getValueKind() == ValueKind_Type ?
[-] 		getThisValueType (&thisValue, itemDecl) :
[+] 		getThisValueType(&thisValue, itemDecl) :
[-] 		getThisValue (&thisValue, itemDecl);
[+] 		getThisValue(&thisValue, itemDecl);
[-] 	Closure* closure = value->createClosure ();
[+] 	Closure* closure = value->createClosure();
[-] 	closure->insertThisArgValue (thisValue);
[+] 	closure->insertThisArgValue(thisValue);
[-] OperatorMgr::getThisValue (
[+] OperatorMgr::getThisValue(
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 		err::setFormatStringError ("function '%s' has no 'this' pointer", m_module->m_functionMgr.getCurrentFunction ()->m_tag.sz ());
[+] 		err::setFormatStringError("function '%s' has no 'this' pointer", m_module->m_functionMgr.getCurrentFunction ()->m_tag.sz ());
[-] 	if (!(itemDecl && isReactorClassTypeMember (itemDecl)) &&
[+] 	if (!(itemDecl && isReactorClassTypeMember(itemDecl)) &&
[-] 		isClassPtrType (thisValue.getType (), ClassTypeKind_Reactor))
[+] 		isClassPtrType(thisValue.getType(), ClassTypeKind_Reactor))
[-] 		ClassType* classType = ((ClassPtrType*) thisValue.getType ())->getTargetType ();
[+] 		ClassType* classType = ((ClassPtrType*)thisValue.getType())->getTargetType();
[-] 		ReactorClassType* reactorType = (ReactorClassType*) classType;
[+] 		ReactorClassType* reactorType = (ReactorClassType*)classType;
[-] 		ClassType* parentType = reactorType->getParentType ();
[+] 		ClassType* parentType = reactorType->getParentType();
[-] 			size_t parentOffset = reactorType->getParentOffset ();
[+] 			size_t parentOffset = reactorType->getParentOffset();
[-] 			ASSERT (parentOffset);
[+] 			ASSERT(parentOffset);
[-] 			m_module->m_llvmIrBuilder.createBitCast (thisValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &thisValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(thisValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &thisValue);
[-] 			m_module->m_llvmIrBuilder.createGep (thisValue, -parentOffset, NULL, &thisValue);
[+] 			m_module->m_llvmIrBuilder.createGep(thisValue, -parentOffset, NULL, &thisValue);
[-] 			m_module->m_llvmIrBuilder.createBitCast (thisValue, parentType->getClassPtrType (), &thisValue);
[+] 			m_module->m_llvmIrBuilder.createBitCast(thisValue, parentType->getClassPtrType(), &thisValue);
[-] OperatorMgr::getThisValueType (
[+] OperatorMgr::getThisValueType(
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	if (!function->isMember ())
[+] 	if (!function->isMember())
[-] 		err::setFormatStringError ("function '%s' has no 'this' pointer", m_module->m_functionMgr.getCurrentFunction ()->m_tag.sz ());
[+] 		err::setFormatStringError("function '%s' has no 'this' pointer", m_module->m_functionMgr.getCurrentFunction ()->m_tag.sz ());
[-] 	Type* thisType = function->getThisType ();
[+] 	Type* thisType = function->getThisType();
[-] 	if (!(itemDecl && isReactorClassTypeMember (itemDecl)) &&
[+] 	if (!(itemDecl && isReactorClassTypeMember(itemDecl)) &&
[-] 		isClassPtrType (thisType, ClassTypeKind_Reactor))
[+] 		isClassPtrType(thisType, ClassTypeKind_Reactor))
[-] 		ClassType* classType = ((ClassPtrType*) thisType)->getTargetType ();
[+] 		ClassType* classType = ((ClassPtrType*)thisType)->getTargetType();
[-] 		ReactorClassType* reactorType = (ReactorClassType*) classType;
[+] 		ReactorClassType* reactorType = (ReactorClassType*)classType;
[-] 		ClassType* parentType = reactorType->getParentType ();
[+] 		ClassType* parentType = reactorType->getParentType();
[-] 			thisType = parentType->getClassPtrType ();
[+] 			thisType = parentType->getClassPtrType();
[-] 	value->setType (thisType);
[+] 	value->setType(thisType);
[-] OperatorMgr::checkAccess (ModuleItemDecl* decl)
[+] OperatorMgr::checkAccess(ModuleItemDecl* decl)
[-] 	Namespace* nspace = decl->getParentNamespace ();
[+] 	Namespace* nspace = decl->getParentNamespace();
[-] 	if (decl->getAccessKind () != AccessKind_Public &&
[+] 	if (decl->getAccessKind() != AccessKind_Public &&
[-] 		m_module->m_namespaceMgr.getAccessKind (nspace) == AccessKind_Public)
[+] 		m_module->m_namespaceMgr.getAccessKind(nspace) == AccessKind_Public)
[-] 		err::setFormatStringError ("'%s.%s' is protected", nspace->getQualifiedName ().sz (), decl->getName ().sz ());
[+] 		err::setFormatStringError("'%s.%s' is protected", nspace->getQualifiedName ().sz (), decl->getName ().sz ());
[-] OperatorMgr::finalizeMemberOperator (
[+] OperatorMgr::finalizeMemberOperator(
[-] 	bool result = checkAccess (decl);
[+] 	bool result = checkAccess(decl);
[-] 	Type* type = resultValue->getType ();
[+] 	Type* type = resultValue->getType();
[-] 	if (type && isDualType (type))
[+] 	if (type && isDualType(type))
[-] 		Namespace* nspace = decl->getParentNamespace ();
[+] 		Namespace* nspace = decl->getParentNamespace();
[-] 		bool isAlien = m_module->m_namespaceMgr.getAccessKind (nspace) == AccessKind_Public;
[+] 		bool isAlien = m_module->m_namespaceMgr.getAccessKind(nspace) == AccessKind_Public;
[-] 		bool isConst = (opValue.getType ()->getFlags () & PtrTypeFlag_Const) != 0;
[+] 		bool isConst = (opValue.getType()->getFlags() & PtrTypeFlag_Const) != 0;
[-] 		type = m_module->m_typeMgr.foldDualType (type, isAlien, isConst);
[+] 		type = m_module->m_typeMgr.foldDualType(type, isAlien, isConst);
[-] 		resultValue->overrideType (type);
[+] 		resultValue->overrideType(type);
[-] OperatorMgr::getNamespaceMemberType (
[+] OperatorMgr::getNamespaceMemberType(
[-] 	ModuleItem* item = nspace->findItemTraverse (name, &coord, TraverseKind_NoParentNamespace);
[+] 	ModuleItem* item = nspace->findItemTraverse(name, &coord, TraverseKind_NoParentNamespace);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), nspace->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), nspace->getQualifiedName ().sz ());
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		resultValue->setNamespace ((GlobalNamespace*) item);
[+] 		resultValue->setNamespace((GlobalNamespace*)item);
[-] 		decl = (GlobalNamespace*) item;
[+] 		decl = (GlobalNamespace*)item;
[-] 		item = ((Typedef*) item)->getType ();
[+] 		item = ((Typedef*)item)->getType();
[-] 		result = checkAccess ((Typedef*) item);
[+] 		result = checkAccess((Typedef*)item);
[-] 		if (!(((Type*) item)->getTypeKindFlags () & TypeKindFlag_Named))
[+] 		if (!(((Type*)item)->getTypeKindFlags() & TypeKindFlag_Named))
[-] 			err::setFormatStringError ("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[-] 		resultValue->setNamespace ((NamedType*) item);
[+] 		resultValue->setNamespace((NamedType*)item);
[-] 		decl = (NamedType*) item;
[+] 		decl = (NamedType*)item;
[-] 		resultValue->setType (((Alias*) item)->getType ());
[+] 		resultValue->setType(((Alias*)item)->getType());
[-] 		decl = (Alias*) item;
[+] 		decl = (Alias*)item;
[-] 		resultValue->setType (((Variable*) item)->getType ()->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Lean));
[+] 		resultValue->setType(((Variable*)item)->getType()->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Lean));
[-] 		decl = (Variable*) item;
[+] 		decl = (Variable*)item;
[-] 		resultValue->setFunctionTypeOverload (((Function*) item)->getTypeOverload ());
[+] 		resultValue->setFunctionTypeOverload(((Function*)item)->getTypeOverload());
[-] 		if (((Function*) item)->isMember ())
[+] 		if (((Function*)item)->isMember())
[-] 			result = createMemberClosure (resultValue);
[+] 			result = createMemberClosure(resultValue);
[-] 		decl = (Function*) item;
[+] 		decl = (Function*)item;
[-] 		resultValue->setType (((Property*) item)->getType ()->getPropertyPtrType (TypeKind_PropertyRef, PropertyPtrTypeKind_Thin));
[+] 		resultValue->setType(((Property*)item)->getType()->getPropertyPtrType(TypeKind_PropertyRef, PropertyPtrTypeKind_Thin));
[-] 		if (((Property*) item)->isMember ())
[+] 		if (((Property*)item)->isMember())
[-] 			result = createMemberClosure (resultValue);
[+] 			result = createMemberClosure(resultValue);
[-] 		decl = (Property*) item;
[+] 		decl = (Property*)item;
[-] 		resultValue->setType (((EnumConst*) item)->getParentEnumType ());
[+] 		resultValue->setType(((EnumConst*)item)->getParentEnumType());
[-] 		decl = (EnumConst*) item;
[+] 		decl = (EnumConst*)item;
[-] 		resultValue->setField ((StructField*) item, coord.m_offset);
[+] 		resultValue->setField((StructField*)item, coord.m_offset);
[-] 		decl = (StructField*) item;
[+] 		decl = (StructField*)item;
[-] 		err::setFormatStringError ("'%s.%s' cannot be used as expression", nspace->getQualifiedName ().sz (), name.sz ());
[+] 		err::setFormatStringError("'%s.%s' cannot be used as expression", nspace->getQualifiedName ().sz (), name.sz ());
[-] 	return finalizeMemberOperator (Value (), decl, resultValue);
[+] 	return finalizeMemberOperator(Value(), decl, resultValue);
[-] OperatorMgr::getNamespaceMember (
[+] OperatorMgr::getNamespaceMember(
[-] 	ModuleItem* item = nspace->findItemTraverse (name, NULL, TraverseKind_NoParentNamespace);
[+] 	ModuleItem* item = nspace->findItemTraverse(name, NULL, TraverseKind_NoParentNamespace);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), nspace->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), nspace->getQualifiedName ().sz ());
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 		item = ((Alias*) item)->getTargetItem ();
[+] 		item = ((Alias*)item)->getTargetItem();
[-] 		itemKind = item->getItemKind ();
[+] 		itemKind = item->getItemKind();
[-] 		ASSERT (itemKind != ModuleItemKind_Alias); // should have been resolved at calclayout stage
[+] 		ASSERT(itemKind != ModuleItemKind_Alias); // should have been resolved at calclayout stage
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		resultValue->setNamespace ((GlobalNamespace*) item);
[+] 		resultValue->setNamespace((GlobalNamespace*)item);
[-] 		decl = (GlobalNamespace*) item;
[+] 		decl = (GlobalNamespace*)item;
[-] 		item = ((Typedef*) item)->getType ();
[+] 		item = ((Typedef*)item)->getType();
[-] 		result = checkAccess ((Typedef*) item);
[+] 		result = checkAccess((Typedef*)item);
[-] 		if (!(((Type*) item)->getTypeKindFlags () & TypeKindFlag_Named))
[+] 		if (!(((Type*)item)->getTypeKindFlags() & TypeKindFlag_Named))
[-] 			err::setFormatStringError ("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[-] 		resultValue->setNamespace ((NamedType*) item);
[+] 		resultValue->setNamespace((NamedType*)item);
[-] 		decl = (NamedType*) item;
[+] 		decl = (NamedType*)item;
[-] 		resultValue->setVariable ((Variable*) item);
[+] 		resultValue->setVariable((Variable*)item);
[-] 		decl = (Variable*) item;
[+] 		decl = (Variable*)item;
[-] 		function = (Function*) item;
[+] 		function = (Function*)item;
[-] 		if (function->isVirtual ())
[+] 		if (function->isVirtual())
[-] 			if (function->getStorageKind () == StorageKind_Abstract)
[+] 			if (function->getStorageKind() == StorageKind_Abstract)
[-] 				err::setFormatStringError ("'%s' is abstract", function->m_tag.sz ());
[+] 				err::setFormatStringError("'%s' is abstract", function->m_tag.sz ());
[-] 			resultValue->setLlvmValue (
[+] 			resultValue->setLlvmValue(
[-] 				function->getLlvmFunction (),
[+] 				function->getLlvmFunction(),
[-] 				function->getType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin)
[+] 				function->getType()->getFunctionPtrType(FunctionPtrTypeKind_Thin)
[-] 			result = createMemberClosure (resultValue);
[+] 			result = createMemberClosure(resultValue);
[-] 		else if (function->isMember ())
[+] 		else if (function->isMember())
[-] 			resultValue->setFunction (function);
[+] 			resultValue->setFunction(function);
[-] 			result = createMemberClosure (resultValue);
[+] 			result = createMemberClosure(resultValue);
[-] 			resultValue->setFunction (function);
[+] 			resultValue->setFunction(function);
[-] 		resultValue->setProperty ((Property*) item);
[+] 		resultValue->setProperty((Property*)item);
[-] 		if (((Property*) item)->isMember ())
[+] 		if (((Property*)item)->isMember())
[-] 			result = createMemberClosure (resultValue);
[+] 			result = createMemberClosure(resultValue);
[-] 		decl = (Property*) item;
[+] 		decl = (Property*)item;
[-] 		result = ((EnumConst*) item)->getParentEnumType ()->ensureLayout ();
[+] 		result = ((EnumConst*)item)->getParentEnumType()->ensureLayout();
[-] 		resultValue->setEnumConst ((EnumConst*) item);
[+] 		resultValue->setEnumConst((EnumConst*)item);
[-] 		decl = (EnumConst*) item;
[+] 		decl = (EnumConst*)item;
[-] 		err::setFormatStringError ("'%s.%s' cannot be used as expression", nspace->getQualifiedName ().sz (), name.sz ());
[+] 		err::setFormatStringError("'%s.%s' cannot be used as expression", nspace->getQualifiedName ().sz (), name.sz ());
[-] 	return finalizeMemberOperator (Value (), decl, resultValue);
[+] 	return finalizeMemberOperator(Value(), decl, resultValue);
[-] OperatorMgr::getNamedTypeMemberType (
[+] OperatorMgr::getNamedTypeMemberType(
[-] 	ModuleItem* member = namedType->findItemTraverse (name, &coord, TraverseKind_NoParentNamespace);
[+] 	ModuleItem* member = namedType->findItemTraverse(name, &coord, TraverseKind_NoParentNamespace);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), namedType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), namedType->getTypeString ().sz ());
[-] 	ModuleItemKind memberKind = member->getItemKind ();
[+] 	ModuleItemKind memberKind = member->getItemKind();
[-] 	switch (memberKind)
[+] 	switch(memberKind)
[-] 		resultValue->setNamespace ((GlobalNamespace*) member);
[+] 		resultValue->setNamespace((GlobalNamespace*)member);
[-] 		decl = (GlobalNamespace*) member;
[+] 		decl = (GlobalNamespace*)member;
[-] 		StructField* field = (StructField*) member;
[+] 		StructField* field = (StructField*)member;
[-] 		if (opValue.getValueKind () == ValueKind_Field)
[+] 		if (opValue.getValueKind() == ValueKind_Field)
[-] 			baseOffset = opValue.getFieldOffset ();
[+] 			baseOffset = opValue.getFieldOffset();
[-] 		if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr))
[+] 		if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr))
[-] 			resultValue->setField (field, baseOffset);
[+] 			resultValue->setField(field, baseOffset);
[-] 		DataPtrType* ptrType = (DataPtrType*) opValue.getType ();
[+] 		DataPtrType* ptrType = (DataPtrType*)opValue.getType();
[-] 		DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 		DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 		Type* resultType = field->getType ()->getDataPtrType (
[+] 		Type* resultType = field->getType()->getDataPtrType(
[-] 			opValue.getType ()->getFlags ()
[+] 			opValue.getType()->getFlags()
[-] 		resultValue->setField (field, resultType, baseOffset);
[+] 		resultValue->setField(field, resultType, baseOffset);
[-] 		resultValue->setType (((Function*) member)->getType ()->getShortType ()->getFunctionPtrType (
[+] 		resultValue->setType(((Function*)member)->getType()->getShortType()->getFunctionPtrType(
[-] 		decl = (Function*) member;
[+] 		decl = (Function*)member;
[-] 		resultValue->setType (((Property*) member)->getType ()->getShortType ()->getPropertyPtrType (
[+] 		resultValue->setType(((Property*)member)->getType()->getShortType()->getPropertyPtrType(
[-] 		decl = (Property*) member;
[+] 		decl = (Property*)member;
[-] 		err::setFormatStringError ("invalid member kind '%s'", getModuleItemKindString (memberKind));
[+] 		err::setFormatStringError("invalid member kind '%s'", getModuleItemKindString (memberKind));
[-] 	return finalizeMemberOperator (opValue, decl, resultValue);
[+] 	return finalizeMemberOperator(opValue, decl, resultValue);
[-] OperatorMgr::getNamedTypeMember (
[+] OperatorMgr::getNamedTypeMember(
[-] 	ModuleItem* member = namedType->findItemTraverse (name, &coord, TraverseKind_NoParentNamespace);
[+] 	ModuleItem* member = namedType->findItemTraverse(name, &coord, TraverseKind_NoParentNamespace);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), namedType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), namedType->getTypeString ().sz ());
[-] 	ModuleItemKind memberKind = member->getItemKind ();
[+] 	ModuleItemKind memberKind = member->getItemKind();
[-] 	switch (memberKind)
[+] 	switch(memberKind)
[-] 		resultValue->setNamespace ((GlobalNamespace*) member);
[+] 		resultValue->setNamespace((GlobalNamespace*)member);
[-] 		decl = (GlobalNamespace*) member;
[+] 		decl = (GlobalNamespace*)member;
[-] 			getField (opValue, (StructField*) member, &coord, resultValue) &&
[+] 			getField(opValue, (StructField*)member, &coord, resultValue) &&
[-] 			finalizeMemberOperator (opValue, (StructField*) member, resultValue);
[+] 			finalizeMemberOperator(opValue, (StructField*)member, resultValue);
[-] 		resultValue->setFunction ((Function*) member);
[+] 		resultValue->setFunction((Function*)member);
[-] 		decl = (Function*) member;
[+] 		decl = (Function*)member;
[-] 		resultValue->setProperty ((Property*) member);
[+] 		resultValue->setProperty((Property*)member);
[-] 		decl = (Property*) member;
[+] 		decl = (Property*)member;
[-] 		err::setFormatStringError ("invalid member kind");
[+] 		err::setFormatStringError("invalid member kind");
[-] 	result = finalizeMemberOperator (opValue, decl, resultValue);
[+] 	result = finalizeMemberOperator(opValue, decl, resultValue);
[-] 	if (decl->getStorageKind () == StorageKind_Static)
[+] 	if (decl->getStorageKind() == StorageKind_Static)
[-] 	AXL_TODO ("remove explicit addr operator and instead allow implicit cast named_type& -> named_type*")
[+] 	AXL_TODO("remove explicit addr operator and instead allow implicit cast named_type& -> named_type*")
[-] 	if (namedType->getTypeKind () != TypeKind_Class)
[+] 	if (namedType->getTypeKind() != TypeKind_Class)
[-] 		result = unaryOperator (UnOpKind_Addr, &thisArgValue);
[+] 		result = unaryOperator(UnOpKind_Addr, &thisArgValue);
[-] 	if (isClassType (namedType, ClassTypeKind_Multicast))
[+] 	if (isClassType(namedType, ClassTypeKind_Multicast))
[-] 		ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr);
[+] 		ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr);
[-] 		if ((member->getFlags () & MulticastMethodFlag_InaccessibleViaEventPtr) &&
[+] 		if ((member->getFlags() & MulticastMethodFlag_InaccessibleViaEventPtr) &&
[-] 			(opValue.getType ()->getFlags () & PtrTypeFlag_Event))
[+] 			(opValue.getType()->getFlags() & PtrTypeFlag_Event))
[-] 			err::setFormatStringError ("'%s' is inaccessible via 'event' pointer", name.sz ());
[+] 			err::setFormatStringError("'%s' is inaccessible via 'event' pointer", name.sz ());
[-] 	Closure* closure = resultValue->createClosure ();
[+] 	Closure* closure = resultValue->createClosure();
[-] 	closure->insertThisArgValue (thisArgValue);
[+] 	closure->insertThisArgValue(thisArgValue);
[-] OperatorMgr::getEnumTypeMemberType (
[+] OperatorMgr::getEnumTypeMemberType(
[-] 	ModuleItem* member = enumType->findItem (name);
[+] 	ModuleItem* member = enumType->findItem(name);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), enumType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), enumType->getTypeString ().sz ());
[-] 	Type* resultType = (enumType->getFlags () & EnumTypeFlag_BitFlag) ?
[+] 	Type* resultType = (enumType->getFlags() & EnumTypeFlag_BitFlag) ?
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::getEnumTypeMember (
[+] OperatorMgr::getEnumTypeMember(
[-] 	ModuleItem* member = enumType->findItem (name);
[+] 	ModuleItem* member = enumType->findItem(name);
[-] 		err::setFormatStringError ("'%s' is not a member of '%s'", name.sz (), enumType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a member of '%s'", name.sz (), enumType->getTypeString ().sz ());
[-] 	ASSERT (member->getItemKind () == ModuleItemKind_EnumConst);
[+] 	ASSERT(member->getItemKind() == ModuleItemKind_EnumConst);
[-] 	EnumConst* enumConst = (EnumConst*) member;
[+] 	EnumConst* enumConst = (EnumConst*)member;
[-] 	Value memberValue (enumConst->getValue (), enumType);
[+] 	Value memberValue(enumConst->getValue(), enumType);
[-] 	BinOpKind binOpKind = (enumType->getFlags () & EnumTypeFlag_BitFlag) ? BinOpKind_BwAnd : BinOpKind_Eq;
[+] 	BinOpKind binOpKind = (enumType->getFlags() & EnumTypeFlag_BitFlag) ? BinOpKind_BwAnd : BinOpKind_Eq;
[-] 	return binaryOperator (
[+] 	return binaryOperator(
[-] OperatorMgr::getVariantMember (
[+] OperatorMgr::getVariantMember(
[-] 	Property* prop = m_module->m_functionMgr.getStdProperty (StdProp_VariantIndex);
[+] 	Property* prop = m_module->m_functionMgr.getStdProperty(StdProp_VariantIndex);
[-] 	resultValue->setProperty (prop);
[+] 	resultValue->setProperty(prop);
[-] 	Value indexValue (index, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT));
[+] 	Value indexValue(index, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT));
[-] 	bool result = unaryOperator (UnOpKind_Addr, opValue, &variantValue);
[+] 	bool result = unaryOperator(UnOpKind_Addr, opValue, &variantValue);
[-] 	Closure* closure = resultValue->createClosure ();
[+] 	Closure* closure = resultValue->createClosure();
[-] 	closure->append (variantValue);
[+] 	closure->append(variantValue);
[-] 	closure->append (indexValue);
[+] 	closure->append(indexValue);
[-] OperatorMgr::getVariantMember (
[+] OperatorMgr::getVariantMember(
[-] 	Property* prop = m_module->m_functionMgr.getStdProperty (StdProp_VariantMember);
[+] 	Property* prop = m_module->m_functionMgr.getStdProperty(StdProp_VariantMember);
[-] 	resultValue->setProperty (prop);
[+] 	resultValue->setProperty(prop);
[-] 	Value nameValue = m_module->m_constMgr.saveLiteral (name);
[+] 	Value nameValue = m_module->m_constMgr.saveLiteral(name);
[-] 	bool result = unaryOperator (UnOpKind_Addr, opValue, &variantValue);
[+] 	bool result = unaryOperator(UnOpKind_Addr, opValue, &variantValue);
[-] 	Closure* closure = resultValue->createClosure ();
[+] 	Closure* closure = resultValue->createClosure();
[-] 	closure->append (variantValue);
[+] 	closure->append(variantValue);
[-] 	closure->append (nameValue);
[+] 	closure->append(nameValue);
[-] OperatorMgr::getMemberOperatorResultType (
[+] OperatorMgr::getMemberOperatorResultType(
[-] 	if (rawOpValue.getValueKind () == ValueKind_Namespace)
[+] 	if (rawOpValue.getValueKind() == ValueKind_Namespace)
[-] 		return getNamespaceMemberType (rawOpValue.getNamespace (), name, resultValue);
[+] 		return getNamespaceMemberType(rawOpValue.getNamespace(), name, resultValue);
[-] 	prepareOperandType (rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepEnum);
[+] 	prepareOperandType(rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepEnum);
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKind () == TypeKind_DataRef)
[+] 	if (type->getTypeKind() == TypeKind_DataRef)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 	if (type->getTypeKind () == TypeKind_DataPtr)
[+] 	if (type->getTypeKind() == TypeKind_DataPtr)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		bool result = getUnaryOperatorResultType (UnOpKind_Indir, &opValue);
[+] 		bool result = getUnaryOperatorResultType(UnOpKind_Indir, &opValue);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return getNamedTypeMemberType (opValue, (NamedType*) type, name, resultValue);
[+] 		return getNamedTypeMemberType(opValue, (NamedType*)type, name, resultValue);
[-] 		prepareOperandType (&opValue);
[+] 		prepareOperandType(&opValue);
[-] 		return getNamedTypeMemberType (opValue, ((ClassPtrType*) type)->getTargetType (), name, resultValue);
[+] 		return getNamedTypeMemberType(opValue, ((ClassPtrType*)type)->getTargetType(), name, resultValue);
[-] 		prepareOperandType (&opValue);
[+] 		prepareOperandType(&opValue);
[-] 		return getEnumTypeMemberType (opValue, (EnumType*) type, name, resultValue);
[+] 		return getEnumTypeMemberType(opValue, (EnumType*)type, name, resultValue);
[-] 		resultValue->setType (m_module->m_typeMgr.getSimplePropertyType (type)); // variant property
[+] 		resultValue->setType(m_module->m_typeMgr.getSimplePropertyType(type)); // variant property
[-] 		err::setFormatStringError ("member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[-] OperatorMgr::memberOperator (
[+] OperatorMgr::memberOperator(
[-] 	bool result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepClassRef);
[+] 	bool result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepClassRef);
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		typeKind = type->getTypeKind ();
[+] 		typeKind = type->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 			return binaryOperator (
[+] 			return binaryOperator(
[-] 				Value (index, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT)),
[+] 				Value(index, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT)),
[-] 			field = ((StructType*) type)->getFieldByIndex (index);
[+] 			field = ((StructType*)type)->getFieldByIndex(index);
[-] 			return field && getStructField (opValue, field, NULL, resultValue);
[+] 			return field && getStructField(opValue, field, NULL, resultValue);
[-] 			field = ((UnionType*) type)->getFieldByIndex (index);
[+] 			field = ((UnionType*)type)->getFieldByIndex(index);
[-] 			return field && getUnionField (opValue, field, resultValue);
[+] 			return field && getUnionField(opValue, field, resultValue);
[-] 			return getVariantMember (opValue, index, resultValue);
[+] 			return getVariantMember(opValue, index, resultValue);
[-] 			err::setFormatStringError ("indexed member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("indexed member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[-] 		type = ((ClassPtrType*) type)->getTargetType ();
[+] 		type = ((ClassPtrType*)type)->getTargetType();
[-] 		field = ((ClassType*) type)->getFieldByIndex (index);
[+] 		field = ((ClassType*)type)->getFieldByIndex(index);
[-] 		return field && getClassField (opValue, field, NULL, resultValue);
[+] 		return field && getClassField(opValue, field, NULL, resultValue);
[-] 		err::setFormatStringError ("indexed member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("indexed member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[-] OperatorMgr::getLibraryMember (
[+] OperatorMgr::getLibraryMember(
[-] 	ASSERT (closure && closure->isMemberClosure ());
[+] 	ASSERT(closure && closure->isMemberClosure());
[-] 	bool result = getNamespaceMember (library, name, &memberValue);
[+] 	bool result = getNamespaceMember(library, name, &memberValue);
[-] 	if (!result || memberValue.getValueKind () != ValueKind_Function)
[+] 	if (!result || memberValue.getValueKind() != ValueKind_Function)
[-] 	Function* function = memberValue.getFunction ();
[+] 	Function* function = memberValue.getFunction();
[-] 	size_t index = function->getLibraryTableIndex ();
[+] 	size_t index = function->getLibraryTableIndex();
[-] 	const char* namePtr = function->getName (); // make sure name pointer stays valid (points to function, not token string)
[+] 	const char* namePtr = function->getName(); // make sure name pointer stays valid (points to function, not token string)
[-] 	Value argValueArray [] =
[+] 	Value argValueArray[] =
[-] 		closure->getThisArgValue (),
[+] 		closure->getThisArgValue(),
[-] 		Value (index, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT)),
[+] 		Value(index, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT)),
[-] 		Value (&namePtr, m_module->m_typeMgr.getStdType (StdType_CharConstPtr)),
[+] 		Value(&namePtr, m_module->m_typeMgr.getStdType(StdType_CharConstPtr)),
[-] 	m_module->m_llvmIrBuilder.createBitCast (
[+] 	m_module->m_llvmIrBuilder.createBitCast(
[-] 		argValueArray [0],
[+] 		argValueArray[0],
[-] 		((ClassType*) m_module->m_typeMgr.getStdType (StdType_DynamicLib))->getClassPtrType (),
[+] 		((ClassType*)m_module->m_typeMgr.getStdType(StdType_DynamicLib))->getClassPtrType(),
[-] 		&argValueArray [0]
[+] 		&argValueArray[0]
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	ASSERT (scope);
[+] 	ASSERT(scope);
[-] 	Function* getterFunction = m_module->m_functionMgr.getStdFunction (StdFunc_TryLazyGetDynamicLibFunction);
[+] 	Function* getterFunction = m_module->m_functionMgr.getStdFunction(StdFunc_TryLazyGetDynamicLibFunction);
[-] 	FunctionType* getterFunctionType = getterFunction->getType ();
[+] 	FunctionType* getterFunctionType = getterFunction->getType();
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		countof (argValueArray),
[+] 		countof(argValueArray),
[-] 	result = m_module->m_controlFlowMgr.throwExceptionIf (ptrValue, getterFunctionType);
[+] 	result = m_module->m_controlFlowMgr.throwExceptionIf(ptrValue, getterFunctionType);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	Type* resultType = function->getType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe);
[+] 	Type* resultType = function->getType()->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe);
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, resultType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, resultType, resultValue);
[-] OperatorMgr::memberOperator (
[+] OperatorMgr::memberOperator(
[-] 	if (rawOpValue.getValueKind () == ValueKind_Namespace)
[+] 	if (rawOpValue.getValueKind() == ValueKind_Namespace)
[-] 		Namespace* nspace = rawOpValue.getNamespace ();
[+] 		Namespace* nspace = rawOpValue.getNamespace();
[-] 		return nspace->getNamespaceKind () == NamespaceKind_DynamicLib ?
[+] 		return nspace->getNamespaceKind() == NamespaceKind_DynamicLib ?
[-] 			getLibraryMember ((DynamicLibNamespace*) nspace, rawOpValue.getClosure (), name, resultValue) :
[+] 			getLibraryMember((DynamicLibNamespace*)nspace, rawOpValue.getClosure(), name, resultValue) :
[-] 			getNamespaceMember (nspace, name, resultValue);
[+] 			getNamespaceMember(nspace, name, resultValue);
[-] 	bool result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepEnum);
[+] 	bool result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepDataRef | OpFlag_KeepEnum);
[-] 	Type* type = opValue.getType ();
[+] 	Type* type = opValue.getType();
[-] 	if (type->getTypeKind () == TypeKind_DataRef)
[+] 	if (type->getTypeKind() == TypeKind_DataRef)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 	if (type->getTypeKind () == TypeKind_DataPtr)
[+] 	if (type->getTypeKind() == TypeKind_DataPtr)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		result = unaryOperator (UnOpKind_Indir, &opValue);
[+] 		result = unaryOperator(UnOpKind_Indir, &opValue);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return getNamedTypeMember (opValue, (NamedType*) type, name, resultValue);
[+] 		return getNamedTypeMember(opValue, (NamedType*)type, name, resultValue);
[-] 			prepareOperand (&opValue) &&
[+] 			prepareOperand(&opValue) &&
[-] 			getNamedTypeMember (opValue, ((ClassPtrType*) type)->getTargetType (), name, resultValue);
[+] 			getNamedTypeMember(opValue, ((ClassPtrType*)type)->getTargetType(), name, resultValue);
[-] 			prepareOperand (&opValue) &&
[+] 			prepareOperand(&opValue) &&
[-] 			getEnumTypeMember (opValue, (EnumType*) type, name, resultValue);
[+] 			getEnumTypeMember(opValue, (EnumType*)type, name, resultValue);
[-] 		return getVariantMember (opValue, name, resultValue);
[+] 		return getVariantMember(opValue, name, resultValue);
[-] 		err::setFormatStringError ("member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("member operator cannot be applied to '%s'", type->getTypeString ().sz ());
[-] OperatorMgr::offsetofOperator (
[+] OperatorMgr::offsetofOperator(
[-] 	if (value.getValueKind () != ValueKind_Field)
[+] 	if (value.getValueKind() != ValueKind_Field)
[-] 		err::setFormatStringError ("'offsetof' can only be applied to fields");
[+] 		err::setFormatStringError("'offsetof' can only be applied to fields");
[-] 	resultValue->setConstSizeT (value.getFieldOffset (), m_module);
[+] 	resultValue->setConstSizeT(value.getFieldOffset(), m_module);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_New.cpp
----------------------
[-] OperatorMgr::memSet (
[+] OperatorMgr::memSet(
[-] 	bool result = castOperator (value, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 	bool result = castOperator(value, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 	Value argValueArray [5] =
[+] 	Value argValueArray[5] =
[-] 		Value (c, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int8)),
[+] 		Value(c, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int8)),
[-] 		Value (size, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32)),
[+] 		Value(size, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32)),
[-] 		Value (alignment, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32)),
[+] 		Value(alignment, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32)),
[-] 		Value (isVolatile, m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool)),
[+] 		Value(isVolatile, m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool)),
[-] 	Function* llvmMemset = m_module->m_functionMgr.getStdFunction (StdFunc_LlvmMemset);
[+] 	Function* llvmMemset = m_module->m_functionMgr.getStdFunction(StdFunc_LlvmMemset);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		llvmMemset->getType (),
[+] 		llvmMemset->getType(),
[-] 		countof (argValueArray),
[+] 		countof(argValueArray),
[-] OperatorMgr::memCpy (
[+] OperatorMgr::memCpy(
[-] 		castOperator (dstValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &dstPtrValue) &&
[+] 		castOperator(dstValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &dstPtrValue) &&
[-] 		castOperator (srcValue, m_module->m_typeMgr.getStdType (StdType_BytePtr), &srcPtrValue);
[+] 		castOperator(srcValue, m_module->m_typeMgr.getStdType(StdType_BytePtr), &srcPtrValue);
[-] 	Value argValueArray [5] =
[+] 	Value argValueArray[5] =
[-] 		Value (size, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32)),
[+] 		Value(size, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32)),
[-] 		Value (alignment, m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32)),
[+] 		Value(alignment, m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32)),
[-] 		Value (isVolatile, m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool)),
[+] 		Value(isVolatile, m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool)),
[-] 	Function* llvmMemcpy = m_module->m_functionMgr.getStdFunction (stdFunc);
[+] 	Function* llvmMemcpy = m_module->m_functionMgr.getStdFunction(stdFunc);
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		llvmMemcpy->getType (),
[+] 		llvmMemcpy->getType(),
[-] 		countof (argValueArray),
[+] 		countof(argValueArray),
[-] OperatorMgr::zeroInitialize (const Value& value)
[+] OperatorMgr::zeroInitialize(const Value& value)
[-] 	ASSERT (value.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(value.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	Type* type = ((DataPtrType*) value.getType ())->getTargetType ();
[+] 	Type* type = ((DataPtrType*)value.getType())->getTargetType();
[-] 	if (type->getSize () <= TypeSizeLimit_StoreSize)
[+] 	if (type->getSize() <= TypeSizeLimit_StoreSize)
[-] 		m_module->m_llvmIrBuilder.createStore (type->getZeroValue (), value);
[+] 		m_module->m_llvmIrBuilder.createStore(type->getZeroValue(), value);
[-] 		memSet (value, 0, type->getSize (), type->getAlignment ());
[+] 		memSet(value, 0, type->getSize(), type->getAlignment());
[-] OperatorMgr::construct (
[+] OperatorMgr::construct(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	Type* type = rawOpValue.getType ();
[+] 	Type* type = rawOpValue.getType();
[-] 	TypeKind ptrTypeKind = type->getTypeKind ();
[+] 	TypeKind ptrTypeKind = type->getTypeKind();
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 		type = ((ClassPtrType*) type)->getTargetType ();
[+] 		type = ((ClassPtrType*)type)->getTargetType();
[-] 		err::setFormatStringError ("'%s' is not a pointer or reference", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is not a pointer or reference", type->getTypeString ().sz ());
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		constructor = ((DerivableType*) type)->getConstructor ();
[+] 		constructor = ((DerivableType*)type)->getConstructor();
[-] 		constructor = ((ClassType*) type)->getConstructor ();
[+] 		constructor = ((ClassType*)type)->getConstructor();
[-] 		if (argList && !argList->isEmpty ())
[+] 		if (argList && !argList->isEmpty())
[-] 			err::setFormatStringError ("'%s' has no constructor", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' has no constructor", type->getTypeString ().sz ());
[-] 	DerivableType* derivableType = (DerivableType*) type;
[+] 	DerivableType* derivableType = (DerivableType*)type;
[-] 	if (constructor->getAccessKind () != AccessKind_Public &&
[+] 	if (constructor->getAccessKind() != AccessKind_Public &&
[-] 		m_module->m_namespaceMgr.getAccessKind (derivableType) == AccessKind_Public)
[+] 		m_module->m_namespaceMgr.getAccessKind(derivableType) == AccessKind_Public)
[-] 		err::setFormatStringError ("'%s.construct' is protected", derivableType->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("'%s.construct' is protected", derivableType->getQualifiedName ().sz ());
[-] 	sl::BoxList <Value> emptyArgList;
[+] 	sl::BoxList<Value> emptyArgList;
[-] 		bool result = unaryOperator (UnOpKind_Addr, &opValue);
[+] 		bool result = unaryOperator(UnOpKind_Addr, &opValue);
[-] 	argList->insertHead (opValue);
[+] 	argList->insertHead(opValue);
[-] 	return callOperator (constructor, argList);
[+] 	return callOperator(constructor, argList);
[-] OperatorMgr::parseInitializer (
[+] OperatorMgr::parseInitializer(
[-] 	const sl::ConstBoxList <Token>& constructorTokenList,
[+] 	const sl::ConstBoxList<Token>& constructorTokenList,
[-] 	const sl::ConstBoxList <Token>& initializerTokenList
[+] 	const sl::ConstBoxList<Token>& initializerTokenList
[-] 	if (rawValue.getType ()->getTypeKind () == TypeKind_DataRef)
[+] 	if (rawValue.getType()->getTypeKind() == TypeKind_DataRef)
[-] 		value.overrideType (((DataPtrType*) rawValue.getType ())->getUnConstPtrType ());
[+] 		value.overrideType(((DataPtrType*)rawValue.getType())->getUnConstPtrType());
[-] 	else if (rawValue.getType ()->getTypeKind () == TypeKind_ClassRef)
[+] 	else if (rawValue.getType()->getTypeKind() == TypeKind_ClassRef)
[-] 		value.overrideType (((ClassPtrType*) rawValue.getType ())->getUnConstPtrType ());
[+] 		value.overrideType(((ClassPtrType*)rawValue.getType())->getUnConstPtrType());
[-] 	sl::BoxList <Value> argList;
[+] 	sl::BoxList<Value> argList;
[-] 	if (!constructorTokenList.isEmpty ())
[+] 	if (!constructorTokenList.isEmpty())
[-] 		Parser parser (m_module);
[+] 		Parser parser(m_module);
[-] 		result = parser.parseTokenList (SymbolKind_expression_or_empty_list_save_list, constructorTokenList);
[+] 		result = parser.parseTokenList(SymbolKind_expression_or_empty_list_save_list, constructorTokenList);
[-] 		sl::takeOver (&argList, &parser.m_expressionValueList);
[+] 		sl::takeOver(&argList, &parser.m_expressionValueList);
[-] 	result = construct (value, &argList);
[+] 	result = construct(value, &argList);
[-] 	if (!initializerTokenList.isEmpty ())
[+] 	if (!initializerTokenList.isEmpty())
[-] 		Parser parser (m_module);
[+] 		Parser parser(m_module);
[-] 		if (initializerTokenList.getHead ()->m_token == '{')
[+] 		if (initializerTokenList.getHead()->m_token == '{')
[-] 			result = parser.parseTokenList (SymbolKind_curly_initializer, initializerTokenList);
[+] 			result = parser.parseTokenList(SymbolKind_curly_initializer, initializerTokenList);
[-] 				parser.parseTokenList (SymbolKind_expression_save_value, initializerTokenList) &&
[+] 				parser.parseTokenList(SymbolKind_expression_save_value, initializerTokenList) &&
[-] 				m_module->m_operatorMgr.binaryOperator (BinOpKind_Assign, value, parser.m_expressionValue);
[+] 				m_module->m_operatorMgr.binaryOperator(BinOpKind_Assign, value, parser.m_expressionValue);
[-] OperatorMgr::parseFunctionArgDefaultValue (
[+] OperatorMgr::parseFunctionArgDefaultValue(
[-] 	const sl::ConstBoxList <Token> tokenList,
[+] 	const sl::ConstBoxList<Token> tokenList,
[-] 	Value prevThisValue = m_module->m_functionMgr.overrideThisValue (thisValue);
[+] 	Value prevThisValue = m_module->m_functionMgr.overrideThisValue(thisValue);
[-] 	bool result = parseFunctionArgDefaultValue (decl, tokenList, resultValue);
[+] 	bool result = parseFunctionArgDefaultValue(decl, tokenList, resultValue);
[-] 	m_module->m_functionMgr.overrideThisValue (prevThisValue);
[+] 	m_module->m_functionMgr.overrideThisValue(prevThisValue);
[-] OperatorMgr::parseFunctionArgDefaultValue (
[+] OperatorMgr::parseFunctionArgDefaultValue(
[-] 	const sl::ConstBoxList <Token> tokenList,
[+] 	const sl::ConstBoxList<Token> tokenList,
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	m_module->m_namespaceMgr.openNamespace (decl->getParentNamespace ());
[+] 	m_module->m_namespaceMgr.openNamespace(decl->getParentNamespace());
[-] 	m_module->m_namespaceMgr.lockSourcePos ();
[+] 	m_module->m_namespaceMgr.lockSourcePos();
[-] 	bool result = parser.parseTokenList (SymbolKind_expression_save_value, tokenList);
[+] 	bool result = parser.parseTokenList(SymbolKind_expression_save_value, tokenList);
[-] 	m_module->m_namespaceMgr.unlockSourcePos ();
[+] 	m_module->m_namespaceMgr.unlockSourcePos();
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] OperatorMgr::parseExpression (
[+] OperatorMgr::parseExpression(
[-] 	const sl::ConstBoxList <Token>& expressionTokenList,
[+] 	const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	bool result = parser.parseTokenList (SymbolKind_expression_save_value, expressionTokenList);
[+] 	bool result = parser.parseTokenList(SymbolKind_expression_save_value, expressionTokenList);
[-] OperatorMgr::parseConstExpression (
[+] OperatorMgr::parseConstExpression(
[-] 	const sl::ConstBoxList <Token>& expressionTokenList,
[+] 	const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	bool result = parseExpression (expressionTokenList, Parser::Flag_ConstExpression, resultValue);
[+] 	bool result = parseExpression(expressionTokenList, Parser::Flag_ConstExpression, resultValue);
[-] 	ASSERT (resultValue->getValueKind () == ValueKind_Const);
[+] 	ASSERT(resultValue->getValueKind() == ValueKind_Const);
[-] OperatorMgr::parseConstIntegerExpression (
[+] OperatorMgr::parseConstIntegerExpression(
[-] 	const sl::ConstBoxList <Token>& expressionTokenList,
[+] 	const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	bool result = parseConstExpression (expressionTokenList, &value);
[+] 	bool result = parseConstExpression(expressionTokenList, &value);
[-] 	if (!(value.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 	if (!(value.getType()->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		err::setFormatStringError ("expression is not integer constant");
[+] 		err::setFormatStringError("expression is not integer constant");
[-] 	memcpy (integer, value.getConstData (), value.getType ()->getSize ());
[+] 	memcpy(integer, value.getConstData(), value.getType()->getSize());
[-] OperatorMgr::parseAutoSizeArrayInitializer (
[+] OperatorMgr::parseAutoSizeArrayInitializer(
[-] 	const sl::ConstBoxList <Token>& initializerTokenList
[+] 	const sl::ConstBoxList<Token>& initializerTokenList
[-] 	int firstToken = initializerTokenList.getHead ()->m_token;
[+] 	int firstToken = initializerTokenList.getHead()->m_token;
[-] 	switch (firstToken)
[+] 	switch(firstToken)
[-] 		return parseAutoSizeArrayLiteralInitializer (initializerTokenList);
[+] 		return parseAutoSizeArrayLiteralInitializer(initializerTokenList);
[-] 		return parseAutoSizeArrayCurlyInitializer (arrayType, initializerTokenList);
[+] 		return parseAutoSizeArrayCurlyInitializer(arrayType, initializerTokenList);
[-] 		err::setFormatStringError ("invalid initializer for auto-size-array");
[+] 		err::setFormatStringError("invalid initializer for auto-size-array");
[-] OperatorMgr::parseAutoSizeArrayLiteralInitializer (const sl::ConstBoxList <Token>& initializerTokenList)
[+] OperatorMgr::parseAutoSizeArrayLiteralInitializer(const sl::ConstBoxList<Token>& initializerTokenList)
[-] 	sl::ConstBoxIterator <Token> token = initializerTokenList.getHead ();
[+] 	sl::ConstBoxIterator<Token> token = initializerTokenList.getHead();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			elementCount += token->m_data.m_string.getLength ();
[+] 			elementCount += token->m_data.m_string.getLength();
[-] 			elementCount += token->m_data.m_binData.getCount ();
[+] 			elementCount += token->m_data.m_binData.getCount();
[-] 	if (initializerTokenList.getTail ()->m_token == TokenKind_Literal)
[+] 	if (initializerTokenList.getTail()->m_token == TokenKind_Literal)
[-] OperatorMgr::parseAutoSizeArrayCurlyInitializer (
[+] OperatorMgr::parseAutoSizeArrayCurlyInitializer(
[-] 	const sl::ConstBoxList <Token>& initializerTokenList
[+] 	const sl::ConstBoxList<Token>& initializerTokenList
[-] 	bool isCharArray = arrayType->getElementType ()->getTypeKind () == TypeKind_Char;
[+] 	bool isCharArray = arrayType->getElementType()->getTypeKind() == TypeKind_Char;
[-] 	sl::ConstBoxIterator <Token> token = initializerTokenList.getHead ();
[+] 	sl::ConstBoxIterator<Token> token = initializerTokenList.getHead();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 					elementCount += token->m_data.m_string.getLength ();
[+] 					elementCount += token->m_data.m_string.getLength();
[-] 					elementCount += token->m_data.m_binData.getCount ();
[+] 					elementCount += token->m_data.m_binData.getCount();
[-] OperatorMgr::gcHeapAllocate (
[+] OperatorMgr::gcHeapAllocate(
[-] 	Value typeValue (&type, m_module->m_typeMgr.getStdType (StdType_BytePtr));
[+] 	Value typeValue(&type, m_module->m_typeMgr.getStdType(StdType_BytePtr));
[-] 	sl::BoxList <Value> allocateArgValueList;
[+] 	sl::BoxList<Value> allocateArgValueList;
[-] 	allocateArgValueList.insertTail (typeValue);
[+] 	allocateArgValueList.insertTail(typeValue);
[-] 	if (type->getTypeKind () == TypeKind_Class)
[+] 	if (type->getTypeKind() == TypeKind_Class)
[-] 		if (type->getFlags () & (ClassTypeFlag_HasAbstractMethods | ClassTypeFlag_OpaqueNonCreatable))
[+] 		if (type->getFlags() & (ClassTypeFlag_HasAbstractMethods | ClassTypeFlag_OpaqueNonCreatable))
[-] 			err::setFormatStringError ("cannot instantiate '%s'", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("cannot instantiate '%s'", type->getTypeString ().sz ());
[-] 		allocate = m_module->m_functionMgr.getStdFunction (StdFunc_AllocateClass);
[+] 		allocate = m_module->m_functionMgr.getStdFunction(StdFunc_AllocateClass);
[-] 		allocate = m_module->m_functionMgr.getStdFunction (StdFunc_AllocateData);
[+] 		allocate = m_module->m_functionMgr.getStdFunction(StdFunc_AllocateData);
[-] 		allocate = m_module->m_functionMgr.getStdFunction (StdFunc_AllocateArray);
[+] 		allocate = m_module->m_functionMgr.getStdFunction(StdFunc_AllocateArray);
[-] 		result = castOperator (rawElementCountValue, TypeKind_SizeT, &countValue);
[+] 		result = castOperator(rawElementCountValue, TypeKind_SizeT, &countValue);
[-] 		allocateArgValueList.insertTail (countValue);
[+] 		allocateArgValueList.insertTail(countValue);
[-] 	m_module->m_operatorMgr.callOperator (
[+] 	m_module->m_operatorMgr.callOperator(
[-] 	if (type->getTypeKind () == TypeKind_Class)
[+] 	if (type->getTypeKind() == TypeKind_Class)
[-] 		m_module->m_llvmIrBuilder.createBitCast (ptrValue, ((ClassType*) type)->getClassPtrType (), resultValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(ptrValue, ((ClassType*)type)->getClassPtrType(), resultValue);
[-] 		resultValue->overrideType (ptrValue, type->getDataPtrType ());
[+] 		resultValue->overrideType(ptrValue, type->getDataPtrType());
[-] OperatorMgr::newOperator (
[+] OperatorMgr::newOperator(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	result = gcHeapAllocate (type, rawElementCountValue, &ptrValue);
[+] 	result = gcHeapAllocate(type, rawElementCountValue, &ptrValue);
[-] 	result = construct (ptrValue, argValueList);
[+] 	result = construct(ptrValue, argValueList);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Property.cpp
----------------------
[-] OperatorMgr::getPropertyThinPtr (
[+] OperatorMgr::getPropertyThinPtr(
[-] 	ASSERT (prop->getType ()->cmp (ptrType->getTargetType ()) == 0);
[+] 	ASSERT(prop->getType()->cmp(ptrType->getTargetType()) == 0);
[-] 	bool result = getPropertyVTable (prop, closure, resultValue);
[+] 	bool result = getPropertyVTable(prop, closure, resultValue);
[-] 	resultValue->overrideType (ptrType);
[+] 	resultValue->overrideType(ptrType);
[-] OperatorMgr::getPropertyVTable (
[+] OperatorMgr::getPropertyVTable(
[-] 	if (prop->isVirtual ())
[+] 	if (prop->isVirtual())
[-] 		return getVirtualProperty (prop, closure, resultValue);
[+] 		return getVirtualProperty(prop, closure, resultValue);
[-] 	*resultValue = prop->getVTableVariable ();
[+] 	*resultValue = prop->getVTableVariable();
[-] OperatorMgr::getPropertyVTable (
[+] OperatorMgr::getPropertyVTable(
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckNullPtr)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckNullPtr)
[-] 		checkNullPtr (opValue);
[+] 		checkNullPtr(opValue);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 	PropertyPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 		err::setFormatStringError ("cannot invoke weak '%s'", ptrType->getTypeString ().sz ());
[+] 		err::setFormatStringError("cannot invoke weak '%s'", ptrType->getTypeString ().sz ());
[-] 		if (opValue.getValueKind () == ValueKind_Property)
[+] 		if (opValue.getValueKind() == ValueKind_Property)
[-] 			return getPropertyVTable (opValue.getProperty (), opValue.getClosure (), resultValue);
[+] 			return getPropertyVTable(opValue.getProperty(), opValue.getClosure(), resultValue);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	PropertyType* propertyType = ptrType->getTargetType ();
[+] 	PropertyType* propertyType = ptrType->getTargetType();
[-] 	PropertyType* stdObjectMemberPropertyType = propertyType->getStdObjectMemberPropertyType ();
[+] 	PropertyType* stdObjectMemberPropertyType = propertyType->getStdObjectMemberPropertyType();
[-] 	Type* vtableType = stdObjectMemberPropertyType->getVTableStructType ()->getDataPtrType_c ();
[+] 	Type* vtableType = stdObjectMemberPropertyType->getVTableStructType()->getDataPtrType_c();
[-] 	Type* resultType = propertyType->getVTableStructType ()->getDataPtrType_c ();
[+] 	Type* resultType = propertyType->getVTableStructType()->getDataPtrType_c();
[-] 	Type* closureType = m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr);
[+] 	Type* closureType = m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, NULL, &vtableValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, NULL, &vtableValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 1, closureType, &closureValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 1, closureType, &closureValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (vtableValue, vtableType, resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(vtableValue, vtableType, resultValue);
[-] 	resultValue->overrideType (resultType);
[+] 	resultValue->overrideType(resultType);
[-] 	Closure* closure = opValue.getClosure ();
[+] 	Closure* closure = opValue.getClosure();
[-] 		resultValue->setClosure (closure);
[+] 		resultValue->setClosure(closure);
[-] 		closure = resultValue->createClosure ();
[+] 		closure = resultValue->createClosure();
[-] 	closure->insertThisArgValue (closureValue);
[+] 	closure->insertThisArgValue(closureValue);
[-] OperatorMgr::getPropertyGetterType (const Value& rawOpValue)
[+] OperatorMgr::getPropertyGetterType(const Value& rawOpValue)
[-] 	prepareOperandType (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	prepareOperandType(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		propertyType = opValue.getProperty ()->getType ();
[+] 		propertyType = opValue.getProperty()->getType();
[-] 		ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 		ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 		PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 		PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 		propertyType = ptrType->hasClosure () ?
[+] 		propertyType = ptrType->hasClosure() ?
[-] 			ptrType->getTargetType ()->getStdObjectMemberPropertyType () :
[+] 			ptrType->getTargetType()->getStdObjectMemberPropertyType() :
[-] 			ptrType->getTargetType ();
[+] 			ptrType->getTargetType();
[-] 	return getFunctionType (opValue, propertyType->getGetterType ());
[+] 	return getFunctionType(opValue, propertyType->getGetterType());
[-] OperatorMgr::getPropertyGetterType (
[+] OperatorMgr::getPropertyGetterType(
[-] 	Type* resultType = getPropertyGetterType (opValue);
[+] 	Type* resultType = getPropertyGetterType(opValue);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::getPropertyGetter (
[+] OperatorMgr::getPropertyGetter(
[-] 	result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		*resultValue = opValue.getProperty ()->getGetter ();
[+] 		*resultValue = opValue.getProperty()->getGetter();
[-] 		resultValue->setClosure (opValue.getClosure ());
[+] 		resultValue->setClosure(opValue.getClosure());
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyType* propertyType = ptrType->hasClosure () ?
[+] 	PropertyType* propertyType = ptrType->hasClosure() ?
[-] 		ptrType->getTargetType ()->getStdObjectMemberPropertyType () :
[+] 		ptrType->getTargetType()->getStdObjectMemberPropertyType() :
[-] 		ptrType->getTargetType ();
[+] 		ptrType->getTargetType();
[-] 	result = getPropertyVTable (opValue, &VTableValue);
[+] 	result = getPropertyVTable(opValue, &VTableValue);
[-] 	size_t index = (propertyType->getFlags () & PropertyTypeFlag_Bindable) ? 1 : 0;
[+] 	size_t index = (propertyType->getFlags() & PropertyTypeFlag_Bindable) ? 1 : 0;
[-] 	m_module->m_llvmIrBuilder.createGep2 (VTableValue, index, NULL, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(VTableValue, index, NULL, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (
[+] 	m_module->m_llvmIrBuilder.createLoad(
[-] 		propertyType->getGetterType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[+] 		propertyType->getGetterType()->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[-] 	resultValue->setClosure (VTableValue.getClosure ());
[+] 	resultValue->setClosure(VTableValue.getClosure());
[-] OperatorMgr::getPropertySetterType (
[+] OperatorMgr::getPropertySetterType(
[-] 	prepareOperandType (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	prepareOperandType(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		propertyType = opValue.getProperty ()->getType ();
[+] 		propertyType = opValue.getProperty()->getType();
[-] 		ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 		ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 		propertyType = ptrType->hasClosure () ?
[+] 		propertyType = ptrType->hasClosure() ?
[-] 			ptrType->getTargetType ()->getStdObjectMemberPropertyType () :
[+] 			ptrType->getTargetType()->getStdObjectMemberPropertyType() :
[-] 			ptrType->getTargetType ();
[+] 			ptrType->getTargetType();
[-] 	if (propertyType->isReadOnly ())
[+] 	if (propertyType->isReadOnly())
[-] 		err::setFormatStringError ("read-only '%s' has no 'set'", propertyType->getTypeString ().sz ());
[+] 		err::setFormatStringError("read-only '%s' has no 'set'", propertyType->getTypeString ().sz ());
[-] 	else if (ptrType->getFlags () & PtrTypeFlag_Const)
[+] 	else if (ptrType->getFlags() & PtrTypeFlag_Const)
[-] 		err::setFormatStringError ("'set' is inaccessible via 'const' property pointer");
[+] 		err::setFormatStringError("'set' is inaccessible via 'const' property pointer");
[-] 	FunctionTypeOverload* setterTypeOverload = propertyType->getSetterType ();
[+] 	FunctionTypeOverload* setterTypeOverload = propertyType->getSetterType();
[-] 	size_t i = setterTypeOverload->chooseSetterOverload (argValue);
[+] 	size_t i = setterTypeOverload->chooseSetterOverload(argValue);
[-] 		err::setFormatStringError ("cannot choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[+] 		err::setFormatStringError("cannot choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[-] 	FunctionType* setterType = setterTypeOverload->getOverload (i);
[+] 	FunctionType* setterType = setterTypeOverload->getOverload(i);
[-] 	return getFunctionType (opValue, setterType);
[+] 	return getFunctionType(opValue, setterType);
[-] OperatorMgr::getPropertySetterType (
[+] OperatorMgr::getPropertySetterType(
[-] 	Type* resultType = getPropertySetterType (opValue, argValue);
[+] 	Type* resultType = getPropertySetterType(opValue, argValue);
[-] 	resultValue->setType (resultType);
[+] 	resultValue->setType(resultType);
[-] OperatorMgr::getPropertySetter (
[+] OperatorMgr::getPropertySetter(
[-] 	result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyType* propertyType = ptrType->hasClosure () ?
[+] 	PropertyType* propertyType = ptrType->hasClosure() ?
[-] 		ptrType->getTargetType ()->getStdObjectMemberPropertyType () :
[+] 		ptrType->getTargetType()->getStdObjectMemberPropertyType() :
[-] 		ptrType->getTargetType ();
[+] 		ptrType->getTargetType();
[-] 	if (propertyType->isReadOnly ())
[+] 	if (propertyType->isReadOnly())
[-] 		err::setFormatStringError ("read-only '%s' has no setter", propertyType->getTypeString ().sz ());
[+] 		err::setFormatStringError("read-only '%s' has no setter", propertyType->getTypeString ().sz ());
[-] 	else if (ptrType->getFlags () & PtrTypeFlag_Const)
[+] 	else if (ptrType->getFlags() & PtrTypeFlag_Const)
[-] 		err::setFormatStringError ("'set' is inaccessible via 'const' property pointer");
[+] 		err::setFormatStringError("'set' is inaccessible via 'const' property pointer");
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		*resultValue = opValue.getProperty ()->getSetter ();
[+] 		*resultValue = opValue.getProperty()->getSetter();
[-] 		resultValue->setClosure (opValue.getClosure ());
[+] 		resultValue->setClosure(opValue.getClosure());
[-] 	FunctionTypeOverload* setterTypeOverload = propertyType->getSetterType ();
[+] 	FunctionTypeOverload* setterTypeOverload = propertyType->getSetterType();
[-] 	if (setterTypeOverload->isOverloaded ())
[+] 	if (setterTypeOverload->isOverloaded())
[-] 			err::setFormatStringError ("no argument value to help choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[+] 			err::setFormatStringError("no argument value to help choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[-] 		i = setterTypeOverload->chooseSetterOverload (argValue);
[+] 		i = setterTypeOverload->chooseSetterOverload(argValue);
[-] 			err::setFormatStringError ("cannot choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[+] 			err::setFormatStringError("cannot choose one of '%d' setter overloads", setterTypeOverload->getOverloadCount ());
[-] 	FunctionType* setterType = setterTypeOverload->getOverload (i);
[+] 	FunctionType* setterType = setterTypeOverload->getOverload(i);
[-] 	result = getPropertyVTable (opValue, &vtableValue);
[+] 	result = getPropertyVTable(opValue, &vtableValue);
[-] 	size_t index = (propertyType->getFlags () & PropertyTypeFlag_Bindable) ? 2 : 1;
[+] 	size_t index = (propertyType->getFlags() & PropertyTypeFlag_Bindable) ? 2 : 1;
[-] 	m_module->m_llvmIrBuilder.createGep2 (vtableValue, index, NULL, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(vtableValue, index, NULL, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (
[+] 	m_module->m_llvmIrBuilder.createLoad(
[-] 		setterType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[+] 		setterType->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[-] 	resultValue->setClosure (vtableValue.getClosure ());
[+] 	resultValue->setClosure(vtableValue.getClosure());
[-] OperatorMgr::getPropertyBinderType (const Value& rawOpValue)
[+] OperatorMgr::getPropertyBinderType(const Value& rawOpValue)
[-] 	prepareOperandType (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	prepareOperandType(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		propertyType = opValue.getProperty ()->getType ();
[+] 		propertyType = opValue.getProperty()->getType();
[-] 		ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 		ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 		PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 		PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 		propertyType = ptrType->hasClosure () ?
[+] 		propertyType = ptrType->hasClosure() ?
[-] 			ptrType->getTargetType ()->getStdObjectMemberPropertyType () :
[+] 			ptrType->getTargetType()->getStdObjectMemberPropertyType() :
[-] 			ptrType->getTargetType ();
[+] 			ptrType->getTargetType();
[-] 	if (!(propertyType->getFlags () & PropertyTypeFlag_Bindable))
[+] 	if (!(propertyType->getFlags() & PropertyTypeFlag_Bindable))
[-] 		err::setFormatStringError ("'%s' has no 'onchanged' binder", propertyType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no 'onchanged' binder", propertyType->getTypeString ().sz ());
[-] 	return getFunctionType (opValue, propertyType->getBinderType ());
[+] 	return getFunctionType(opValue, propertyType->getBinderType());
[-] OperatorMgr::getPropertyBinderType (
[+] OperatorMgr::getPropertyBinderType(
[-] 	Type* type = getPropertyBinderType (opValue);
[+] 	Type* type = getPropertyBinderType(opValue);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
[-] OperatorMgr::getPropertyBinder (
[+] OperatorMgr::getPropertyBinder(
[-] 	result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	ASSERT (opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr);
[+] 	ASSERT(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr);
[-] 	PropertyPtrType* ptrType = (PropertyPtrType*) opValue.getType ();
[+] 	PropertyPtrType* ptrType = (PropertyPtrType*)opValue.getType();
[-] 	PropertyType* propertyType = ptrType->getTargetType ();
[+] 	PropertyType* propertyType = ptrType->getTargetType();
[-] 	if (!(propertyType->getFlags () & PropertyTypeFlag_Bindable))
[+] 	if (!(propertyType->getFlags() & PropertyTypeFlag_Bindable))
[-] 		err::setFormatStringError ("'%s' has no 'onchanged' binder", propertyType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no 'onchanged' binder", propertyType->getTypeString ().sz ());
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		*resultValue = opValue.getProperty ()->getBinder ();
[+] 		*resultValue = opValue.getProperty()->getBinder();
[-] 		resultValue->setClosure (opValue.getClosure ());
[+] 		resultValue->setClosure(opValue.getClosure());
[-] 	if (ptrType->hasClosure ())
[+] 	if (ptrType->hasClosure())
[-] 		propertyType = propertyType->getStdObjectMemberPropertyType ();
[+] 		propertyType = propertyType->getStdObjectMemberPropertyType();
[-] 	result = getPropertyVTable (opValue, &VTableValue);
[+] 	result = getPropertyVTable(opValue, &VTableValue);
[-] 	m_module->m_llvmIrBuilder.createGep2 (VTableValue, 0, NULL, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(VTableValue, 0, NULL, &pfnValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (
[+] 	m_module->m_llvmIrBuilder.createLoad(
[-] 		propertyType->getBinderType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[+] 		propertyType->getBinderType()->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe),
[-] 	resultValue->setClosure (VTableValue.getClosure ());
[+] 	resultValue->setClosure(VTableValue.getClosure());
[-] OperatorMgr::getProperty (
[+] OperatorMgr::getProperty(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyRef);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyRef);
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		Property* prop = opValue.getProperty ();
[+] 		Property* prop = opValue.getProperty();
[-] 		if (prop->getFlags () & PropertyFlag_AutoGet)
[+] 		if (prop->getFlags() & PropertyFlag_AutoGet)
[-] 			return getPropertyAutoGetValue (opValue, resultValue);
[+] 			return getPropertyAutoGetValue(opValue, resultValue);
[-] 		getPropertyGetter (opValue, &getterValue) &&
[+] 		getPropertyGetter(opValue, &getterValue) &&
[-] 		callOperator (getterValue, NULL, resultValue);
[+] 		callOperator(getterValue, NULL, resultValue);
[-] OperatorMgr::setProperty (
[+] OperatorMgr::setProperty(
[-] 	ASSERT (opValue.getType ()->getTypeKind () == TypeKind_PropertyRef);
[+] 	ASSERT(opValue.getType()->getTypeKind() == TypeKind_PropertyRef);
[-] 		getPropertySetter (opValue, srcValue, &setterValue) &&
[+] 		getPropertySetter(opValue, srcValue, &setterValue) &&
[-] 		callOperator (setterValue, srcValue);
[+] 		callOperator(setterValue, srcValue);
[-] OperatorMgr::getPropertyAutoGetValueType (const Value& opValue)
[+] OperatorMgr::getPropertyAutoGetValueType(const Value& opValue)
[-] 	if (opValue.getValueKind () != ValueKind_Property ||
[+] 	if (opValue.getValueKind() != ValueKind_Property ||
[-] 		!(opValue.getProperty ()->getFlags () & PropertyFlag_AutoGet))
[+] 		!(opValue.getProperty()->getFlags() & PropertyFlag_AutoGet))
[-] 		err::setFormatStringError ("'%s' has no autoget field", opValue.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no autoget field", opValue.getType ()->getTypeString ().sz ());
[-] 	ModuleItem* autoGetValue = opValue.getProperty ()->getAutoGetValue ();
[+] 	ModuleItem* autoGetValue = opValue.getProperty()->getAutoGetValue();
[-] 	type = autoGetValue->getItemKind () == ModuleItemKind_StructField ?
[+] 	type = autoGetValue->getItemKind() == ModuleItemKind_StructField ?
[-] 		((StructField*) autoGetValue)->getType() :
[+] 		((StructField*)autoGetValue)->getType() :
[-] 		((Variable*) autoGetValue)->getType();
[+] 		((Variable*)autoGetValue)->getType();
[-] 	return type->getDataPtrType (TypeKind_DataRef, DataPtrTypeKind_Lean);
[+] 	return type->getDataPtrType(TypeKind_DataRef, DataPtrTypeKind_Lean);
[-] OperatorMgr::getPropertyAutoGetValueType (
[+] OperatorMgr::getPropertyAutoGetValueType(
[-] 	Type* type = getPropertyAutoGetValueType (opValue);
[+] 	Type* type = getPropertyAutoGetValueType(opValue);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
[-] OperatorMgr::getPropertyAutoGetValue (
[+] OperatorMgr::getPropertyAutoGetValue(
[-] 	if (opValue.getValueKind () != ValueKind_Property ||
[+] 	if (opValue.getValueKind() != ValueKind_Property ||
[-] 		!(opValue.getProperty ()->getFlags () & PropertyFlag_AutoGet))
[+] 		!(opValue.getProperty()->getFlags() & PropertyFlag_AutoGet))
[-] 		err::setFormatStringError ("'%s' has no autoget field", opValue.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no autoget field", opValue.getType ()->getTypeString ().sz ());
[-] 	return getPropertyField (opValue, opValue.getProperty ()->getAutoGetValue (), resultValue);
[+] 	return getPropertyField(opValue, opValue.getProperty()->getAutoGetValue(), resultValue);
[-] OperatorMgr::getPropertyOnChangedType (const Value& rawOpValue)
[+] OperatorMgr::getPropertyOnChangedType(const Value& rawOpValue)
[-] 	prepareOperandType (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	prepareOperandType(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr) ||
[+] 	if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr) ||
[-] 		!(((PropertyPtrType*) opValue.getType ())->getTargetType ()->getFlags () & PropertyTypeFlag_Bindable))
[+] 		!(((PropertyPtrType*)opValue.getType())->getTargetType()->getFlags() & PropertyTypeFlag_Bindable))
[-] 		err::setFormatStringError ("'%s' has no bindable event", opValue.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no bindable event", opValue.getType ()->getTypeString ().sz ());
[-] 	return m_module->m_typeMgr.getStdType (StdType_SimpleEventPtr);
[+] 	return m_module->m_typeMgr.getStdType(StdType_SimpleEventPtr);
[-] OperatorMgr::getPropertyOnChangedType (
[+] OperatorMgr::getPropertyOnChangedType(
[-] 	Type* type = getPropertyOnChangedType (opValue);
[+] 	Type* type = getPropertyOnChangedType(opValue);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
[-] OperatorMgr::getPropertyOnChanged (
[+] OperatorMgr::getPropertyOnChanged(
[-] 	bool result = prepareOperand (rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[+] 	bool result = prepareOperand(rawOpValue, &opValue, OpFlag_KeepPropertyRef);
[-] 	if (!(opValue.getType ()->getTypeKindFlags () & TypeKindFlag_PropertyPtr) ||
[+] 	if (!(opValue.getType()->getTypeKindFlags() & TypeKindFlag_PropertyPtr) ||
[-] 		!(((PropertyPtrType*) opValue.getType ())->getTargetType ()->getFlags () & PropertyTypeFlag_Bindable))
[+] 		!(((PropertyPtrType*)opValue.getType())->getTargetType()->getFlags() & PropertyTypeFlag_Bindable))
[-] 		err::setFormatStringError ("'%s' has no bindable event", opValue.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no bindable event", opValue.getType ()->getTypeString ().sz ());
[-] 	if (opValue.getValueKind () == ValueKind_Property)
[+] 	if (opValue.getValueKind() == ValueKind_Property)
[-] 		return getPropertyField (opValue, opValue.getProperty ()->getOnChanged (), resultValue);
[+] 		return getPropertyField(opValue, opValue.getProperty()->getOnChanged(), resultValue);
[-] 		getPropertyBinder (opValue, &binderValue) &&
[+] 		getPropertyBinder(opValue, &binderValue) &&
[-] 		callOperator (binderValue, NULL, resultValue);
[+] 		callOperator(binderValue, NULL, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr_Virtual.cpp
----------------------
[-] OperatorMgr::getClassVTable (
[+] OperatorMgr::getClassVTable(
[-] 	StructType* vtableType = classType->getVTableStructType ();
[+] 	StructType* vtableType = classType->getVTableStructType();
[-] 	ASSERT (vtableType);
[+] 	ASSERT(vtableType);
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_SimpleCheckNullPtr)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_SimpleCheckNullPtr)
[-] 		checkNullPtr (opValue);
[+] 		checkNullPtr(opValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (opValue, m_module->m_typeMgr.getStdType (StdType_IfaceHdrPtr), &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(opValue, m_module->m_typeMgr.getStdType(StdType_IfaceHdrPtr), &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createGep2 (ptrValue, 0, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(ptrValue, 0, NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (ptrValue, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(ptrValue, NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, vtableType->getDataPtrType_c (), resultValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, vtableType->getDataPtrType_c(), resultValue);
[-] OperatorMgr::getVirtualMethod (
[+] OperatorMgr::getVirtualMethod(
[-] 	ASSERT (function->isVirtual ());
[+] 	ASSERT(function->isVirtual());
[-] 	if (!closure || !closure->isMemberClosure ())
[+] 	if (!closure || !closure->isMemberClosure())
[-] 		err::setFormatStringError ("virtual function requires an object pointer");
[+] 		err::setFormatStringError("virtual function requires an object pointer");
[-] 	Value value = *closure->getArgValueList ()->getHead ();
[+] 	Value value = *closure->getArgValueList()->getHead();
[-] 	ClassType* classType = ((ClassPtrType*) value.getType ())->getTargetType ();
[+] 	ClassType* classType = ((ClassPtrType*)value.getType())->getTargetType();
[-] 	ClassType* vtableType = function->getVirtualOriginClassType ();
[+] 	ClassType* vtableType = function->getVirtualOriginClassType();
[-] 	size_t VTableIndex = function->getClassVTableIndex ();
[+] 	size_t VTableIndex = function->getClassVTableIndex();
[-] 	classType->findBaseTypeTraverse (vtableType, &coord);
[+] 	classType->findBaseTypeTraverse(vtableType, &coord);
[-] 	getClassVTable (value, classType, &ptrValue);
[+] 	getClassVTable(value, classType, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createGep2 (
[+] 	m_module->m_llvmIrBuilder.createGep2(
[-] 	m_module->m_llvmIrBuilder.createLoad (
[+] 	m_module->m_llvmIrBuilder.createLoad(
[-] 	resultValue->setLlvmValue (
[+] 	resultValue->setLlvmValue(
[-] 		ptrValue.getLlvmValue (),
[+] 		ptrValue.getLlvmValue(),
[-] 		function->getType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin)
[+] 		function->getType()->getFunctionPtrType(FunctionPtrTypeKind_Thin)
[-] 	resultValue->setClosure (closure);
[+] 	resultValue->setClosure(closure);
[-] OperatorMgr::getVirtualProperty (
[+] OperatorMgr::getVirtualProperty(
[-] 	ASSERT (prop->isVirtual ());
[+] 	ASSERT(prop->isVirtual());
[-] 	if (!closure || !closure->isMemberClosure ())
[+] 	if (!closure || !closure->isMemberClosure())
[-] 		err::setFormatStringError ("virtual property requires an object pointer");
[+] 		err::setFormatStringError("virtual property requires an object pointer");
[-] 	Value value = *closure->getArgValueList ()->getHead ();
[+] 	Value value = *closure->getArgValueList()->getHead();
[-] 	ClassType* classType = ((ClassPtrType*) value.getType ())->getTargetType ();
[+] 	ClassType* classType = ((ClassPtrType*)value.getType())->getTargetType();
[-] 	size_t VTableIndex = prop->getParentClassVTableIndex ();
[+] 	size_t VTableIndex = prop->getParentClassVTableIndex();
[-] 	classType->findBaseTypeTraverse (prop->getParentType (), &coord);
[+] 	classType->findBaseTypeTraverse(prop->getParentType(), &coord);
[-] 	getClassVTable (value, classType, &ptrValue);
[+] 	getClassVTable(value, classType, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createGep2 (
[+] 	m_module->m_llvmIrBuilder.createGep2(
[-] 	m_module->m_llvmIrBuilder.createBitCast (
[+] 	m_module->m_llvmIrBuilder.createBitCast(
[-] 		prop->getType ()->getVTableStructType ()->getDataPtrType_c (),
[+] 		prop->getType()->getVTableStructType()->getDataPtrType_c(),
[-] 	resultValue->overrideType (ptrValue, prop->getType ()->getPropertyPtrType (PropertyPtrTypeKind_Thin));
[+] 	resultValue->overrideType(ptrValue, prop->getType()->getPropertyPtrType(PropertyPtrTypeKind_Thin));
[-] 	resultValue->setClosure (closure);
[+] 	resultValue->setClosure(closure);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp.cpp
----------------------
[-] getUnOpKindString (UnOpKind opKind)
[+] getUnOpKindString(UnOpKind opKind)
[-] 	static const char* stringTable [UnOpKind__Count] =
[+] 	static const char* stringTable[UnOpKind__Count] =
[-] 	return (size_t) opKind < UnOpKind__Count ?
[+] 	return (size_t)opKind < UnOpKind__Count ?
[-] 		stringTable [opKind] :
[+] 		stringTable[opKind] :
[-] 		stringTable [UnOpKind_Undefined];
[+] 		stringTable[UnOpKind_Undefined];
[-] UnaryOperator::UnaryOperator ()
[+] UnaryOperator::UnaryOperator()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] UnaryOperator::getResultType (
[+] UnaryOperator::getResultType(
[-] 	Type* type = getResultType (opValue);
[+] 	Type* type = getResultType(opValue);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Arithmetic.cpp
----------------------
[-] getArithmeticOperatorResultType (Type* opType)
[+] getArithmeticOperatorResultType(Type* opType)
[-] 	TypeKind typeKind = opType->getTypeKind ();
[+] 	TypeKind typeKind = opType->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return getArithmeticOperatorResultType (((EnumType*) opType)->getBaseType ());
[+] 		return getArithmeticOperatorResultType(((EnumType*)opType)->getBaseType());
[-] 	return opType->getModule ()->m_typeMgr.getPrimitiveType (typeKind);
[+] 	return opType->getModule()->m_typeMgr.getPrimitiveType(typeKind);
[-] UnOp_Minus::llvmOpInt (
[+] UnOp_Minus::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createNeg_i (opValue, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createNeg_i(opValue, resultType, resultValue);
[-] UnOp_Minus::llvmOpFp (
[+] UnOp_Minus::llvmOpFp(
[-] 	return m_module->m_llvmIrBuilder.createNeg_f (opValue, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createNeg_f(opValue, resultType, resultValue);
[-] UnOp_BwNot::llvmOpInt (
[+] UnOp_BwNot::llvmOpInt(
[-] 	return m_module->m_llvmIrBuilder.createNot (opValue, resultType, resultValue);
[+] 	return m_module->m_llvmIrBuilder.createNot(opValue, resultType, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Inc.cpp
----------------------
[-] UnOp_PreInc::getResultType (const Value& opValue)
[+] UnOp_PreInc::getResultType(const Value& opValue)
[-] 	return opValue.getType ();
[+] 	return opValue.getType();
[-] UnOp_PreInc::op (
[+] UnOp_PreInc::op(
[-] 	oneValue.setConstInt32 (1, m_module);
[+] 	oneValue.setConstInt32(1, m_module);
[-] 	bool result = m_module->m_operatorMgr.binaryOperator (binOpKind, opValue, oneValue);
[+] 	bool result = m_module->m_operatorMgr.binaryOperator(binOpKind, opValue, oneValue);
[-] UnOp_PostInc::getResultType (const Value& opValue)
[+] UnOp_PostInc::getResultType(const Value& opValue)
[-] 	m_module->m_operatorMgr.prepareOperandType (opValue, &oldValue);
[+] 	m_module->m_operatorMgr.prepareOperandType(opValue, &oldValue);
[-] 	return oldValue.getType ();
[+] 	return oldValue.getType();
[-] UnOp_PostInc::op (
[+] UnOp_PostInc::op(
[-] 	result = m_module->m_operatorMgr.prepareOperand (opValue, &oldValue);
[+] 	result = m_module->m_operatorMgr.prepareOperand(opValue, &oldValue);
[-] 	oneValue.setConstInt32 (1, m_module);
[+] 	oneValue.setConstInt32(1, m_module);
[-] 	result = m_module->m_operatorMgr.binaryOperator (binOpKind, opValue, oneValue);
[+] 	result = m_module->m_operatorMgr.binaryOperator(binOpKind, opValue, oneValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_LogNot.cpp
----------------------
[-] UnOp_LogNot::getResultType (const Value& opValue)
[+] UnOp_LogNot::getResultType(const Value& opValue)
[-] 	return m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
[+] 	return m_module->m_typeMgr.getPrimitiveType(TypeKind_Bool);
[-] UnOp_LogNot::op (
[+] UnOp_LogNot::op(
[-] 	TypeKind srcTypeKind = opValue.getType ()->getTypeKind ();
[+] 	TypeKind srcTypeKind = opValue.getType()->getTypeKind();
[-] 	switch (srcTypeKind)
[+] 	switch(srcTypeKind)
[-] 		return zeroCmpOperator (opValue, resultValue);
[+] 		return zeroCmpOperator(opValue, resultValue);
[-] 		return ptrOperator (opValue, resultValue);
[+] 		return ptrOperator(opValue, resultValue);
[-] 		return variantOperator (opValue, resultValue);
[+] 		return variantOperator(opValue, resultValue);
[-] 		setOperatorError (opValue);
[+] 		setOperatorError(opValue);
[-] UnOp_LogNot::zeroCmpOperator (
[+] UnOp_LogNot::zeroCmpOperator(
[-] 	Value zeroValue = opValue.getType ()->getZeroValue ();
[+] 	Value zeroValue = opValue.getType()->getZeroValue();
[-] 	return m_module->m_operatorMgr.binaryOperator (BinOpKind_Eq, opValue, zeroValue, resultValue);
[+] 	return m_module->m_operatorMgr.binaryOperator(BinOpKind_Eq, opValue, zeroValue, resultValue);
[-] UnOp_LogNot::ptrOperator (
[+] UnOp_LogNot::ptrOperator(
[-] 	if (opValue.getType ()->getSize () == sizeof (void*))
[+] 	if (opValue.getType()->getSize() == sizeof(void*))
[-] 		return zeroCmpOperator (opValue, resultValue);
[+] 		return zeroCmpOperator(opValue, resultValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (opValue, 0, m_module->m_typeMgr.getStdType (StdType_BytePtr), &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(opValue, 0, m_module->m_typeMgr.getStdType(StdType_BytePtr), &ptrValue);
[-] 	return zeroCmpOperator (ptrValue, resultValue);
[+] 	return zeroCmpOperator(ptrValue, resultValue);
[-] UnOp_LogNot::variantOperator (
[+] UnOp_LogNot::variantOperator(
[-] 		m_module->m_operatorMgr.castOperator (opValue, TypeKind_Bool, &boolValue) &&
[+] 		m_module->m_operatorMgr.castOperator(opValue, TypeKind_Bool, &boolValue) &&
[-] 		zeroCmpOperator (boolValue, resultValue);
[+] 		zeroCmpOperator(boolValue, resultValue);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Ptr.cpp
----------------------
[-] UnOp_Addr::getResultType (const Value& opValue)
[+] UnOp_Addr::getResultType(const Value& opValue)
[-] 	} t = { opValue.getType () };
[+] 	} t = { opValue.getType() };
[-] 	TypeKind opTypeKind = t.m_type->getTypeKind ();
[+] 	TypeKind opTypeKind = t.m_type->getTypeKind();
[-] 	switch (opTypeKind)
[+] 	switch(opTypeKind)
[-] 		return t.m_dataPtrType->getTargetType ()->getDataPtrType (
[+] 		return t.m_dataPtrType->getTargetType()->getDataPtrType(
[-] 			t.m_dataPtrType->getPtrTypeKind (),
[+] 			t.m_dataPtrType->getPtrTypeKind(),
[-] 			t.m_dataPtrType->getFlags ()
[+] 			t.m_dataPtrType->getFlags()
[-] 		return t.m_classPtrType->getTargetType ()->getClassPtrType (
[+] 		return t.m_classPtrType->getTargetType()->getClassPtrType(
[-] 			t.m_classPtrType->getPtrTypeKind (),
[+] 			t.m_classPtrType->getPtrTypeKind(),
[-] 			t.m_classPtrType->getFlags ()
[+] 			t.m_classPtrType->getFlags()
[-] 		return t.m_functionPtrType->getTargetType ()->getFunctionPtrType (
[+] 		return t.m_functionPtrType->getTargetType()->getFunctionPtrType(
[-] 			t.m_functionPtrType->getPtrTypeKind (),
[+] 			t.m_functionPtrType->getPtrTypeKind(),
[-] 			t.m_functionPtrType->getFlags ()
[+] 			t.m_functionPtrType->getFlags()
[-] 		return t.m_propertyPtrType->getTargetType ()->getPropertyPtrType (
[+] 		return t.m_propertyPtrType->getTargetType()->getPropertyPtrType(
[-] 			t.m_propertyPtrType->getPtrTypeKind (),
[+] 			t.m_propertyPtrType->getPtrTypeKind(),
[-] 			t.m_propertyPtrType->getFlags ()
[+] 			t.m_propertyPtrType->getFlags()
[-] 		err::setFormatStringError ("can only apply unary '&' to a reference");
[+] 		err::setFormatStringError("can only apply unary '&' to a reference");
[-] UnOp_Addr::op (
[+] UnOp_Addr::op(
[-] 	Type* resultType = getResultType (opValue);
[+] 	Type* resultType = getResultType(opValue);
[-] 	resultValue->overrideType (opValue, resultType);
[+] 	resultValue->overrideType(opValue, resultType);
[-] UnOp_Indir::getResultType (const Value& opValue)
[+] UnOp_Indir::getResultType(const Value& opValue)
[-] 	} t = { opValue.getType () };
[+] 	} t = { opValue.getType() };
[-] 	TypeKind opTypeKind = t.m_type->getTypeKind ();
[+] 	TypeKind opTypeKind = t.m_type->getTypeKind();
[-] 	switch (opTypeKind)
[+] 	switch(opTypeKind)
[-] 		return t.m_dataPtrType->getTargetType ()->getDataPtrType (
[+] 		return t.m_dataPtrType->getTargetType()->getDataPtrType(
[-] 			t.m_dataPtrType->getPtrTypeKind (),
[+] 			t.m_dataPtrType->getPtrTypeKind(),
[-] 			t.m_dataPtrType->getFlags ()
[+] 			t.m_dataPtrType->getFlags()
[-] 		return t.m_classPtrType->getTargetType ()->getClassPtrType (
[+] 		return t.m_classPtrType->getTargetType()->getClassPtrType(
[-] 			t.m_classPtrType->getPtrTypeKind (),
[+] 			t.m_classPtrType->getPtrTypeKind(),
[-] 			t.m_classPtrType->getFlags ()
[+] 			t.m_classPtrType->getFlags()
[-] 		return t.m_functionPtrType->getTargetType ()->getFunctionPtrType (
[+] 		return t.m_functionPtrType->getTargetType()->getFunctionPtrType(
[-] 			t.m_functionPtrType->getPtrTypeKind (),
[+] 			t.m_functionPtrType->getPtrTypeKind(),
[-] 			t.m_functionPtrType->getFlags ()
[+] 			t.m_functionPtrType->getFlags()
[-] 		return t.m_propertyPtrType->getTargetType ()->getPropertyPtrType (
[+] 		return t.m_propertyPtrType->getTargetType()->getPropertyPtrType(
[-] 			t.m_propertyPtrType->getPtrTypeKind (),
[+] 			t.m_propertyPtrType->getPtrTypeKind(),
[-] 			t.m_propertyPtrType->getFlags ()
[+] 			t.m_propertyPtrType->getFlags()
[-] 		err::setFormatStringError ("can only apply unary '*' to a pointer");
[+] 		err::setFormatStringError("can only apply unary '*' to a pointer");
[-] UnOp_Indir::op (
[+] UnOp_Indir::op(
[-] 	Type* resultType = getResultType (opValue);
[+] 	Type* resultType = getResultType(opValue);
[-] 	ASSERT (resultType->getTypeKindFlags () & TypeKindFlag_Ref);
[+] 	ASSERT(resultType->getTypeKindFlags() & TypeKindFlag_Ref);
[-] 	resultValue->overrideType (opValue, resultType);
[+] 	resultValue->overrideType(opValue, resultType);
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp.h
----------------------
[-] 	BinaryOperator ();
[+] 	BinaryOperator();
[-] 	getModule ()
[+] 	getModule()
[-] 	getOpKind ()
[+] 	getOpKind()
[-] 	getOpFlags1 ()
[+] 	getOpFlags1()
[-] 	getOpFlags2 ()
[+] 	getOpFlags2()
[-] 	getResultType (
[+] 	getResultType(
[-] 	getResultType (
[+] 	getResultType(
[-] 	op (
[+] 	op(
[-] 	setOperatorError (
[+] 	setOperatorError(
[-] 		return err::setFormatStringError (
[+] 		return err::setFormatStringError(
[-] 			getBinOpKindString (m_opKind),
[+] 			getBinOpKindString(m_opKind),
[-] 			opType1->getTypeString ().sz (),
[+] 			opType1->getTypeString().sz(),
[-] 			opType2->getTypeString ().sz ()
[+] 			opType2->getTypeString().sz()
[-] 	setOperatorError (
[+] 	setOperatorError(
[-] 		return setOperatorError (opValue1.getType (), opValue2.getType ());
[+] 		return setOperatorError(opValue1.getType(), opValue2.getType());
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Arithmetic.h
----------------------
[-] 	getResultType (
[+] 	getResultType(
[-] 		return getArithmeticResultType (opValue1, opValue2);
[+] 		return getArithmeticResultType(opValue1, opValue2);
[-] 	op (
[+] 	op(
[-] 		Type* type = getArithmeticResultType (rawOpValue1, rawOpValue2);
[+] 		Type* type = getArithmeticResultType(rawOpValue1, rawOpValue2);
[-] 			castOperator (m_module, rawOpValue1, type, &opValue1) &&
[+] 			castOperator(m_module, rawOpValue1, type, &opValue1) &&
[-] 			castOperator (m_module, rawOpValue2, type, &opValue2);
[+] 			castOperator(m_module, rawOpValue2, type, &opValue2);
[-] 		if (opValue1.getValueKind () == ValueKind_Const && opValue2.getValueKind () == ValueKind_Const)
[+] 		if (opValue1.getValueKind() == ValueKind_Const && opValue2.getValueKind() == ValueKind_Const)
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				resultValue->setConstInt32 (
[+] 				resultValue->setConstInt32(
[-] 					T::constOpInt32 (
[+] 					T::constOpInt32(
[-] 						opValue1.getInt32 (),
[+] 						opValue1.getInt32(),
[-] 						opValue2.getInt32 (),
[+] 						opValue2.getInt32(),
[-] 						(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 						(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				resultValue->setConstInt64 (
[+] 				resultValue->setConstInt64(
[-] 					T::constOpInt64 (
[+] 					T::constOpInt64(
[-] 						opValue1.getInt64 (),
[+] 						opValue1.getInt64(),
[-] 						opValue2.getInt64 (),
[+] 						opValue2.getInt64(),
[-] 						(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 						(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				resultValue->setConstFloat (T::constOpFp32 (opValue1.getFloat (), opValue2.getFloat ()), m_module);
[+] 				resultValue->setConstFloat(T::constOpFp32(opValue1.getFloat(), opValue2.getFloat()), m_module);
[-] 				resultValue->setConstDouble (T::constOpFp64 (opValue1.getDouble (), opValue2.getDouble ()), m_module);
[+] 				resultValue->setConstDouble(T::constOpFp64(opValue1.getDouble(), opValue2.getDouble()), m_module);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				static_cast <T*> (this)->llvmOpInt (
[+] 				static_cast<T*> (this)->llvmOpInt(
[-] 					(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 					(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				static_cast <T*> (this)->llvmOpFp (
[+] 				static_cast<T*> (this)->llvmOpFp(
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 	getArithmeticResultType (
[+] 	getArithmeticResultType(
[-] 		Type* type = getArithmeticOperatorResultType (opValue1, opValue2);
[+] 		Type* type = getArithmeticOperatorResultType(opValue1, opValue2);
[-] 		if (!type || T::isIntegerOnly && !(type->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 		if (!type || T::isIntegerOnly && !(type->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 			setOperatorError (opValue1, opValue2);
[+] 			setOperatorError(opValue1, opValue2);
[-] class BinOp_IntegerOnly: public BinOp_Arithmetic <T>
[+] class BinOp_IntegerOnly: public BinOp_Arithmetic<T>
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] class BinOp_Add: public BinOp_Arithmetic <BinOp_Add>
[+] class BinOp_Add: public BinOp_Arithmetic<BinOp_Add>
[-] 	BinOp_Add ()
[+] 	BinOp_Add()
[-] 	op (
[+] 	op(
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Sub: public BinOp_Arithmetic <BinOp_Sub>
[+] class BinOp_Sub: public BinOp_Arithmetic<BinOp_Sub>
[-] 	BinOp_Sub ()
[+] 	BinOp_Sub()
[-] 	op (
[+] 	op(
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Mul: public BinOp_Arithmetic <BinOp_Mul>
[+] class BinOp_Mul: public BinOp_Arithmetic<BinOp_Mul>
[-] 	BinOp_Mul ()
[+] 	BinOp_Mul()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Div: public BinOp_Arithmetic <BinOp_Div>
[+] class BinOp_Div: public BinOp_Arithmetic<BinOp_Div>
[-] 	BinOp_Div ()
[+] 	BinOp_Div()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 / (uint32_t) opValue2 : opValue1 / opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 / (uint32_t)opValue2 : opValue1 / opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 / (uint64_t) opValue2 : opValue1 / opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 / (uint64_t)opValue2 : opValue1 / opValue2;
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Mod: public BinOp_IntegerOnly <BinOp_Mod>
[+] class BinOp_Mod: public BinOp_IntegerOnly<BinOp_Mod>
[-] 	BinOp_Mod ()
[+] 	BinOp_Mod()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 % (uint32_t) opValue2 : opValue1 % opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 % (uint32_t)opValue2 : opValue1 % opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 % (uint64_t) opValue2 : opValue1 % opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 % (uint64_t)opValue2 : opValue1 % opValue2;
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] class BinOp_Shl: public BinOp_IntegerOnly <BinOp_Shl>
[+] class BinOp_Shl: public BinOp_IntegerOnly<BinOp_Shl>
[-] 	BinOp_Shl ()
[+] 	BinOp_Shl()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] class BinOp_Shr: public BinOp_IntegerOnly <BinOp_Shr>
[+] class BinOp_Shr: public BinOp_IntegerOnly<BinOp_Shr>
[-] 	BinOp_Shr ()
[+] 	BinOp_Shr()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] class BinOp_BwAnd: public BinOp_IntegerOnly <BinOp_BwAnd>
[+] class BinOp_BwAnd: public BinOp_IntegerOnly<BinOp_BwAnd>
[-] 	BinOp_BwAnd ();
[+] 	BinOp_BwAnd();
[-] 	getResultType (
[+] 	getResultType(
[-] 			isBitFlagEnumType (opValue1.getType ()) ? opValue1.getType () :
[+] 			isBitFlagEnumType(opValue1.getType()) ? opValue1.getType() :
[-] 			isBitFlagEnumType (opValue2.getType ()) ? opValue2.getType () :
[+] 			isBitFlagEnumType(opValue2.getType()) ? opValue2.getType() :
[-] 			getArithmeticResultType (opValue1, opValue2);
[+] 			getArithmeticResultType(opValue1, opValue2);
[-] 	op (
[+] 	op(
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] isBitFlagEnumOpType (
[+] isBitFlagEnumOpType(
[-] 	return opValue1.getType () == opValue2.getType () && isBitFlagEnumType (opValue1.getType ());
[+] 	return opValue1.getType() == opValue2.getType() && isBitFlagEnumType(opValue1.getType());
[-] class BinOp_BwOr: public BinOp_IntegerOnly <BinOp_BwOr>
[+] class BinOp_BwOr: public BinOp_IntegerOnly<BinOp_BwOr>
[-] 	BinOp_BwOr ();
[+] 	BinOp_BwOr();
[-] 	getResultType (
[+] 	getResultType(
[-] 		return isBitFlagEnumOpType (opValue1, opValue2) ?
[+] 		return isBitFlagEnumOpType(opValue1, opValue2) ?
[-] 			opValue1.getType () :
[+] 			opValue1.getType() :
[-] 			getArithmeticResultType (opValue1, opValue2);
[+] 			getArithmeticResultType(opValue1, opValue2);
[-] 	op (
[+] 	op(
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] class BinOp_BwXor: public BinOp_IntegerOnly <BinOp_BwXor>
[+] class BinOp_BwXor: public BinOp_IntegerOnly<BinOp_BwXor>
[-] 	BinOp_BwXor ();
[+] 	BinOp_BwXor();
[-] 	getResultType (
[+] 	getResultType(
[-] 		return isBitFlagEnumOpType (opValue1, opValue2) ?
[+] 		return isBitFlagEnumOpType(opValue1, opValue2) ?
[-] 			opValue1.getType () :
[+] 			opValue1.getType() :
[-] 			getArithmeticResultType (opValue1, opValue2);
[+] 			getArithmeticResultType(opValue1, opValue2);
[-] 	op (
[+] 	op(
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
----------------------
27/02/2019 18:02:12 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Assign.h
----------------------
[-] 	BinOp_Assign ()
[+] 	BinOp_Assign()
[-] 	getResultType (
[+] 	getResultType(
[-] 		return opValue1.getType ();
[+] 		return opValue1.getType();
[-] 	op (
[+] 	op(
[-] 	BinOp_OpAssign ()
[+] 	BinOp_OpAssign()
[-] 	getResultType (
[+] 	getResultType(
[-] 		return opValue1.getType ();
[+] 		return opValue1.getType();
[-] 	op (
[+] 	op(
[-] 	BinOp_RefAssign ()
[+] 	BinOp_RefAssign()
[-] 	getResultType (
[+] 	getResultType(
[-] 		err::setFormatStringError ("'%s' has no overloaded ':=' operator", opValue1.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no overloaded ':=' operator", opValue1.getType ()->getTypeString ().sz ());
[-] 	op (
[+] 	op(
[-] 		err::setFormatStringError ("'%s' has no overloaded ':=' operator", opValue1.getType ()->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no overloaded ':=' operator", opValue1.getType ()->getTypeString ().sz ());
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_At.h
----------------------
[-] 	BinOp_At ()
[+] 	BinOp_At()
[-] 	getResultType (
[+] 	getResultType(
[-] 	op (
[+] 	op(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Cmp.h
----------------------
[-] getPtrCmpOperatorOperandType (
[+] getPtrCmpOperatorOperandType(
[-] 	getResultType (
[+] 	getResultType(
[-] 		return getSimpleType (TypeKind_Bool, m_module);
[+] 		return getSimpleType(TypeKind_Bool, m_module);
[-] 	op (
[+] 	op(
[-] 		if ((rawOpValue1.getType ()->getTypeKindFlags () & TypeKindFlag_Ptr) ||
[+] 		if ((rawOpValue1.getType()->getTypeKindFlags() & TypeKindFlag_Ptr) ||
[-] 			(rawOpValue2.getType ()->getTypeKindFlags () & TypeKindFlag_Ptr))
[+] 			(rawOpValue2.getType()->getTypeKindFlags() & TypeKindFlag_Ptr))
[-] 			type = getPtrCmpOperatorOperandType (rawOpValue1, rawOpValue2);
[+] 			type = getPtrCmpOperatorOperandType(rawOpValue1, rawOpValue2);
[-] 			type = getArithmeticOperatorResultType (rawOpValue1, rawOpValue2);
[+] 			type = getArithmeticOperatorResultType(rawOpValue1, rawOpValue2);
[-] 			setOperatorError (rawOpValue1, rawOpValue2);
[+] 			setOperatorError(rawOpValue1, rawOpValue2);
[-] 			castOperator (m_module, rawOpValue1, type, &opValue1) &&
[+] 			castOperator(m_module, rawOpValue1, type, &opValue1) &&
[-] 			castOperator (m_module, rawOpValue2, type, &opValue2);
[+] 			castOperator(m_module, rawOpValue2, type, &opValue2);
[-] 		if (opValue1.getValueKind () == ValueKind_Const && opValue2.getValueKind () == ValueKind_Const)
[+] 		if (opValue1.getValueKind() == ValueKind_Const && opValue2.getValueKind() == ValueKind_Const)
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				resultValue->setConstBool (
[+] 				resultValue->setConstBool(
[-] 					T::constOpInt32 (
[+] 					T::constOpInt32(
[-] 						opValue1.getInt32 (),
[+] 						opValue1.getInt32(),
[-] 						opValue2.getInt32 (),
[+] 						opValue2.getInt32(),
[-] 						(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 						(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				resultValue->setConstBool (
[+] 				resultValue->setConstBool(
[-] 					T::constOpInt32 (
[+] 					T::constOpInt32(
[-] 						opValue1.getInt32 (),
[+] 						opValue1.getInt32(),
[-] 						opValue2.getInt32 (),
[+] 						opValue2.getInt32(),
[-] 						(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 						(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				resultValue->setConstBool (T::constOpFp32 (opValue1.getFloat (), opValue2.getFloat ()), m_module);
[+] 				resultValue->setConstBool(T::constOpFp32(opValue1.getFloat(), opValue2.getFloat()), m_module);
[-] 				resultValue->setConstBool (T::constOpFp64 (opValue1.getDouble (), opValue2.getDouble ()), m_module);
[+] 				resultValue->setConstBool(T::constOpFp64(opValue1.getDouble(), opValue2.getDouble()), m_module);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				static_cast <T*> (this)->llvmOpInt (
[+] 				static_cast<T*> (this)->llvmOpInt(
[-] 					(type->getTypeKindFlags () & TypeKindFlag_Unsigned) != 0
[+] 					(type->getTypeKindFlags() & TypeKindFlag_Unsigned) != 0
[-] 				static_cast <T*> (this)->llvmOpFp (
[+] 				static_cast<T*> (this)->llvmOpFp(
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] class BinOp_Eq: public BinOp_Cmp <BinOp_Eq>
[+] class BinOp_Eq: public BinOp_Cmp<BinOp_Eq>
[-] 	BinOp_Eq ()
[+] 	BinOp_Eq()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Ne: public BinOp_Cmp <BinOp_Ne>
[+] class BinOp_Ne: public BinOp_Cmp<BinOp_Ne>
[-] 	BinOp_Ne ()
[+] 	BinOp_Ne()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Lt: public BinOp_Cmp <BinOp_Lt>
[+] class BinOp_Lt: public BinOp_Cmp<BinOp_Lt>
[-] 	BinOp_Lt ()
[+] 	BinOp_Lt()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 < (uint32_t) opValue2 : opValue1 < opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 < (uint32_t)opValue2 : opValue1 < opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 < (uint64_t) opValue2 : opValue1 < opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 < (uint64_t)opValue2 : opValue1 < opValue2;
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Le: public BinOp_Cmp <BinOp_Le>
[+] class BinOp_Le: public BinOp_Cmp<BinOp_Le>
[-] 	BinOp_Le ()
[+] 	BinOp_Le()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 <= (uint32_t) opValue2 : opValue1 <= opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 <= (uint32_t)opValue2 : opValue1 <= opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 <= (uint64_t) opValue2 : opValue1 <= opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 <= (uint64_t)opValue2 : opValue1 <= opValue2;
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Gt: public BinOp_Cmp <BinOp_Gt>
[+] class BinOp_Gt: public BinOp_Cmp<BinOp_Gt>
[-] 	BinOp_Gt ()
[+] 	BinOp_Gt()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 > (uint32_t) opValue2 : opValue1 > opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 > (uint32_t)opValue2 : opValue1 > opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 > (uint64_t) opValue2 : opValue1 > opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 > (uint64_t)opValue2 : opValue1 > opValue2;
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class BinOp_Ge: public BinOp_Cmp <BinOp_Ge>
[+] class BinOp_Ge: public BinOp_Cmp<BinOp_Ge>
[-] 	BinOp_Ge ()
[+] 	BinOp_Ge()
[-] 	constOpInt32 (
[+] 	constOpInt32(
[-] 		return isUnsigned ? (uint32_t) opValue1 >= (uint32_t) opValue2 : opValue1 >= opValue2;
[+] 		return isUnsigned ? (uint32_t)opValue1 >= (uint32_t)opValue2 : opValue1 >= opValue2;
[-] 	constOpInt64 (
[+] 	constOpInt64(
[-] 		return isUnsigned ? (uint64_t) opValue1 >= (uint64_t) opValue2 : opValue1 >= opValue2;
[+] 		return isUnsigned ? (uint64_t)opValue1 >= (uint64_t)opValue2 : opValue1 >= opValue2;
[-] 	constOpFp32 (
[+] 	constOpFp32(
[-] 	constOpFp64 (
[+] 	constOpFp64(
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Idx.h
----------------------
[-] 	BinOp_Idx ()
[+] 	BinOp_Idx()
[-] 	getResultType (
[+] 	getResultType(
[-] 	op (
[+] 	op(
[-] 	getPropertyIndexResultType (
[+] 	getPropertyIndexResultType(
[-] 	arrayIndexOperator (
[+] 	arrayIndexOperator(
[-] 	variantIndexOperator (
[+] 	variantIndexOperator(
[-] 	propertyIndexOperator (
[+] 	propertyIndexOperator(
[-] 	getDerivableTypeIndexResultType (
[+] 	getDerivableTypeIndexResultType(
[-] 	derivableTypeIndexOperator (
[+] 	derivableTypeIndexOperator(
[-] 	getDerivableTypeIndexerProperty (
[+] 	getDerivableTypeIndexerProperty(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_BinOp_Logic.h
----------------------
[-] 	BinOp_LogAnd ()
[+] 	BinOp_LogAnd()
[-] 	getResultType (
[+] 	getResultType(
[-] 	op (
[+] 	op(
[-] 		ASSERT (false); // special handling in COperator::LogicalOrOperator
[+] 		ASSERT(false); // special handling in COperator::LogicalOrOperator
[-] 	BinOp_LogOr ()
[+] 	BinOp_LogOr()
[-] 	getResultType (
[+] 	getResultType(
[-] 	op (
[+] 	op(
[-] 		ASSERT (false); // special handling in COperator::LogicalOrOperator
[+] 		ASSERT(false); // special handling in COperator::LogicalOrOperator
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp.h
----------------------
[-] setCastError (
[+] setCastError(
[-] setUnsafeCastError (
[+] setUnsafeCastError(
[-] castOperator (
[+] castOperator(
[-] castOperator (
[+] castOperator(
[-] 	return castOperator (module, *opValue, type, opValue);
[+] 	return castOperator(module, *opValue, type, opValue);
[-] 	CastOperator ();
[+] 	CastOperator();
[-] 	getModule ()
[+] 	getModule()
[-] 	getOpFlags ()
[+] 	getOpFlags()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	cast (
[+] 	cast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 		setCastError (opValue, type);
[+] 		setCastError(opValue, type);
[-] 	getCastKind (
[+] 	getCastKind(
[-] 		return opValue.getType ()->cmp (type) == 0 ? CastKind_Identitiy : CastKind_Implicit;
[+] 		return opValue.getType()->cmp(type) == 0 ? CastKind_Identitiy : CastKind_Implicit;
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 		resultValue->setVoid (m_module);
[+] 		resultValue->setVoid(m_module);
[-] 	getCastKind (
[+] 	getCastKind(
[-] 		return opValue.getType ()->cmp (type) == 0 ? CastKind_Identitiy : CastKind_Implicit;
[+] 		return opValue.getType()->cmp(type) == 0 ? CastKind_Identitiy : CastKind_Implicit;
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastOperator (
[+] 	getCastOperator(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastOperators (
[+] 	getCastOperators(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Array.h
----------------------
[-] 	Cast_Array ()
[+] 	Cast_Array()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Bool.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	Cast_Bool ()
[+] 	Cast_Bool()
[-] 	getCastOperator (
[+] 	getCastOperator(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_ClassPtr.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_DataPtr.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	Cast_DataPtr_Base ()
[+] 	Cast_DataPtr_Base()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	getOffset (
[+] 	getOffset(
[-] 	getOffsetUnsafePtrValue (
[+] 	getOffsetUnsafePtrValue(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 		ASSERT (false); // there are no lean pointer constants
[+] 		ASSERT(false); // there are no lean pointer constants
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	CastOperator* m_operatorTable [DataPtrTypeKind__Count] [DataPtrTypeKind__Count];
[+] 	CastOperator* m_operatorTable[DataPtrTypeKind__Count] [DataPtrTypeKind__Count];
[-] 	Cast_DataPtr ();
[+] 	Cast_DataPtr();
[-] 	getCastOperator (
[+] 	getCastOperator(
[-] 	Cast_DataRef ()
[+] 	Cast_DataRef()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Fp.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 		*(float*) dst = (float) *(double*) opValue.getConstData ();
[+] 		*(float*)dst = (float)*(double*)opValue.getConstData();
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 		*(double*) dst = *(float*) opValue.getConstData ();
[+] 		*(double*)dst = *(float*)opValue.getConstData();
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 		return opValue.getType ()->getSize () < type->getSize () ? CastKind_ImplicitCrossFamily : CastKind_Explicit;
[+] 		return opValue.getType()->getSize() < type->getSize() ? CastKind_ImplicitCrossFamily : CastKind_Explicit;
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	constCast_Fp32 (
[+] 	constCast_Fp32(
[-] 	constCast_Fp64 (
[+] 	constCast_Fp64(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 		return opValue.getType ()->getSize () < type->getSize () ? CastKind_ImplicitCrossFamily : CastKind_Explicit;
[+] 		return opValue.getType()->getSize() < type->getSize() ? CastKind_ImplicitCrossFamily : CastKind_Explicit;
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	constCast_Fp32 (
[+] 	constCast_Fp32(
[-] 	constCast_Fp64 (
[+] 	constCast_Fp64(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	getCastOperator (
[+] 	getCastOperator(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_FunctionPtr.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast_NoThunkSimpleClosure (
[+] 	llvmCast_NoThunkSimpleClosure(
[-] 	llvmCast_DirectThunkNoClosure (
[+] 	llvmCast_DirectThunkNoClosure(
[-] 	llvmCast_DirectThunkSimpleClosure (
[+] 	llvmCast_DirectThunkSimpleClosure(
[-] 	llvmCast_FullClosure (
[+] 	llvmCast_FullClosure(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	CastOperator* m_operatorTable [FunctionPtrTypeKind__Count] [FunctionPtrTypeKind__Count];
[+] 	CastOperator* m_operatorTable[FunctionPtrTypeKind__Count] [FunctionPtrTypeKind__Count];
[-] 	Cast_FunctionPtr ();
[+] 	Cast_FunctionPtr();
[-] 	getCastOperator (
[+] 	getCastOperator(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Int.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	constCast (
[+] 	constCast(
[-] 	constCast (
[+] 	constCast(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	Cast_Enum ()
[+] 	Cast_Enum()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	getCastOperators (
[+] 	getCastOperators(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 		ASSERT (opValue.getType ()->getSize () >= sizeof (intptr_t));
[+] 		ASSERT(opValue.getType()->getSize() >= sizeof(intptr_t));
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastOperator (
[+] 	getCastOperator(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_PropertyPtr.h
----------------------
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast_DirectThunk (
[+] 	llvmCast_DirectThunk(
[-] 	llvmCast_FullClosure (
[+] 	llvmCast_FullClosure(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast_NoThunkSimpleClosure (
[+] 	llvmCast_NoThunkSimpleClosure(
[-] 	llvmCast_DirectThunkNoClosure (
[+] 	llvmCast_DirectThunkNoClosure(
[-] 	llvmCast_DirectThunkSimpleClosure (
[+] 	llvmCast_DirectThunkSimpleClosure(
[-] 	llvmCast_FullClosure (
[+] 	llvmCast_FullClosure(
[-] 	createClosurePropertyPtr (
[+] 	createClosurePropertyPtr(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	CastOperator* m_operatorTable [PropertyPtrTypeKind__Count] [PropertyPtrTypeKind__Count];
[+] 	CastOperator* m_operatorTable[PropertyPtrTypeKind__Count] [PropertyPtrTypeKind__Count];
[-] 	Cast_PropertyPtr ();
[+] 	Cast_PropertyPtr();
[-] 	getCastOperator (
[+] 	getCastOperator(
[-] 	Cast_PropertyRef ()
[+] 	Cast_PropertyRef()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Struct.h
----------------------
[-] 	Cast_Struct ()
[+] 	Cast_Struct()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_CastOp_Variant.h
----------------------
[-] 	Cast_Variant ()
[+] 	Cast_Variant()
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	constCast (
[+] 	constCast(
[-] 	llvmCast (
[+] 	llvmCast(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_OperatorMgr.h
----------------------
[-] 	UnaryOperator* m_unaryOperatorTable [UnOpKind__Count];
[+] 	UnaryOperator* m_unaryOperatorTable[UnOpKind__Count];
[-] 	BinaryOperator* m_binaryOperatorTable [BinOpKind__Count];
[+] 	BinaryOperator* m_binaryOperatorTable[BinOpKind__Count];
[-] 	CastOperator* m_castOperatorTable [TypeKind__Count];
[+] 	CastOperator* m_castOperatorTable[TypeKind__Count];
[-] 	CastOperator* m_stdCastOperatorTable [StdCast__Count];
[+] 	CastOperator* m_stdCastOperatorTable[StdCast__Count];
[-] 	OperatorMgr ();
[+] 	OperatorMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	enterUnsafeRgn ()
[+] 	enterUnsafeRgn()
[-] 	leaveUnsafeRgn ()
[+] 	leaveUnsafeRgn()
[-] 	resetUnsafeRgn ()
[+] 	resetUnsafeRgn()
[-] 	isUnsafeRgn ()
[+] 	isUnsafeRgn()
[-] 	prepareOperandType (
[+] 	prepareOperandType(
[-] 	prepareOperandType (
[+] 	prepareOperandType(
[-] 		prepareOperandType (*opValue, opValue, opFlags);
[+] 		prepareOperandType(*opValue, opValue, opFlags);
[-] 	prepareOperandType (
[+] 	prepareOperandType(
[-] 	prepareOperand (
[+] 	prepareOperand(
[-] 	prepareOperand (
[+] 	prepareOperand(
[-] 		return prepareOperand (*opValue, opValue, opFlags);
[+] 		return prepareOperand(*opValue, opValue, opFlags);
[-] 	prepareArgumentReturnValue (Value* value);
[+] 	prepareArgumentReturnValue(Value* value);
[-] 	prepareDataPtr (
[+] 	prepareDataPtr(
[-] 	prepareDataPtr (Value* value)
[+] 	prepareDataPtr(Value* value)
[-] 		return prepareDataPtr (*value, value);
[+] 		return prepareDataPtr(*value, value);
[-] 	prepareArrayRef (
[+] 	prepareArrayRef(
[-] 	prepareArrayRef (Value* value)
[+] 	prepareArrayRef(Value* value)
[-] 		prepareArrayRef (*value, value);
[+] 		prepareArrayRef(*value, value);
[-] 	getUnaryOperatorResultType (
[+] 	getUnaryOperatorResultType(
[-] 	getUnaryOperatorResultType (
[+] 	getUnaryOperatorResultType(
[-] 	getUnaryOperatorResultType (
[+] 	getUnaryOperatorResultType(
[-] 		return getUnaryOperatorResultType (opKind, *value, value);
[+] 		return getUnaryOperatorResultType(opKind, *value, value);
[-] 	unaryOperator (
[+] 	unaryOperator(
[-] 	unaryOperator (
[+] 	unaryOperator(
[-] 		return unaryOperator (opKind, *value, value);
[+] 		return unaryOperator(opKind, *value, value);
[-] 	getBinaryOperatorResultType (
[+] 	getBinaryOperatorResultType(
[-] 	getBinaryOperatorResultType (
[+] 	getBinaryOperatorResultType(
[-] 	getBinaryOperatorResultType (
[+] 	getBinaryOperatorResultType(
[-] 		return getBinaryOperatorResultType (opKind, *value, opValue2, value);
[+] 		return getBinaryOperatorResultType(opKind, *value, opValue2, value);
[-] 	binaryOperator (
[+] 	binaryOperator(
[-] 	logicalOrOperator (
[+] 	logicalOrOperator(
[-] 	logicalAndOperator (
[+] 	logicalAndOperator(
[-] 	binaryOperator (
[+] 	binaryOperator(
[-] 		return binaryOperator (opKind, *value, opValue2, value);
[+] 		return binaryOperator(opKind, *value, opValue2, value);
[-] 	logicalOrOperator (
[+] 	logicalOrOperator(
[-] 		return logicalOrOperator (opBlock1, opBlock2, *value, opValue2, value);
[+] 		return logicalOrOperator(opBlock1, opBlock2, *value, opValue2, value);
[-] 	logicalAndOperator (
[+] 	logicalAndOperator(
[-] 		return logicalAndOperator (opBlock1, opBlock2, *value, opValue2, value);
[+] 		return logicalAndOperator(opBlock1, opBlock2, *value, opValue2, value);
[-] 	getConditionalOperatorResultType (
[+] 	getConditionalOperatorResultType(
[-] 	getConditionalOperatorResultType (
[+] 	getConditionalOperatorResultType(
[-] 	conditionalOperator (
[+] 	conditionalOperator(
[-] 	forceCast (
[+] 	forceCast(
[-] 	forceCast (
[+] 	forceCast(
[-] 		forceCast (*value, type, value);
[+] 		forceCast(*value, type, value);
[-] 	getStdCastOperator (StdCast castKind)
[+] 	getStdCastOperator(StdCast castKind)
[-] 		ASSERT ((size_t) castKind < StdCast__Count);
[+] 		ASSERT((size_t)castKind < StdCast__Count);
[-] 		return m_stdCastOperatorTable [castKind];
[+] 		return m_stdCastOperatorTable[castKind];
[-] 	getCastKind (
[+] 	getCastKind(
[-] 	checkCastKind (
[+] 	checkCastKind(
[-] 	getArgCastKind (
[+] 	getArgCastKind(
[-] 	getArgCastKind (
[+] 	getArgCastKind(
[-] 	getArgCastKind (
[+] 	getArgCastKind(
[-] 		const sl::Array <FunctionArg*>& argArray
[+] 		const sl::Array<FunctionArg*>& argArray
[-] 		return getArgCastKind (functionType, argArray, argArray.getCount ());
[+] 		return getArgCastKind(functionType, argArray, argArray.getCount());
[-] 	getArgCastKind (
[+] 	getArgCastKind(
[-] 		const sl::ConstBoxList <Value>& argValueList
[+] 		const sl::ConstBoxList<Value>& argValueList
[-] 	getFunctionCastKind (
[+] 	getFunctionCastKind(
[-] 	getPropertyCastKind (
[+] 	getPropertyCastKind(
[-] 	castOperator (
[+] 	castOperator(
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (dynamism, *value, type, value);
[+] 		return castOperator(dynamism, *value, type, value);
[-] 	castOperator (
[+] 	castOperator(
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (dynamism, *value, typeKind, value);
[+] 		return castOperator(dynamism, *value, typeKind, value);
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (OperatorDynamism_Static, opValue, type, resultValue);
[+] 		return castOperator(OperatorDynamism_Static, opValue, type, resultValue);
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (OperatorDynamism_Static, *value, type, value);
[+] 		return castOperator(OperatorDynamism_Static, *value, type, value);
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (OperatorDynamism_Static, opValue, typeKind, resultValue);
[+] 		return castOperator(OperatorDynamism_Static, opValue, typeKind, resultValue);
[-] 	castOperator (
[+] 	castOperator(
[-] 		return castOperator (OperatorDynamism_Static, *value, typeKind, value);
[+] 		return castOperator(OperatorDynamism_Static, *value, typeKind, value);
[-] 	sizeofOperator (
[+] 	sizeofOperator(
[-] 	sizeofOperator (
[+] 	sizeofOperator(
[-] 		return sizeofOperator (dynamism, *value, value);
[+] 		return sizeofOperator(dynamism, *value, value);
[-] 	sizeofOperator (
[+] 	sizeofOperator(
[-] 		return sizeofOperator (OperatorDynamism_Static, opValue, resultValue);
[+] 		return sizeofOperator(OperatorDynamism_Static, opValue, resultValue);
[-] 	sizeofOperator (Value* value)
[+] 	sizeofOperator(Value* value)
[-] 		return sizeofOperator (OperatorDynamism_Static, *value, value);
[+] 		return sizeofOperator(OperatorDynamism_Static, *value, value);
[-] 	countofOperator (
[+] 	countofOperator(
[-] 	countofOperator (
[+] 	countofOperator(
[-] 		return countofOperator (dynamism, *value, value);
[+] 		return countofOperator(dynamism, *value, value);
[-] 	countofOperator (
[+] 	countofOperator(
[-] 		return countofOperator (OperatorDynamism_Static, opValue, resultValue);
[+] 		return countofOperator(OperatorDynamism_Static, opValue, resultValue);
[-] 	countofOperator (Value* value)
[+] 	countofOperator(Value* value)
[-] 		return countofOperator (OperatorDynamism_Static, *value, value);
[+] 		return countofOperator(OperatorDynamism_Static, *value, value);
[-] 	typeofOperator (
[+] 	typeofOperator(
[-] 	typeofOperator (
[+] 	typeofOperator(
[-] 		return typeofOperator (dynamism, *value, value);
[+] 		return typeofOperator(dynamism, *value, value);
[-] 	typeofOperator (
[+] 	typeofOperator(
[-] 		return typeofOperator (OperatorDynamism_Static, opValue, resultValue);
[+] 		return typeofOperator(OperatorDynamism_Static, opValue, resultValue);
[-] 	typeofOperator (Value* value)
[+] 	typeofOperator(Value* value)
[-] 		return typeofOperator (OperatorDynamism_Static, *value, value);
[+] 		return typeofOperator(OperatorDynamism_Static, *value, value);
[-] 	offsetofOperator (
[+] 	offsetofOperator(
[-] 	offsetofOperator (Value* value)
[+] 	offsetofOperator(Value* value)
[-] 		return offsetofOperator (*value, value);
[+] 		return offsetofOperator(*value, value);
[-] 	awaitOperator (
[+] 	awaitOperator(
[-] 	awaitOperator (Value* value)
[+] 	awaitOperator(Value* value)
[-] 		return awaitOperator (*value, value);
[+] 		return awaitOperator(*value, value);
[-] 	zeroInitialize (const Value& value);
[+] 	zeroInitialize(const Value& value);
[-] 	memSet (
[+] 	memSet(
[-] 	memCpy (
[+] 	memCpy(
[-] 	memCpy (
[+] 	memCpy(
[-] 		return memCpy (StdFunc_LlvmMemcpy, dstValue, srcValue, size, alignment, isVolatile);
[+] 		return memCpy(StdFunc_LlvmMemcpy, dstValue, srcValue, size, alignment, isVolatile);
[-] 	memMove (
[+] 	memMove(
[-] 		return memCpy (StdFunc_LlvmMemmove, dstValue, srcValue, size, alignment, isVolatile);
[+] 		return memCpy(StdFunc_LlvmMemmove, dstValue, srcValue, size, alignment, isVolatile);
[-] 	construct (
[+] 	construct(
[-] 		sl::BoxList <Value>* argValueList = NULL
[+] 		sl::BoxList<Value>* argValueList = NULL
[-] 	parseInitializer (
[+] 	parseInitializer(
[-] 		const sl::ConstBoxList <Token>& constructorTokenList,
[+] 		const sl::ConstBoxList<Token>& constructorTokenList,
[-] 		const sl::ConstBoxList <Token>& initializerTokenList
[+] 		const sl::ConstBoxList<Token>& initializerTokenList
[-] 	parseFunctionArgDefaultValue (
[+] 	parseFunctionArgDefaultValue(
[-] 		const sl::ConstBoxList <Token> tokenList,
[+] 		const sl::ConstBoxList<Token> tokenList,
[-] 	parseFunctionArgDefaultValue (
[+] 	parseFunctionArgDefaultValue(
[-] 		const sl::ConstBoxList <Token> tokenList,
[+] 		const sl::ConstBoxList<Token> tokenList,
[-] 	parseFunctionArgDefaultValue (
[+] 	parseFunctionArgDefaultValue(
[-] 		const sl::ConstBoxList <Token> tokenList,
[+] 		const sl::ConstBoxList<Token> tokenList,
[-] 		return closure && closure->isMemberClosure () ?
[+] 		return closure && closure->isMemberClosure() ?
[-] 			parseFunctionArgDefaultValue (decl, closure->getThisArgValue (), tokenList, resultValue) :
[+] 			parseFunctionArgDefaultValue(decl, closure->getThisArgValue(), tokenList, resultValue) :
[-] 			parseFunctionArgDefaultValue (decl, Value (), tokenList, resultValue);
[+] 			parseFunctionArgDefaultValue(decl, Value(), tokenList, resultValue);
[-] 	parseExpression (
[+] 	parseExpression(
[-] 		const sl::ConstBoxList <Token>& expressionTokenList,
[+] 		const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	parseExpression (
[+] 	parseExpression(
[-] 		const sl::ConstBoxList <Token>& expressionTokenList,
[+] 		const sl::ConstBoxList<Token>& expressionTokenList,
[-] 		return parseExpression (expressionTokenList, 0, resultValue);
[+] 		return parseExpression(expressionTokenList, 0, resultValue);
[-] 	parseConstExpression (
[+] 	parseConstExpression(
[-] 		const sl::ConstBoxList <Token>& expressionTokenList,
[+] 		const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	parseConstIntegerExpression (
[+] 	parseConstIntegerExpression(
[-] 		const sl::ConstBoxList <Token>& expressionTokenList,
[+] 		const sl::ConstBoxList<Token>& expressionTokenList,
[-] 	parseAutoSizeArrayInitializer (
[+] 	parseAutoSizeArrayInitializer(
[-] 		const sl::ConstBoxList <Token>& initializerTokenList
[+] 		const sl::ConstBoxList<Token>& initializerTokenList
[-] 	parseAutoSizeArrayLiteralInitializer (const sl::ConstBoxList <Token>& initializerTokenList);
[+] 	parseAutoSizeArrayLiteralInitializer(const sl::ConstBoxList<Token>& initializerTokenList);
[-] 	parseAutoSizeArrayCurlyInitializer (
[+] 	parseAutoSizeArrayCurlyInitializer(
[-] 		const sl::ConstBoxList <Token>& initializerTokenList
[+] 		const sl::ConstBoxList<Token>& initializerTokenList
[-] 	getNewOperatorResultType (Type* type)
[+] 	getNewOperatorResultType(Type* type)
[-] 		return type->getTypeKind () == TypeKind_Class ?
[+] 		return type->getTypeKind() == TypeKind_Class ?
[-] 			(Type*) ((ClassType*) type)->getClassPtrType () :
[+] 			(Type*)((ClassType*)type)->getClassPtrType() :
[-] 			type->getDataPtrType ();
[+] 			type->getDataPtrType();
[-] 	gcHeapAllocate (
[+] 	gcHeapAllocate(
[-] 	gcHeapAllocate (
[+] 	gcHeapAllocate(
[-] 		return gcHeapAllocate (type, Value (), resultValue);
[+] 		return gcHeapAllocate(type, Value(), resultValue);
[-] 	newOperator (
[+] 	newOperator(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	newOperator (
[+] 	newOperator(
[-] 		return newOperator (type, Value (), NULL, resultValue);
[+] 		return newOperator(type, Value(), NULL, resultValue);
[-] 	newOperator (
[+] 	newOperator(
[-] 		return newOperator (type, elementCountValue, NULL, resultValue);
[+] 		return newOperator(type, elementCountValue, NULL, resultValue);
[-] 	newOperator (
[+] 	newOperator(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 		return newOperator (type, Value (), argValueList, resultValue);
[+] 		return newOperator(type, Value(), argValueList, resultValue);
[-] 	createMemberClosure (
[+] 	createMemberClosure(
[-] 	getThisValue (
[+] 	getThisValue(
[-] 	getThisValueType (
[+] 	getThisValueType(
[-] 	memberOperator (
[+] 	memberOperator(
[-] 	memberOperator (
[+] 	memberOperator(
[-] 		return memberOperator (*value, index, value);
[+] 		return memberOperator(*value, index, value);
[-] 	getMemberOperatorResultType (
[+] 	getMemberOperatorResultType(
[-] 	getMemberOperatorResultType (
[+] 	getMemberOperatorResultType(
[-] 		return getMemberOperatorResultType (*value, name, value);
[+] 		return getMemberOperatorResultType(*value, name, value);
[-] 	memberOperator (
[+] 	memberOperator(
[-] 	memberOperator (
[+] 	memberOperator(
[-] 		return memberOperator (*value, name, value);
[+] 		return memberOperator(*value, name, value);
[-] 	callTraceFunction (
[+] 	callTraceFunction(
[-] 	traceBlock (BasicBlock* block);
[+] 	traceBlock(BasicBlock* block);
[-] 	getCallOperatorResultType (
[+] 	getCallOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 	getCallOperatorResultType (
[+] 	getCallOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	getCallOperatorResultType (
[+] 	getCallOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 		return getCallOperatorResultType (*value, argValueList, value);
[+] 		return getCallOperatorResultType(*value, argValueList, value);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 		return callOperator (*value, argValueList, value);
[+] 		return callOperator(*value, argValueList, value);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		return callOperator (opValue, &argValueList, resultValue);
[+] 		return callOperator(opValue, &argValueList, resultValue);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue);
[+] 		argValueList.insertTail(argValue);
[-] 		return callOperator (opValue, &argValueList, resultValue);
[+] 		return callOperator(opValue, &argValueList, resultValue);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue1);
[+] 		argValueList.insertTail(argValue1);
[-] 		argValueList.insertTail (argValue2);
[+] 		argValueList.insertTail(argValue2);
[-] 		return callOperator (opValue, &argValueList, resultValue);
[+] 		return callOperator(opValue, &argValueList, resultValue);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue1);
[+] 		argValueList.insertTail(argValue1);
[-] 		argValueList.insertTail (argValue2);
[+] 		argValueList.insertTail(argValue2);
[-] 		argValueList.insertTail (argValue3);
[+] 		argValueList.insertTail(argValue3);
[-] 		return callOperator (opValue, &argValueList, resultValue);
[+] 		return callOperator(opValue, &argValueList, resultValue);
[-] 	callOperator (
[+] 	callOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue1);
[+] 		argValueList.insertTail(argValue1);
[-] 		argValueList.insertTail (argValue2);
[+] 		argValueList.insertTail(argValue2);
[-] 		argValueList.insertTail (argValue3);
[+] 		argValueList.insertTail(argValue3);
[-] 		argValueList.insertTail (argValue4);
[+] 		argValueList.insertTail(argValue4);
[-] 		return callOperator (opValue, &argValueList, resultValue);
[+] 		return callOperator(opValue, &argValueList, resultValue);
[-] 	gcSafePoint ();
[+] 	gcSafePoint();
[-] 	checkStackOverflow ();
[+] 	checkStackOverflow();
[-] 	checkDivByZero (const Value& value);
[+] 	checkDivByZero(const Value& value);
[-] 	getClosureOperatorResultType (
[+] 	getClosureOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 	getClosureOperatorResultType (
[+] 	getClosureOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	getClosureOperatorResultType (
[+] 	getClosureOperatorResultType(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 		return getClosureOperatorResultType (*value,  argValueList, value);
[+] 		return getClosureOperatorResultType(*value,  argValueList, value);
[-] 	closureOperator (
[+] 	closureOperator(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	closureOperator (
[+] 	closureOperator(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 		return closureOperator (*value,  argValueList, value);
[+] 		return closureOperator(*value,  argValueList, value);
[-] 	closureOperator (
[+] 	closureOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		return closureOperator (opValue, &argValueList, resultValue);
[+] 		return closureOperator(opValue, &argValueList, resultValue);
[-] 	closureOperator (
[+] 	closureOperator(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue);
[+] 		argValueList.insertTail(argValue);
[-] 		return closureOperator (opValue, &argValueList, resultValue);
[+] 		return closureOperator(opValue, &argValueList, resultValue);
[-] 	closureOperator2 (
[+] 	closureOperator2(
[-] 		sl::BoxList <Value> argValueList;
[+] 		sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValue1);
[+] 		argValueList.insertTail(argValue1);
[-] 		argValueList.insertTail (argValue2);
[+] 		argValueList.insertTail(argValue2);
[-] 		return closureOperator (opValue, &argValueList, resultValue);
[+] 		return closureOperator(opValue, &argValueList, resultValue);
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 	getPropertyGetterType (const Value& opValue);
[+] 	getPropertyGetterType(const Value& opValue);
[-] 	getPropertyGetterType (
[+] 	getPropertyGetterType(
[-] 	getPropertyGetterType (Value* value)
[+] 	getPropertyGetterType(Value* value)
[-] 		return getPropertyGetterType (*value, value);
[+] 		return getPropertyGetterType(*value, value);
[-] 	getPropertyGetter (
[+] 	getPropertyGetter(
[-] 	getPropertyGetter (Value* value)
[+] 	getPropertyGetter(Value* value)
[-] 		return getPropertyGetter (*value, value);
[+] 		return getPropertyGetter(*value, value);
[-] 	getPropertySetterType (
[+] 	getPropertySetterType(
[-] 	getPropertySetterType (
[+] 	getPropertySetterType(
[-] 	getPropertySetterType (
[+] 	getPropertySetterType(
[-] 		return getPropertySetterType (*value, argValue, value);
[+] 		return getPropertySetterType(*value, argValue, value);
[-] 	getPropertySetter (
[+] 	getPropertySetter(
[-] 	getPropertySetter (
[+] 	getPropertySetter(
[-] 		return getPropertySetter (*value, argValue, value);
[+] 		return getPropertySetter(*value, argValue, value);
[-] 	getPropertySetterType (const Value& opValue)
[+] 	getPropertySetterType(const Value& opValue)
[-] 		return getPropertySetterType (opValue, Value ());
[+] 		return getPropertySetterType(opValue, Value());
[-] 	getPropertySetterType (
[+] 	getPropertySetterType(
[-] 		return getPropertySetterType (opValue, Value (), resultValue);
[+] 		return getPropertySetterType(opValue, Value(), resultValue);
[-] 	getPropertySetterType (Value* value)
[+] 	getPropertySetterType(Value* value)
[-] 		return getPropertySetterType (*value, Value (), value);
[+] 		return getPropertySetterType(*value, Value(), value);
[-] 	getPropertySetter (
[+] 	getPropertySetter(
[-] 		return getPropertySetter (opValue, Value (), resultValue);
[+] 		return getPropertySetter(opValue, Value(), resultValue);
[-] 	getPropertySetter (Value* value)
[+] 	getPropertySetter(Value* value)
[-] 		return getPropertySetter (*value, Value (), value);
[+] 		return getPropertySetter(*value, Value(), value);
[-] 	getPropertyBinderType (const Value& opValue);
[+] 	getPropertyBinderType(const Value& opValue);
[-] 	getPropertyBinderType (
[+] 	getPropertyBinderType(
[-] 	getPropertyBinderType (Value* value)
[+] 	getPropertyBinderType(Value* value)
[-] 		return getPropertyBinderType (*value, value);
[+] 		return getPropertyBinderType(*value, value);
[-] 	getPropertyBinder (
[+] 	getPropertyBinder(
[-] 	getPropertyBinder (Value* value)
[+] 	getPropertyBinder(Value* value)
[-] 		return getPropertyBinder (*value, value);
[+] 		return getPropertyBinder(*value, value);
[-] 	getPropertyAutoGetValueType (const Value& opValue);
[+] 	getPropertyAutoGetValueType(const Value& opValue);
[-] 	getPropertyAutoGetValueType (
[+] 	getPropertyAutoGetValueType(
[-] 	getPropertyAutoGetValueType (Value* value)
[+] 	getPropertyAutoGetValueType(Value* value)
[-] 		return getPropertyAutoGetValueType (*value, value);
[+] 		return getPropertyAutoGetValueType(*value, value);
[-] 	getPropertyAutoGetValue (
[+] 	getPropertyAutoGetValue(
[-] 	getPropertyAutoGetValue (Value* value)
[+] 	getPropertyAutoGetValue(Value* value)
[-] 		return getPropertyAutoGetValue (*value, value);
[+] 		return getPropertyAutoGetValue(*value, value);
[-] 	getPropertyOnChangedType (const Value& opValue);
[+] 	getPropertyOnChangedType(const Value& opValue);
[-] 	getPropertyOnChangedType (
[+] 	getPropertyOnChangedType(
[-] 	getPropertyOnChangedType (Value* value)
[+] 	getPropertyOnChangedType(Value* value)
[-] 		return getPropertyOnChangedType (*value, value);
[+] 		return getPropertyOnChangedType(*value, value);
[-] 	getPropertyOnChanged (
[+] 	getPropertyOnChanged(
[-] 	getPropertyOnChanged (Value* value)
[+] 	getPropertyOnChanged(Value* value)
[-] 		return getPropertyOnChanged (*value, value);
[+] 		return getPropertyOnChanged(*value, value);
[-] 	getProperty (
[+] 	getProperty(
[-] 	setProperty (
[+] 	setProperty(
[-] 	getPropertyThinPtr (
[+] 	getPropertyThinPtr(
[-] 	getPropertyThinPtr (
[+] 	getPropertyThinPtr(
[-] 		return getPropertyThinPtr (
[+] 		return getPropertyThinPtr(
[-] 			prop->getType ()->getPropertyPtrType (PropertyPtrTypeKind_Thin),
[+] 			prop->getType()->getPropertyPtrType(PropertyPtrTypeKind_Thin),
[-] 	getPropertyVTable (
[+] 	getPropertyVTable(
[-] 	getPropertyVTable (
[+] 	getPropertyVTable(
[-] 	loadDataRef (
[+] 	loadDataRef(
[-] 	loadDataRef (Value* value)
[+] 	loadDataRef(Value* value)
[-] 		return loadDataRef (*value, value);
[+] 		return loadDataRef(*value, value);
[-] 	storeDataRef (
[+] 	storeDataRef(
[-] 	getField (
[+] 	getField(
[-] 	getField (
[+] 	getField(
[-] 		return getField (opValue, member, NULL, resultValue);
[+] 		return getField(opValue, member, NULL, resultValue);
[-] 	getField (
[+] 	getField(
[-] 		return getField (*value, member, NULL, value);
[+] 		return getField(*value, member, NULL, value);
[-] 	getPromiseField (
[+] 	getPromiseField(
[-] 	getFieldPtrImpl (
[+] 	getFieldPtrImpl(
[-] 	getStructField (
[+] 	getStructField(
[-] 	getDynamicStructField (
[+] 	getDynamicStructField(
[-] 	getUnionField (
[+] 	getUnionField(
[-] 	getClassField (
[+] 	getClassField(
[-] 	getPropertyField (
[+] 	getPropertyField(
[-] 	getVirtualMethod (
[+] 	getVirtualMethod(
[-] 	getVirtualProperty (
[+] 	getVirtualProperty(
[-] 	createClosureObject (
[+] 	createClosureObject(
[-] 	createDataClosureObject (
[+] 	createDataClosureObject(
[-] 	checkPtr (
[+] 	checkPtr(
[-] 	checkDataPtrRange (const Value& value);
[+] 	checkDataPtrRange(const Value& value);
[-] 	checkNullPtr (const Value& value);
[+] 	checkNullPtr(const Value& value);
[-] 	checkAccess (ModuleItemDecl* decl);
[+] 	checkAccess(ModuleItemDecl* decl);
[-] 	getOverloadedUnaryOperator (
[+] 	getOverloadedUnaryOperator(
[-] 	getOverloadedBinaryOperator (
[+] 	getOverloadedBinaryOperator(
[-] 	extractBitField (
[+] 	extractBitField(
[-] 	mergeBitField (
[+] 	mergeBitField(
[-] 	getNamespaceMemberType (
[+] 	getNamespaceMemberType(
[-] 	getNamespaceMember (
[+] 	getNamespaceMember(
[-] 	getNamedTypeMemberType (
[+] 	getNamedTypeMemberType(
[-] 	getNamedTypeMember (
[+] 	getNamedTypeMember(
[-] 	getEnumTypeMemberType (
[+] 	getEnumTypeMemberType(
[-] 	getEnumTypeMember (
[+] 	getEnumTypeMember(
[-] 	getVariantMember (
[+] 	getVariantMember(
[-] 	getVariantMember (
[+] 	getVariantMember(
[-] 	getLibraryMember (
[+] 	getLibraryMember(
[-] 	finalizeMemberOperator (
[+] 	finalizeMemberOperator(
[-] 	getClassVTable (
[+] 	getClassVTable(
[-] 	callImpl (
[+] 	callImpl(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	callClosureFunctionPtr (
[+] 	callClosureFunctionPtr(
[-] 		sl::BoxList <Value>* argValueList,
[+] 		sl::BoxList<Value>* argValueList,
[-] 	castArgValueList (
[+] 	castArgValueList(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 	getCdeclVarArgType (Type* type);
[+] 	getCdeclVarArgType(Type* type);
[-] 	callOperatorVararg (
[+] 	callOperatorVararg(
[-] 	callOperatorVararg (
[+] 	callOperatorVararg(
[-] 		return callOperatorVararg (operatorVararg, type, *value, value);
[+] 		return callOperatorVararg(operatorVararg, type, *value, value);
[-] 	deleteDataPtr (const Value& opValue);
[+] 	deleteDataPtr(const Value& opValue);
[-] 	deleteClassPtr (const Value& opValue);
[+] 	deleteClassPtr(const Value& opValue);
[-] 	dynamicCastDataPtr (
[+] 	dynamicCastDataPtr(
[-] 	dynamicCastClassPtr (
[+] 	dynamicCastClassPtr(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp.h
----------------------
[-] 	UnaryOperator ();
[+] 	UnaryOperator();
[-] 	getModule ()
[+] 	getModule()
[-] 	getOpKind ()
[+] 	getOpKind()
[-] 	getOpFlags ()
[+] 	getOpFlags()
[-] 	getResultType (
[+] 	getResultType(
[-] 	getResultType (const Value& opValue) = 0;
[+] 	getResultType(const Value& opValue) = 0;
[-] 	op (
[+] 	op(
[-] 	setOperatorError (Type* opType)
[+] 	setOperatorError(Type* opType)
[-] 		return err::setFormatStringError (
[+] 		return err::setFormatStringError(
[-] 			getUnOpKindString (m_opKind),
[+] 			getUnOpKindString(m_opKind),
[-] 			opType->getTypeString ().sz ()
[+] 			opType->getTypeString().sz()
[-] 	setOperatorError (const Value& opValue)
[+] 	setOperatorError(const Value& opValue)
[-] 		return setOperatorError (opValue.getType ());
[+] 		return setOperatorError(opValue.getType());
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Arithmetic.h
----------------------
[-] getArithmeticOperatorResultType (Type* opType);
[+] getArithmeticOperatorResultType(Type* opType);
[-] getArithmeticOperatorResultType (const Value& opValue)
[+] getArithmeticOperatorResultType(const Value& opValue)
[-] 	return getArithmeticOperatorResultType (opValue.getType ());
[+] 	return getArithmeticOperatorResultType(opValue.getType());
[-] getArithmeticOperatorResultType (
[+] getArithmeticOperatorResultType(
[-] 	return getArithmeticOperatorResultType (
[+] 	return getArithmeticOperatorResultType(
[-] 		opType1->getTypeKind () > opType2->getTypeKind () ?
[+] 		opType1->getTypeKind() > opType2->getTypeKind() ?
[-] getArithmeticOperatorResultType (
[+] getArithmeticOperatorResultType(
[-] 	return getArithmeticOperatorResultType (opValue1.getType (), opValue2.getType ());
[+] 	return getArithmeticOperatorResultType(opValue1.getType(), opValue2.getType());
[-] 	getResultType (const Value& opValue)
[+] 	getResultType(const Value& opValue)
[-] 		Type* type = getArithmeticOperatorResultType (opValue);
[+] 		Type* type = getArithmeticOperatorResultType(opValue);
[-] 		if (!type || T::isIntegerOnly && !(type->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 		if (!type || T::isIntegerOnly && !(type->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 			setOperatorError (opValue);
[+] 			setOperatorError(opValue);
[-] 	op (
[+] 	op(
[-] 		Type* type = getResultType (rawOpValue);
[+] 		Type* type = getResultType(rawOpValue);
[-] 		bool result = castOperator (m_module, rawOpValue, type, &opValue);
[+] 		bool result = castOperator(m_module, rawOpValue, type, &opValue);
[-] 		if (opValue.getValueKind () == ValueKind_Const)
[+] 		if (opValue.getValueKind() == ValueKind_Const)
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				resultValue->setConstInt32 (T::constOpInt32 (opValue.getInt32 ()), type);
[+] 				resultValue->setConstInt32(T::constOpInt32(opValue.getInt32()), type);
[-] 				resultValue->setConstInt64 (T::constOpInt64 (opValue.getInt64 ()), type);
[+] 				resultValue->setConstInt64(T::constOpInt64(opValue.getInt64()), type);
[-] 				resultValue->setConstFloat (T::constOpFp32 (opValue.getFloat ()), m_module);
[+] 				resultValue->setConstFloat(T::constOpFp32(opValue.getFloat()), m_module);
[-] 				resultValue->setConstDouble (T::constOpFp64 (opValue.getDouble ()), m_module);
[+] 				resultValue->setConstDouble(T::constOpFp64(opValue.getDouble()), m_module);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 			TypeKind typeKind = type->getTypeKind ();
[+] 			TypeKind typeKind = type->getTypeKind();
[-] 			switch (typeKind)
[+] 			switch(typeKind)
[-] 				static_cast <T*> (this)->llvmOpInt (opValue, type, resultValue);
[+] 				static_cast<T*> (this)->llvmOpInt(opValue, type, resultValue);
[-] 				static_cast <T*> (this)->llvmOpFp (opValue, type, resultValue);
[+] 				static_cast<T*> (this)->llvmOpFp(opValue, type, resultValue);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] class UnOp_IntegerOnly: public UnOp_Arithmetic <T>
[+] class UnOp_IntegerOnly: public UnOp_Arithmetic<T>
[-] 	constOpFp32 (float opValue)
[+] 	constOpFp32(float opValue)
[-] 	constOpFp64 (double opValue)
[+] 	constOpFp64(double opValue)
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] class UnOp_Plus: public UnOp_Arithmetic <UnOp_Plus>
[+] class UnOp_Plus: public UnOp_Arithmetic<UnOp_Plus>
[-] 	UnOp_Plus ()
[+] 	UnOp_Plus()
[-] 	constOpInt32 (int32_t opValue)
[+] 	constOpInt32(int32_t opValue)
[-] 	constOpInt64 (int64_t opValue)
[+] 	constOpInt64(int64_t opValue)
[-] 	constOpFp32 (float opValue)
[+] 	constOpFp32(float opValue)
[-] 	constOpFp64 (double opValue)
[+] 	constOpFp64(double opValue)
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 		return resultValue->getLlvmValue ();
[+] 		return resultValue->getLlvmValue();
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] 		return resultValue->getLlvmValue ();
[+] 		return resultValue->getLlvmValue();
[-] class UnOp_Minus: public UnOp_Arithmetic <UnOp_Minus>
[+] class UnOp_Minus: public UnOp_Arithmetic<UnOp_Minus>
[-] 	UnOp_Minus ()
[+] 	UnOp_Minus()
[-] 	constOpInt32 (int32_t opValue)
[+] 	constOpInt32(int32_t opValue)
[-] 	constOpInt64 (int64_t opValue)
[+] 	constOpInt64(int64_t opValue)
[-] 	constOpFp32 (float opValue)
[+] 	constOpFp32(float opValue)
[-] 	constOpFp64 (double opValue)
[+] 	constOpFp64(double opValue)
[-] 	llvmOpInt (
[+] 	llvmOpInt(
[-] 	llvmOpFp (
[+] 	llvmOpFp(
[-] class UnOp_BwNot: public UnOp_IntegerOnly <UnOp_BwNot>
[+] class UnOp_BwNot: public UnOp_IntegerOnly<UnOp_BwNot>
[-] 	UnOp_BwNot ()
[+] 	UnOp_BwNot()
[-] 	constOpInt32 (int32_t opValue)
[+] 	constOpInt32(int32_t opValue)
[-] 	constOpInt64 (int64_t opValue)
[+] 	constOpInt64(int64_t opValue)
[-] 	llvmOpInt (
[+] 	llvmOpInt(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Inc.h
----------------------
[-] 	UnOp_PreInc ()
[+] 	UnOp_PreInc()
[-] 	getResultType (const Value& opValue);
[+] 	getResultType(const Value& opValue);
[-] 	op (
[+] 	op(
[-] 	UnOp_PostInc ()
[+] 	UnOp_PostInc()
[-] 	getResultType (const Value& opValue);
[+] 	getResultType(const Value& opValue);
[-] 	op (
[+] 	op(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_LogNot.h
----------------------
[-] 	UnOp_LogNot ()
[+] 	UnOp_LogNot()
[-] 	getResultType (const Value& opValue);
[+] 	getResultType(const Value& opValue);
[-] 	op (
[+] 	op(
[-] 	zeroCmpOperator (
[+] 	zeroCmpOperator(
[-] 	ptrOperator (
[+] 	ptrOperator(
[-] 	variantOperator (
[+] 	variantOperator(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_OperatorMgr\jnc_ct_UnOp_Ptr.h
----------------------
[-] 	UnOp_Addr ()
[+] 	UnOp_Addr()
[-] 	getResultType (const Value& opValue);
[+] 	getResultType(const Value& opValue);
[-] 	op (
[+] 	op(
[-] 	UnOp_Indir ()
[+] 	UnOp_Indir()
[-] 	getResultType (const Value& opValue);
[+] 	getResultType(const Value& opValue);
[-] 	op (
[+] 	op(
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_Decl.cpp
----------------------
[-] getTypeModifierString (TypeModifier modifier)
[+] getTypeModifierString(TypeModifier modifier)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (modifier);
[+] 	size_t i = sl::getLoBitIdx32(modifier);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getTypeModifierString (uint_t modifiers)
[+] getTypeModifierString(uint_t modifiers)
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	TypeModifier modifier = getFirstTypeModifier (modifiers);
[+] 	TypeModifier modifier = getFirstTypeModifier(modifiers);
[-] 	sl::String string = getTypeModifierString (modifier);
[+] 	sl::String string = getTypeModifierString(modifier);
[-] 		modifier = getFirstTypeModifier (modifiers);
[+] 		modifier = getFirstTypeModifier(modifiers);
[-] 		string += getTypeModifierString (modifier);
[+] 		string += getTypeModifierString(modifier);
[-] TypeModifiers::addTypeModifier (TypeModifier modifier)
[+] TypeModifiers::addTypeModifier(TypeModifier modifier)
[-] 	antiModifierTable [] =
[+] 	antiModifierTable[] =
[-] 		err::setFormatStringError ("type modifier '%s' used more than once", getTypeModifierString (modifier));
[+] 		err::setFormatStringError("type modifier '%s' used more than once", getTypeModifierString (modifier));
[-] 	size_t i = sl::getLoBitIdx32 (modifier);
[+] 	size_t i = sl::getLoBitIdx32(modifier);
[-] 	if (i >= countof (antiModifierTable))
[+] 	if (i >= countof(antiModifierTable))
[-] 	uint_t antiModifiers = m_typeModifiers & antiModifierTable [i];
[+] 	uint_t antiModifiers = m_typeModifiers & antiModifierTable[i];
[-] 		TypeModifier antiModifier = getFirstTypeModifier (antiModifiers);
[+] 		TypeModifier antiModifier = getFirstTypeModifier(antiModifiers);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getTypeModifierString (antiModifier),
[+] 			getTypeModifierString(antiModifier),
[-] 			getTypeModifierString (modifier)
[+] 			getTypeModifierString(modifier)
[-] TypeModifiers::clearTypeModifiers (int modifierMask)
[+] TypeModifiers::clearTypeModifiers(int modifierMask)
[-] TypeModifiers::checkAntiTypeModifiers (int modifierMask)
[+] TypeModifiers::checkAntiTypeModifiers(int modifierMask)
[-] 	TypeModifier firstModifier = getFirstTypeModifier (modifiers);
[+] 	TypeModifier firstModifier = getFirstTypeModifier(modifiers);
[-] 	TypeModifier secondModifier = getFirstTypeModifier (modifiers);
[+] 	TypeModifier secondModifier = getFirstTypeModifier(modifiers);
[-] 	err::setFormatStringError (
[+] 	err::setFormatStringError(
[-] 		getTypeModifierString (firstModifier),
[+] 		getTypeModifierString(firstModifier),
[-] 		getTypeModifierString (secondModifier)
[+] 		getTypeModifierString(secondModifier)
[-] TypeSpecifier::setType (Type* type)
[+] TypeSpecifier::setType(Type* type)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			m_type->getTypeString ().sz (),
[+] 			m_type->getTypeString().sz(),
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] getPostDeclaratorModifierString (PostDeclaratorModifier modifier)
[+] getPostDeclaratorModifierString(PostDeclaratorModifier modifier)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i  = sl::getLoBitIdx32 (modifier);
[+] 	size_t i  = sl::getLoBitIdx32(modifier);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getPostDeclaratorModifierString (uint_t modifiers)
[+] getPostDeclaratorModifierString(uint_t modifiers)
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	PostDeclaratorModifier modifier = getFirstPostDeclaratorModifier (modifiers);
[+] 	PostDeclaratorModifier modifier = getFirstPostDeclaratorModifier(modifiers);
[-] 	sl::String string = getPostDeclaratorModifierString (modifier);
[+] 	sl::String string = getPostDeclaratorModifierString(modifier);
[-] 		modifier = getFirstPostDeclaratorModifier (modifiers);
[+] 		modifier = getFirstPostDeclaratorModifier(modifiers);
[-] 		string += getPostDeclaratorModifierString (modifier);
[+] 		string += getPostDeclaratorModifierString(modifier);
[-] DeclFunctionSuffix::addFunctionTypeFlag (FunctionTypeFlag flag)
[+] DeclFunctionSuffix::addFunctionTypeFlag(FunctionTypeFlag flag)
[-] 		err::setFormatStringError ("function modifier '%s' used more than once", getFunctionTypeFlagString (flag));
[+] 		err::setFormatStringError("function modifier '%s' used more than once", getFunctionTypeFlagString (flag));
[-] Declarator::Declarator ()
[+] Declarator::Declarator()
[-] Declarator::setTypeSpecifier (
[+] Declarator::setTypeSpecifier(
[-] 		m_baseType = module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 		m_baseType = module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] 	takeOverTypeModifiers (typeSpecifier);
[+] 	takeOverTypeModifiers(typeSpecifier);
[-] 	m_baseType = typeSpecifier->getType ();
[+] 	m_baseType = typeSpecifier->getType();
[-] 			module->m_typeMgr.getPrimitiveType (TypeKind_Int) :
[+] 			module->m_typeMgr.getPrimitiveType(TypeKind_Int) :
[-] 			module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 			module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] Declarator::addName (sl::String name)
[+] Declarator::addName(sl::String name)
[-] 		err::setFormatStringError ("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[+] 		err::setFormatStringError("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[-] 	m_name.addName (name);
[+] 	m_name.addName(name);
[-] Declarator::addUnnamedMethod (FunctionKind functionKind)
[+] Declarator::addUnnamedMethod(FunctionKind functionKind)
[-] 		err::setFormatStringError ("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[+] 		err::setFormatStringError("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[-] Declarator::addCastOperator (Type* type)
[+] Declarator::addCastOperator(Type* type)
[-] Declarator::addUnaryBinaryOperator (
[+] Declarator::addUnaryBinaryOperator(
[-] 		err::setFormatStringError ("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[+] 		err::setFormatStringError("cannot further qualify '%s' declarator", getFunctionKindString (m_functionKind));
[-] 		err::setFormatStringError ("assignment operator could not be overloaded");
[+] 		err::setFormatStringError("assignment operator could not be overloaded");
[-] Declarator::setPostDeclaratorModifier (PostDeclaratorModifier modifier)
[+] Declarator::setPostDeclaratorModifier(PostDeclaratorModifier modifier)
[-] 		err::setFormatStringError ("type modifier '%s' used more than once", getPostDeclaratorModifierString (modifier));
[+] 		err::setFormatStringError("type modifier '%s' used more than once", getPostDeclaratorModifierString (modifier));
[-] Declarator::addPointerPrefix ()
[+] Declarator::addPointerPrefix()
[-] 	DeclPointerPrefix* prefix = AXL_MEM_NEW (DeclPointerPrefix);
[+] 	DeclPointerPrefix* prefix = AXL_MEM_NEW(DeclPointerPrefix);
[-] 	prefix->takeOverTypeModifiers (this);
[+] 	prefix->takeOverTypeModifiers(this);
[-] 	m_pointerPrefixList.insertTail (prefix);
[+] 	m_pointerPrefixList.insertTail(prefix);
[-] Declarator::addArraySuffix (sl::BoxList <Token>* elementCountInitializer)
[+] Declarator::addArraySuffix(sl::BoxList<Token>* elementCountInitializer)
[-] 	DeclArraySuffix* suffix = AXL_MEM_NEW (DeclArraySuffix);
[+] 	DeclArraySuffix* suffix = AXL_MEM_NEW(DeclArraySuffix);
[-] 	sl::takeOver (&suffix->m_elementCountInitializer, elementCountInitializer);
[+] 	sl::takeOver(&suffix->m_elementCountInitializer, elementCountInitializer);
[-] 	m_suffixList.insertTail (suffix);
[+] 	m_suffixList.insertTail(suffix);
[-] Declarator::addArraySuffix (size_t elementCount)
[+] Declarator::addArraySuffix(size_t elementCount)
[-] 	DeclArraySuffix* suffix = AXL_MEM_NEW (DeclArraySuffix);
[+] 	DeclArraySuffix* suffix = AXL_MEM_NEW(DeclArraySuffix);
[-] 	m_suffixList.insertTail (suffix);
[+] 	m_suffixList.insertTail(suffix);
[-] Declarator::addFunctionSuffix ()
[+] Declarator::addFunctionSuffix()
[-] 	DeclFunctionSuffix* suffix = AXL_MEM_NEW (DeclFunctionSuffix);
[+] 	DeclFunctionSuffix* suffix = AXL_MEM_NEW(DeclFunctionSuffix);
[-] 	m_suffixList.insertTail (suffix);
[+] 	m_suffixList.insertTail(suffix);
[-] Declarator::addGetterSuffix ()
[+] Declarator::addGetterSuffix()
[-] 	DeclFunctionSuffix* suffix = AXL_MEM_NEW (DeclFunctionSuffix);
[+] 	DeclFunctionSuffix* suffix = AXL_MEM_NEW(DeclFunctionSuffix);
[-] 	m_suffixList.insertHead (suffix);
[+] 	m_suffixList.insertHead(suffix);
[-] Declarator::addBitFieldSuffix (size_t bitCount)
[+] Declarator::addBitFieldSuffix(size_t bitCount)
[-] 	if (m_bitCount || !m_suffixList.isEmpty () || !m_pointerPrefixList.isEmpty ())
[+] 	if (m_bitCount || !m_suffixList.isEmpty() || !m_pointerPrefixList.isEmpty())
[-] 		err::setFormatStringError ("bit field can only be applied to integer type");
[+] 		err::setFormatStringError("bit field can only be applied to integer type");
[-] Declarator::calcTypeImpl (
[+] Declarator::calcTypeImpl(
[-] 	return typeCalc.calcType (this, elementCountValue, flags);
[+] 	return typeCalc.calcType(this, elementCountValue, flags);
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_DeclTypeCalc.cpp
----------------------
[-] DeclTypeCalc::calcType (
[+] DeclTypeCalc::calcType(
[-] 	const sl::ConstList <DeclPointerPrefix>& pointerPrefixList,
[+] 	const sl::ConstList<DeclPointerPrefix>& pointerPrefixList,
[-] 	const sl::ConstList <DeclSuffix>& suffixList,
[+] 	const sl::ConstList<DeclSuffix>& suffixList,
[-] 	m_module = type->getModule ();
[+] 	m_module = type->getModule();
[-] 	sl::ConstIterator <DeclSuffix> firstSuffix = suffixList.getHead ();
[+] 	sl::ConstIterator<DeclSuffix> firstSuffix = suffixList.getHead();
[-] 	sl::ConstIterator <DeclSuffix> suffixEnd;
[+] 	sl::ConstIterator<DeclSuffix> suffixEnd;
[-] 		firstSuffix->getSuffixKind () == DeclSuffixKind_Array)
[+] 		firstSuffix->getSuffixKind() == DeclSuffixKind_Array)
[-] 		DeclArraySuffix* arraySuffix = (DeclArraySuffix*) *firstSuffix;
[+] 		DeclArraySuffix* arraySuffix = (DeclArraySuffix*)*firstSuffix;
[-] 		sl::BoxList <Token>* elementCountInitializer = arraySuffix->getElementCountInitializer ();
[+] 		sl::BoxList<Token>* elementCountInitializer = arraySuffix->getElementCountInitializer();
[-] 		if (!elementCountInitializer->isEmpty ())
[+] 		if (!elementCountInitializer->isEmpty())
[-] 			result = m_module->m_operatorMgr.parseExpression (*elementCountInitializer, elementCountValue);
[+] 			result = m_module->m_operatorMgr.parseExpression(*elementCountInitializer, elementCountValue);
[-] 		else if (arraySuffix->getElementCount () != -1)
[+] 		else if (arraySuffix->getElementCount() != -1)
[-] 			elementCountValue->setConstSizeT (arraySuffix->getElementCount (), m_module);
[+] 			elementCountValue->setConstSizeT(arraySuffix->getElementCount(), m_module);
[-] 	m_suffix = suffixList.getTail ();
[+] 	m_suffix = suffixList.getTail();
[-] 	sl::ConstIterator <DeclPointerPrefix> pointerPrefix = pointerPrefixList.getHead ();
[+] 	sl::ConstIterator<DeclPointerPrefix> pointerPrefix = pointerPrefixList.getHead();
[-] 		TypeKind typeKind = type->getTypeKind ();
[+] 		TypeKind typeKind = type->getTypeKind();
[-] 		m_typeModifiers = pointerPrefix->getTypeModifiers ();
[+] 		m_typeModifiers = pointerPrefix->getTypeModifiers();
[-] 			ArrayType* arrayType = getArrayType (type);
[+] 			ArrayType* arrayType = getArrayType(type);
[-] 			type = getDataPtrType (arrayType);
[+] 			type = getDataPtrType(arrayType);
[-] 			FunctionType* functionType = getFunctionType (type);
[+] 			FunctionType* functionType = getFunctionType(type);
[-] 			type = getFunctionPtrType (functionType);
[+] 			type = getFunctionPtrType(functionType);
[-] 			PropertyType* propertyType = getPropertyType (type);
[+] 			PropertyType* propertyType = getPropertyType(type);
[-] 			type = getPropertyPtrType (propertyType);
[+] 			type = getPropertyPtrType(propertyType);
[-] 			ClassType* classType = getMulticastType (type);
[+] 			ClassType* classType = getMulticastType(type);
[-] 			type = getClassPtrType (classType);
[+] 			type = getClassPtrType(classType);
[-] 			type = m_module->m_typeMgr.getStdType (StdType_ReactorBase);
[+] 			type = m_module->m_typeMgr.getStdType(StdType_ReactorBase);
[-] 		else switch (typeKind)
[+] 		else switch(typeKind)
[-] 			type = getClassPtrType ((ClassType*) type);
[+] 			type = getClassPtrType((ClassType*)type);
[-] 			type = getFunctionPtrType ((FunctionType*) type);
[+] 			type = getFunctionPtrType((FunctionType*)type);
[-] 			type = getPropertyPtrType ((PropertyType*) type);
[+] 			type = getPropertyPtrType((PropertyType*)type);
[-] 			type = getImportPtrType ((NamedImportType*) type);
[+] 			type = getImportPtrType((NamedImportType*)type);
[-] 			type = getDataPtrType (type);
[+] 			type = getDataPtrType(type);
[-] 		if (!type || !checkUnusedModifiers ())
[+] 		if (!type || !checkUnusedModifiers())
[-] 	takeOverTypeModifiers (typeModifiers);
[+] 	takeOverTypeModifiers(typeModifiers);
[-] 		type = getIntegerType (type);
[+] 		type = getIntegerType(type);
[-] 	else if (type->getStdType () == StdType_AbstractData)
[+] 	else if (type->getStdType() == StdType_AbstractData)
[-] 		err::setError ("can only use 'anydata' in pointer declaration");
[+] 		err::setError("can only use 'anydata' in pointer declaration");
[-] 		type = getPropertyType (type);
[+] 		type = getPropertyType(type);
[-] 			*flags = getPropertyFlags ();
[+] 			*flags = getPropertyFlags();
[-] 		type = getMulticastType (type);
[+] 		type = getMulticastType(type);
[-] 		type->getTypeKind () != TypeKind_Void) // bindable aliases
[+] 		type->getTypeKind() != TypeKind_Void) // bindable aliases
[-] 		type = getBindableDataType (type);
[+] 		type = getBindableDataType(type);
[-] 		type = m_module->m_typeMgr.getStdType (StdType_ReactorBase);
[+] 		type = m_module->m_typeMgr.getStdType(StdType_ReactorBase);
[-] 		DeclSuffix* suffix = (DeclSuffix*) *m_suffix;
[+] 		DeclSuffix* suffix = (DeclSuffix*)*m_suffix;
[-] 		DeclSuffixKind suffixKind = suffix->getSuffixKind ();
[+] 		DeclSuffixKind suffixKind = suffix->getSuffixKind();
[-] 		switch (suffixKind)
[+] 		switch(suffixKind)
[-] 			type = getArrayType (type);
[+] 			type = getArrayType(type);
[-] 			if (type->getTypeKind () == TypeKind_Function)
[+] 			if (type->getTypeKind() == TypeKind_Function)
[-] 				ASSERT (!m_suffix);
[+] 				ASSERT(!m_suffix);
[-] 			type = getFunctionType (type);
[+] 			type = getFunctionType(type);
[-] 			if (!checkUnusedModifiers ())
[+] 			if (!checkUnusedModifiers())
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 	if (!(type->getTypeKindFlags () & TypeKindFlag_Code) && flags != NULL)
[+] 	if (!(type->getTypeKindFlags() & TypeKindFlag_Code) && flags != NULL)
[-] 			err::setError ("redundant 'cmut'"); // must be applied to explicit pointers only
[+] 			err::setError("redundant 'cmut'"); // must be applied to explicit pointers only
[-] 		result = getPtrTypeFlags (type, flags);
[+] 		result = getPtrTypeFlags(type, flags);
[-] 	if (!checkUnusedModifiers ())
[+] 	if (!checkUnusedModifiers())
[-] DeclTypeCalc::calcPtrType (
[+] DeclTypeCalc::calcPtrType(
[-] 	m_module = type->getModule ();
[+] 	m_module = type->getModule();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		type = getClassPtrType ((ClassType*) type);
[+] 		type = getClassPtrType((ClassType*)type);
[-] 		type = getFunctionPtrType ((FunctionType*) type);
[+] 		type = getFunctionPtrType((FunctionType*)type);
[-] 		type = getPropertyPtrType ((PropertyType*) type);
[+] 		type = getPropertyPtrType((PropertyType*)type);
[-] 		type = getDataPtrType (type);
[+] 		type = getDataPtrType(type);
[-] 	if (!checkUnusedModifiers ())
[+] 	if (!checkUnusedModifiers())
[-] DeclTypeCalc::calcIntModType (
[+] DeclTypeCalc::calcIntModType(
[-] 	m_module = type->getModule ();
[+] 	m_module = type->getModule();
[-] 	type = getIntegerType (type);
[+] 	type = getIntegerType(type);
[-] 	if (!checkUnusedModifiers ())
[+] 	if (!checkUnusedModifiers())
[-] DeclTypeCalc::calcPropertyGetterType (Declarator* declarator)
[+] DeclTypeCalc::calcPropertyGetterType(Declarator* declarator)
[-] 	uint_t typeModifiers = declarator->getTypeModifiers ();
[+] 	uint_t typeModifiers = declarator->getTypeModifiers();
[-] 	ASSERT (typeModifiers & TypeModifier_Property);
[+] 	ASSERT(typeModifiers & TypeModifier_Property);
[-] 	declarator->addGetterSuffix ();
[+] 	declarator->addGetterSuffix();
[-] 	Type* type = calcType (
[+] 	Type* type = calcType(
[-] 		declarator->getBaseType (),
[+] 		declarator->getBaseType(),
[-] 		declarator->getPointerPrefixList (),
[+] 		declarator->getPointerPrefixList(),
[-] 		declarator->getSuffixList (),
[+] 		declarator->getSuffixList(),
[-] 	ASSERT (type->getTypeKind () == TypeKind_Function);
[+] 	ASSERT(type->getTypeKind() == TypeKind_Function);
[-] 	return (FunctionType*) type;
[+] 	return (FunctionType*)type;
[-] DeclTypeCalc::checkUnusedModifiers ()
[+] DeclTypeCalc::checkUnusedModifiers()
[-] 		err::setFormatStringError ("unused modifier '%s'", getTypeModifierString (m_typeModifiers).sz ());
[+] 		err::setFormatStringError("unused modifier '%s'", getTypeModifierString (m_typeModifiers).sz ());
[-] DeclTypeCalc::getPtrTypeFlags (
[+] DeclTypeCalc::getPtrTypeFlags(
[-] 		if (type->getTypeKindFlags () & TypeKindFlag_Code)
[+] 		if (type->getTypeKindFlags() & TypeKindFlag_Code)
[-] 			err::setFormatStringError ("'volatile' cannot be applied to '%s'", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'volatile' cannot be applied to '%s'", type->getTypeString ().sz ());
[-] 		ASSERT (isClassType (type, ClassTypeKind_Multicast));
[+] 		ASSERT(isClassType(type, ClassTypeKind_Multicast));
[-] DeclTypeCalc::getPropertyFlags ()
[+] DeclTypeCalc::getPropertyFlags()
[-] DeclTypeCalc::getIntegerType (Type* type)
[+] DeclTypeCalc::getIntegerType(Type* type)
[-] 	ASSERT (m_typeModifiers & TypeModifierMaskKind_Integer);
[+] 	ASSERT(m_typeModifiers & TypeModifierMaskKind_Integer);
[-] 	if (type->getTypeKind () == TypeKind_TypedefShadow)
[+] 	if (type->getTypeKind() == TypeKind_TypedefShadow)
[-] 		type = ((TypedefShadowType*) type)->getTypedef ()->getType ();
[+] 		type = ((TypedefShadowType*)type)->getTypedef()->getType();
[-] 	if (type->getTypeKind () == TypeKind_NamedImport)
[+] 	if (type->getTypeKind() == TypeKind_NamedImport)
[-] 		return getImportIntModType ((NamedImportType*) type);
[+] 		return getImportIntModType((NamedImportType*)type);
[-] 	if (!(type->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 	if (!(type->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		err::setFormatStringError ("'%s' modifier cannot be applied to '%s'",
[+] 		err::setFormatStringError("'%s' modifier cannot be applied to '%s'",
[-] 			getTypeModifierString (m_typeModifiers & TypeModifierMaskKind_Integer).sz (),
[+] 			getTypeModifierString(m_typeModifiers & TypeModifierMaskKind_Integer).sz(),
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] 		TypeKind modTypeKind = getUnsignedIntegerTypeKind (type->getTypeKind ());
[+] 		TypeKind modTypeKind = getUnsignedIntegerTypeKind(type->getTypeKind());
[-] 		type = m_module->m_typeMgr.getPrimitiveType (modTypeKind);
[+] 		type = m_module->m_typeMgr.getPrimitiveType(modTypeKind);
[-] 		TypeKind modTypeKind = getBigEndianIntegerTypeKind (type->getTypeKind ());
[+] 		TypeKind modTypeKind = getBigEndianIntegerTypeKind(type->getTypeKind());
[-] 		type = m_module->m_typeMgr.getPrimitiveType (modTypeKind);
[+] 		type = m_module->m_typeMgr.getPrimitiveType(modTypeKind);
[-] DeclTypeCalc::getArrayType (Type* elementType)
[+] DeclTypeCalc::getArrayType(Type* elementType)
[-] 	if (!m_suffix || m_suffix->getSuffixKind () != DeclSuffixKind_Array)
[+] 	if (!m_suffix || m_suffix->getSuffixKind() != DeclSuffixKind_Array)
[-] 		err::setFormatStringError ("missing array suffix");
[+] 		err::setFormatStringError("missing array suffix");
[-] 	DeclArraySuffix* suffix = (DeclArraySuffix*) *m_suffix--;
[+] 	DeclArraySuffix* suffix = (DeclArraySuffix*)*m_suffix--;
[-] 	TypeKind typeKind = elementType->getTypeKind ();
[+] 	TypeKind typeKind = elementType->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		err::setFormatStringError ("cannot create array of '%s'", elementType->getTypeString ().sz () );
[+] 		err::setFormatStringError("cannot create array of '%s'", elementType->getTypeString ().sz () );
[-] 		if (isAutoSizeArrayType (elementType))
[+] 		if (isAutoSizeArrayType(elementType))
[-] 			err::setFormatStringError ("cannot create array of auto-size-array '%s'", elementType->getTypeString ().sz () );
[+] 			err::setFormatStringError("cannot create array of auto-size-array '%s'", elementType->getTypeString ().sz () );
[-] 			elementType = getIntegerType (elementType);
[+] 			elementType = getIntegerType(elementType);
[-] 		else if (elementType->getStdType () == StdType_AbstractData)
[+] 		else if (elementType->getStdType() == StdType_AbstractData)
[-] 			err::setError ("can only use 'anydata' in pointer declaration");
[+] 			err::setError("can only use 'anydata' in pointer declaration");
[-] 	sl::BoxList <Token>* elementCountInitializer = suffix->getElementCountInitializer ();
[+] 	sl::BoxList<Token>* elementCountInitializer = suffix->getElementCountInitializer();
[-] 	if (!elementCountInitializer->isEmpty ())
[+] 	if (!elementCountInitializer->isEmpty())
[-] 		return m_module->m_typeMgr.createArrayType (elementType, elementCountInitializer);
[+] 		return m_module->m_typeMgr.createArrayType(elementType, elementCountInitializer);
[-] 	size_t elementCount = suffix->getElementCount ();
[+] 	size_t elementCount = suffix->getElementCount();
[-] 		m_module->m_typeMgr.createAutoSizeArrayType (elementType) :
[+] 		m_module->m_typeMgr.createAutoSizeArrayType(elementType) :
[-] 		m_module->m_typeMgr.getArrayType (elementType, elementCount);
[+] 		m_module->m_typeMgr.getArrayType(elementType, elementCount);
[-] DeclTypeCalc::prepareReturnType (Type* type)
[+] DeclTypeCalc::prepareReturnType(Type* type)
[-] 	while (m_suffix && m_suffix->getSuffixKind () == DeclSuffixKind_Array)
[+] 	while (m_suffix && m_suffix->getSuffixKind() == DeclSuffixKind_Array)
[-] 		type = getArrayType (type);
[+] 		type = getArrayType(type);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] 		if (isAutoSizeArrayType (type))
[+] 		if (isAutoSizeArrayType(type))
[-] 			err::setFormatStringError ("function cannot return auto-size-array '%s'", type->getTypeString ().sz () );
[+] 			err::setFormatStringError("function cannot return auto-size-array '%s'", type->getTypeString ().sz () );
[-] 			return getIntegerType (type);
[+] 			return getIntegerType(type);
[-] 		else if (type->getStdType () == StdType_AbstractData)
[+] 		else if (type->getStdType() == StdType_AbstractData)
[-] 			err::setError ("can only use 'anydata' in pointer declaration");
[+] 			err::setError("can only use 'anydata' in pointer declaration");
[-] DeclTypeCalc::getFunctionType (Type* returnType)
[+] DeclTypeCalc::getFunctionType(Type* returnType)
[-] 	returnType = prepareReturnType (returnType);
[+] 	returnType = prepareReturnType(returnType);
[-] 	if (!m_suffix || m_suffix->getSuffixKind () != DeclSuffixKind_Function)
[+] 	if (!m_suffix || m_suffix->getSuffixKind() != DeclSuffixKind_Function)
[-] 		err::setFormatStringError ("missing function suffix");
[+] 		err::setFormatStringError("missing function suffix");
[-] 	DeclFunctionSuffix* suffix = (DeclFunctionSuffix*) *m_suffix--;
[+] 	DeclFunctionSuffix* suffix = (DeclFunctionSuffix*)*m_suffix--;
[-] 	CallConvKind callConvKind = getCallConvKindFromModifiers (m_typeModifiers);
[+] 	CallConvKind callConvKind = getCallConvKindFromModifiers(m_typeModifiers);
[-] 	CallConv* callConv = m_module->m_typeMgr.getCallConv (callConvKind);
[+] 	CallConv* callConv = m_module->m_typeMgr.getCallConv(callConvKind);
[-] 	uint_t typeFlags = suffix->getFunctionTypeFlags ();
[+] 	uint_t typeFlags = suffix->getFunctionTypeFlags();
[-] 		if (returnType->getTypeKind () != TypeKind_NamedImport &&
[+] 		if (returnType->getTypeKind() != TypeKind_NamedImport &&
[-] 			!(returnType->getTypeKindFlags () & TypeKindFlag_ErrorCode))
[+] 			!(returnType->getTypeKindFlags() & TypeKindFlag_ErrorCode))
[-] 			err::setFormatStringError ("'%s' cannot be used as error code", returnType->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be used as error code", returnType->getTypeString ().sz ());
[-] 		uint_t callConvFlags = callConv->getFlags ();
[+] 		uint_t callConvFlags = callConv->getFlags();
[-] 			err::setFormatStringError ("vararg cannot be used with '%s'", callConv->getCallConvDisplayString ());
[+] 			err::setFormatStringError("vararg cannot be used with '%s'", callConv->getCallConvDisplayString ());
[-] 			err::setFormatStringError ("only 'cdecl' vararg is currently supported");
[+] 			err::setFormatStringError("only 'cdecl' vararg is currently supported");
[-] 	return m_module->m_typeMgr.createUserFunctionType (
[+] 	return m_module->m_typeMgr.createUserFunctionType(
[-] 		suffix->getArgArray (),
[+] 		suffix->getArgArray(),
[-] DeclTypeCalc::getPropertyType (Type* returnType)
[+] DeclTypeCalc::getPropertyType(Type* returnType)
[-] 	returnType = prepareReturnType (returnType);
[+] 	returnType = prepareReturnType(returnType);
[-] 	if (returnType->getTypeKind () == TypeKind_Void)
[+] 	if (returnType->getTypeKind() == TypeKind_Void)
[-] 		err::setFormatStringError ("property cannot return 'void'");
[+] 		err::setFormatStringError("property cannot return 'void'");
[-] 	CallConvKind callConvKind = getCallConvKindFromModifiers (m_typeModifiers);
[+] 	CallConvKind callConvKind = getCallConvKindFromModifiers(m_typeModifiers);
[-] 	CallConv* callConv = m_module->m_typeMgr.getCallConv (callConvKind);
[+] 	CallConv* callConv = m_module->m_typeMgr.getCallConv(callConvKind);
[-] 		return m_module->m_typeMgr.getSimplePropertyType (
[+] 		return m_module->m_typeMgr.getSimplePropertyType(
[-] 	if (!m_suffix || m_suffix->getSuffixKind () != DeclSuffixKind_Function)
[+] 	if (!m_suffix || m_suffix->getSuffixKind() != DeclSuffixKind_Function)
[-] 		err::setFormatStringError ("missing indexed property suffix");
[+] 		err::setFormatStringError("missing indexed property suffix");
[-] 	DeclFunctionSuffix* suffix = (DeclFunctionSuffix*) *m_suffix--;
[+] 	DeclFunctionSuffix* suffix = (DeclFunctionSuffix*)*m_suffix--;
[-] 	return m_module->m_typeMgr.createIndexedPropertyType (
[+] 	return m_module->m_typeMgr.createIndexedPropertyType(
[-] 		suffix->getArgArray (),
[+] 		suffix->getArgArray(),
[-] DeclTypeCalc::getBindableDataType (Type* dataType)
[+] DeclTypeCalc::getBindableDataType(Type* dataType)
[-] 	dataType = prepareReturnType (dataType);
[+] 	dataType = prepareReturnType(dataType);
[-] 	if (dataType->getTypeKind () == TypeKind_Void)
[+] 	if (dataType->getTypeKind() == TypeKind_Void)
[-] 		err::setFormatStringError ("bindable data cannot be 'void'");
[+] 		err::setFormatStringError("bindable data cannot be 'void'");
[-] 		err::setFormatStringError ("bindable data cannot be 'indexed'");
[+] 		err::setFormatStringError("bindable data cannot be 'indexed'");
[-] 	CallConvKind callConvKind = getCallConvKindFromModifiers (m_typeModifiers);
[+] 	CallConvKind callConvKind = getCallConvKindFromModifiers(m_typeModifiers);
[-] 	CallConv* callConv = m_module->m_typeMgr.getCallConv (callConvKind);
[+] 	CallConv* callConv = m_module->m_typeMgr.getCallConv(callConvKind);
[-] 	return m_module->m_typeMgr.getSimplePropertyType (callConv, dataType, PropertyTypeFlag_Bindable);
[+] 	return m_module->m_typeMgr.getSimplePropertyType(callConv, dataType, PropertyTypeFlag_Bindable);
[-] DeclTypeCalc::getMulticastType (Type* leftType)
[+] DeclTypeCalc::getMulticastType(Type* leftType)
[-] 	TypeKind typeKind = leftType->getTypeKind ();
[+] 	TypeKind typeKind = leftType->getTypeKind();
[-] 		ptrType = (FunctionPtrType*) leftType;
[+] 		ptrType = (FunctionPtrType*)leftType;
[-] 		ptrType = getFunctionPtrType ((FunctionType*) leftType);
[+] 		ptrType = getFunctionPtrType((FunctionType*)leftType);
[-] 		FunctionType* functionType = getFunctionType (leftType);
[+] 		FunctionType* functionType = getFunctionType(leftType);
[-] 		ptrType = getFunctionPtrType (functionType);
[+] 		ptrType = getFunctionPtrType(functionType);
[-] 	return m_module->m_typeMgr.getMulticastType (ptrType);
[+] 	return m_module->m_typeMgr.getMulticastType(ptrType);
[-] DeclTypeCalc::getDataPtrType (Type* dataType)
[+] DeclTypeCalc::getDataPtrType(Type* dataType)
[-] 		dataType = getIntegerType (dataType);
[+] 		dataType = getIntegerType(dataType);
[-] 	uint_t typeFlags = getPtrTypeFlagsFromModifiers (m_typeModifiers);
[+] 	uint_t typeFlags = getPtrTypeFlagsFromModifiers(m_typeModifiers);
[-] 	return dataType->getDataPtrType (
[+] 	return dataType->getDataPtrType(
[-] DeclTypeCalc::getClassPtrType (ClassType* classType)
[+] DeclTypeCalc::getClassPtrType(ClassType* classType)
[-] 	uint_t typeFlags = getPtrTypeFlagsFromModifiers (m_typeModifiers);
[+] 	uint_t typeFlags = getPtrTypeFlagsFromModifiers(m_typeModifiers);
[-] 	return classType->getClassPtrType (
[+] 	return classType->getClassPtrType(
[-] DeclTypeCalc::getFunctionPtrType (FunctionType* functionType)
[+] DeclTypeCalc::getFunctionPtrType(FunctionType* functionType)
[-] 	return functionType->getFunctionPtrType (ptrTypeKind);
[+] 	return functionType->getFunctionPtrType(ptrTypeKind);
[-] DeclTypeCalc::getPropertyPtrType (PropertyType* propertyType)
[+] DeclTypeCalc::getPropertyPtrType(PropertyType* propertyType)
[-] 	return propertyType->getPropertyPtrType (ptrTypeKind);
[+] 	return propertyType->getPropertyPtrType(ptrTypeKind);
[-] DeclTypeCalc::getImportPtrType (NamedImportType* importType)
[+] DeclTypeCalc::getImportPtrType(NamedImportType* importType)
[-] 	return m_module->m_typeMgr.getImportPtrType (importType, typeModifiers);
[+] 	return m_module->m_typeMgr.getImportPtrType(importType, typeModifiers);
[-] DeclTypeCalc::getImportIntModType (NamedImportType* importType)
[+] DeclTypeCalc::getImportIntModType(NamedImportType* importType)
[-] 	return m_module->m_typeMgr.getImportIntModType (importType, typeModifiers);
[+] 	return m_module->m_typeMgr.getImportIntModType(importType, typeModifiers);
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_Lexer.cpp
----------------------
[-] isByteStringSep (uchar_t c)
[+] isByteStringSep(uchar_t c)
[-] 	switch (c)
[+] 	switch(c)
[-] decodeByteString (
[+] decodeByteString(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	ASSERT (radix == 2 || radix == 8 || radix == 10 || radix == 16);
[+] 	ASSERT(radix == 2 || radix == 8 || radix == 10 || radix == 16);
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	buffer->reserve (string.getLength () / 2); // good estimate no matter the radix
[+] 	buffer->reserve(string.getLength() / 2); // good estimate no matter the radix
[-] 	char byteBuffer [16] = { 0 }; // big enough to fit byte in any radix
[+] 	char byteBuffer[16] = { 0 }; // big enough to fit byte in any radix
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 		bool_t isSep = isByteStringSep (c);
[+] 		bool_t isSep = isByteStringSep(c);
[-] 		switch (state)
[+] 		switch(state)
[-] 			byteBuffer [0] = c;
[+] 			byteBuffer[0] = c;
[-] 				byteBuffer [byteLength++] = c;
[+] 				byteBuffer[byteLength++] = c;
[-] 			byteBuffer [byteLength] = 0;
[+] 			byteBuffer[byteLength] = 0;
[-] 			x = (uchar_t) strtoul (byteBuffer, &byteEnd, radix);
[+] 			x = (uchar_t)strtoul(byteBuffer, &byteEnd, radix);
[-] 			if (byteEnd == &byteBuffer [byteLength])
[+] 			if (byteEnd == &byteBuffer[byteLength])
[-] 				buffer->append (x);
[+] 				buffer->append(x);
[-] 		byteBuffer [byteLength] = 0;
[+] 		byteBuffer[byteLength] = 0;
[-] 		x = (uchar_t) strtoul (byteBuffer, &byteEnd, radix);
[+] 		x = (uchar_t)strtoul(byteBuffer, &byteEnd, radix);
[-] 		if (byteEnd == &byteBuffer [byteLength])
[+] 		if (byteEnd == &byteBuffer[byteLength])
[-] 			buffer->append (x);
[+] 			buffer->append(x);
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] Lexer::Lexer ()
[+] Lexer::Lexer()
[-] Lexer::createKeywordTokenEx (
[+] Lexer::createKeywordTokenEx(
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] Lexer::createStringToken (
[+] Lexer::createStringToken(
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] 	ASSERT (token->m_pos.m_length >= left + right);
[+] 	ASSERT(token->m_pos.m_length >= left + right);
[-] 		token->m_data.m_string = enc::EscapeEncoding::decode (sl::StringRef (ts + left, length));
[+] 		token->m_data.m_string = enc::EscapeEncoding::decode(sl::StringRef(ts + left, length));
[-] 		token->m_data.m_string = sl::StringRef (ts + left, length);
[+] 		token->m_data.m_string = sl::StringRef(ts + left, length);
[-] Lexer::createSourceFileToken ()
[+] Lexer::createSourceFileToken()
[-] 	Token* token = createToken (TokenKind_Literal);
[+] 	Token* token = createToken(TokenKind_Literal);
[-] Lexer::createSourceDirToken ()
[+] Lexer::createSourceDirToken()
[-] 	if (m_dir.isEmpty ())
[+] 	if (m_dir.isEmpty())
[-] 		m_dir = m_filePath.isEmpty () ?
[+] 		m_dir = m_filePath.isEmpty() ?
[-] 			io::getCurrentDir () :
[+] 			io::getCurrentDir() :
[-] 			io::getDir (m_filePath);
[+] 			io::getDir(m_filePath);
[-] 	Token* token = createToken (TokenKind_Literal);
[+] 	Token* token = createToken(TokenKind_Literal);
[-] Lexer::createBinLiteralToken (int radix)
[+] Lexer::createBinLiteralToken(int radix)
[-] 	Token* token = createToken (TokenKind_BinLiteral);
[+] 	Token* token = createToken(TokenKind_BinLiteral);
[-] 	ASSERT (token->m_pos.m_length >= 4);
[+] 	ASSERT(token->m_pos.m_length >= 4);
[-] 	decodeByteString (&token->m_data.m_binData, radix, sl::StringRef (ts + 3, token->m_pos.m_length - 4));
[+] 	decodeByteString(&token->m_data.m_binData, radix, sl::StringRef(ts + 3, token->m_pos.m_length - 4));
[-] Lexer::createCharToken (
[+] Lexer::createCharToken(
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] 	ASSERT (token->m_pos.m_length >= 2);
[+] 	ASSERT(token->m_pos.m_length >= 2);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		enc::EscapeEncoding::decode (&string, sl::StringRef (ts + left, length));
[+] 		enc::EscapeEncoding::decode(&string, sl::StringRef(ts + left, length));
[-] 		length = string.getLength ();
[+] 		length = string.getLength();
[-] 	if (length > sizeof (int))
[+] 	if (length > sizeof(int))
[-] 		length = sizeof (int);
[+] 		length = sizeof(int);
[-] Lexer::createIntegerToken (
[+] Lexer::createIntegerToken(
[-] 	Token* token = createToken (TokenKind_Integer);
[+] 	Token* token = createToken(TokenKind_Integer);
[-] 	token->m_data.m_int64_u = _strtoui64 (ts + left, NULL, radix);
[+] 	token->m_data.m_int64_u = _strtoui64(ts + left, NULL, radix);
[-] Lexer::createFpToken ()
[+] Lexer::createFpToken()
[-] 	Token* token = createToken (TokenKind_Fp);
[+] 	Token* token = createToken(TokenKind_Fp);
[-] 	token->m_data.m_double = strtod (ts, NULL);
[+] 	token->m_data.m_double = strtod(ts, NULL);
[-] Lexer::createConstIntegerToken (int value)
[+] Lexer::createConstIntegerToken(int value)
[-] 	Token* token = createToken (TokenKind_Integer);
[+] 	Token* token = createToken(TokenKind_Integer);
[-] Lexer::preCreateMlLiteralToken (int radix)
[+] Lexer::preCreateMlLiteralToken(int radix)
[-] 	ASSERT (!m_mlLiteralToken);
[+] 	ASSERT(!m_mlLiteralToken);
[-] 	m_mlLiteralToken = preCreateToken (0);
[+] 	m_mlLiteralToken = preCreateToken(0);
[-] getWsPrefixLength (const sl::StringRef& string)
[+] getWsPrefixLength(const sl::StringRef& string)
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] normalizeMlLiteral (
[+] normalizeMlLiteral(
[-] 	size_t prefixLength = prefix.getLength ();
[+] 	size_t prefixLength = prefix.getLength();
[-] 	ASSERT (source.getLength () >= prefixLength);
[+] 	ASSERT(source.getLength() >= prefixLength);
[-] 	string->clear ();
[+] 	string->clear();
[-] 	const char* p = source.cp ();
[+] 	const char* p = source.cp();
[-] 	const char* end = source.getEnd ();
[+] 	const char* end = source.getEnd();
[-] 		ASSERT (chunkLength > prefixLength);
[+] 		ASSERT(chunkLength > prefixLength);
[-] 		size_t linePrefixLength = getWsPrefixLength (sl::StringRef (p, chunkLength));
[+] 		size_t linePrefixLength = getWsPrefixLength(sl::StringRef(p, chunkLength));
[-] 		bool isEmpty = p [linePrefixLength] == '\n';
[+] 		bool isEmpty = p[linePrefixLength] == '\n';
[-] 			if (linePrefixLength && p [linePrefixLength - 1] == '\r')
[+] 			if (linePrefixLength && p[linePrefixLength - 1] == '\r')
[-] 				string->append ("\r\n", 2);
[+] 				string->append("\r\n", 2);
[-] 				string->append ('\n');
[+] 				string->append('\n');
[-] 			if (linePrefixLength < prefixLength || memcmp (p, prefix.cp (), prefixLength) != 0)
[+] 			if (linePrefixLength < prefixLength || memcmp(p, prefix.cp(), prefixLength) != 0)
[-] 			const char* nl = strchr (p, '\n');
[+] 			const char* nl = strchr(p, '\n');
[-] 			ASSERT (nl);
[+] 			ASSERT(nl);
[-] 			string->append (p, nl - p + 1);
[+] 			string->append(p, nl - p + 1);
[-] Lexer::createMlLiteralToken ()
[+] Lexer::createMlLiteralToken()
[-] 	ASSERT (m_mlLiteralToken);
[+] 	ASSERT(m_mlLiteralToken);
[-] 	ASSERT (token->m_pos.m_length >= left + right);
[+] 	ASSERT(token->m_pos.m_length >= left + right);
[-] 		decodeByteString (&token->m_data.m_binData, radix, sl::StringRef (p, length));
[+] 		decodeByteString(&token->m_data.m_binData, radix, sl::StringRef(p, length));
[-] 		token->m_data.m_string = sl::StringRef (p, length);
[+] 		token->m_data.m_string = sl::StringRef(p, length);
[-] 		if (right > 3 && ts [-1] == '\n')
[+] 		if (right > 3 && ts[-1] == '\n')
[-] 			bool hasCommonPrefix = normalizeMlLiteral (&normalizedString, sl::StringRef (p, length), sl::StringRef (ts, right - 3));
[+] 			bool hasCommonPrefix = normalizeMlLiteral(&normalizedString, sl::StringRef(p, length), sl::StringRef(ts, right - 3));
[-] Lexer::preCreateFmtLiteralToken ()
[+] Lexer::preCreateFmtLiteralToken()
[-] 	ASSERT (!m_fmtLiteralToken);
[+] 	ASSERT(!m_fmtLiteralToken);
[-] 	m_fmtLiteralToken = preCreateToken (0);
[+] 	m_fmtLiteralToken = preCreateToken(0);
[-] Lexer::createFmtLiteralToken (
[+] Lexer::createFmtLiteralToken(
[-] 	ASSERT (m_fmtLiteralToken);
[+] 	ASSERT(m_fmtLiteralToken);
[-] 	ASSERT (token->m_pos.m_length >= left + right);
[+] 	ASSERT(token->m_pos.m_length >= left + right);
[-] 	token->m_data.m_string = enc::EscapeEncoding::decode (sl::StringRef (
[+] 	token->m_data.m_string = enc::EscapeEncoding::decode(sl::StringRef(
[-] Lexer::createFmtSimpleIdentifierTokens ()
[+] Lexer::createFmtSimpleIdentifierTokens()
[-] 	createFmtLiteralToken (TokenKind_FmtLiteral, false);
[+] 	createFmtLiteralToken(TokenKind_FmtLiteral, false);
[-] 	createStringToken (TokenKind_Identifier, 1, 0);
[+] 	createStringToken(TokenKind_Identifier, 1, 0);
[-] 	preCreateFmtLiteralToken ();
[+] 	preCreateFmtLiteralToken();
[-] Lexer::createFmtLastErrorDescriptionTokens ()
[+] Lexer::createFmtLastErrorDescriptionTokens()
[-] 	createFmtLiteralToken (TokenKind_FmtLiteral, false);
[+] 	createFmtLiteralToken(TokenKind_FmtLiteral, false);
[-] 	Token* token = createToken (TokenKind_Identifier);
[+] 	Token* token = createToken(TokenKind_Identifier);
[-] 	createToken ('.');
[+] 	createToken('.');
[-] 	token = createToken (TokenKind_Identifier);
[+] 	token = createToken(TokenKind_Identifier);
[-] 	createToken ('(');
[+] 	createToken('(');
[-] 	createToken (')');
[+] 	createToken(')');
[-] 	createToken ('.');
[+] 	createToken('.');
[-] 	token = createToken (TokenKind_Identifier);
[+] 	token = createToken(TokenKind_Identifier);
[-] 	preCreateFmtLiteralToken ();
[+] 	preCreateFmtLiteralToken();
[-] Lexer::createFmtIndexTokens ()
[+] Lexer::createFmtIndexTokens()
[-] 	createFmtLiteralToken (TokenKind_FmtLiteral, true);
[+] 	createFmtLiteralToken(TokenKind_FmtLiteral, true);
[-] 	createIntegerToken (10, 1);
[+] 	createIntegerToken(10, 1);
[-] 	preCreateFmtLiteralToken ();
[+] 	preCreateFmtLiteralToken();
[-] Lexer::createFmtSpecifierToken ()
[+] Lexer::createFmtSpecifierToken()
[-] 	ASSERT (*ts == ';');
[+] 	ASSERT(*ts == ';');
[-] 	return ts < te ? createStringToken (TokenKind_FmtSpecifier) : NULL;
[+] 	return ts < te ? createStringToken(TokenKind_FmtSpecifier) : NULL;
[-] Lexer::createDoxyCommentToken (TokenKind tokenKind)
[+] Lexer::createDoxyCommentToken(TokenKind tokenKind)
[-] 	ASSERT (te - ts >= 3 && *ts == '/');
[+] 	ASSERT(te - ts >= 3 && *ts == '/');
[-] 		ASSERT (ts [1] == '*' && te [-1] == '/' && te [-2] == '*');
[+] 		ASSERT(ts[1] == '*' && te[-1] == '/' && te[-2] == '*');
[-] 	Token* token = createStringToken (tokenKind, 3, right);
[+] 	Token* token = createStringToken(tokenKind, 3, right);
[-] Lexer::onLeftParentheses ()
[+] Lexer::onLeftParentheses()
[-] 	if (!m_parenthesesLevelStack.isEmpty ())
[+] 	if (!m_parenthesesLevelStack.isEmpty())
[-] 		m_parenthesesLevelStack [m_parenthesesLevelStack.getCount () - 1]++;
[+] 		m_parenthesesLevelStack[m_parenthesesLevelStack.getCount() - 1]++;
[-] 	createToken ('(');
[+] 	createToken('(');
[-] Lexer::onRightParentheses ()
[+] Lexer::onRightParentheses()
[-] 	if (!m_parenthesesLevelStack.isEmpty ())
[+] 	if (!m_parenthesesLevelStack.isEmpty())
[-] 		size_t i = m_parenthesesLevelStack.getCount () - 1;
[+] 		size_t i = m_parenthesesLevelStack.getCount() - 1;
[-] 		if (m_parenthesesLevelStack [i] == 1)
[+] 		if (m_parenthesesLevelStack[i] == 1)
[-] 			m_parenthesesLevelStack.pop ();
[+] 			m_parenthesesLevelStack.pop();
[-] 			preCreateFmtLiteralToken ();
[+] 			preCreateFmtLiteralToken();
[-] 		m_parenthesesLevelStack [i]--;
[+] 		m_parenthesesLevelStack[i]--;
[-] 	createToken (')');
[+] 	createToken(')');
[-] Lexer::onSemicolon ()
[+] Lexer::onSemicolon()
[-] 	ASSERT (*ts == ';');
[+] 	ASSERT(*ts == ';');
[-] 	if (!m_parenthesesLevelStack.isEmpty ())
[+] 	if (!m_parenthesesLevelStack.isEmpty())
[-] 		size_t i = m_parenthesesLevelStack.getCount () - 1;
[+] 		size_t i = m_parenthesesLevelStack.getCount() - 1;
[-] 		if (m_parenthesesLevelStack [i] == 1)
[+] 		if (m_parenthesesLevelStack[i] == 1)
[-] 	createToken (';');
[+] 	createToken(';');
[-] Lexer::terminateFmtSpecifier ()
[+] Lexer::terminateFmtSpecifier()
[-] 	ASSERT (!m_parenthesesLevelStack.isEmpty () && m_fmtLiteralToken == NULL);
[+] 	ASSERT(!m_parenthesesLevelStack.isEmpty() && m_fmtLiteralToken == NULL);
[-] 	m_parenthesesLevelStack.pop ();
[+] 	m_parenthesesLevelStack.pop();
[-] 	preCreateFmtLiteralToken ();
[+] 	preCreateFmtLiteralToken();
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_Parser.cpp
----------------------
[-] Parser::Parser (Module* module):
[+] Parser::Parser(Module* module):
[-] 	m_doxyParser (module)
[+] 	m_doxyParser(module)
[-] Parser::parseTokenList (
[+] Parser::parseTokenList(
[-] 	const sl::ConstBoxList <Token>& tokenList,
[+] 	const sl::ConstBoxList<Token>& tokenList,
[-] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	Unit* unit = m_module->m_unitMgr.getCurrentUnit();
[-] 	ASSERT (unit);
[+] 	ASSERT(unit);
[-] 	ASSERT (!tokenList.isEmpty ());
[+] 	ASSERT(!tokenList.isEmpty());
[-] 	create (symbol, isBuildingAst);
[+] 	create(symbol, isBuildingAst);
[-] 	sl::ConstBoxIterator <Token> token = tokenList.getHead ();
[+] 	sl::ConstBoxIterator<Token> token = tokenList.getHead();
[-] 		result = parseToken (&*token);
[+] 		result = parseToken(&*token);
[-] 			lex::ensureSrcPosError (unit->getFilePath (), token->m_pos.m_line, token->m_pos.m_col);
[+] 			lex::ensureSrcPosError(unit->getFilePath(), token->m_pos.m_line, token->m_pos.m_col);
[-] 	Token::Pos pos = tokenList.getTail ()->m_pos;
[+] 	Token::Pos pos = tokenList.getTail()->m_pos;
[-] 	result = parseToken (&eofToken);
[+] 	result = parseToken(&eofToken);
[-] 		lex::ensureSrcPosError (unit->getFilePath (), eofToken.m_pos.m_line, eofToken.m_pos.m_col);
[+] 		lex::ensureSrcPosError(unit->getFilePath(), eofToken.m_pos.m_line, eofToken.m_pos.m_col);
[-] Parser::isTypeSpecified ()
[+] Parser::isTypeSpecified()
[-] 	if (m_typeSpecifierStack.isEmpty ())
[+] 	if (m_typeSpecifierStack.isEmpty())
[-] 	TypeSpecifier* typeSpecifier = m_typeSpecifierStack.getBack ();
[+] 	TypeSpecifier* typeSpecifier = m_typeSpecifierStack.getBack();
[-] 		typeSpecifier->getType () != NULL ||
[+] 		typeSpecifier->getType() != NULL ||
[-] 		typeSpecifier->getTypeModifiers () & (TypeModifier_Unsigned | TypeModifier_Property | TypeModifier_Reactor);
[+] 		typeSpecifier->getTypeModifiers() & (TypeModifier_Unsigned | TypeModifier_Property | TypeModifier_Reactor);
[-] Parser::getNamedImportType (
[+] Parser::getNamedImportType(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamedImportType* type = m_module->m_typeMgr.getNamedImportType (name, nspace);
[+] 	NamedImportType* type = m_module->m_typeMgr.getNamedImportType(name, nspace);
[-] 		type->m_parentUnit = m_module->m_unitMgr.getCurrentUnit ();
[+] 		type->m_parentUnit = m_module->m_unitMgr.getCurrentUnit();
[-] Parser::findType (
[+] Parser::findType(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 		if (!name.isSimple ())
[+] 		if (!name.isSimple())
[-] 			return getNamedImportType (name, pos);
[+] 			return getNamedImportType(name, pos);
[-] 		sl::String shortName = name.getShortName ();
[+] 		sl::String shortName = name.getShortName();
[-] 		item = nspace->findItem (shortName);
[+] 		item = nspace->findItem(shortName);
[-] 			return getNamedImportType (name, pos);
[+] 			return getNamedImportType(name, pos);
[-] 			DerivableType* baseType = findBaseType (baseTypeIdx);
[+] 			DerivableType* baseType = findBaseType(baseTypeIdx);
[-] 			if (name.isEmpty ())
[+] 			if (name.isEmpty())
[-] 		item = nspace->findItemTraverse (name);
[+] 		item = nspace->findItemTraverse(name);
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		return (Type*) item;
[+] 		return (Type*)item;
[-] 		return (m_module->getCompileFlags () & ModuleCompileFlag_KeepTypedefShadow) ?
[+] 		return (m_module->getCompileFlags() & ModuleCompileFlag_KeepTypedefShadow) ?
[-] 			((Typedef*) item)->getShadowType () :
[+] 			((Typedef*)item)->getShadowType() :
[-] 			((Typedef*) item)->getType ();
[+] 			((Typedef*)item)->getType();
[-] Parser::getType (
[+] Parser::getType(
[-] 	Type* type = findType (baseTypeIdx, name, pos);
[+] 	Type* type = findType(baseTypeIdx, name, pos);
[-] 			err::setFormatStringError ("'%s' is not found or not a type", name.getFullName ().sz ());
[+] 			err::setFormatStringError("'%s' is not found or not a type", name.getFullName ().sz ());
[-] 		else if (name.isEmpty ())
[+] 		else if (name.isEmpty())
[-] 			err::setFormatStringError ("'basetype%d' is not found", baseTypeIdx + 1);
[+] 			err::setFormatStringError("'basetype%d' is not found", baseTypeIdx + 1);
[-] 			err::setFormatStringError ("'basetype%d.%s' is not found or not a type", baseTypeIdx + 1, name.getFullName ().sz ());
[+] 			err::setFormatStringError("'basetype%d.%s' is not found or not a type", baseTypeIdx + 1, name.getFullName ().sz ());
[-] Parser::setSetAsType (Type* type)
[+] Parser::setSetAsType(Type* type)
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (nspace->getNamespaceKind () != NamespaceKind_Type)
[+] 	if (nspace->getNamespaceKind() != NamespaceKind_Type)
[-] 		err::setFormatStringError ("invalid setas in '%s'", nspace->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("invalid setas in '%s'", nspace->getQualifiedName ().sz ());
[-] 	DerivableType* derivableType = (DerivableType*) (NamedType*) nspace;
[+] 	DerivableType* derivableType = (DerivableType*)(NamedType*)nspace;
[-] 		err::setFormatStringError ("setas redefinition for '%s'", derivableType->getTypeString ().sz ());
[+] 		err::setFormatStringError("setas redefinition for '%s'", derivableType->getTypeString ().sz ());
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup (&derivableType->m_setAsType);
[+] 		((ImportType*)type)->addFixup(&derivableType->m_setAsType);
[-] Parser::preDeclaration ()
[+] Parser::preDeclaration()
[-] Parser::bodylessDeclaration ()
[+] Parser::bodylessDeclaration()
[-] 	ASSERT (m_lastDeclaredItem);
[+] 	ASSERT(m_lastDeclaredItem);
[-] 	ModuleItemKind itemKind = m_lastDeclaredItem->getItemKind ();
[+] 	ModuleItemKind itemKind = m_lastDeclaredItem->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		return finalizeLastProperty (false);
[+] 		return finalizeLastProperty(false);
[-] 		err::setFormatStringError ("orphan '%s' without a body", m_lastDeclaredItem->m_tag.sz ());
[+] 		err::setFormatStringError("orphan '%s' without a body", m_lastDeclaredItem->m_tag.sz ());
[-] Parser::setDeclarationBody (sl::BoxList <Token>* tokenList)
[+] Parser::setDeclarationBody(sl::BoxList<Token>* tokenList)
[-] 		err::setFormatStringError ("declaration without declarator cannot have a body");
[+] 		err::setFormatStringError("declaration without declarator cannot have a body");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	ModuleItemKind itemKind = m_lastDeclaredItem->getItemKind ();
[+] 	ModuleItemKind itemKind = m_lastDeclaredItem->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		if (nspace->getNamespaceKind () == NamespaceKind_DynamicLib)
[+] 		if (nspace->getNamespaceKind() == NamespaceKind_DynamicLib)
[-] 			err::setFormatStringError ("dynamiclib function cannot have a body");
[+] 			err::setFormatStringError("dynamiclib function cannot have a body");
[-] 		function = (Function*) m_lastDeclaredItem;
[+] 		function = (Function*)m_lastDeclaredItem;
[-] 		function->addUsingSet (nspace);
[+] 		function->addUsingSet(nspace);
[-] 		return function->setBody (tokenList);
[+] 		return function->setBody(tokenList);
[-] 		return parseLastPropertyBody (*tokenList);
[+] 		return parseLastPropertyBody(*tokenList);
[-] 		type = ((Typedef*) m_lastDeclaredItem)->getType ();
[+] 		type = ((Typedef*)m_lastDeclaredItem)->getType();
[-] 		type = (Type*) m_lastDeclaredItem;
[+] 		type = (Type*)m_lastDeclaredItem;
[-] 		type = ((Variable*) m_lastDeclaredItem)->getType ();
[+] 		type = ((Variable*)m_lastDeclaredItem)->getType();
[-] 		type = ((StructField*) m_lastDeclaredItem)->getType ();
[+] 		type = ((StructField*)m_lastDeclaredItem)->getType();
[-] 		orphan = (Orphan*) m_lastDeclaredItem;
[+] 		orphan = (Orphan*)m_lastDeclaredItem;
[-] 		orphan->addUsingSet (nspace);
[+] 		orphan->addUsingSet(nspace);
[-] 		return orphan->setBody (tokenList);
[+] 		return orphan->setBody(tokenList);
[-] 		err::setFormatStringError ("'%s' cannot have a body", getModuleItemKindString (m_lastDeclaredItem->getItemKind ()));
[+] 		err::setFormatStringError("'%s' cannot have a body", getModuleItemKindString (m_lastDeclaredItem->getItemKind ()));
[-] 	if (!isClassType (type, ClassTypeKind_Reactor))
[+] 	if (!isClassType(type, ClassTypeKind_Reactor))
[-] 		err::setFormatStringError ("only functions and reactors can have bodies, not '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("only functions and reactors can have bodies, not '%s'", type->getTypeString ().sz ());
[-] 	return ((ReactorClassType*) type)->setBody (tokenList);
[+] 	return ((ReactorClassType*)type)->setBody(tokenList);
[-] Parser::setStorageKind (StorageKind storageKind)
[+] Parser::setStorageKind(StorageKind storageKind)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getStorageKindString (m_storageKind),
[+] 			getStorageKindString(m_storageKind),
[-] 			getStorageKindString (storageKind)
[+] 			getStorageKindString(storageKind)
[-] Parser::setAccessKind (AccessKind accessKind)
[+] Parser::setAccessKind(AccessKind accessKind)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getAccessKindString (m_accessKind),
[+] 			getAccessKindString(m_accessKind),
[-] 			getAccessKindString (accessKind)
[+] 			getAccessKindString(accessKind)
[-] Parser::postDeclaratorName (Declarator* declarator)
[+] Parser::postDeclaratorName(Declarator* declarator)
[-] 	if (!m_topDeclarator->isQualified () || declarator->m_baseType->getTypeKind () != TypeKind_NamedImport)
[+] 	if (!m_topDeclarator->isQualified() || declarator->m_baseType->getTypeKind() != TypeKind_NamedImport)
[-] 	if (m_topDeclarator->getDeclaratorKind () == DeclaratorKind_Name)
[+] 	if (m_topDeclarator->getDeclaratorKind() == DeclaratorKind_Name)
[-] 		anchorName.removeLastName ();
[+] 		anchorName.removeLastName();
[-] 	ASSERT (!anchorName.isEmpty ());
[+] 	ASSERT(!anchorName.isEmpty());
[-] 	declarator->m_baseType = ((NamedImportType*) declarator->m_baseType)->setAnchorName (anchorName);
[+] 	declarator->m_baseType = ((NamedImportType*)declarator->m_baseType)->setAnchorName(anchorName);
[-] Parser::postDeclarator (Declarator* declarator)
[+] Parser::postDeclarator(Declarator* declarator)
[-] 	ASSERT (m_topDeclarator);
[+] 	ASSERT(m_topDeclarator);
[-] Parser::getGlobalNamespace (
[+] Parser::getGlobalNamespace(
[-] 	ModuleItem* item = parentNamespace->findItem (name);
[+] 	ModuleItem* item = parentNamespace->findItem(name);
[-] 		nspace = m_module->m_namespaceMgr.createGlobalNamespace (name, parentNamespace);
[+] 		nspace = m_module->m_namespaceMgr.createGlobalNamespace(name, parentNamespace);
[-] 		nspace->m_parentUnit = m_module->m_unitMgr.getCurrentUnit ();
[+] 		nspace->m_parentUnit = m_module->m_unitMgr.getCurrentUnit();
[-] 		parentNamespace->addItem (nspace);
[+] 		parentNamespace->addItem(nspace);
[-] 		if (item->getItemKind () != ModuleItemKind_Namespace)
[+] 		if (item->getItemKind() != ModuleItemKind_Namespace)
[-] 			err::setFormatStringError ("'%s' exists and is not a namespace", parentNamespace->createQualifiedName (name).sz ());
[+] 			err::setFormatStringError("'%s' exists and is not a namespace", parentNamespace->createQualifiedName (name).sz ());
[-] 		nspace = (GlobalNamespace*) item;
[+] 		nspace = (GlobalNamespace*)item;
[-] Parser::openGlobalNamespace (
[+] Parser::openGlobalNamespace(
[-] 	Namespace* currentNamespace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* currentNamespace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (currentNamespace->getNamespaceKind () != NamespaceKind_Global)
[+] 	if (currentNamespace->getNamespaceKind() != NamespaceKind_Global)
[-] 		err::setFormatStringError ("cannot open global namespace in '%s'", getNamespaceKindString (currentNamespace->getNamespaceKind ()));
[+] 		err::setFormatStringError("cannot open global namespace in '%s'", getNamespaceKindString (currentNamespace->getNamespaceKind ()));
[-] 	GlobalNamespace* nspace = getGlobalNamespace ((GlobalNamespace*) currentNamespace, name.getFirstName (), pos);
[+] 	GlobalNamespace* nspace = getGlobalNamespace((GlobalNamespace*)currentNamespace, name.getFirstName(), pos);
[-] 	if (nspace->getFlags () & ModuleItemFlag_Sealed)
[+] 	if (nspace->getFlags() & ModuleItemFlag_Sealed)
[-] 		err::setFormatStringError ("cannot extend sealed namespace '%s'", nspace->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("cannot extend sealed namespace '%s'", nspace->getQualifiedName ().sz ());
[-] 	sl::ConstBoxIterator <sl::String> it = name.getNameList ().getHead ();
[+] 	sl::ConstBoxIterator<sl::String> it = name.getNameList().getHead();
[-] 		nspace = getGlobalNamespace (nspace, *it, pos);
[+] 		nspace = getGlobalNamespace(nspace, *it, pos);
[-] 	m_module->m_namespaceMgr.openNamespace (nspace);
[+] 	m_module->m_namespaceMgr.openNamespace(nspace);
[-] Parser::openExtensionNamespace (
[+] Parser::openExtensionNamespace(
[-] 	Namespace* currentNamespace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* currentNamespace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	ExtensionNamespace* extensionNamespace = m_module->m_namespaceMgr.createExtensionNamespace (
[+] 	ExtensionNamespace* extensionNamespace = m_module->m_namespaceMgr.createExtensionNamespace(
[-] 	bool result = currentNamespace->addItem (extensionNamespace);
[+] 	bool result = currentNamespace->addItem(extensionNamespace);
[-] 	m_module->m_namespaceMgr.openNamespace (extensionNamespace);
[+] 	m_module->m_namespaceMgr.openNamespace(extensionNamespace);
[-] Parser::useNamespace (
[+] Parser::useNamespace(
[-] 	const sl::BoxList <QualifiedName>& nameList,
[+] 	const sl::BoxList<QualifiedName>& nameList,
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState () < ModuleCompileState_Linked ?
[+] 	NamespaceMgr* importNamespaceMgr = m_module->getCompileState() < ModuleCompileState_Linked ?
[-] 	sl::ConstBoxIterator <QualifiedName> it = nameList.getHead ();
[+] 	sl::ConstBoxIterator<QualifiedName> it = nameList.getHead();
[-] 		result = nspace->m_usingSet.addNamespace (importNamespaceMgr, nspace, namespaceKind, *it);
[+] 		result = nspace->m_usingSet.addNamespace(importNamespaceMgr, nspace, namespaceKind, *it);
[-] Parser::popAttributeBlock ()
[+] Parser::popAttributeBlock()
[-] Parser::declareInReaction (Declarator* declarator)
[+] Parser::declareInReaction(Declarator* declarator)
[-] 	ASSERT (m_stage == Stage_Reaction && m_reactorType);
[+] 	ASSERT(m_stage == Stage_Reaction && m_reactorType);
[-] 	if (!declarator->isSimple ())
[+] 	if (!declarator->isSimple())
[-] 		err::setFormatStringError ("invalid declarator in reactor");
[+] 		err::setFormatStringError("invalid declarator in reactor");
[-] 	sl::String name = declarator->getName ()->getShortName ();
[+] 	sl::String name = declarator->getName()->getShortName();
[-] 	m_lastDeclaredItem = m_reactorType->findItem (name);
[+] 	m_lastDeclaredItem = m_reactorType->findItem(name);
[-] 		err::setFormatStringError ("member '%s' not found in reactor '%s'", name.sz (), m_reactorType->m_tag.sz ());
[+] 		err::setFormatStringError("member '%s' not found in reactor '%s'", name.sz (), m_reactorType->m_tag.sz ());
[-] 	if (declarator->m_initializer.isEmpty ())
[+] 	if (declarator->m_initializer.isEmpty())
[-] 	token.m_pos = declarator->m_initializer.getHead ()->m_pos;
[+] 	token.m_pos = declarator->m_initializer.getHead()->m_pos;
[-] 	declarator->m_initializer.insertHead (token);
[+] 	declarator->m_initializer.insertHead(token);
[-] 	declarator->m_initializer.insertHead (token);
[+] 	declarator->m_initializer.insertHead(token);
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	return parser.parseTokenList (SymbolKind_expression, declarator->m_initializer);
[+] 	return parser.parseTokenList(SymbolKind_expression, declarator->m_initializer);
[-] Parser::declare (Declarator* declarator)
[+] Parser::declare(Declarator* declarator)
[-] 		return declareInReaction (declarator);
[+] 		return declareInReaction(declarator);
[-] 	bool isLibrary = m_module->m_namespaceMgr.getCurrentNamespace ()->getNamespaceKind () == NamespaceKind_DynamicLib;
[+] 	bool isLibrary = m_module->m_namespaceMgr.getCurrentNamespace()->getNamespaceKind() == NamespaceKind_DynamicLib;
[-] 	if ((declarator->getTypeModifiers () & TypeModifier_Property) && m_storageKind != StorageKind_Typedef)
[+] 	if ((declarator->getTypeModifiers() & TypeModifier_Property) && m_storageKind != StorageKind_Typedef)
[-] 			err::setFormatStringError ("only functions can be part of library");
[+] 			err::setFormatStringError("only functions can be part of library");
[-] 		return declareProperty (declarator, NULL, 0);
[+] 		return declareProperty(declarator, NULL, 0);
[-] 	Type* type = declarator->calcType (&declFlags);
[+] 	Type* type = declarator->calcType(&declFlags);
[-] 	DeclaratorKind declaratorKind = declarator->getDeclaratorKind ();
[+] 	DeclaratorKind declaratorKind = declarator->getDeclaratorKind();
[-] 	uint_t postModifiers = declarator->getPostDeclaratorModifiers ();
[+] 	uint_t postModifiers = declarator->getPostDeclaratorModifiers();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 		err::setFormatStringError ("only functions can be part of library");
[+] 		err::setFormatStringError("only functions can be part of library");
[-] 		err::setFormatStringError ("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[+] 		err::setFormatStringError("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[-] 	switch (m_storageKind)
[+] 	switch(m_storageKind)
[-] 		return declareTypedef (declarator, type);
[+] 		return declareTypedef(declarator, type);
[-] 		return declareAlias (declarator, type, declFlags);
[+] 		return declareAlias(declarator, type, declFlags);
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 			err::setFormatStringError ("illegal use of type 'void'");
[+] 			err::setFormatStringError("illegal use of type 'void'");
[-] 			return declareFunction (declarator, (FunctionType*) type);
[+] 			return declareFunction(declarator, (FunctionType*)type);
[-] 			return declareProperty (declarator, (PropertyType*) type, declFlags);
[+] 			return declareProperty(declarator, (PropertyType*)type, declFlags);
[-] 			return type->getStdType () == StdType_ReactorBase ?
[+] 			return type->getStdType() == StdType_ReactorBase ?
[-] 				declareReactor (declarator, declFlags) :
[+] 				declareReactor(declarator, declFlags) :
[-] 				declareData (declarator, type, declFlags);
[+] 				declareData(declarator, type, declFlags);
[-] Parser::assignDeclarationAttributes (
[+] Parser::assignDeclarationAttributes(
[-] 		m_module->m_namespaceMgr.getCurrentAccessKind ();
[+] 		m_module->m_namespaceMgr.getCurrentAccessKind();
[-] 	decl->m_parentUnit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	decl->m_parentUnit = m_module->m_unitMgr.getCurrentUnit();
[-] 	decl->m_parentNamespace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	decl->m_parentNamespace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	decl->m_attributeBlock = attributeBlock ? attributeBlock : popAttributeBlock ();
[+] 	decl->m_attributeBlock = attributeBlock ? attributeBlock : popAttributeBlock();
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_Documentation)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_Documentation)
[-] 		item->setDoxyBlock (doxyBlock ? doxyBlock : m_doxyParser.popBlock ());
[+] 		item->setDoxyBlock(doxyBlock ? doxyBlock : m_doxyParser.popBlock());
[-] Parser::declareTypedef (
[+] Parser::declareTypedef(
[-] 	ASSERT (m_storageKind == StorageKind_Typedef);
[+] 	ASSERT(m_storageKind == StorageKind_Typedef);
[-] 	if (!declarator->isSimple ())
[+] 	if (!declarator->isSimple())
[-] 		err::setFormatStringError ("invalid typedef declarator");
[+] 		err::setFormatStringError("invalid typedef declarator");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	sl::String name = declarator->getName ()->getShortName ();
[+] 	sl::String name = declarator->getName()->getShortName();
[-] 	ModuleItem* prevItem = nspace->findItem (name);
[+] 	ModuleItem* prevItem = nspace->findItem(name);
[-] 		if (prevItem->getItemKind () != ModuleItemKind_Typedef ||
[+] 		if (prevItem->getItemKind() != ModuleItemKind_Typedef ||
[-] 			((Typedef*) prevItem)->getType ()->cmp (type) != 0)
[+] 			((Typedef*)prevItem)->getType()->cmp(type) != 0)
[-] 			setRedefinitionError (name);
[+] 			setRedefinitionError(name);
[-] 		m_doxyParser.popBlock ();
[+] 		m_doxyParser.popBlock();
[-] 	sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 	sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 	Typedef* tdef = m_module->m_typeMgr.createTypedef (name, qualifiedName, type);
[+] 	Typedef* tdef = m_module->m_typeMgr.createTypedef(name, qualifiedName, type);
[-] 	assignDeclarationAttributes (item, decl, declarator);
[+] 	assignDeclarationAttributes(item, decl, declarator);
[-] 	return nspace->addItem (name, item);
[+] 	return nspace->addItem(name, item);
[-] Parser::declareAlias (
[+] Parser::declareAlias(
[-] 	if (!declarator->m_constructor.isEmpty ())
[+] 	if (!declarator->m_constructor.isEmpty())
[-] 		err::setFormatStringError ("alias cannot have constructor");
[+] 		err::setFormatStringError("alias cannot have constructor");
[-] 	if (declarator->m_initializer.isEmpty ())
[+] 	if (declarator->m_initializer.isEmpty())
[-] 		err::setFormatStringError ("missing alias initializer");
[+] 		err::setFormatStringError("missing alias initializer");
[-] 	if (!declarator->isSimple ())
[+] 	if (!declarator->isSimple())
[-] 		err::setFormatStringError ("invalid alias declarator");
[+] 		err::setFormatStringError("invalid alias declarator");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	sl::String name = declarator->getName ()->getShortName ();
[+] 	sl::String name = declarator->getName()->getShortName();
[-] 	sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 	sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 	sl::BoxList <Token>* initializer = &declarator->m_initializer;
[+] 	sl::BoxList<Token>* initializer = &declarator->m_initializer;
[-] 	Alias* alias = m_module->m_namespaceMgr.createAlias (
[+] 	Alias* alias = m_module->m_namespaceMgr.createAlias(
[-] 	assignDeclarationAttributes (alias, alias, declarator);
[+] 	assignDeclarationAttributes(alias, alias, declarator);
[-] 	if (nspace->getNamespaceKind () == NamespaceKind_Property)
[+] 	if (nspace->getNamespaceKind() == NamespaceKind_Property)
[-] 		Property* prop = (Property*) nspace;
[+] 		Property* prop = (Property*)nspace;
[-] 			result = prop->setOnChanged (alias);
[+] 			result = prop->setOnChanged(alias);
[-] 			result = prop->setAutoGetValue (alias);
[+] 			result = prop->setAutoGetValue(alias);
[-] 	return nspace->addItem (alias);
[+] 	return nspace->addItem(alias);
[-] Parser::declareFunction (
[+] Parser::declareFunction(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamespaceKind namespaceKind = nspace->getNamespaceKind ();
[+] 	NamespaceKind namespaceKind = nspace->getNamespaceKind();
[-] 	DeclaratorKind declaratorKind = declarator->getDeclaratorKind ();
[+] 	DeclaratorKind declaratorKind = declarator->getDeclaratorKind();
[-] 	uint_t postModifiers = declarator->getPostDeclaratorModifiers ();
[+] 	uint_t postModifiers = declarator->getPostDeclaratorModifiers();
[-] 	FunctionKind functionKind = declarator->getFunctionKind ();
[+] 	FunctionKind functionKind = declarator->getFunctionKind();
[-] 	bool hasArgs = !type->getArgArray ().isEmpty ();
[+] 	bool hasArgs = !type->getArgArray().isEmpty();
[-] 		ASSERT (functionKind == FunctionKind_UnaryOperator || functionKind == FunctionKind_BinaryOperator);
[+] 		ASSERT(functionKind == FunctionKind_UnaryOperator || functionKind == FunctionKind_BinaryOperator);
[-] 	ASSERT (functionKind);
[+] 	ASSERT(functionKind);
[-] 	uint_t functionKindFlags = getFunctionKindFlags (functionKind);
[+] 	uint_t functionKindFlags = getFunctionKindFlags(functionKind);
[-] 		err::setFormatStringError ("'%s' cannot have storage specifier", getFunctionKindString (functionKind));
[+] 		err::setFormatStringError("'%s' cannot have storage specifier", getFunctionKindString (functionKind));
[-] 		err::setFormatStringError ("'%s' cannot have arguments", getFunctionKindString (functionKind));
[+] 		err::setFormatStringError("'%s' cannot have arguments", getFunctionKindString (functionKind));
[-] 			namespaceKind == NamespaceKind_Property ? ((Property*) nspace)->getStorageKind () : StorageKind_Undefined;
[+] 			namespaceKind == NamespaceKind_Property ? ((Property*)nspace)->getStorageKind() : StorageKind_Undefined;
[-] 			err::setFormatStringError ("invalid storage '%s' in property template", getStorageKindString (m_storageKind));
[+] 			err::setFormatStringError("invalid storage '%s' in property template", getStorageKindString (m_storageKind));
[-] 			err::setFormatStringError ("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[+] 			err::setFormatStringError("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[-] 		bool result = ((PropertyTemplate*) nspace)->addMethod (functionKind, type);
[+] 		bool result = ((PropertyTemplate*)nspace)->addMethod(functionKind, type);
[-] 	if (declarator->isQualified ())
[+] 	if (declarator->isQualified())
[-] 		Orphan* orphan = m_module->m_namespaceMgr.createOrphan (OrphanKind_Function, type);
[+] 		Orphan* orphan = m_module->m_namespaceMgr.createOrphan(OrphanKind_Function, type);
[-] 		Function* function = m_module->m_functionMgr.createFunction (functionKind, type);
[+] 		Function* function = m_module->m_functionMgr.createFunction(functionKind, type);
[-] 		if (!declarator->m_initializer.isEmpty ())
[+] 		if (!declarator->m_initializer.isEmpty())
[-] 			sl::takeOver (&function->m_initializer, &declarator->m_initializer);
[+] 			sl::takeOver(&function->m_initializer, &declarator->m_initializer);
[-] 			m_module->markForCompile (function);
[+] 			m_module->markForCompile(function);
[-] 	functionName->m_declaratorName = *declarator->getName ();
[+] 	functionName->m_declaratorName = *declarator->getName();
[-] 	functionItem->m_tag = nspace->createQualifiedName (functionName->m_declaratorName);
[+] 	functionItem->m_tag = nspace->createQualifiedName(functionName->m_declaratorName);
[-] 	assignDeclarationAttributes (functionItem, functionItemDecl, declarator);
[+] 	assignDeclarationAttributes(functionItem, functionItemDecl, declarator);
[-] 	switch (functionKind)
[+] 	switch(functionKind)
[-] 		functionItemDecl->m_name = declarator->getName ()->getShortName ();
[+] 		functionItemDecl->m_name = declarator->getName()->getShortName();
[-] 		functionItemDecl->m_qualifiedName = nspace->createQualifiedName (functionItemDecl->m_name);
[+] 		functionItemDecl->m_qualifiedName = nspace->createQualifiedName(functionItemDecl->m_name);
[-] 		functionName->m_unOpKind = declarator->getUnOpKind ();
[+] 		functionName->m_unOpKind = declarator->getUnOpKind();
[-] 		functionItem->m_tag.appendFormat (".unary operator %s", getUnOpKindString (functionName->m_unOpKind));
[+] 		functionItem->m_tag.appendFormat(".unary operator %s", getUnOpKindString (functionName->m_unOpKind));
[-] 		functionName->m_binOpKind = declarator->getBinOpKind ();
[+] 		functionName->m_binOpKind = declarator->getBinOpKind();
[-] 		functionItem->m_tag.appendFormat (".binary operator %s", getBinOpKindString (functionName->m_binOpKind));
[+] 		functionItem->m_tag.appendFormat(".binary operator %s", getBinOpKindString (functionName->m_binOpKind));
[-] 		functionName->m_castOpType = declarator->getCastOpType ();
[+] 		functionName->m_castOpType = declarator->getCastOpType();
[-] 		functionItem->m_tag.appendFormat (".cast operator %s", functionName->m_castOpType->getTypeString ().sz ());
[+] 		functionItem->m_tag.appendFormat(".cast operator %s", functionName->m_castOpType->getTypeString ().sz ());
[-] 		functionItem->m_tag.appendFormat (".%s", getFunctionKindString (functionKind));
[+] 		functionItem->m_tag.appendFormat(".%s", getFunctionKindString (functionKind));
[-] 	if (functionItem->getItemKind () == ModuleItemKind_Orphan)
[+] 	if (functionItem->getItemKind() == ModuleItemKind_Orphan)
[-] 			err::setFormatStringError ("illegal orphan in dynamiclib '%s'", nspace->getQualifiedName ().sz ());
[+] 			err::setFormatStringError("illegal orphan in dynamiclib '%s'", nspace->getQualifiedName ().sz ());
[-] 	ASSERT (functionItem->getItemKind () == ModuleItemKind_Function);
[+] 	ASSERT(functionItem->getItemKind() == ModuleItemKind_Function);
[-] 	Function* function = (Function*) functionItem;
[+] 	Function* function = (Function*)functionItem;
[-] 	switch (namespaceKind)
[+] 	switch(namespaceKind)
[-] 		return ((ExtensionNamespace*) nspace)->addMethod (function);
[+] 		return ((ExtensionNamespace*)nspace)->addMethod(function);
[-] 		typeKind = ((NamedType*) nspace)->getTypeKind ();
[+] 		typeKind = ((NamedType*)nspace)->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 			return ((StructType*) nspace)->addMethod (function);
[+] 			return ((StructType*)nspace)->addMethod(function);
[-] 			return ((UnionType*) nspace)->addMethod (function);
[+] 			return ((UnionType*)nspace)->addMethod(function);
[-] 			return ((ClassType*) nspace)->addMethod (function);
[+] 			return ((ClassType*)nspace)->addMethod(function);
[-] 			err::setFormatStringError ("method members are not allowed in '%s'", ((NamedType*) nspace)->getTypeString ().sz ());
[+] 			err::setFormatStringError("method members are not allowed in '%s'", ((NamedType*) nspace)->getTypeString ().sz ());
[-] 		return ((Property*) nspace)->addMethod (function);
[+] 		return ((Property*)nspace)->addMethod(function);
[-] 			err::setFormatStringError ("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[+] 			err::setFormatStringError("unused post-declarator modifier '%s'", getPostDeclaratorModifierString (postModifiers).sz ());
[-] 			err::setFormatStringError ("invalid storage specifier '%s' for a global function", getStorageKindString (m_storageKind));
[+] 			err::setFormatStringError("invalid storage specifier '%s' for a global function", getStorageKindString (m_storageKind));
[-] 	if (!nspace->getParentNamespace ()) // module constructor / destructor
[+] 	if (!nspace->getParentNamespace()) // module constructor / destructor
[-] 		switch (functionKind)
[+] 		switch(functionKind)
[-] 			return function->getParentUnit ()->setConstructor (function);
[+] 			return function->getParentUnit()->setConstructor(function);
[-] 			return function->getParentUnit ()->setDestructor (function);
[+] 			return function->getParentUnit()->setDestructor(function);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getFunctionKindString (functionKind),
[+] 			getFunctionKindString(functionKind),
[-] 			getNamespaceKindString (namespaceKind)
[+] 			getNamespaceKindString(namespaceKind)
[-] 	return nspace->addFunction (function) != -1;
[+] 	return nspace->addFunction(function) != -1;
[-] Parser::declareProperty (
[+] Parser::declareProperty(
[-] 	if (!declarator->isSimple ())
[+] 	if (!declarator->isSimple())
[-] 		err::setFormatStringError ("invalid property declarator");
[+] 		err::setFormatStringError("invalid property declarator");
[-] 	Property* prop = createProperty (declarator);
[+] 	Property* prop = createProperty(declarator);
[-] 		return prop->create (type);
[+] 		return prop->create(type);
[-] 	m_lastPropertyTypeModifiers = declarator->getTypeModifiers ();
[+] 	m_lastPropertyTypeModifiers = declarator->getTypeModifiers();
[-] 	if (declarator->getBaseType ()->getTypeKind () != TypeKind_Void ||
[+] 	if (declarator->getBaseType()->getTypeKind() != TypeKind_Void ||
[-] 		!declarator->getPointerPrefixList ().isEmpty () ||
[+] 		!declarator->getPointerPrefixList().isEmpty() ||
[-] 		!declarator->getSuffixList ().isEmpty ())
[+] 		!declarator->getSuffixList().isEmpty())
[-] 		m_lastPropertyGetterType = typeCalc.calcPropertyGetterType (declarator);
[+] 		m_lastPropertyGetterType = typeCalc.calcPropertyGetterType(declarator);
[-] Parser::createPropertyTemplate ()
[+] Parser::createPropertyTemplate()
[-] 	PropertyTemplate* propertyTemplate = m_module->m_functionMgr.createPropertyTemplate ();
[+] 	PropertyTemplate* propertyTemplate = m_module->m_functionMgr.createPropertyTemplate();
[-] 	uint_t modifiers = getTypeSpecifier ()->clearTypeModifiers (TypeModifier_Property | TypeModifier_Bindable);
[+] 	uint_t modifiers = getTypeSpecifier()->clearTypeModifiers(TypeModifier_Property | TypeModifier_Bindable);
[-] Parser::createProperty (Declarator* declarator)
[+] Parser::createProperty(Declarator* declarator)
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamespaceKind namespaceKind = nspace->getNamespaceKind ();
[+] 	NamespaceKind namespaceKind = nspace->getNamespaceKind();
[-] 		err::setFormatStringError ("property templates cannot have property members");
[+] 		err::setFormatStringError("property templates cannot have property members");
[-] 	const sl::String& name = declarator->getName ()->getShortName ();
[+] 	const sl::String& name = declarator->getName()->getShortName();
[-] 	sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 	sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 	Property* prop = m_module->m_functionMgr.createProperty (name, qualifiedName);
[+] 	Property* prop = m_module->m_functionMgr.createProperty(name, qualifiedName);
[-] 	assignDeclarationAttributes (prop, prop, declarator);
[+] 	assignDeclarationAttributes(prop, prop, declarator);
[-] 	switch (namespaceKind)
[+] 	switch(namespaceKind)
[-] 		result = ((ExtensionNamespace*) nspace)->addProperty (prop);
[+] 		result = ((ExtensionNamespace*)nspace)->addProperty(prop);
[-] 		typeKind = ((NamedType*) nspace)->getTypeKind ();
[+] 		typeKind = ((NamedType*)nspace)->getTypeKind();
[-] 		switch (typeKind)
[+] 		switch(typeKind)
[-] 			result = ((StructType*) nspace)->addProperty (prop);
[+] 			result = ((StructType*)nspace)->addProperty(prop);
[-] 			result = ((UnionType*) nspace)->addProperty (prop);
[+] 			result = ((UnionType*)nspace)->addProperty(prop);
[-] 			result = ((ClassType*) nspace)->addProperty (prop);
[+] 			result = ((ClassType*)nspace)->addProperty(prop);
[-] 			err::setFormatStringError ("property members are not allowed in '%s'", ((NamedType*) nspace)->getTypeString ().sz ());
[+] 			err::setFormatStringError("property members are not allowed in '%s'", ((NamedType*) nspace)->getTypeString ().sz ());
[-] 		result = ((Property*) nspace)->addProperty (prop);
[+] 		result = ((Property*)nspace)->addProperty(prop);
[-] 			err::setFormatStringError ("invalid storage specifier '%s' for a global property", getStorageKindString (m_storageKind));
[+] 			err::setFormatStringError("invalid storage specifier '%s' for a global property", getStorageKindString (m_storageKind));
[-] 		result = nspace->addItem (prop);
[+] 		result = nspace->addItem(prop);
[-] Parser::parseLastPropertyBody (const sl::ConstBoxList <Token>& body)
[+] Parser::parseLastPropertyBody(const sl::ConstBoxList<Token>& body)
[-] 	ASSERT (m_lastDeclaredItem && m_lastDeclaredItem->getItemKind () == ModuleItemKind_Property);
[+] 	ASSERT(m_lastDeclaredItem && m_lastDeclaredItem->getItemKind() == ModuleItemKind_Property);
[-] 	Property* prop = (Property*) m_lastDeclaredItem;
[+] 	Property* prop = (Property*)m_lastDeclaredItem;
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	m_module->m_namespaceMgr.openNamespace (prop);
[+] 	m_module->m_namespaceMgr.openNamespace(prop);
[-] 	result = parser.parseTokenList (SymbolKind_named_type_block_impl, body);
[+] 	result = parser.parseTokenList(SymbolKind_named_type_block_impl, body);
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] 	return finalizeLastProperty (true);
[+] 	return finalizeLastProperty(true);
[-] Parser::finalizeLastProperty (bool hasBody)
[+] Parser::finalizeLastProperty(bool hasBody)
[-] 	ASSERT (m_lastDeclaredItem && m_lastDeclaredItem->getItemKind () == ModuleItemKind_Property);
[+] 	ASSERT(m_lastDeclaredItem && m_lastDeclaredItem->getItemKind() == ModuleItemKind_Property);
[-] 	Property* prop = (Property*) m_lastDeclaredItem;
[+] 	Property* prop = (Property*)m_lastDeclaredItem;
[-] 	if (prop->getType ())
[+] 	if (prop->getType())
[-] 		if (m_lastPropertyGetterType && m_lastPropertyGetterType->cmp (prop->m_getter->getType ()) != 0)
[+] 		if (m_lastPropertyGetterType && m_lastPropertyGetterType->cmp(prop->m_getter->getType()) != 0)
[-] 			err::setFormatStringError ("getter type '%s' does not match property declaration", prop->m_getter->getType ()->getTypeString ().sz ());
[+] 			err::setFormatStringError("getter type '%s' does not match property declaration", prop->m_getter->getType ()->getTypeString ().sz ());
[-] 		ASSERT (prop->m_autoGetValue->getItemKind () == ModuleItemKind_Alias); // otherwise, getter would have been created
[+] 		ASSERT(prop->m_autoGetValue->getItemKind() == ModuleItemKind_Alias); // otherwise, getter would have been created
[-] 			err::setFormatStringError ("incomplete property: no 'get' method or 'autoget' field");
[+] 			err::setFormatStringError("incomplete property: no 'get' method or 'autoget' field");
[-] 		Function* getter = m_module->m_functionMgr.createFunction (FunctionKind_Getter, m_lastPropertyGetterType);
[+] 		Function* getter = m_module->m_functionMgr.createFunction(FunctionKind_Getter, m_lastPropertyGetterType);
[-] 		result = prop->addMethod (getter);
[+] 		result = prop->addMethod(getter);
[-] 		FunctionType* getterType = prop->m_getter->getType ()->getShortType ();
[+] 		FunctionType* getterType = prop->m_getter->getType()->getShortType();
[-] 		sl::Array <FunctionArg*> argArray = getterType->getArgArray ();
[+] 		sl::Array<FunctionArg*> argArray = getterType->getArgArray();
[-] 		Type* setterArgType = getterType->getReturnType ();
[+] 		Type* setterArgType = getterType->getReturnType();
[-] 		if (setterArgType->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 		if (setterArgType->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 			Type* setAsType = ((DerivableType*) setterArgType)->getSetAsType ();
[+] 			Type* setAsType = ((DerivableType*)setterArgType)->getSetAsType();
[-] 		argArray.append (setterArgType->getSimpleFunctionArg ());
[+] 		argArray.append(setterArgType->getSimpleFunctionArg());
[-] 		FunctionType* setterType = m_module->m_typeMgr.getFunctionType (argArray);
[+] 		FunctionType* setterType = m_module->m_typeMgr.getFunctionType(argArray);
[-] 		Function* setter = m_module->m_functionMgr.createFunction (FunctionKind_Setter, setterType);
[+] 		Function* setter = m_module->m_functionMgr.createFunction(FunctionKind_Setter, setterType);
[-] 		result = prop->addMethod (setter);
[+] 		result = prop->addMethod(setter);
[-] 			result = prop->createOnChanged ();
[+] 			result = prop->createOnChanged();
[-] 			result = prop->createAutoGetValue (prop->m_getter->getType ()->getReturnType ());
[+] 			result = prop->createAutoGetValue(prop->m_getter->getType()->getReturnType());
[-] 		prop->createType ();
[+] 		prop->createType();
[-] 		m_module->markForCompile (prop);
[+] 		m_module->markForCompile(prop);
[-] 	if (prop->getStaticConstructor ())
[+] 	if (prop->getStaticConstructor())
[-] 		m_module->m_functionMgr.addStaticConstructor (prop);
[+] 		m_module->m_functionMgr.addStaticConstructor(prop);
[-] Parser::declareReactor (
[+] Parser::declareReactor(
[-] 	if (declarator->getDeclaratorKind () != DeclaratorKind_Name)
[+] 	if (declarator->getDeclaratorKind() != DeclaratorKind_Name)
[-] 		err::setFormatStringError ("invalid reactor declarator");
[+] 		err::setFormatStringError("invalid reactor declarator");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamespaceKind namespaceKind = nspace->getNamespaceKind ();
[+] 	NamespaceKind namespaceKind = nspace->getNamespaceKind();
[-] 	switch (namespaceKind)
[+] 	switch(namespaceKind)
[-] 		parentType = ((Property*) nspace)->getParentType ();
[+] 		parentType = ((Property*)nspace)->getParentType();
[-] 		parentType = (NamedType*) nspace;
[+] 		parentType = (NamedType*)nspace;
[-] 	if (parentType && parentType->getTypeKind () != TypeKind_Class)
[+] 	if (parentType && parentType->getTypeKind() != TypeKind_Class)
[-] 		err::setFormatStringError ("'%s' cannot contain reactor members", parentType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' cannot contain reactor members", parentType->getTypeString ().sz ());
[-] 	sl::String name = declarator->getName ()->getShortName ();
[+] 	sl::String name = declarator->getName()->getShortName();
[-] 	sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 	sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 	if (declarator->isQualified ())
[+] 	if (declarator->isQualified())
[-] 		Orphan* oprhan = m_module->m_namespaceMgr.createOrphan (OrphanKind_Reactor, NULL);
[+] 		Orphan* oprhan = m_module->m_namespaceMgr.createOrphan(OrphanKind_Reactor, NULL);
[-] 		oprhan->m_declaratorName = *declarator->getName ();
[+] 		oprhan->m_declaratorName = *declarator->getName();
[-] 		assignDeclarationAttributes (oprhan, oprhan, declarator);
[+] 		assignDeclarationAttributes(oprhan, oprhan, declarator);
[-] 		ReactorClassType* type = m_module->m_typeMgr.createReactorType (name, qualifiedName, (ClassType*) parentType);
[+] 		ReactorClassType* type = m_module->m_typeMgr.createReactorType(name, qualifiedName, (ClassType*)parentType);
[-] 		assignDeclarationAttributes (type, type, declarator);
[+] 		assignDeclarationAttributes(type, type, declarator);
[-] 		result = declareData (declarator, type, ptrTypeFlags);
[+] 		result = declareData(declarator, type, ptrTypeFlags);
[-] Parser::declareData (
[+] Parser::declareData(
[-] 	if (!declarator->isSimple ())
[+] 	if (!declarator->isSimple())
[-] 		err::setFormatStringError ("invalid data declarator");
[+] 		err::setFormatStringError("invalid data declarator");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	NamespaceKind namespaceKind = nspace->getNamespaceKind ();
[+] 	NamespaceKind namespaceKind = nspace->getNamespaceKind();
[-] 	switch (namespaceKind)
[+] 	switch(namespaceKind)
[-] 		err::setFormatStringError ("'%s' cannot have data fields", getNamespaceKindString (namespaceKind));
[+] 		err::setFormatStringError("'%s' cannot have data fields", getNamespaceKindString (namespaceKind));
[-] 	sl::String name = declarator->getName ()->getShortName ();
[+] 	sl::String name = declarator->getName()->getShortName();
[-] 	size_t bitCount = declarator->getBitCount ();
[+] 	size_t bitCount = declarator->getBitCount();
[-] 	sl::BoxList <Token>* constructor = &declarator->m_constructor;
[+] 	sl::BoxList<Token>* constructor = &declarator->m_constructor;
[-] 	sl::BoxList <Token>* initializer = &declarator->m_initializer;
[+] 	sl::BoxList<Token>* initializer = &declarator->m_initializer;
[-] 	if (isAutoSizeArrayType (type))
[+] 	if (isAutoSizeArrayType(type))
[-] 		if (initializer->isEmpty ())
[+] 		if (initializer->isEmpty())
[-] 			err::setFormatStringError ("auto-size array '%s' should have initializer", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("auto-size array '%s' should have initializer", type->getTypeString ().sz ());
[-] 		ArrayType* arrayType = (ArrayType*) type;
[+] 		ArrayType* arrayType = (ArrayType*)type;
[-] 		arrayType->m_elementCount = m_module->m_operatorMgr.parseAutoSizeArrayInitializer (arrayType, *initializer);
[+] 		arrayType->m_elementCount = m_module->m_operatorMgr.parseAutoSizeArrayInitializer(arrayType, *initializer);
[-] 			result = arrayType->ensureLayout ();
[+] 			result = arrayType->ensureLayout();
[-] 		err::setFormatStringError ("'%s' can only be used on property field", getPtrTypeFlagString (ptrTypeFlags & (PtrTypeFlag_AutoGet | PtrTypeFlag_Bindable)).sz ());
[+] 		err::setFormatStringError("'%s' can only be used on property field", getPtrTypeFlagString (ptrTypeFlags & (PtrTypeFlag_AutoGet | PtrTypeFlag_Bindable)).sz ());
[-] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	Scope* scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 		switch (namespaceKind)
[+] 		switch(namespaceKind)
[-] 			storageKind = (type->getFlags () & TypeFlag_NoStack) ? StorageKind_Heap : StorageKind_Stack;
[+] 			storageKind = (type->getFlags() & TypeFlag_NoStack) ? StorageKind_Heap : StorageKind_Stack;
[-] 			storageKind = ((Property*) nspace)->getParentType () ? StorageKind_Member : StorageKind_Static;
[+] 			storageKind = ((Property*)nspace)->getParentType() ? StorageKind_Member : StorageKind_Static;
[-] 		if (!scope && (!constructor->isEmpty () || !initializer->isEmpty ()))
[+] 		if (!scope && (!constructor->isEmpty() || !initializer->isEmpty()))
[-] 			err::setFormatStringError ("global 'threadlocal' variables cannot have initializers");
[+] 			err::setFormatStringError("global 'threadlocal' variables cannot have initializers");
[-] 		switch (namespaceKind)
[+] 		switch(namespaceKind)
[-] 			if (((Property*) nspace)->getParentType ())
[+] 			if (((Property*)nspace)->getParentType())
[-] 			err::setFormatStringError ("'mutable' can only be applied to member fields");
[+] 			err::setFormatStringError("'mutable' can only be applied to member fields");
[-] 			err::setFormatStringError ("'disposable' can only be applied to local variables");
[+] 			err::setFormatStringError("'disposable' can only be applied to local variables");
[-] 		if (!isDisposableType (type))
[+] 		if (!isDisposableType(type))
[-] 			err::setFormatStringError ("'%s' is not a disposable type", type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' is not a disposable type", type->getTypeString ().sz ());
[-] 		ASSERT (scope);
[+] 		ASSERT(scope);
[-] 		if (!(scope->getFlags () & ScopeFlag_Disposable))
[+] 		if (!(scope->getFlags() & ScopeFlag_Disposable))
[-] 			scope = m_module->m_namespaceMgr.openScope (
[+] 			scope = m_module->m_namespaceMgr.openScope(
[-] 				declarator->getPos (),
[+] 				declarator->getPos(),
[-] 		storageKind = (type->getFlags () & TypeFlag_NoStack) ? StorageKind_Heap : StorageKind_Stack;
[+] 		storageKind = (type->getFlags() & TypeFlag_NoStack) ? StorageKind_Heap : StorageKind_Stack;
[-] 		err::setFormatStringError ("invalid storage specifier '%s' for variable", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("invalid storage specifier '%s' for variable", getStorageKindString (storageKind));
[-] 		Property* prop = (Property*) nspace;
[+] 		Property* prop = (Property*)nspace;
[-] 			StructField* field = prop->createField (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 			StructField* field = prop->createField(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 			assignDeclarationAttributes (field, field, declarator);
[+] 			assignDeclarationAttributes(field, field, declarator);
[-] 			Variable* variable = m_module->m_variableMgr.createVariable (
[+] 			Variable* variable = m_module->m_variableMgr.createVariable(
[-] 				nspace->createQualifiedName (name),
[+] 				nspace->createQualifiedName(name),
[-] 			assignDeclarationAttributes (variable, variable, declarator);
[+] 			assignDeclarationAttributes(variable, variable, declarator);
[-] 			result = nspace->addItem (variable);
[+] 			result = nspace->addItem(variable);
[-] 			if (variable->isInitializationNeeded ())
[+] 			if (variable->isInitializationNeeded())
[-] 				prop->m_initializedStaticFieldArray.append (variable);
[+] 				prop->m_initializedStaticFieldArray.append(variable);
[-] 			result = prop->setOnChanged (dataItem);
[+] 			result = prop->setOnChanged(dataItem);
[-] 			result = prop->setAutoGetValue (dataItem);
[+] 			result = prop->setAutoGetValue(dataItem);
[-] 		Variable* variable = m_module->m_variableMgr.createVariable (
[+] 		Variable* variable = m_module->m_variableMgr.createVariable(
[-] 			nspace->createQualifiedName (name),
[+] 			nspace->createQualifiedName(name),
[-] 			result = m_module->m_variableMgr.finalizeDisposableVariable (variable);
[+] 			result = m_module->m_variableMgr.finalizeDisposableVariable(variable);
[-] 		assignDeclarationAttributes (variable, variable, declarator);
[+] 		assignDeclarationAttributes(variable, variable, declarator);
[-] 		result = nspace->addItem (variable);
[+] 		result = nspace->addItem(variable);
[-] 		if (nspace->getNamespaceKind () == NamespaceKind_Type)
[+] 		if (nspace->getNamespaceKind() == NamespaceKind_Type)
[-] 			NamedType* namedType = (NamedType*) nspace;
[+] 			NamedType* namedType = (NamedType*)nspace;
[-] 			TypeKind namedTypeKind = namedType->getTypeKind ();
[+] 			TypeKind namedTypeKind = namedType->getTypeKind();
[-] 			switch (namedTypeKind)
[+] 			switch(namedTypeKind)
[-] 				if (variable->isInitializationNeeded ())
[+] 				if (variable->isInitializationNeeded())
[-] 					((DerivableType*) namedType)->m_initializedStaticFieldArray.append (variable);
[+] 					((DerivableType*)namedType)->m_initializedStaticFieldArray.append(variable);
[-] 				err::setFormatStringError ("field members are not allowed in '%s'", namedType->getTypeString ().sz ());
[+] 				err::setFormatStringError("field members are not allowed in '%s'", namedType->getTypeString ().sz ());
[-] 			switch (storageKind)
[+] 			switch(storageKind)
[-] 				result = m_module->m_variableMgr.initializeVariable (variable);
[+] 				result = m_module->m_variableMgr.initializeVariable(variable);
[-] 				if (!variable->isInitializationNeeded ())
[+] 				if (!variable->isInitializationNeeded())
[-] 				m_module->m_controlFlowMgr.onceStmt_Create (&stmt, variable->m_pos, storageKind);
[+] 				m_module->m_controlFlowMgr.onceStmt_Create(&stmt, variable->m_pos, storageKind);
[-] 				result = m_module->m_controlFlowMgr.onceStmt_PreBody (&stmt, variable->m_pos);
[+] 				result = m_module->m_controlFlowMgr.onceStmt_PreBody(&stmt, variable->m_pos);
[-] 				result = m_module->m_variableMgr.initializeVariable (variable);
[+] 				result = m_module->m_variableMgr.initializeVariable(variable);
[-] 					!variable->m_initializer.isEmpty () ? variable->m_initializer.getTail ()->m_pos :
[+] 					!variable->m_initializer.isEmpty() ? variable->m_initializer.getTail()->m_pos :
[-] 					!variable->m_constructor.isEmpty () ? variable->m_constructor.getTail ()->m_pos :
[+] 					!variable->m_constructor.isEmpty() ? variable->m_constructor.getTail()->m_pos :
[-] 				m_module->m_controlFlowMgr.onceStmt_PostBody (&stmt, pos);
[+] 				m_module->m_controlFlowMgr.onceStmt_PostBody(&stmt, pos);
[-] 		ASSERT (nspace->getNamespaceKind () == NamespaceKind_Type);
[+] 		ASSERT(nspace->getNamespaceKind() == NamespaceKind_Type);
[-] 		NamedType* namedType = (NamedType*) nspace;
[+] 		NamedType* namedType = (NamedType*)nspace;
[-] 		TypeKind namedTypeKind = namedType->getTypeKind ();
[+] 		TypeKind namedTypeKind = namedType->getTypeKind();
[-] 		switch (namedTypeKind)
[+] 		switch(namedTypeKind)
[-] 			field = ((ClassType*) namedType)->createField (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 			field = ((ClassType*)namedType)->createField(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 			field = ((StructType*) namedType)->createField (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 			field = ((StructType*)namedType)->createField(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 			field = ((UnionType*) namedType)->createField (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 			field = ((UnionType*)namedType)->createField(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 			err::setFormatStringError ("field members are not allowed in '%s'", namedType->getTypeString ().sz ());
[+] 			err::setFormatStringError("field members are not allowed in '%s'", namedType->getTypeString ().sz ());
[-] 		assignDeclarationAttributes (field, field, declarator);
[+] 		assignDeclarationAttributes(field, field, declarator);
[-] Parser::declareUnnamedStructOrUnion (DerivableType* type)
[+] Parser::declareUnnamedStructOrUnion(DerivableType* type)
[-] 	declarator.m_pos = *type->getPos ();
[+] 	declarator.m_pos = *type->getPos();
[-] 	return declareData (&declarator, type, 0);
[+] 	return declareData(&declarator, type, 0);
[-] Parser::createFormalArg (
[+] Parser::createFormalArg(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	Type* type = declarator->calcType (&ptrTypeFlags);
[+] 	Type* type = declarator->calcType(&ptrTypeFlags);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			type->getTypeString ().sz ()
[+] 			type->getTypeString().sz()
[-] 		err::setFormatStringError ("invalid storage '%s' for argument", getStorageKindString (m_storageKind));
[+] 		err::setFormatStringError("invalid storage '%s' for argument", getStorageKindString (m_storageKind));
[-] 	if (declarator->isSimple ())
[+] 	if (declarator->isSimple())
[-] 		name = declarator->getName ()->getShortName ();
[+] 		name = declarator->getName()->getShortName();
[-] 	else if (declarator->getDeclaratorKind () != DeclaratorKind_Undefined)
[+] 	else if (declarator->getDeclaratorKind() != DeclaratorKind_Undefined)
[-] 		err::setFormatStringError ("invalid formal argument declarator");
[+] 		err::setFormatStringError("invalid formal argument declarator");
[-] 	sl::BoxList <Token>* initializer = &declarator->m_initializer;
[+] 	sl::BoxList<Token>* initializer = &declarator->m_initializer;
[-] 	FunctionArg* arg = m_module->m_typeMgr.createFunctionArg (name, type, ptrTypeFlags, initializer);
[+] 	FunctionArg* arg = m_module->m_typeMgr.createFunctionArg(name, type, ptrTypeFlags, initializer);
[-] 	assignDeclarationAttributes (arg, arg, declarator);
[+] 	assignDeclarationAttributes(arg, arg, declarator);
[-] 	argSuffix->m_argArray.append (arg);
[+] 	argSuffix->m_argArray.append(arg);
[-] Parser::addEnumFlag (
[+] Parser::addEnumFlag(
[-] 		err::setFormatStringError ("modifier '%s' used more than once", getEnumTypeFlagString (flag));
[+] 		err::setFormatStringError("modifier '%s' used more than once", getEnumTypeFlagString (flag));
[-] Parser::createEnumType (
[+] Parser::createEnumType(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		enumType = m_module->m_typeMgr.createUnnamedEnumType (baseType, flags);
[+] 		enumType = m_module->m_typeMgr.createUnnamedEnumType(baseType, flags);
[-] 		sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 		sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 		enumType = m_module->m_typeMgr.createEnumType (name, qualifiedName, baseType, flags);
[+] 		enumType = m_module->m_typeMgr.createEnumType(name, qualifiedName, baseType, flags);
[-] 		bool result = nspace->addItem (enumType);
[+] 		bool result = nspace->addItem(enumType);
[-] 	assignDeclarationAttributes (enumType, enumType, m_lastMatchedToken.m_pos);
[+] 	assignDeclarationAttributes(enumType, enumType, m_lastMatchedToken.m_pos);
[-] Parser::createEnumConst (
[+] Parser::createEnumConst(
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	EnumConst* enumConst = type->createConst (name, initializer);
[+] 	EnumConst* enumConst = type->createConst(name, initializer);
[-] 	assignDeclarationAttributes (enumConst, enumConst, pos);
[+] 	assignDeclarationAttributes(enumConst, enumConst, pos);
[-] Parser::createStructType (
[+] Parser::createStructType(
[-] 	sl::BoxList <Type*>* baseTypeList,
[+] 	sl::BoxList<Type*>* baseTypeList,
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		structType = m_module->m_typeMgr.createUnnamedStructType (fieldAlignment, flags);
[+] 		structType = m_module->m_typeMgr.createUnnamedStructType(fieldAlignment, flags);
[-] 		sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 		sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 		structType = m_module->m_typeMgr.createStructType (name, qualifiedName, fieldAlignment, flags);
[+] 		structType = m_module->m_typeMgr.createStructType(name, qualifiedName, fieldAlignment, flags);
[-] 		sl::BoxIterator <Type*> baseType = baseTypeList->getHead ();
[+] 		sl::BoxIterator<Type*> baseType = baseTypeList->getHead();
[-] 			result = structType->addBaseType (*baseType) != NULL;
[+] 			result = structType->addBaseType(*baseType) != NULL;
[-] 	if (!name.isEmpty ())
[+] 	if (!name.isEmpty())
[-] 		result = nspace->addItem (structType);
[+] 		result = nspace->addItem(structType);
[-] 	assignDeclarationAttributes (structType, structType, m_lastMatchedToken.m_pos);
[+] 	assignDeclarationAttributes(structType, structType, m_lastMatchedToken.m_pos);
[-] Parser::createUnionType (
[+] Parser::createUnionType(
[-] 		err::setError ("dynamic unions are not supported yet");
[+] 		err::setError("dynamic unions are not supported yet");
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		unionType = m_module->m_typeMgr.createUnnamedUnionType (fieldAlignment, flags);
[+] 		unionType = m_module->m_typeMgr.createUnnamedUnionType(fieldAlignment, flags);
[-] 		sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 		sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 		unionType = m_module->m_typeMgr.createUnionType (name, qualifiedName, fieldAlignment, flags);
[+] 		unionType = m_module->m_typeMgr.createUnionType(name, qualifiedName, fieldAlignment, flags);
[-] 		result = nspace->addItem (unionType);
[+] 		result = nspace->addItem(unionType);
[-] 	assignDeclarationAttributes (unionType, unionType, m_lastMatchedToken.m_pos);
[+] 	assignDeclarationAttributes(unionType, unionType, m_lastMatchedToken.m_pos);
[-] Parser::createClassType (
[+] Parser::createClassType(
[-] 	sl::BoxList <Type*>* baseTypeList,
[+] 	sl::BoxList<Type*>* baseTypeList,
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		classType = m_module->m_typeMgr.createUnnamedClassType (fieldAlignment, flags);
[+] 		classType = m_module->m_typeMgr.createUnnamedClassType(fieldAlignment, flags);
[-] 		sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 		sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 		classType = m_module->m_typeMgr.createClassType (name, qualifiedName, fieldAlignment, flags);
[+] 		classType = m_module->m_typeMgr.createClassType(name, qualifiedName, fieldAlignment, flags);
[-] 		sl::BoxIterator <Type*> baseType = baseTypeList->getHead ();
[+] 		sl::BoxIterator<Type*> baseType = baseTypeList->getHead();
[-] 			result = classType->addBaseType (*baseType) != NULL;
[+] 			result = classType->addBaseType(*baseType) != NULL;
[-] 	if (!name.isEmpty ())
[+] 	if (!name.isEmpty())
[-] 		result = nspace->addItem (classType);
[+] 		result = nspace->addItem(classType);
[-] 	assignDeclarationAttributes (classType, classType, m_lastMatchedToken.m_pos);
[+] 	assignDeclarationAttributes(classType, classType, m_lastMatchedToken.m_pos);
[-] Parser::createDynamicLibType (const sl::StringRef& name)
[+] Parser::createDynamicLibType(const sl::StringRef& name)
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	sl::String qualifiedName = nspace->createQualifiedName (name);
[+] 	sl::String qualifiedName = nspace->createQualifiedName(name);
[-] 	classType = m_module->m_typeMgr.createClassType (name, qualifiedName);
[+] 	classType = m_module->m_typeMgr.createClassType(name, qualifiedName);
[-] 	Type* baseType = m_module->m_typeMgr.getStdType (StdType_DynamicLib);
[+] 	Type* baseType = m_module->m_typeMgr.getStdType(StdType_DynamicLib);
[-] 	result = classType->addBaseType (baseType) != NULL;
[+] 	result = classType->addBaseType(baseType) != NULL;
[-] 	result = nspace->addItem (classType);
[+] 	result = nspace->addItem(classType);
[-] 	DynamicLibNamespace* dynamicLibNamespace = m_module->m_namespaceMgr.createDynamicLibNamespace (classType);
[+] 	DynamicLibNamespace* dynamicLibNamespace = m_module->m_namespaceMgr.createDynamicLibNamespace(classType);
[-] 	result = classType->addItem (dynamicLibNamespace);
[+] 	result = classType->addItem(dynamicLibNamespace);
[-] 	assignDeclarationAttributes (classType, classType, m_lastMatchedToken.m_pos);
[+] 	assignDeclarationAttributes(classType, classType, m_lastMatchedToken.m_pos);
[-] 	m_module->m_namespaceMgr.openNamespace (dynamicLibNamespace);
[+] 	m_module->m_namespaceMgr.openNamespace(dynamicLibNamespace);
[-] Parser::finalizeDynamicLibType ()
[+] Parser::finalizeDynamicLibType()
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	ASSERT (nspace->getNamespaceKind () == NamespaceKind_DynamicLib);
[+] 	ASSERT(nspace->getNamespaceKind() == NamespaceKind_DynamicLib);
[-] 	DynamicLibNamespace* dynamicLibNamespace = (DynamicLibNamespace*) nspace;
[+] 	DynamicLibNamespace* dynamicLibNamespace = (DynamicLibNamespace*)nspace;
[-] 	ClassType* dynamicLibType = dynamicLibNamespace->getLibraryType ();
[+] 	ClassType* dynamicLibType = dynamicLibNamespace->getLibraryType();
[-] 		err::setFormatStringError ("dynamiclib '%s' has no functions", dynamicLibType->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("dynamiclib '%s' has no functions", dynamicLibType->getQualifiedName ().sz ());
[-] 	ArrayType* functionTableType = m_module->m_typeMgr.getStdType (StdType_BytePtr)->getArrayType (m_dynamicLibFunctionCount);
[+] 	ArrayType* functionTableType = m_module->m_typeMgr.getStdType(StdType_BytePtr)->getArrayType(m_dynamicLibFunctionCount);
[-] 	dynamicLibType->createField (functionTableType);
[+] 	dynamicLibType->createField(functionTableType);
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] Parser::addReactionBinding (const Value& value)
[+] Parser::addReactionBinding(const Value& value)
[-] 	ASSERT (m_stage == Stage_Reaction && m_reactorType);
[+] 	ASSERT(m_stage == Stage_Reaction && m_reactorType);
[-] 	Function* addBindingFunc = getReactorMethod (m_module, ReactorMethod_AddOnChangedBinding);
[+] 	Function* addBindingFunc = getReactorMethod(m_module, ReactorMethod_AddOnChangedBinding);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 		m_module->m_operatorMgr.getPropertyOnChanged (value, &onChangedValue) &&
[+] 		m_module->m_operatorMgr.getPropertyOnChanged(value, &onChangedValue) &&
[-] 		m_module->m_operatorMgr.callOperator (addBindingFunc, thisValue, onChangedValue);
[+] 		m_module->m_operatorMgr.callOperator(addBindingFunc, thisValue, onChangedValue);
[-] Parser::resetReactionBindings ()
[+] Parser::resetReactionBindings()
[-] 	Function* resetBindingsFunc = getReactorMethod (m_module, ReactorMethod_ResetOnChangedBindings);
[+] 	Function* resetBindingsFunc = getReactorMethod(m_module, ReactorMethod_ResetOnChangedBindings);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 	return m_module->m_operatorMgr.callOperator (resetBindingsFunc, thisValue);
[+] 	return m_module->m_operatorMgr.callOperator(resetBindingsFunc, thisValue);
[-] Parser::reactorOnEventStmt (
[+] Parser::reactorOnEventStmt(
[-] 	const sl::ConstBoxList <Value>& valueList,
[+] 	const sl::ConstBoxList<Value>& valueList,
[-] 	sl::BoxList <Token>* tokenList
[+] 	sl::BoxList<Token>* tokenList
[-] 	ASSERT (m_stage == Stage_Reaction && m_reactorType);
[+] 	ASSERT(m_stage == Stage_Reaction && m_reactorType);
[-] 	DeclFunctionSuffix* suffix = declarator->getFunctionSuffix ();
[+] 	DeclFunctionSuffix* suffix = declarator->getFunctionSuffix();
[-] 	ASSERT (suffix);
[+] 	ASSERT(suffix);
[-] 	FunctionType* functionType = m_module->m_typeMgr.getFunctionType (suffix->getArgArray ());
[+] 	FunctionType* functionType = m_module->m_typeMgr.getFunctionType(suffix->getArgArray());
[-] 	Function* handler = m_reactorType->createOnEventHandler (m_reactionIdx, functionType);
[+] 	Function* handler = m_reactorType->createOnEventHandler(m_reactionIdx, functionType);
[-] 	handler->setBody (tokenList);
[+] 	handler->setBody(tokenList);
[-] 	Function* addBindingFunc = getReactorMethod (m_module, ReactorMethod_AddOnEventBinding);
[+] 	Function* addBindingFunc = getReactorMethod(m_module, ReactorMethod_AddOnEventBinding);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 	sl::ConstBoxIterator <Value> it = valueList.getHead ();
[+] 	sl::ConstBoxIterator<Value> it = valueList.getHead();
[-] 		bool result = m_module->m_operatorMgr.callOperator (addBindingFunc, thisValue, *it);
[+] 		bool result = m_module->m_operatorMgr.callOperator(addBindingFunc, thisValue, *it);
[-] Parser::callBaseTypeMemberConstructor (
[+] Parser::callBaseTypeMemberConstructor(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	ASSERT (m_constructorType || m_constructorProperty);
[+] 	ASSERT(m_constructorType || m_constructorProperty);
[-] 	Namespace* nspace = m_module->m_functionMgr.getCurrentFunction ()->getParentNamespace ();
[+] 	Namespace* nspace = m_module->m_functionMgr.getCurrentFunction()->getParentNamespace();
[-] 	ModuleItem* item = nspace->findItemTraverse (name);
[+] 	ModuleItem* item = nspace->findItemTraverse(name);
[-] 		err::setFormatStringError ("name '%s' is not found", name.getFullName ().sz ());
[+] 		err::setFormatStringError("name '%s' is not found", name.getFullName ().sz ());
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		return callBaseTypeConstructor ((Type*) item, argList);
[+] 		return callBaseTypeConstructor((Type*)item, argList);
[-] 		return callBaseTypeConstructor (((Typedef*) item)->getType (), argList);
[+] 		return callBaseTypeConstructor(((Typedef*)item)->getType(), argList);
[-] 		err::setFormatStringError ("property construction is not yet implemented");
[+] 		err::setFormatStringError("property construction is not yet implemented");
[-] 		return callFieldConstructor ((StructField*) item, argList);
[+] 		return callFieldConstructor((StructField*)item, argList);
[-] 		err::setFormatStringError ("static field construction is not yet implemented");
[+] 		err::setFormatStringError("static field construction is not yet implemented");
[-] 		err::setFormatStringError ("'%s' cannot be used in base-type-member construct list");
[+] 		err::setFormatStringError("'%s' cannot be used in base-type-member construct list");
[-] Parser::findBaseType (size_t baseTypeIdx)
[+] Parser::findBaseType(size_t baseTypeIdx)
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	ASSERT (function); // should not be called at pass
[+] 	ASSERT(function); // should not be called at pass
[-] 	DerivableType* parentType = function->getParentType ();
[+] 	DerivableType* parentType = function->getParentType();
[-] 	BaseTypeSlot* slot = parentType->getBaseTypeByIndex (baseTypeIdx);
[+] 	BaseTypeSlot* slot = parentType->getBaseTypeByIndex(baseTypeIdx);
[-] 	return slot->getType ();
[+] 	return slot->getType();
[-] Parser::getBaseType (size_t baseTypeIdx)
[+] Parser::getBaseType(size_t baseTypeIdx)
[-] 	DerivableType* type = findBaseType (baseTypeIdx);
[+] 	DerivableType* type = findBaseType(baseTypeIdx);
[-] 		err::setFormatStringError ("'basetype%d' is not found", baseTypeIdx + 1);
[+] 		err::setFormatStringError("'basetype%d' is not found", baseTypeIdx + 1);
[-] Parser::getBaseType (
[+] Parser::getBaseType(
[-] 	DerivableType* type = getBaseType (baseTypeIdx);
[+] 	DerivableType* type = getBaseType(baseTypeIdx);
[-] 	resultValue->setNamespace (type);
[+] 	resultValue->setNamespace(type);
[-] Parser::callBaseTypeConstructor (
[+] Parser::callBaseTypeConstructor(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	ASSERT (m_constructorType || m_constructorProperty);
[+] 	ASSERT(m_constructorType || m_constructorProperty);
[-] 		err::setFormatStringError ("'%s.construct' cannot have base-type constructor calls", m_constructorProperty->m_tag.sz ());
[+] 		err::setFormatStringError("'%s.construct' cannot have base-type constructor calls", m_constructorProperty->m_tag.sz ());
[-] 	BaseTypeSlot* baseTypeSlot = m_constructorType->getBaseTypeByIndex (baseTypeIdx);
[+] 	BaseTypeSlot* baseTypeSlot = m_constructorType->getBaseTypeByIndex(baseTypeIdx);
[-] 	return callBaseTypeConstructorImpl (baseTypeSlot, argList);
[+] 	return callBaseTypeConstructorImpl(baseTypeSlot, argList);
[-] Parser::callBaseTypeConstructor (
[+] Parser::callBaseTypeConstructor(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	ASSERT (m_constructorType || m_constructorProperty);
[+] 	ASSERT(m_constructorType || m_constructorProperty);
[-] 		err::setFormatStringError ("'%s.construct' cannot have base-type constructor calls", m_constructorProperty->m_tag.sz ());
[+] 		err::setFormatStringError("'%s.construct' cannot have base-type constructor calls", m_constructorProperty->m_tag.sz ());
[-] 	BaseTypeSlot* baseTypeSlot = m_constructorType->findBaseType (type);
[+] 	BaseTypeSlot* baseTypeSlot = m_constructorType->findBaseType(type);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			type->getTypeString ().sz (),
[+] 			type->getTypeString().sz(),
[-] 			m_constructorType->getTypeString ().sz ()
[+] 			m_constructorType->getTypeString().sz()
[-] 	return callBaseTypeConstructorImpl (baseTypeSlot, argList);
[+] 	return callBaseTypeConstructorImpl(baseTypeSlot, argList);
[-] Parser::callBaseTypeConstructorImpl (
[+] Parser::callBaseTypeConstructorImpl(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	DerivableType* type = baseTypeSlot->getType ();
[+] 	DerivableType* type = baseTypeSlot->getType();
[-] 		err::setFormatStringError ("'%s' is already constructed", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is already constructed", type->getTypeString ().sz ());
[-] 	Function* constructor = type->getConstructor ();
[+] 	Function* constructor = type->getConstructor();
[-] 		err::setFormatStringError ("'%s' has no constructor", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no constructor", type->getTypeString ().sz ());
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 	argList->insertHead (thisValue);
[+] 	argList->insertHead(thisValue);
[-] 	bool result = m_module->m_operatorMgr.callOperator (constructor, argList);
[+] 	bool result = m_module->m_operatorMgr.callOperator(constructor, argList);
[-] Parser::callFieldConstructor (
[+] Parser::callFieldConstructor(
[-] 	sl::BoxList <Value>* argList
[+] 	sl::BoxList<Value>* argList
[-] 	ASSERT (m_constructorType || m_constructorProperty);
[+] 	ASSERT(m_constructorType || m_constructorProperty);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 		err::setFormatStringError ("property field construction is not yet implemented");
[+] 		err::setFormatStringError("property field construction is not yet implemented");
[-] 	if (field->getParentNamespace () != m_constructorType)
[+] 	if (field->getParentNamespace() != m_constructorType)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			field->getName ().sz (),
[+] 			field->getName().sz(),
[-] 			m_constructorType->getTypeString ().sz ()
[+] 			m_constructorType->getTypeString().sz()
[-] 	if (field->getFlags () & ModuleItemFlag_Constructed)
[+] 	if (field->getFlags() & ModuleItemFlag_Constructed)
[-] 		err::setFormatStringError ("'%s' is already constructed", field->getName ().sz ());
[+] 		err::setFormatStringError("'%s' is already constructed", field->getName ().sz ());
[-] 	if (!(field->getType ()->getTypeKindFlags () & TypeKindFlag_Derivable) ||
[+] 	if (!(field->getType()->getTypeKindFlags() & TypeKindFlag_Derivable) ||
[-] 		!((DerivableType*) field->getType ())->getConstructor ())
[+] 		!((DerivableType*)field->getType())->getConstructor())
[-] 		err::setFormatStringError ("'%s' has no constructor", field->getName ().sz ());
[+] 		err::setFormatStringError("'%s' has no constructor", field->getName ().sz ());
[-] 	Function* constructor = ((DerivableType*) field->getType ())->getConstructor ();
[+] 	Function* constructor = ((DerivableType*)field->getType())->getConstructor();
[-] 		m_module->m_operatorMgr.getField (thisValue, field, NULL, &fieldValue) &&
[+] 		m_module->m_operatorMgr.getField(thisValue, field, NULL, &fieldValue) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, &fieldValue);
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, &fieldValue);
[-] 	argList->insertHead (fieldValue);
[+] 	argList->insertHead(fieldValue);
[-] 	result = m_module->m_operatorMgr.callOperator (constructor, argList);
[+] 	result = m_module->m_operatorMgr.callOperator(constructor, argList);
[-] Parser::finalizeBaseTypeMemberConstructBlock ()
[+] Parser::finalizeBaseTypeMemberConstructBlock()
[-] 	ASSERT (m_constructorType || m_constructorProperty);
[+] 	ASSERT(m_constructorType || m_constructorProperty);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 			m_constructorProperty->callMemberFieldConstructors (thisValue) &&
[+] 			m_constructorProperty->callMemberFieldConstructors(thisValue) &&
[-] 			m_constructorProperty->initializeMemberFields (thisValue) &&
[+] 			m_constructorProperty->initializeMemberFields(thisValue) &&
[-] 			m_constructorProperty->callMemberPropertyConstructors (thisValue);
[+] 			m_constructorProperty->callMemberPropertyConstructors(thisValue);
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 		m_constructorType->callBaseTypeConstructors (thisValue) &&
[+] 		m_constructorType->callBaseTypeConstructors(thisValue) &&
[-] 		m_constructorType->callMemberFieldConstructors (thisValue) &&
[+] 		m_constructorType->callMemberFieldConstructors(thisValue) &&
[-] 		m_constructorType->initializeMemberFields (thisValue) &&
[+] 		m_constructorType->initializeMemberFields(thisValue) &&
[-] 		m_constructorType->callMemberPropertyConstructors (thisValue);
[+] 		m_constructorType->callMemberPropertyConstructors(thisValue);
[-] 	Function* preconstructor = m_constructorType->getPreConstructor ();
[+] 	Function* preconstructor = m_constructorType->getPreConstructor();
[-] 	return m_module->m_operatorMgr.callOperator (preconstructor, thisValue);
[+] 	return m_module->m_operatorMgr.callOperator(preconstructor, thisValue);
[-] Parser::newOperator_0 (
[+] Parser::newOperator_0(
[-] 	resultValue->setType (m_module->m_operatorMgr.getNewOperatorResultType (type));
[+] 	resultValue->setType(m_module->m_operatorMgr.getNewOperatorResultType(type));
[-] Parser::lookupIdentifier (
[+] Parser::lookupIdentifier(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	item = nspace->findItemTraverse (name, &coord);
[+] 	item = nspace->findItemTraverse(name, &coord);
[-] 		err::setFormatStringError ("undeclared identifier '%s'", name.sz ());
[+] 		err::setFormatStringError("undeclared identifier '%s'", name.sz ());
[-] 		lex::pushSrcPosError (m_module->m_unitMgr.getCurrentUnit ()->getFilePath (), pos);
[+] 		lex::pushSrcPosError(m_module->m_unitMgr.getCurrentUnit()->getFilePath(), pos);
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		value->setNamespace ((GlobalNamespace*) item);
[+] 		value->setNamespace((GlobalNamespace*)item);
[-] 		item = ((Typedef*) item)->getType ();
[+] 		item = ((Typedef*)item)->getType();
[-] 		if (!(((Type*) item)->getTypeKindFlags () & TypeKindFlag_Named))
[+] 		if (!(((Type*)item)->getTypeKindFlags() & TypeKindFlag_Named))
[-] 			err::setFormatStringError ("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[-] 		value->setNamespace ((NamedType*) item);
[+] 		value->setNamespace((NamedType*)item);
[-] 		*value = ((Const*) item)->getValue ();
[+] 		*value = ((Const*)item)->getValue();
[-] 			err::setFormatStringError ("variable '%s' cannot be used in const expression", name.sz ());
[+] 			err::setFormatStringError("variable '%s' cannot be used in const expression", name.sz ());
[-] 		value->setVariable ((Variable*) item);
[+] 		value->setVariable((Variable*)item);
[-] 			err::setFormatStringError ("function '%s' cannot be used in const expression", name.sz ());
[+] 			err::setFormatStringError("function '%s' cannot be used in const expression", name.sz ());
[-] 		value->setFunction ((Function*) item);
[+] 		value->setFunction((Function*)item);
[-] 		if (((Function*) item)->isMember ())
[+] 		if (((Function*)item)->isMember())
[-] 			result = m_module->m_operatorMgr.createMemberClosure (value, (Function*) item);
[+] 			result = m_module->m_operatorMgr.createMemberClosure(value, (Function*)item);
[-] 			err::setFormatStringError ("property '%s' cannot be used in const expression", name.sz ());
[+] 			err::setFormatStringError("property '%s' cannot be used in const expression", name.sz ());
[-] 		value->setProperty ((Property*) item);
[+] 		value->setProperty((Property*)item);
[-] 		if (((Property*) item)->isMember ())
[+] 		if (((Property*)item)->isMember())
[-] 			result = m_module->m_operatorMgr.createMemberClosure (value, (Property*) item);
[+] 			result = m_module->m_operatorMgr.createMemberClosure(value, (Property*)item);
[-] 		if (!(item->getFlags () & EnumConstFlag_ValueReady))
[+] 		if (!(item->getFlags() & EnumConstFlag_ValueReady))
[-] 			result = ((EnumConst*) item)->getParentEnumType ()->ensureLayout ();
[+] 			result = ((EnumConst*)item)->getParentEnumType()->ensureLayout();
[-] 		value->setEnumConst ((EnumConst*) item);
[+] 		value->setEnumConst((EnumConst*)item);
[-] 			err::setFormatStringError ("field '%s' cannot be used in const expression", name.sz ());
[+] 			err::setFormatStringError("field '%s' cannot be used in const expression", name.sz ());
[-] 			m_module->m_operatorMgr.getThisValue (&thisValue, (StructField*) item) &&
[+] 			m_module->m_operatorMgr.getThisValue(&thisValue, (StructField*)item) &&
[-] 			m_module->m_operatorMgr.getField (thisValue, (StructField*) item, &coord, value);
[+] 			m_module->m_operatorMgr.getField(thisValue, (StructField*)item, &coord, value);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getModuleItemKindString (item->getItemKind ()),
[+] 			getModuleItemKindString(item->getItemKind()),
[-] 			name.sz ()
[+] 			name.sz()
[-] Parser::lookupIdentifierType (
[+] Parser::lookupIdentifierType(
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	item = nspace->findItemTraverse (name);
[+] 	item = nspace->findItemTraverse(name);
[-] 		err::setFormatStringError ("undeclared identifier '%s'", name.sz ());
[+] 		err::setFormatStringError("undeclared identifier '%s'", name.sz ());
[-] 		lex::pushSrcPosError (m_module->m_unitMgr.getCurrentUnit ()->getFilePath (), pos);
[+] 		lex::pushSrcPosError(m_module->m_unitMgr.getCurrentUnit()->getFilePath(), pos);
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		value->setNamespace ((GlobalNamespace*) item);
[+] 		value->setNamespace((GlobalNamespace*)item);
[-] 		item = ((Typedef*) item)->getType ();
[+] 		item = ((Typedef*)item)->getType();
[-] 		if (!(((Type*) item)->getTypeKindFlags () & TypeKindFlag_Named))
[+] 		if (!(((Type*)item)->getTypeKindFlags() & TypeKindFlag_Named))
[-] 			err::setFormatStringError ("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be used as expression", ((Type*) item)->getTypeString ().sz ());
[-] 		value->setNamespace ((NamedType*) item);
[+] 		value->setNamespace((NamedType*)item);
[-] 		value->setType (getDirectRefType (((Variable*) item)->getType ()));
[+] 		value->setType(getDirectRefType(((Variable*)item)->getType()));
[-] 		value->setType (((Alias*) item)->getType ());
[+] 		value->setType(((Alias*)item)->getType());
[-] 		Function* function = (Function*) item;
[+] 		Function* function = (Function*)item;
[-] 		value->setFunctionTypeOverload (function->getTypeOverload ());
[+] 		value->setFunctionTypeOverload(function->getTypeOverload());
[-] 		if (((Function*) item)->isMember ())
[+] 		if (((Function*)item)->isMember())
[-] 			result = m_module->m_operatorMgr.createMemberClosure (value, (Function*) item);
[+] 			result = m_module->m_operatorMgr.createMemberClosure(value, (Function*)item);
[-] 		value->setType (((Property*) item)->getType ()->getPropertyPtrType (TypeKind_PropertyRef, PropertyPtrTypeKind_Thin));
[+] 		value->setType(((Property*)item)->getType()->getPropertyPtrType(TypeKind_PropertyRef, PropertyPtrTypeKind_Thin));
[-] 		if (((Property*) item)->isMember ())
[+] 		if (((Property*)item)->isMember())
[-] 			result = m_module->m_operatorMgr.createMemberClosure (value, (Property*) item);
[+] 			result = m_module->m_operatorMgr.createMemberClosure(value, (Property*)item);
[-] 		value->setType (((EnumConst*) item)->getParentEnumType ()->getBaseType ());
[+] 		value->setType(((EnumConst*)item)->getParentEnumType()->getBaseType());
[-] 		value->setType (getDirectRefType (((StructField*) item)->getType ()));
[+] 		value->setType(getDirectRefType(((StructField*)item)->getType()));
[-] 		err::setFormatStringError ("'%s' cannot be used as expression", name.sz ());
[+] 		err::setFormatStringError("'%s' cannot be used as expression", name.sz ());
[-] Parser::prepareCurlyInitializerNamedItem (
[+] Parser::prepareCurlyInitializerNamedItem(
[-] 	bool result = m_module->m_operatorMgr.memberOperator (
[+] 	bool result = m_module->m_operatorMgr.memberOperator(
[-] Parser::prepareCurlyInitializerIndexedItem (CurlyInitializer* initializer)
[+] Parser::prepareCurlyInitializerIndexedItem(CurlyInitializer* initializer)
[-] 		err::setFormatStringError ("indexed-based initializer cannot be used after named-based initializer");
[+] 		err::setFormatStringError("indexed-based initializer cannot be used after named-based initializer");
[-] 	bool result = m_module->m_operatorMgr.memberOperator (
[+] 	bool result = m_module->m_operatorMgr.memberOperator(
[-] Parser::skipCurlyInitializerItem (CurlyInitializer* initializer)
[+] Parser::skipCurlyInitializerItem(CurlyInitializer* initializer)
[-] Parser::assignCurlyInitializerItem (
[+] Parser::assignCurlyInitializerItem(
[-] 		value.getValueKind () != ValueKind_Const ||
[+] 		value.getValueKind() != ValueKind_Const ||
[-] 		!isCharArrayType (value.getType ()) ||
[+] 		!isCharArrayType(value.getType()) ||
[-] 		!isCharArrayRefType (initializer->m_targetValue.getType ()))
[+] 		!isCharArrayRefType(initializer->m_targetValue.getType()))
[-] 		return m_module->m_operatorMgr.binaryOperator (BinOpKind_Assign, initializer->m_memberValue, value);
[+] 		return m_module->m_operatorMgr.binaryOperator(BinOpKind_Assign, initializer->m_memberValue, value);
[-] 	ArrayType* srcType = (ArrayType*) value.getType ();
[+] 	ArrayType* srcType = (ArrayType*)value.getType();
[-] 	ArrayType* dstType = (ArrayType*) ((DataPtrType*) initializer->m_targetValue.getType ())->getTargetType ();
[+] 	ArrayType* dstType = (ArrayType*)((DataPtrType*)initializer->m_targetValue.getType())->getTargetType();
[-] 	size_t length = srcType->getElementCount ();
[+] 	size_t length = srcType->getElementCount();
[-] 	if (dstType->getElementCount () < initializer->m_index + length)
[+] 	if (dstType->getElementCount() < initializer->m_index + length)
[-] 		err::setFormatStringError ("literal initializer is too big to fit inside the target array");
[+] 		err::setFormatStringError("literal initializer is too big to fit inside the target array");
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, initializer->m_memberValue, &memberPtrValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, initializer->m_memberValue, &memberPtrValue) &&
[-] 		m_module->m_operatorMgr.memCpy (memberPtrValue, value, length);
[+] 		m_module->m_operatorMgr.memCpy(memberPtrValue, value, length);
[-] Parser::addFmtSite (
[+] Parser::addFmtSite(
[-] 	literal->m_binData.append (string.cp (), string.getLength ());
[+] 	literal->m_binData.append(string.cp(), string.getLength());
[-] 	FmtSite* site = AXL_MEM_NEW (FmtSite);
[+] 	FmtSite* site = AXL_MEM_NEW(FmtSite);
[-] 	site->m_offset = literal->m_binData.getCount ();
[+] 	site->m_offset = literal->m_binData.getCount();
[-] 	literal->m_fmtSiteList.insertTail (site);
[+] 	literal->m_fmtSiteList.insertTail(site);
[-] 		if (value.getValueKind () != ValueKind_Const ||
[+] 		if (value.getValueKind() != ValueKind_Const ||
[-] 			!(value.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 			!(value.getType()->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 			err::setFormatStringError ("expression is not integer constant");
[+] 			err::setFormatStringError("expression is not integer constant");
[-] 		memcpy (&site->m_index, value.getConstData (), value.getType ()->getSize ());
[+] 		memcpy(&site->m_index, value.getConstData(), value.getType()->getSize());
[-] Parser::finalizeLiteral_0 (
[+] Parser::finalizeLiteral_0(
[-] 		type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType ();
[+] 		type = m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType();
[-] 		type = m_module->m_typeMgr.getArrayType (m_module->m_typeMgr.getPrimitiveType (TypeKind_Char), literal->m_length);
[+] 		type = m_module->m_typeMgr.getArrayType(m_module->m_typeMgr.getPrimitiveType(TypeKind_Char), literal->m_length);
[-] 	resultValue->setType (type);
[+] 	resultValue->setType(type);
[-] Parser::finalizeLiteral (
[+] Parser::finalizeLiteral(
[-] 	sl::BoxList <Value>* argValueList,
[+] 	sl::BoxList<Value>* argValueList,
[-] 	if (literal->m_fmtSiteList.isEmpty ())
[+] 	if (literal->m_fmtSiteList.isEmpty())
[-] 			literal->m_binData.append (0);
[+] 			literal->m_binData.append(0);
[-] 		resultValue->setCharArray (literal->m_binData, literal->m_binData.getCount (), m_module);
[+] 		resultValue->setCharArray(literal->m_binData, literal->m_binData.getCount(), m_module);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value*> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value*> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		argCount = argValueList->getCount ();
[+] 		argCount = argValueList->getCount();
[-] 		argValueArray.setCount (argCount);
[+] 		argValueArray.setCount(argCount);
[-] 		sl::BoxIterator <Value> it = argValueList->getHead ();
[+] 		sl::BoxIterator<Value> it = argValueList->getHead();
[-] 			ASSERT (it);
[+] 			ASSERT(it);
[-] 			argValueArray [i] = it.p ();
[+] 			argValueArray[i] = it.p();
[-] 	Type* type = m_module->m_typeMgr.getStdType (StdType_FmtLiteral);
[+] 	Type* type = m_module->m_typeMgr.getStdType(StdType_FmtLiteral);
[-] 	Variable* fmtLiteral = m_module->m_variableMgr.createSimpleStackVariable ("fmtLiteral", type);
[+] 	Variable* fmtLiteral = m_module->m_variableMgr.createSimpleStackVariable("fmtLiteral", type);
[-] 	result = m_module->m_variableMgr.initializeVariable (fmtLiteral);
[+] 	result = m_module->m_variableMgr.initializeVariable(fmtLiteral);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	argUsageMap.setBitCount (argCount);
[+] 	argUsageMap.setBitCount(argCount);
[-] 	sl::Iterator <FmtSite> siteIt = literal->m_fmtSiteList.getHead ();
[+] 	sl::Iterator<FmtSite> siteIt = literal->m_fmtSiteList.getHead();
[-] 				err::setFormatStringError ("formatting literal doesn't have argument %%%d", site->m_index);
[+] 				err::setFormatStringError("formatting literal doesn't have argument %%%d", site->m_index);
[-] 			value = argValueArray [i];
[+] 			value = argValueArray[i];
[-] 			argUsageMap.setBit (i);
[+] 			argUsageMap.setBit(i);
[-] 			appendFmtLiteralRawData (
[+] 			appendFmtLiteralRawData(
[-] 		if (value->isEmpty ())
[+] 		if (value->isEmpty())
[-] 			err::setFormatStringError ("formatting literals arguments cannot be skipped");
[+] 			err::setFormatStringError("formatting literals arguments cannot be skipped");
[-] 		result = appendFmtLiteralValue (fmtLiteralValue, *value, site->m_fmtSpecifierString);
[+] 		result = appendFmtLiteralValue(fmtLiteralValue, *value, site->m_fmtSpecifierString);
[-] 	size_t unusedArgIdx = argUsageMap.findBit (0, false);
[+] 	size_t unusedArgIdx = argUsageMap.findBit(0, false);
[-] 		err::setFormatStringError ("formatting literal argument %%%d is not used", unusedArgIdx + 1);
[+] 		err::setFormatStringError("formatting literal argument %%%d is not used", unusedArgIdx + 1);
[-] 	size_t endOffset = literal->m_binData.getCount ();
[+] 	size_t endOffset = literal->m_binData.getCount();
[-] 		appendFmtLiteralRawData (
[+] 		appendFmtLiteralRawData(
[-] 	Type* validatorType = m_module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr);
[+] 	Type* validatorType = m_module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr);
[-] 	m_module->m_llvmIrBuilder.createGep2 (fmtLiteralValue, 0, NULL, &fatPtrValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(fmtLiteralValue, 0, NULL, &fatPtrValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (fatPtrValue, NULL, &fatPtrValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(fatPtrValue, NULL, &fatPtrValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (fatPtrValue, 0, NULL, &thinPtrValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(fatPtrValue, 0, NULL, &thinPtrValue);
[-] 	m_module->m_llvmIrBuilder.createExtractValue (fatPtrValue, 1, validatorType, &validatorValue);
[+] 	m_module->m_llvmIrBuilder.createExtractValue(fatPtrValue, 1, validatorType, &validatorValue);
[-] 	resultValue->setLeanDataPtr (
[+] 	resultValue->setLeanDataPtr(
[-] 		thinPtrValue.getLlvmValue (),
[+] 		thinPtrValue.getLlvmValue(),
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType (DataPtrTypeKind_Lean),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType(DataPtrTypeKind_Lean),
[-] Parser::appendFmtLiteralRawData (
[+] Parser::appendFmtLiteralRawData(
[-] 	Function* append = m_module->m_functionMgr.getStdFunction (StdFunc_AppendFmtLiteral_a);
[+] 	Function* append = m_module->m_functionMgr.getStdFunction(StdFunc_AppendFmtLiteral_a);
[-] 	literalValue.setCharArray (p, length, m_module);
[+] 	literalValue.setCharArray(p, length, m_module);
[-] 	m_module->m_operatorMgr.castOperator (&literalValue, m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType_c ());
[+] 	m_module->m_operatorMgr.castOperator(&literalValue, m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType_c());
[-] 	lengthValue.setConstSizeT (length, m_module);
[+] 	lengthValue.setConstSizeT(length, m_module);
[-] 	m_module->m_llvmIrBuilder.createCall3 (
[+] 	m_module->m_llvmIrBuilder.createCall3(
[-] 		append->getType (),
[+] 		append->getType(),
[-] Parser::appendFmtLiteralValue (
[+] Parser::appendFmtLiteralValue(
[-] 		return appendFmtLiteralBinValue (fmtLiteralValue, rawSrcValue);
[+] 		return appendFmtLiteralBinValue(fmtLiteralValue, rawSrcValue);
[-] 	bool result = m_module->m_operatorMgr.prepareOperand (rawSrcValue, &srcValue);
[+] 	bool result = m_module->m_operatorMgr.prepareOperand(rawSrcValue, &srcValue);
[-] 	Type* type = srcValue.getType ();
[+] 	Type* type = srcValue.getType();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	uint_t typeKindFlags = type->getTypeKindFlags ();
[+] 	uint_t typeKindFlags = type->getTypeKindFlags();
[-] 		static StdFunc funcTable [2] [2] =
[+] 		static StdFunc funcTable[2] [2] =
[-] 		size_t i1 = type->getSize () > 4;
[+] 		size_t i1 = type->getSize() > 4;
[-] 		appendFunc = funcTable [i1] [i2];
[+] 		appendFunc = funcTable[i1] [i2];
[-] 	else if (isCharArrayType (type) || isCharArrayRefType (type) || isCharPtrType (type))
[+] 	else if (isCharArrayType(type) || isCharArrayRefType(type) || isCharPtrType(type))
[-] 		err::setFormatStringError ("don't know how to format '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("don't know how to format '%s'", type->getTypeString ().sz ());
[-] 	Function* append = m_module->m_functionMgr.getStdFunction (appendFunc);
[+] 	Function* append = m_module->m_functionMgr.getStdFunction(appendFunc);
[-] 	Type* argType = append->getType ()->getArgArray () [2]->getType ();
[+] 	Type* argType = append->getType()->getArgArray() [2]->getType();
[-] 	result = m_module->m_operatorMgr.castOperator (srcValue, argType, &argValue);
[+] 	result = m_module->m_operatorMgr.castOperator(srcValue, argType, &argValue);
[-] 	if (!fmtSpecifierString.isEmpty ())
[+] 	if (!fmtSpecifierString.isEmpty())
[-] 		fmtSpecifierValue.setCharArray (fmtSpecifierString, m_module);
[+] 		fmtSpecifierValue.setCharArray(fmtSpecifierString, m_module);
[-] 		m_module->m_operatorMgr.castOperator (&fmtSpecifierValue, m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType_c ());
[+] 		m_module->m_operatorMgr.castOperator(&fmtSpecifierValue, m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType_c());
[-] 		fmtSpecifierValue = m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)->getDataPtrType_c ()->getZeroValue ();
[+] 		fmtSpecifierValue = m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)->getDataPtrType_c()->getZeroValue();
[-] 	return m_module->m_operatorMgr.callOperator (
[+] 	return m_module->m_operatorMgr.callOperator(
[-] Parser::appendFmtLiteralBinValue (
[+] Parser::appendFmtLiteralBinValue(
[-] 	bool result = m_module->m_operatorMgr.prepareOperand (rawSrcValue, &srcValue);
[+] 	bool result = m_module->m_operatorMgr.prepareOperand(rawSrcValue, &srcValue);
[-] 	Type* type = srcValue.getType ();
[+] 	Type* type = srcValue.getType();
[-] 	Function* append = m_module->m_functionMgr.getStdFunction (StdFunc_AppendFmtLiteral_a);
[+] 	Function* append = m_module->m_functionMgr.getStdFunction(StdFunc_AppendFmtLiteral_a);
[-] 	Type* argType = m_module->m_typeMgr.getStdType (StdType_BytePtr);
[+] 	Type* argType = m_module->m_typeMgr.getStdType(StdType_BytePtr);
[-] 	Value sizeValue (
[+] 	Value sizeValue(
[-] 		type->getSize (),
[+] 		type->getSize(),
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT)
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT)
[-] 	m_module->m_llvmIrBuilder.createAlloca (type, "tmpFmtValue", NULL, &tmpValue);
[+] 	m_module->m_llvmIrBuilder.createAlloca(type, "tmpFmtValue", NULL, &tmpValue);
[-] 	m_module->m_llvmIrBuilder.createStore (srcValue, tmpValue);
[+] 	m_module->m_llvmIrBuilder.createStore(srcValue, tmpValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (tmpValue, argType, &tmpValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(tmpValue, argType, &tmpValue);
[-] 	m_module->m_llvmIrBuilder.createCall3 (
[+] 	m_module->m_llvmIrBuilder.createCall3(
[-] 		append->getType (),
[+] 		append->getType(),
[-] Parser::finalizeReSwitchCaseLiteral (
[+] Parser::finalizeReSwitchCaseLiteral(
[-] 	if (value.getValueKind () != ValueKind_Const)
[+] 	if (value.getValueKind() != ValueKind_Const)
[-] 		err::setFormatStringError ("not a constant literal expression");
[+] 		err::setFormatStringError("not a constant literal expression");
[-] 	size_t length = value.m_type->getSize ();
[+] 	size_t length = value.m_type->getSize();
[-] 		ASSERT (length);
[+] 		ASSERT(length);
[-] 	*data = sl::StringRef (value.m_constData.getHdr (), value.m_constData.cp (), length);
[+] 	*data = sl::StringRef(value.m_constData.getHdr(), value.m_constData.cp(), length);
[-] Parser::assertCondition (const sl::BoxList <Token>& tokenList)
[+] Parser::assertCondition(const sl::BoxList<Token>& tokenList)
[-] 	result = m_module->m_operatorMgr.parseExpression (tokenList, &conditionValue);
[+] 	result = m_module->m_operatorMgr.parseExpression(tokenList, &conditionValue);
[-] 	BasicBlock* failBlock = m_module->m_controlFlowMgr.createBlock ("assert_fail");
[+] 	BasicBlock* failBlock = m_module->m_controlFlowMgr.createBlock("assert_fail");
[-] 	BasicBlock* continueBlock = m_module->m_controlFlowMgr.createBlock ("assert_continue");
[+] 	BasicBlock* continueBlock = m_module->m_controlFlowMgr.createBlock("assert_continue");
[-] 	result = m_module->m_controlFlowMgr.conditionalJump (conditionValue, continueBlock, failBlock, failBlock);
[+] 	result = m_module->m_controlFlowMgr.conditionalJump(conditionValue, continueBlock, failBlock, failBlock);
[-] Parser::finalizeAssertStmt (
[+] Parser::finalizeAssertStmt(
[-] 	const sl::BoxList <Token>& conditionTokenList,
[+] 	const sl::BoxList<Token>& conditionTokenList,
[-] 	ASSERT (!conditionTokenList.isEmpty ());
[+] 	ASSERT(!conditionTokenList.isEmpty());
[-] 	sl::String fileName = m_module->m_unitMgr.getCurrentUnit ()->getFilePath ();
[+] 	sl::String fileName = m_module->m_unitMgr.getCurrentUnit()->getFilePath();
[-] 	sl::String conditionString = Token::getTokenListString (conditionTokenList);
[+] 	sl::String conditionString = Token::getTokenListString(conditionTokenList);
[-] 	Token::Pos pos = conditionTokenList.getHead ()->m_pos;
[+] 	Token::Pos pos = conditionTokenList.getHead()->m_pos;
[-] 	fileNameValue.setCharArray (fileName, m_module);
[+] 	fileNameValue.setCharArray(fileName, m_module);
[-] 	lineValue.setConstInt32 (pos.m_line, m_module);
[+] 	lineValue.setConstInt32(pos.m_line, m_module);
[-] 	conditionValue.setCharArray (conditionString, m_module);
[+] 	conditionValue.setCharArray(conditionString, m_module);
[-] 	Function* assertionFailure = m_module->m_functionMgr.getStdFunction (StdFunc_AssertionFailure);
[+] 	Function* assertionFailure = m_module->m_functionMgr.getStdFunction(StdFunc_AssertionFailure);
[-] 	sl::BoxList <Value> argValueList;
[+] 	sl::BoxList<Value> argValueList;
[-] 	argValueList.insertTail (fileNameValue);
[+] 	argValueList.insertTail(fileNameValue);
[-] 	argValueList.insertTail (lineValue);
[+] 	argValueList.insertTail(lineValue);
[-] 	argValueList.insertTail (conditionValue);
[+] 	argValueList.insertTail(conditionValue);
[-] 		argValueList.insertTail (messageValue);
[+] 		argValueList.insertTail(messageValue);
[-] 		nullValue.setNull (m_module);
[+] 		nullValue.setNull(m_module);
[-] 		argValueList.insertTail (nullValue);
[+] 		argValueList.insertTail(nullValue);
[-] 	bool result = m_module->m_operatorMgr.callOperator (assertionFailure, &argValueList);
[+] 	bool result = m_module->m_operatorMgr.callOperator(assertionFailure, &argValueList);
[-] 	m_module->m_controlFlowMgr.follow (continueBlock);
[+] 	m_module->m_controlFlowMgr.follow(continueBlock);
[-] Parser::addScopeAnchorToken (
[+] Parser::addScopeAnchorToken(
[-] 	sl::BoxIterator <Token> it = stmt->m_tokenList.insertTail (token);
[+] 	sl::BoxIterator<Token> it = stmt->m_tokenList.insertTail(token);
----------------------
27/02/2019 18:02:13 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_Decl.h
----------------------
[-] getFirstTypeModifier (uint_t modifiers)
[+] getFirstTypeModifier(uint_t modifiers)
[-] 	return (TypeModifier) (1 << sl::getLoBitIdx (modifiers));
[+] 	return (TypeModifier)(1 << sl::getLoBitIdx(modifiers));
[-] getTypeModifierString (TypeModifier modifier);
[+] getTypeModifierString(TypeModifier modifier);
[-] getTypeModifierString (uint_t modifiers);
[+] getTypeModifierString(uint_t modifiers);
[-] getFirstTypeModifierString (uint_t modifiers)
[+] getFirstTypeModifierString(uint_t modifiers)
[-] 	return getTypeModifierString (getFirstTypeModifier (modifiers));
[+] 	return getTypeModifierString(getFirstTypeModifier(modifiers));
[-] 	TypeModifiers ()
[+] 	TypeModifiers()
[-] 	getTypeModifiers () const
[+] 	getTypeModifiers() const
[-] 	addTypeModifier (TypeModifier modifier);
[+] 	addTypeModifier(TypeModifier modifier);
[-] 	clearTypeModifiers ()
[+] 	clearTypeModifiers()
[-] 	clearTypeModifiers (int modifierMask);
[+] 	clearTypeModifiers(int modifierMask);
[-] 	takeOverTypeModifiers (TypeModifiers* modifiers)
[+] 	takeOverTypeModifiers(TypeModifiers* modifiers)
[-] 	checkAntiTypeModifiers (int modifierMask);
[+] 	checkAntiTypeModifiers(int modifierMask);
[-] 	TypeSpecifier ()
[+] 	TypeSpecifier()
[-] 	getType ()
[+] 	getType()
[-] 	setType (Type* type);
[+] 	setType(Type* type);
[-] 	DeclSuffix ()
[+] 	DeclSuffix()
[-] 	~DeclSuffix ()
[+] 	~DeclSuffix()
[-] 	getSuffixKind () const
[+] 	getSuffixKind() const
[-] 	getDeclarator () const
[+] 	getDeclarator() const
[-] 	sl::BoxList <Token> m_elementCountInitializer;
[+] 	sl::BoxList<Token> m_elementCountInitializer;
[-] 	DeclArraySuffix ()
[+] 	DeclArraySuffix()
[-] 	getElementCount ()
[+] 	getElementCount()
[-] 	sl::BoxList <Token>*
[+] 	sl::BoxList<Token>*
[-] 	getElementCountInitializer ()
[+] 	getElementCountInitializer()
[-] 	sl::Array <FunctionArg*> m_argArray;
[+] 	sl::Array<FunctionArg*> m_argArray;
[-] 	DeclFunctionSuffix ()
[+] 	DeclFunctionSuffix()
[-] 	sl::Array <FunctionArg*>
[+] 	sl::Array<FunctionArg*>
[-] 	getArgArray ()
[+] 	getArgArray()
[-] 	getFunctionTypeFlags ()
[+] 	getFunctionTypeFlags()
[-] 	addFunctionTypeFlag (FunctionTypeFlag flag);
[+] 	addFunctionTypeFlag(FunctionTypeFlag flag);
[-] getFirstPostDeclaratorModifier (uint_t modifiers)
[+] getFirstPostDeclaratorModifier(uint_t modifiers)
[-] 	return (PostDeclaratorModifier) (1 << sl::getLoBitIdx (modifiers));
[+] 	return (PostDeclaratorModifier)(1 << sl::getLoBitIdx(modifiers));
[-] getPostDeclaratorModifierString (PostDeclaratorModifier modifier);
[+] getPostDeclaratorModifierString(PostDeclaratorModifier modifier);
[-] getPostDeclaratorModifierString (uint_t modifiers);
[+] getPostDeclaratorModifierString(uint_t modifiers);
[-] getFirstPostDeclaratorModifierString (uint_t modifiers)
[+] getFirstPostDeclaratorModifierString(uint_t modifiers)
[-] 	return getPostDeclaratorModifierString (getFirstPostDeclaratorModifier (modifiers));
[+] 	return getPostDeclaratorModifierString(getFirstPostDeclaratorModifier(modifiers));
[-] 	sl::List <DeclPointerPrefix> m_pointerPrefixList;
[+] 	sl::List<DeclPointerPrefix> m_pointerPrefixList;
[-] 	sl::List <DeclSuffix> m_suffixList;
[+] 	sl::List<DeclSuffix> m_suffixList;
[-] 	sl::BoxList <Token> m_constructor;
[+] 	sl::BoxList<Token> m_constructor;
[-] 	sl::BoxList <Token> m_initializer;
[+] 	sl::BoxList<Token> m_initializer;
[-] 	Declarator ();
[+] 	Declarator();
[-] 	isSimple ()
[+] 	isSimple()
[-] 		return m_declaratorKind == DeclaratorKind_Name && m_name.isSimple ();
[+] 		return m_declaratorKind == DeclaratorKind_Name && m_name.isSimple();
[-] 	isQualified ()
[+] 	isQualified()
[-] 		return m_declaratorKind == DeclaratorKind_Name ? !m_name.isSimple () : !m_name.isEmpty ();
[+] 		return m_declaratorKind == DeclaratorKind_Name ? !m_name.isSimple() : !m_name.isEmpty();
[-] 	getDeclaratorKind ()
[+] 	getDeclaratorKind()
[-] 	getFunctionKind ()
[+] 	getFunctionKind()
[-] 	getUnOpKind ()
[+] 	getUnOpKind()
[-] 	getBinOpKind ()
[+] 	getBinOpKind()
[-] 	getCastOpType ()
[+] 	getCastOpType()
[-] 	setTypeSpecifier (
[+] 	setTypeSpecifier(
[-] 	getName ()
[+] 	getName()
[-] 	getPos ()
[+] 	getPos()
[-] 	getBitCount ()
[+] 	getBitCount()
[-] 	getPostDeclaratorModifiers ()
[+] 	getPostDeclaratorModifiers()
[-] 	getBaseType ()
[+] 	getBaseType()
[-] 	getAttributeBlock ()
[+] 	getAttributeBlock()
[-] 	getDoxyBlock ()
[+] 	getDoxyBlock()
[-] 	sl::ConstList <DeclPointerPrefix>
[+] 	sl::ConstList<DeclPointerPrefix>
[-] 	getPointerPrefixList ()
[+] 	getPointerPrefixList()
[-] 	sl::ConstList <DeclSuffix>
[+] 	sl::ConstList<DeclSuffix>
[-] 	getSuffixList ()
[+] 	getSuffixList()
[-] 	setPostDeclaratorModifier (PostDeclaratorModifier modifier);
[+] 	setPostDeclaratorModifier(PostDeclaratorModifier modifier);
[-] 	getFunctionSuffix ()
[+] 	getFunctionSuffix()
[-] 		sl::Iterator <DeclSuffix> suffix = m_suffixList.getHead ();
[+] 		sl::Iterator<DeclSuffix> suffix = m_suffixList.getHead();
[-] 		return suffix && suffix->getSuffixKind () == DeclSuffixKind_Function ? (DeclFunctionSuffix*) *suffix : NULL;
[+] 		return suffix && suffix->getSuffixKind() == DeclSuffixKind_Function ? (DeclFunctionSuffix*)*suffix : NULL;
[-] 	calcType ()
[+] 	calcType()
[-] 		return calcTypeImpl (NULL, NULL);
[+] 		return calcTypeImpl(NULL, NULL);
[-] 	calcType (Value* elementCountValue)
[+] 	calcType(Value* elementCountValue)
[-] 		return calcTypeImpl (elementCountValue, NULL);
[+] 		return calcTypeImpl(elementCountValue, NULL);
[-] 	calcType (uint_t* flags)
[+] 	calcType(uint_t* flags)
[-] 		return calcTypeImpl (NULL, flags);
[+] 		return calcTypeImpl(NULL, flags);
[-] 	addName (sl::String name);
[+] 	addName(sl::String name);
[-] 	addUnnamedMethod (FunctionKind functionKind);
[+] 	addUnnamedMethod(FunctionKind functionKind);
[-] 	addCastOperator (Type* type);
[+] 	addCastOperator(Type* type);
[-] 	addUnaryBinaryOperator (
[+] 	addUnaryBinaryOperator(
[-] 	addPointerPrefix ();
[+] 	addPointerPrefix();
[-] 	addArraySuffix (sl::BoxList <Token>* elementCountInitializer);
[+] 	addArraySuffix(sl::BoxList<Token>* elementCountInitializer);
[-] 	addArraySuffix (size_t elementCount);
[+] 	addArraySuffix(size_t elementCount);
[-] 	addFunctionSuffix ();
[+] 	addFunctionSuffix();
[-] 	addGetterSuffix ();
[+] 	addGetterSuffix();
[-] 	addBitFieldSuffix (size_t bitCount);
[+] 	addBitFieldSuffix(size_t bitCount);
[-] 	deleteSuffix (DeclSuffix* suffix)
[+] 	deleteSuffix(DeclSuffix* suffix)
[-] 		m_suffixList.erase (suffix);
[+] 		m_suffixList.erase(suffix);
[-] 	calcTypeImpl (
[+] 	calcTypeImpl(
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_DeclTypeCalc.h
----------------------
[-] 	sl::ConstIterator <DeclSuffix> m_suffix;
[+] 	sl::ConstIterator<DeclSuffix> m_suffix;
[-] 	DeclTypeCalc ()
[+] 	DeclTypeCalc()
[-] 	calcType (
[+] 	calcType(
[-] 		return calcType (
[+] 		return calcType(
[-] 			declarator->getBaseType (),
[+] 			declarator->getBaseType(),
[-] 			declarator->getPointerPrefixList (),
[+] 			declarator->getPointerPrefixList(),
[-] 			declarator->getSuffixList (),
[+] 			declarator->getSuffixList(),
[-] 	calcType (
[+] 	calcType(
[-] 		const sl::ConstList <DeclPointerPrefix>& pointerPrefixList,
[+] 		const sl::ConstList<DeclPointerPrefix>& pointerPrefixList,
[-] 		const sl::ConstList <DeclSuffix>& suffixList,
[+] 		const sl::ConstList<DeclSuffix>& suffixList,
[-] 	calcPtrType (
[+] 	calcPtrType(
[-] 	calcIntModType (
[+] 	calcIntModType(
[-] 	calcPropertyGetterType (Declarator* declarator);
[+] 	calcPropertyGetterType(Declarator* declarator);
[-] 	checkUnusedModifiers ();
[+] 	checkUnusedModifiers();
[-] 	getPtrTypeFlags (
[+] 	getPtrTypeFlags(
[-] 	getPropertyFlags ();
[+] 	getPropertyFlags();
[-] 	getIntegerType (Type* type);
[+] 	getIntegerType(Type* type);
[-] 	getArrayType (Type* elementType);
[+] 	getArrayType(Type* elementType);
[-] 	getFunctionType (Type* returnType);
[+] 	getFunctionType(Type* returnType);
[-] 	getPropertyType (Type* returnType);
[+] 	getPropertyType(Type* returnType);
[-] 	getBindableDataType (Type* dataType);
[+] 	getBindableDataType(Type* dataType);
[-] 	getMulticastType (Type* leftType);
[+] 	getMulticastType(Type* leftType);
[-] 	getDataPtrType (Type* dataType);
[+] 	getDataPtrType(Type* dataType);
[-] 	getClassPtrType (ClassType* classType);
[+] 	getClassPtrType(ClassType* classType);
[-] 	getFunctionPtrType (FunctionType* functionType);
[+] 	getFunctionPtrType(FunctionType* functionType);
[-] 	getPropertyPtrType (PropertyType* propertyType);
[+] 	getPropertyPtrType(PropertyType* propertyType);
[-] 	getImportPtrType (NamedImportType* importType);
[+] 	getImportPtrType(NamedImportType* importType);
[-] 	getImportIntModType (NamedImportType* importType);
[+] 	getImportIntModType(NamedImportType* importType);
[-] 	prepareReturnType (Type* type);
[+] 	prepareReturnType(Type* type);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Parser\jnc_ct_Lexer.h
----------------------
[-] AXL_LEX_BEGIN_TOKEN_NAME_MAP (TokenName)
[+] AXL_LEX_BEGIN_TOKEN_NAME_MAP(TokenName)
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eof,          "eof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eof,          "eof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Error,        "error")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Error,        "error")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Identifier,   "identifier")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Identifier,   "identifier")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Integer,      "integer-constant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Integer,      "integer-constant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Fp,           "floating-point-constant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Fp,           "floating-point-constant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DoxyComment1, "///")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DoxyComment1, "///")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DoxyComment2, "//!")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DoxyComment2, "//!")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DoxyComment3, "/**")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DoxyComment3, "/**")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DoxyComment4, "/*!")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DoxyComment4, "/*!")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Literal,      "string-literal")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Literal,      "string-literal")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_BinLiteral,   "bin-literal")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_BinLiteral,   "bin-literal")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_FmtLiteral,   "fmt-literal")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_FmtLiteral,   "fmt-literal")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_FmtSpecifier, "fmt-specifier")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_FmtSpecifier, "fmt-specifier")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Import,       "import")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Import,       "import")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Namespace,    "namespace")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Namespace,    "namespace")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Extension,    "extension")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Extension,    "extension")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DynamicLib,   "dynamiclib")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DynamicLib,   "dynamiclib")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Using,        "using")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Using,        "using")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Friend,       "friend")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Friend,       "friend")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Public,       "public")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Public,       "public")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Protected,    "protected")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Protected,    "protected")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Alignment,    "alignment")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Alignment,    "alignment")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_SetAs,        "setas")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_SetAs,        "setas")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Typedef,      "typedef")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Typedef,      "typedef")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Alias,        "alias")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Alias,        "alias")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Static,       "static")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Static,       "static")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ThreadLocal,  "threadlocal")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ThreadLocal,  "threadlocal")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Abstract,     "abstract")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Abstract,     "abstract")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Virtual,      "virtual")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Virtual,      "virtual")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Override,     "override")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Override,     "override")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Mutable,      "mutable")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Mutable,      "mutable")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Disposable,   "disposable")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Disposable,   "disposable")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Unsigned,     "unsigned")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Unsigned,     "unsigned")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_BigEndian,    "bigendian")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_BigEndian,    "bigendian")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Const,        "const")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Const,        "const")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ReadOnly,     "readonly")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ReadOnly,     "readonly")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_CMut,         "cmut")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_CMut,         "cmut")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Volatile,     "volatile")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Volatile,     "volatile")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Weak,         "weak")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Weak,         "weak")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Thin,         "thin")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Thin,         "thin")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Safe,         "safe")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Safe,         "safe")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Unsafe,       "unsafe")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Unsafe,       "unsafe")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ErrorCode,    "errorcode")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ErrorCode,    "errorcode")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Cdecl,        "cdecl")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Cdecl,        "cdecl")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Stdcall,      "stdcall")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Stdcall,      "stdcall")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Thiscall,     "thiscall")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Thiscall,     "thiscall")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Jnccall,      "jnccall")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Jnccall,      "jnccall")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Array,        "array")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Array,        "array")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Function,     "function")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Function,     "function")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Property,     "property")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Property,     "property")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Bindable,     "bindable")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Bindable,     "bindable")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AutoGet,      "autoget")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AutoGet,      "autoget")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Indexed,      "indexed")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Indexed,      "indexed")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Multicast,    "multicast")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Multicast,    "multicast")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Event,        "event")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Event,        "event")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Reactor,      "reactor")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Reactor,      "reactor")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Async,        "async")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Async,        "async")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AnyData,      "anydata")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AnyData,      "anydata")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Void,         "void")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Void,         "void")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Variant,      "variant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Variant,      "variant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Bool,         "bool")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Bool,         "bool")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Int,          "int")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Int,          "int")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_IntPtr,       "intptr")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_IntPtr,       "intptr")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Char,         "char")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Char,         "char")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Short,        "short")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Short,        "short")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Long,         "long")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Long,         "long")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Float,        "float")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Float,        "float")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Double,       "double")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Double,       "double")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Enum,         "enum")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Enum,         "enum")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Struct,       "struct")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Struct,       "struct")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Union,        "union")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Union,        "union")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Class,        "class")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Class,        "class")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Opaque,       "opaque")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Opaque,       "opaque")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Exposed,      "exposed")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Exposed,      "exposed")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_BitFlag,      "bitflag")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_BitFlag,      "bitflag")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Get,          "get")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Get,          "get")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Set,          "set")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Set,          "set")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_PreConstruct, "preconstruct")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_PreConstruct, "preconstruct")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Construct,    "construct")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Construct,    "construct")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Destruct,     "destruct")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Destruct,     "destruct")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Operator,     "operator")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Operator,     "operator")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Postfix,      "postfix")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Postfix,      "postfix")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_If,           "if")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_If,           "if")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Else,         "else")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Else,         "else")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_For,          "for")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_For,          "for")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_While,        "while")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_While,        "while")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Do,           "do")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Do,           "do")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Break,        "break")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Break,        "break")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Continue,     "continue")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Continue,     "continue")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Return,       "return")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Return,       "return")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Switch,       "switch")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Switch,       "switch")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ReSwitch,     "reswitch")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ReSwitch,     "reswitch")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Case,         "case")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Case,         "case")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Default,      "default")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Default,      "default")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Once,         "once")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Once,         "once")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OnEvent,      "onevent")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OnEvent,      "onevent")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Try,          "try")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Try,          "try")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Throw,        "throw")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Throw,        "throw")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Catch,        "catch")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Catch,        "catch")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Finally,      "finally")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Finally,      "finally")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_NestedScope,  "nestedscope")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_NestedScope,  "nestedscope")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Assert,       "assert")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Assert,       "assert")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Await,        "await")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Await,        "await")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_BaseType,     "basetype")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_BaseType,     "basetype")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_This,         "this")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_This,         "this")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_True,         "true")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_True,         "true")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_False,        "false")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_False,        "false")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Null,         "null")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Null,         "null")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_New,          "new")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_New,          "new")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_SizeOf,       "sizeof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_SizeOf,       "sizeof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_CountOf,      "countof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_CountOf,      "countof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OffsetOf,     "offsetof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OffsetOf,     "offsetof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_TypeOf,       "typeof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_TypeOf,       "typeof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_BindingOf,    "bindingof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_BindingOf,    "bindingof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Dynamic,      "dynamic")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Dynamic,      "dynamic")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Inc,          "++")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Inc,          "++")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Dec,          "--")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Dec,          "--")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ptr,          "->")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ptr,          "->")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Imply,        "=>")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Imply,        "=>")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Shl,          "<<")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Shl,          "<<")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Shr,          ">>")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Shr,          ">>")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_LogAnd,       "&&")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_LogAnd,       "&&")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_LogOr,        "||")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_LogOr,        "||")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eq,           "==")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eq,           "==")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ne,           "!=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ne,           "!=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Le,           "<=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Le,           "<=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ge,           ">=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ge,           ">=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_RefAssign,    ":=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_RefAssign,    ":=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AddAssign,    "+=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AddAssign,    "+=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_SubAssign,    "-=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_SubAssign,    "-=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_MulAssign,    "*=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_MulAssign,    "*=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DivAssign,    "/=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DivAssign,    "/=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ModAssign,    "%=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ModAssign,    "%=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ShlAssign,    "<<=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ShlAssign,    "<<=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ShrAssign,    ">>=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ShrAssign,    ">>=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AndAssign,    "&=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AndAssign,    "&=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_XorAssign,    "^=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_XorAssign,    "^=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OrAssign,     "|=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OrAssign,     "|=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AtAssign,     "@=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AtAssign,     "@=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ellipsis,     "...")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ellipsis,     "...")
[-] AXL_LEX_END_TOKEN_NAME_MAP ();
[+] AXL_LEX_END_TOKEN_NAME_MAP();
[-] 	sl::Array <char> m_binData;
[+] 	sl::Array<char> m_binData;
[-] typedef lex::RagelToken <TokenKind, TokenName, TokenData> Token;
[+] typedef lex::RagelToken<TokenKind, TokenName, TokenData> Token;
[-] class Lexer: public lex::RagelLexer <Lexer, Token>
[+] class Lexer: public lex::RagelLexer<Lexer, Token>
[-] 	friend class lex::RagelLexer <Lexer, Token>;
[+] 	friend class lex::RagelLexer<Lexer, Token>;
[-] 	sl::Array <intptr_t> m_parenthesesLevelStack;
[+] 	sl::Array<intptr_t> m_parenthesesLevelStack;
[-] 	Lexer ();
[+] 	Lexer();
[-] 	createKeywordTokenEx (
[+] 	createKeywordTokenEx(
[-] 	createStringToken (
[+] 	createStringToken(
[-] 	createSourceFileToken ();
[+] 	createSourceFileToken();
[-] 	createSourceDirToken ();
[+] 	createSourceDirToken();
[-] 	createBinLiteralToken (int radix);
[+] 	createBinLiteralToken(int radix);
[-] 	createCharToken (
[+] 	createCharToken(
[-] 	createIntegerToken (
[+] 	createIntegerToken(
[-] 	createFpToken ();
[+] 	createFpToken();
[-] 	createConstIntegerToken (int value);
[+] 	createConstIntegerToken(int value);
[-] 	preCreateMlLiteralToken (int radix = 0);
[+] 	preCreateMlLiteralToken(int radix = 0);
[-] 	createMlLiteralToken ();
[+] 	createMlLiteralToken();
[-] 	preCreateFmtLiteralToken ();
[+] 	preCreateFmtLiteralToken();
[-] 	createFmtLiteralToken (
[+] 	createFmtLiteralToken(
[-] 	createFmtSimpleIdentifierTokens ();
[+] 	createFmtSimpleIdentifierTokens();
[-] 	createFmtLastErrorDescriptionTokens ();
[+] 	createFmtLastErrorDescriptionTokens();
[-] 	createFmtIndexTokens ();
[+] 	createFmtIndexTokens();
[-] 	createFmtSpecifierToken ();
[+] 	createFmtSpecifierToken();
[-] 	createDoxyCommentToken (TokenKind tokenKind);
[+] 	createDoxyCommentToken(TokenKind tokenKind);
[-] 	onLeftParentheses ();
[+] 	onLeftParentheses();
[-] 	onRightParentheses ();
[+] 	onRightParentheses();
[-] 	onSemicolon ();
[+] 	onSemicolon();
[-] 	terminateFmtSpecifier ();
[+] 	terminateFmtSpecifier();
[-] 	terminateFmtLiteral ();
[+] 	terminateFmtLiteral();
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ArrayType.cpp
----------------------
[-] ArrayType::ArrayType ()
[+] ArrayType::ArrayType()
[-] ArrayType::getRootType ()
[+] ArrayType::getRootType()
[-] 		m_rootType = m_elementType->getTypeKind () == TypeKind_Array ?
[+] 		m_rootType = m_elementType->getTypeKind() == TypeKind_Array ?
[-] 			((ArrayType*) m_elementType)->getRootType () :
[+] 			((ArrayType*)m_elementType)->getRootType() :
[-] ArrayType::prepareTypeString ()
[+] ArrayType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = getRootType ()->getTypeString ();
[+] 	tuple->m_typeStringPrefix = getRootType()->getTypeString();
[-] 	tuple->m_typeStringSuffix = createDimensionString ();
[+] 	tuple->m_typeStringSuffix = createDimensionString();
[-] ArrayType::prepareDoxyLinkedText ()
[+] ArrayType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix = getRootType ()->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = getRootType()->getDoxyLinkedTextPrefix();
[-] 	tuple->m_doxyLinkedTextSuffix = createDimensionString ();
[+] 	tuple->m_doxyLinkedTextSuffix = createDimensionString();
[-] ArrayType::createDimensionString ()
[+] ArrayType::createDimensionString()
[-] 		string.format ("[%d]", m_elementCount);
[+] 		string.format("[%d]", m_elementCount);
[-] 	while (elementType->getTypeKind () == TypeKind_Array)
[+] 	while (elementType->getTypeKind() == TypeKind_Array)
[-] 		ArrayType* arrayType = (ArrayType*) elementType;
[+] 		ArrayType* arrayType = (ArrayType*)elementType;
[-] 		string.appendFormat (" [%d]", arrayType->m_elementCount);
[+] 		string.appendFormat(" [%d]", arrayType->m_elementCount);
[-] ArrayType::ensureDynamicLayout (
[+] ArrayType::ensureDynamicLayout(
[-] 	result = calcLayoutImpl (dynamicStruct, dynamicField);
[+] 	result = calcLayoutImpl(dynamicStruct, dynamicField);
[-] ArrayType::calcLayoutImpl (
[+] ArrayType::calcLayoutImpl(
[-] 	bool result = m_elementType->ensureLayout ();
[+] 	bool result = m_elementType->ensureLayout();
[-] 	if (m_elementType->getTypeKind () == TypeKind_Class ||
[+] 	if (m_elementType->getTypeKind() == TypeKind_Class ||
[-] 		m_elementType->getFlags () & TypeFlag_Dynamic)
[+] 		m_elementType->getFlags() & TypeFlag_Dynamic)
[-] 		err::setFormatStringError ("'%s' cannot be an element of an array", m_elementType->getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' cannot be an element of an array", m_elementType->getTypeString ().sz ());
[-] 		AXL_MEM_DELETE (m_typeStringTuple);
[+] 		AXL_MEM_DELETE(m_typeStringTuple);
[-] 	uint_t rootTypeFlags = getRootType ()->getFlags ();
[+] 	uint_t rootTypeFlags = getRootType()->getFlags();
[-] 	m_alignment = m_elementType->getAlignment ();
[+] 	m_alignment = m_elementType->getAlignment();
[-] 	if (!m_elementCountInitializer.isEmpty ())
[+] 	if (!m_elementCountInitializer.isEmpty())
[-] 		ASSERT (m_parentUnit && m_parentNamespace);
[+] 		ASSERT(m_parentUnit && m_parentNamespace);
[-] 			m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 			m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 		m_module->m_namespaceMgr.openNamespace (m_parentNamespace);
[+] 		m_module->m_namespaceMgr.openNamespace(m_parentNamespace);
[-] 		result = m_module->m_operatorMgr.parseConstIntegerExpression (m_elementCountInitializer, &value);
[+] 		result = m_module->m_operatorMgr.parseConstIntegerExpression(m_elementCountInitializer, &value);
[-] 		m_module->m_namespaceMgr.closeNamespace ();
[+] 		m_module->m_namespaceMgr.closeNamespace();
[-] 			Type* returnType = m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 			Type* returnType = m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 			FunctionType* type = m_module->m_typeMgr.getFunctionType (returnType, NULL, 0);
[+] 			FunctionType* type = m_module->m_typeMgr.getFunctionType(returnType, NULL, 0);
[-] 			m_getDynamicSizeFunction = m_module->m_functionMgr.createFunction (FunctionKind_Internal, type);
[+] 			m_getDynamicSizeFunction = m_module->m_functionMgr.createFunction(FunctionKind_Internal, type);
[-] 			m_getDynamicSizeFunction->m_tag.format (
[+] 			m_getDynamicSizeFunction->m_tag.format(
[-] 				dynamicStruct->m_tag.sz (),
[+] 				dynamicStruct->m_tag.sz(),
[-] 				dynamicField->getName ().sz ()
[+] 				dynamicField->getName().sz()
[-] 			m_getDynamicSizeFunction->convertToMemberMethod (dynamicStruct);
[+] 			m_getDynamicSizeFunction->convertToMemberMethod(dynamicStruct);
[-] 			m_module->markForCompile (this);
[+] 			m_module->markForCompile(this);
[-] 			err::setFormatStringError ("invalid array size '%lld'\n", value);
[+] 			err::setFormatStringError("invalid array size '%lld'\n", value);
[-] 			lex::pushSrcPosError (
[+] 			lex::pushSrcPosError(
[-] 				m_parentUnit->getFilePath (),
[+] 				m_parentUnit->getFilePath(),
[-] 				m_elementCountInitializer.getHead ()->m_pos
[+] 				m_elementCountInitializer.getHead()->m_pos
[-] 			err::setFormatStringError ("array size '%lld' is too big\n", value);
[+] 			err::setFormatStringError("array size '%lld' is too big\n", value);
[-] 			lex::pushSrcPosError (
[+] 			lex::pushSrcPosError(
[-] 				m_parentUnit->getFilePath (),
[+] 				m_parentUnit->getFilePath(),
[-] 				m_elementCountInitializer.getHead ()->m_pos
[+] 				m_elementCountInitializer.getHead()->m_pos
[-] 		m_elementCount = (size_t) value;
[+] 		m_elementCount = (size_t)value;
[-] 	sl::String signature = createSignature (m_elementType, m_elementCount);
[+] 	sl::String signature = createSignature(m_elementType, m_elementCount);
[-] 	m_module->m_typeMgr.updateTypeSignature (this, signature);
[+] 	m_module->m_typeMgr.updateTypeSignature(this, signature);
[-] 	m_size = m_elementType->getSize () * m_elementCount;
[+] 	m_size = m_elementType->getSize() * m_elementCount;
[-] ArrayType::compile ()
[+] ArrayType::compile()
[-] 	ASSERT (m_getDynamicSizeFunction);
[+] 	ASSERT(m_getDynamicSizeFunction);
[-] 	m_module->m_functionMgr.internalPrologue (m_getDynamicSizeFunction);
[+] 	m_module->m_functionMgr.internalPrologue(m_getDynamicSizeFunction);
[-] 	m_module->m_functionMgr.createThisValue ();
[+] 	m_module->m_functionMgr.createThisValue();
[-] 	Unit* parentUnit = m_getDynamicSizeFunction->getParentUnit ();
[+] 	Unit* parentUnit = m_getDynamicSizeFunction->getParentUnit();
[-] 		m_module->m_unitMgr.setCurrentUnit (parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(parentUnit);
[-] 	m_module->m_namespaceMgr.openNamespace (m_getDynamicSizeFunction->getParentNamespace ());
[+] 	m_module->m_namespaceMgr.openNamespace(m_getDynamicSizeFunction->getParentNamespace());
[-] 	result = m_module->m_operatorMgr.parseExpression (m_elementCountInitializer, &resultValue);
[+] 	result = m_module->m_operatorMgr.parseExpression(m_elementCountInitializer, &resultValue);
[-] 	size_t size = m_elementType->getSize ();
[+] 	size_t size = m_elementType->getSize();
[-] 		Value sizeValue (size, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT));
[+] 		Value sizeValue(size, m_module->m_typeMgr.getPrimitiveType(TypeKind_SizeT));
[-] 		result = m_module->m_operatorMgr.binaryOperator (
[+] 		result = m_module->m_operatorMgr.binaryOperator(
[-] 	result = m_module->m_controlFlowMgr.ret (resultValue);
[+] 	result = m_module->m_controlFlowMgr.ret(resultValue);
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] ArrayType::markGcRoots (
[+] ArrayType::markGcRoots(
[-] 	ASSERT (m_flags & TypeFlag_GcRoot);
[+] 	ASSERT(m_flags & TypeFlag_GcRoot);
[-] 	gcHeap->addRootArray (p, m_elementType, m_elementCount);
[+] 	gcHeap->addRootArray(p, m_elementType, m_elementCount);
[-] ArrayType::prepareLlvmDiType ()
[+] ArrayType::prepareLlvmDiType()
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createArrayType (this);
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createArrayType(this);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_BitFieldType.cpp
----------------------
[-] BitFieldType::BitFieldType ()
[+] BitFieldType::BitFieldType()
[-] BitFieldType::prepareTypeString ()
[+] BitFieldType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = m_baseType->getTypeStringPrefix ();
[+] 	tuple->m_typeStringPrefix = m_baseType->getTypeStringPrefix();
[-] 	tuple->m_typeStringSuffix.format (":%d:%d", m_bitOffset, m_bitOffset + m_bitCount);
[+] 	tuple->m_typeStringSuffix.format(":%d:%d", m_bitOffset, m_bitOffset + m_bitCount);
[-] BitFieldType::prepareDoxyLinkedText ()
[+] BitFieldType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = m_baseType->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_typeStringPrefix = m_baseType->getDoxyLinkedTextPrefix();
[-] 	tuple->m_typeStringSuffix = getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix = getTypeStringSuffix();
[-] BitFieldType::calcLayout ()
[+] BitFieldType::calcLayout()
[-] 	TypeKind typeKind = m_baseType->getTypeKind ();
[+] 	TypeKind typeKind = m_baseType->getTypeKind();
[-] 		err::setFormatStringError ("bit field can only be used with integer types");
[+] 		err::setFormatStringError("bit field can only be used with integer types");
[-] 	m_size = m_baseType->getSize ();
[+] 	m_size = m_baseType->getSize();
[-] 	m_alignment = m_baseType->getAlignment ();
[+] 	m_alignment = m_baseType->getAlignment();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClassPtrType.cpp
----------------------
[-] ClassPtrType::ClassPtrType ()
[+] ClassPtrType::ClassPtrType()
[-] 	m_size = sizeof (void*);
[+] 	m_size = sizeof(void*);
[-] 	m_alignment = sizeof (void*);
[+] 	m_alignment = sizeof(void*);
[-] ClassPtrType::createSignature (
[+] ClassPtrType::createSignature(
[-] 	signature += getPtrTypeFlagSignature (flags);
[+] 	signature += getPtrTypeFlagSignature(flags);
[-] 	signature += classType->getSignature ();
[+] 	signature += classType->getSignature();
[-] ClassPtrType::getPointerStringSuffix ()
[+] ClassPtrType::getPointerStringSuffix()
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_flags);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_flags);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		string += getClassPtrTypeKindString (m_ptrTypeKind);
[+] 		string += getClassPtrTypeKindString(m_ptrTypeKind);
[-] ClassPtrType::prepareLlvmType ()
[+] ClassPtrType::prepareLlvmType()
[-] 	m_llvmType = llvm::PointerType::get (m_targetType->getIfaceStructType ()->getLlvmType (), 0);
[+] 	m_llvmType = llvm::PointerType::get(m_targetType->getIfaceStructType()->getLlvmType(), 0);
[-] ClassPtrType::prepareLlvmDiType ()
[+] ClassPtrType::prepareLlvmDiType()
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createPointerType (m_targetType->getIfaceStructType ());
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createPointerType(m_targetType->getIfaceStructType());
[-] ClassPtrType::markGcRoots (
[+] ClassPtrType::markGcRoots(
[-] 		gcHeap->weakMark (iface->m_box);
[+] 		gcHeap->weakMark(iface->m_box);
[-] 		gcHeap->markClass (iface->m_box);
[+] 		gcHeap->markClass(iface->m_box);
[-] ClassPtrType::calcFoldedDualType (
[+] ClassPtrType::calcFoldedDualType(
[-] 	ASSERT (isDualType (this));
[+] 	ASSERT(isDualType(this));
[-] 	return m_module->m_typeMgr.getClassPtrType (m_targetType, m_typeKind, m_ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getClassPtrType(m_targetType, m_typeKind, m_ptrTypeKind, flags);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClassType.cpp
----------------------
[-] ClassType::ClassType ()
[+] ClassType::ClassType()
[-] ClassType::getClassPtrType (
[+] ClassType::getClassPtrType(
[-] 	return m_module->m_typeMgr.getClassPtrType (this, typeKind, ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getClassPtrType(this, typeKind, ptrTypeKind, flags);
[-] ClassType::getVTableStructType ()
[+] ClassType::getVTableStructType()
[-] 	m_vtableStructType = m_module->m_typeMgr.createUnnamedStructType ();
[+] 	m_vtableStructType = m_module->m_typeMgr.createUnnamedStructType();
[-] 	m_vtableStructType->m_tag.format ("%s.VTable",m_tag.sz ());
[+] 	m_vtableStructType->m_tag.format("%s.VTable",m_tag.sz ());
[-] ClassType::createFieldImpl (
[+] ClassType::createFieldImpl(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 		err::setFormatStringError ("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[-] 	StructField* field = m_ifaceStructType->createField (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 	StructField* field = m_ifaceStructType->createField(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		m_unnamedFieldArray.append (field);
[+] 		m_unnamedFieldArray.append(field);
[-] 	else if (name [0] != '!') // internal field
[+] 	else if (name[0] != '!') // internal field
[-] 		bool result = addItem (field);
[+] 		bool result = addItem(field);
[-] 	if (!field->m_constructor.isEmpty () ||
[+] 	if (!field->m_constructor.isEmpty() ||
[-] 		!field->m_initializer.isEmpty ())
[+] 		!field->m_initializer.isEmpty())
[-] 		m_initializedMemberFieldArray.append (field);
[+] 		m_initializedMemberFieldArray.append(field);
[-] 	m_memberFieldArray.append (field);
[+] 	m_memberFieldArray.append(field);
[-] ClassType::addMethod (Function* function)
[+] ClassType::addMethod(Function* function)
[-] 	StorageKind storageKind = function->getStorageKind ();
[+] 	StorageKind storageKind = function->getStorageKind();
[-] 	FunctionKind functionKind = function->getFunctionKind ();
[+] 	FunctionKind functionKind = function->getFunctionKind();
[-] 	uint_t functionKindFlags = getFunctionKindFlags (functionKind);
[+] 	uint_t functionKindFlags = getFunctionKindFlags(functionKind);
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 			err::setFormatStringError ("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[+] 			err::setFormatStringError("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[-] 		function->convertToMemberMethod (this);
[+] 		function->convertToMemberMethod(this);
[-] 		m_overrideMethodArray.append (function);
[+] 		m_overrideMethodArray.append(function);
[-] 		function->convertToMemberMethod (this);
[+] 		function->convertToMemberMethod(this);
[-] 		m_virtualMethodArray.append (function);
[+] 		m_virtualMethodArray.append(function);
[-] 		function->convertToMemberMethod (this);
[+] 		function->convertToMemberMethod(this);
[-] 		err::setFormatStringError ("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[-] 	sl::Array <FunctionArg*> argArray;
[+] 	sl::Array<FunctionArg*> argArray;
[-] 	switch (functionKind)
[+] 	switch(functionKind)
[-] 		m_module->m_functionMgr.addStaticConstructor (this);
[+] 		m_module->m_functionMgr.addStaticConstructor(this);
[-] 		overloadIdx = addFunction (function);
[+] 		overloadIdx = addFunction(function);
[-] 			m_memberMethodArray.append (function);
[+] 			m_memberMethodArray.append(function);
[-] 		if (m_unaryOperatorTable.isEmpty ())
[+] 		if (m_unaryOperatorTable.isEmpty())
[-] 			m_unaryOperatorTable.setCountZeroConstruct (UnOpKind__Count);
[+] 			m_unaryOperatorTable.setCountZeroConstruct(UnOpKind__Count);
[-] 		target = &m_unaryOperatorTable [function->getUnOpKind ()];
[+] 		target = &m_unaryOperatorTable[function->getUnOpKind()];
[-] 		if (m_binaryOperatorTable.isEmpty ())
[+] 		if (m_binaryOperatorTable.isEmpty())
[-] 			m_binaryOperatorTable.setCountZeroConstruct (BinOpKind__Count);
[+] 			m_binaryOperatorTable.setCountZeroConstruct(BinOpKind__Count);
[-] 		target = &m_binaryOperatorTable [function->getBinOpKind ()];
[+] 		target = &m_binaryOperatorTable[function->getBinOpKind()];
[-] 		argArray = function->getType ()->getArgArray ();
[+] 		argArray = function->getType()->getArgArray();
[-] 		if (argArray.getCount () < 2)
[+] 		if (argArray.getCount() < 2)
[-] 			err::setFormatStringError ("indexer property getter should take at least one index argument");
[+] 			err::setFormatStringError("indexer property getter should take at least one index argument");
[-] 		indexerProperty = getIndexerProperty (argArray [1]->getType ());
[+] 		indexerProperty = getIndexerProperty(argArray[1]->getType());
[-] 		argArray = function->getType ()->getArgArray ();
[+] 		argArray = function->getType()->getArgArray();
[-] 		if (argArray.getCount () < 3)
[+] 		if (argArray.getCount() < 3)
[-] 			err::setFormatStringError ("indexer property setter should take at least one index argument");
[+] 			err::setFormatStringError("indexer property setter should take at least one index argument");
[-] 		indexerProperty = getIndexerProperty (argArray [1]->getType ());
[+] 		indexerProperty = getIndexerProperty(argArray[1]->getType());
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getFunctionKindString (functionKind),
[+] 			getFunctionKindString(functionKind),
[-] 			getTypeString ().sz ()
[+] 			getTypeString().sz()
[-] 	if (function->m_tag.isEmpty ())
[+] 	if (function->m_tag.isEmpty())
[-] 		function->m_tag.format ("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[+] 		function->m_tag.format("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getTypeString ().sz (),
[+] 			getTypeString().sz(),
[-] 			getFunctionKindString (functionKind)
[+] 			getFunctionKindString(functionKind)
[-] 		bool result = (*target)->addOverload (function) != -1;
[+] 		bool result = (*target)->addOverload(function) != -1;
[-] ClassType::addProperty (Property* prop)
[+] ClassType::addProperty(Property* prop)
[-] 	if (prop->isNamed ())
[+] 	if (prop->isNamed())
[-] 		bool result = addItem (prop);
[+] 		bool result = addItem(prop);
[-] 	StorageKind storageKind = prop->getStorageKind ();
[+] 	StorageKind storageKind = prop->getStorageKind();
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 		m_virtualPropertyArray.append (prop);
[+] 		m_virtualPropertyArray.append(prop);
[-] 	m_memberPropertyArray.append (prop);
[+] 	m_memberPropertyArray.append(prop);
[-] ClassType::calcLayout ()
[+] ClassType::calcLayout()
[-] 	if (m_baseTypeList.isEmpty () ||
[+] 	if (m_baseTypeList.isEmpty() ||
[-] 		m_baseTypeList.getHead ()->getType ()->getTypeKind () != TypeKind_Class)
[+] 		m_baseTypeList.getHead()->getType()->getTypeKind() != TypeKind_Class)
[-] 		m_ifaceStructType->addBaseType (m_module->m_typeMgr.getStdType (StdType_IfaceHdr));
[+] 		m_ifaceStructType->addBaseType(m_module->m_typeMgr.getStdType(StdType_IfaceHdr));
[-] 	size_t baseTypeCount = m_baseTypeList.getCount ();
[+] 	size_t baseTypeCount = m_baseTypeList.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <BaseTypeSlot*> ifaceBaseTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<BaseTypeSlot*> ifaceBaseTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	ifaceBaseTypeArray.setCount (baseTypeCount);
[+] 	ifaceBaseTypeArray.setCount(baseTypeCount);
[-] 	sl::Iterator <BaseTypeSlot> slotIt = m_baseTypeList.getHead ();
[+] 	sl::Iterator<BaseTypeSlot> slotIt = m_baseTypeList.getHead();
[-] 		if (!(slot->m_type->getTypeKindFlags () & TypeKindFlag_Derivable) ||
[+] 		if (!(slot->m_type->getTypeKindFlags() & TypeKindFlag_Derivable) ||
[-] 			(slot->m_type->getFlags () & TypeFlag_Dynamic))
[+] 			(slot->m_type->getFlags() & TypeFlag_Dynamic))
[-] 			err::setFormatStringError ("'%s' cannot be a base type of a class", slot->m_type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be a base type of a class", slot->m_type->getTypeString ().sz ());
[-] 		sl::StringHashTableIterator <BaseTypeSlot*> it = m_baseTypeMap.visit (slot->m_type->getSignature ());
[+] 		sl::StringHashTableIterator<BaseTypeSlot*> it = m_baseTypeMap.visit(slot->m_type->getSignature());
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				slot->m_type->getTypeString ().sz ()
[+] 				slot->m_type->getTypeString().sz()
[-] 		DerivableType* type = slot->getType ();
[+] 		DerivableType* type = slot->getType();
[-] 		result = type->ensureLayout ();
[+] 		result = type->ensureLayout();
[-] 		if (slot->m_type->getFlags () & TypeFlag_GcRoot)
[+] 		if (slot->m_type->getFlags() & TypeFlag_GcRoot)
[-] 			m_gcRootBaseTypeArray.append (slot);
[+] 			m_gcRootBaseTypeArray.append(slot);
[-] 		if (slot->m_type->getConstructor ())
[+] 		if (slot->m_type->getConstructor())
[-] 			m_baseTypeConstructArray.append (slot);
[+] 			m_baseTypeConstructArray.append(slot);
[-] 		if (slot->m_type->getTypeKind () != TypeKind_Class)
[+] 		if (slot->m_type->getTypeKind() != TypeKind_Class)
[-] 			ifaceBaseTypeArray [i] = m_ifaceStructType->addBaseType (slot->m_type);
[+] 			ifaceBaseTypeArray[i] = m_ifaceStructType->addBaseType(slot->m_type);
[-] 		ClassType* baseClassType = (ClassType*) slot->m_type;
[+] 		ClassType* baseClassType = (ClassType*)slot->m_type;
[-] 			err::setFormatStringError ("cannot derive from non-creatable opaque '%s'", baseClassType->getTypeString ().sz ());
[+] 			err::setFormatStringError("cannot derive from non-creatable opaque '%s'", baseClassType->getTypeString ().sz ());
[-] 		ifaceBaseTypeArray [i] = m_ifaceStructType->addBaseType (baseClassType->getIfaceStructType ());
[+] 		ifaceBaseTypeArray[i] = m_ifaceStructType->addBaseType(baseClassType->getIfaceStructType());
[-] 		slot->m_vtableIndex = m_vtable.getCount ();
[+] 		slot->m_vtableIndex = m_vtable.getCount();
[-] 		m_vtable.append (baseClassType->m_vtable);
[+] 		m_vtable.append(baseClassType->m_vtable);
[-] 			getVTableStructType ()->append (baseClassType->m_vtableStructType);
[+] 			getVTableStructType()->append(baseClassType->m_vtableStructType);
[-] 		m_baseTypePrimeArray.append (slot);
[+] 		m_baseTypePrimeArray.append(slot);
[-] 			m_baseTypeDestructArray.append (slot);
[+] 			m_baseTypeDestructArray.append(slot);
[-] 	result = m_ifaceStructType->ensureLayout ();
[+] 	result = m_ifaceStructType->ensureLayout();
[-] 	size_t count = m_memberFieldArray.getCount ();
[+] 	size_t count = m_memberFieldArray.getCount();
[-] 		StructField* field = m_memberFieldArray [i];
[+] 		StructField* field = m_memberFieldArray[i];
[-] 		Type* type = field->getType ();
[+] 		Type* type = field->getType();
[-] 		if (type->getFlags () & TypeFlag_GcRoot)
[+] 		if (type->getFlags() & TypeFlag_GcRoot)
[-] 			m_gcRootMemberFieldArray.append (field);
[+] 			m_gcRootMemberFieldArray.append(field);
[-] 		if ((type->getTypeKindFlags () & TypeKindFlag_Derivable) && ((DerivableType*) type)->getConstructor ())
[+] 		if ((type->getTypeKindFlags() & TypeKindFlag_Derivable) && ((DerivableType*)type)->getConstructor())
[-] 			m_memberFieldConstructArray.append (field);
[+] 			m_memberFieldConstructArray.append(field);
[-] 		if (type->getTypeKind () == TypeKind_Class)
[+] 		if (type->getTypeKind() == TypeKind_Class)
[-] 			ClassType* classType = (ClassType*) type;
[+] 			ClassType* classType = (ClassType*)type;
[-] 			if (classType->getDestructor ())
[+] 			if (classType->getDestructor())
[-] 				err::setFormatStringError ("cannot instantiate '%s'", type->getTypeString ().sz ());
[+] 				err::setFormatStringError("cannot instantiate '%s'", type->getTypeString ().sz ());
[-] 			if (classType->getClassTypeKind () == ClassTypeKind_Reactor)
[+] 			if (classType->getClassTypeKind() == ClassTypeKind_Reactor)
[-] 				((ReactorClassType*) classType)->m_parentOffset = field->getOffset () + sizeof (Box); // reactor's box
[+] 				((ReactorClassType*)classType)->m_parentOffset = field->getOffset() + sizeof(Box); // reactor's box
[-] 			m_classMemberFieldArray.append (field);
[+] 			m_classMemberFieldArray.append(field);
[-] 	count = m_memberPropertyArray.getCount ();
[+] 	count = m_memberPropertyArray.getCount();
[-] 		Property* prop = m_memberPropertyArray [i];
[+] 		Property* prop = m_memberPropertyArray[i];
[-] 		result = prop->ensureLayout ();
[+] 		result = prop->ensureLayout();
[-] 		if (prop->getConstructor ())
[+] 		if (prop->getConstructor())
[-] 			m_memberPropertyConstructArray.append (prop);
[+] 			m_memberPropertyConstructArray.append(prop);
[-] 		if (prop->getDestructor ())
[+] 		if (prop->getDestructor())
[-] 			m_memberPropertyDestructArray.append (prop);
[+] 			m_memberPropertyDestructArray.append(prop);
[-] 	slotIt = m_baseTypeList.getHead ();
[+] 	slotIt = m_baseTypeList.getHead();
[-] 		BaseTypeSlot* ifaceSlot = ifaceBaseTypeArray [i];
[+] 		BaseTypeSlot* ifaceSlot = ifaceBaseTypeArray[i];
[-] 	m_classStructType->ensureLayout ();
[+] 	m_classStructType->ensureLayout();
[-] 	if (!m_virtualPropertyArray.isEmpty () || !m_virtualMethodArray.isEmpty ())
[+] 	if (!m_virtualPropertyArray.isEmpty() || !m_virtualMethodArray.isEmpty())
[-] 		getVTableStructType (); // ensure VTable struct
[+] 		getVTableStructType(); // ensure VTable struct
[-] 	count = m_virtualPropertyArray.getCount ();
[+] 	count = m_virtualPropertyArray.getCount();
[-] 		Property* prop = m_virtualPropertyArray [i];
[+] 		Property* prop = m_virtualPropertyArray[i];
[-] 		ASSERT (prop->m_storageKind == StorageKind_Abstract || prop->m_storageKind == StorageKind_Virtual);
[+] 		ASSERT(prop->m_storageKind == StorageKind_Abstract || prop->m_storageKind == StorageKind_Virtual);
[-] 		size_t VTableIndex = m_vtable.getCount ();
[+] 		size_t VTableIndex = m_vtable.getCount();
[-] 		m_vtable.append (prop->m_vtable);
[+] 		m_vtable.append(prop->m_vtable);
[-] 		m_vtableStructType->append (prop->m_type->getVTableStructType ());
[+] 		m_vtableStructType->append(prop->m_type->getVTableStructType());
[-] 		size_t accessorCount = prop->m_vtable.getCount ();
[+] 		size_t accessorCount = prop->m_vtable.getCount();
[-] 			Function* accessor = prop->m_vtable [j];
[+] 			Function* accessor = prop->m_vtable[j];
[-] 	count = m_virtualMethodArray.getCount ();
[+] 	count = m_virtualMethodArray.getCount();
[-] 		Function* function = m_virtualMethodArray [i];
[+] 		Function* function = m_virtualMethodArray[i];
[-] 		ASSERT (function->m_storageKind == StorageKind_Abstract || function->m_storageKind == StorageKind_Virtual);
[+] 		ASSERT(function->m_storageKind == StorageKind_Abstract || function->m_storageKind == StorageKind_Virtual);
[-] 		result = function->getType ()->ensureLayout ();
[+] 		result = function->getType()->ensureLayout();
[-] 		addVirtualFunction (function);
[+] 		addVirtualFunction(function);
[-] 	count = m_overrideMethodArray.getCount ();
[+] 	count = m_overrideMethodArray.getCount();
[-] 		Function* function = m_overrideMethodArray [i];
[+] 		Function* function = m_overrideMethodArray[i];
[-] 		ASSERT (function->m_storageKind == StorageKind_Override);
[+] 		ASSERT(function->m_storageKind == StorageKind_Override);
[-] 		result = function->getType ()->ensureLayout ();
[+] 		result = function->getType()->ensureLayout();
[-] 		result = overrideVirtualFunction (function);
[+] 		result = overrideVirtualFunction(function);
[-] 		result = m_vtableStructType->ensureLayout ();
[+] 		result = m_vtableStructType->ensureLayout();
[-] 		createVTableVariable ();
[+] 		createVTableVariable();
[-] 	if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty ())
[+] 	if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty())
[-] 		result = createDefaultMethod (FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[+] 		result = createDefaultMethod(FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[-] 		!m_baseTypeConstructArray.isEmpty () ||
[+] 		!m_baseTypeConstructArray.isEmpty() ||
[-] 		!m_memberFieldConstructArray.isEmpty () ||
[+] 		!m_memberFieldConstructArray.isEmpty() ||
[-] 		!m_initializedMemberFieldArray.isEmpty () ||
[+] 		!m_initializedMemberFieldArray.isEmpty() ||
[-] 		!m_memberPropertyConstructArray.isEmpty ()))
[+] 		!m_memberPropertyConstructArray.isEmpty()))
[-] 		result = createDefaultMethod (FunctionKind_Constructor) != NULL;
[+] 		result = createDefaultMethod(FunctionKind_Constructor) != NULL;
[-] 		(!m_baseTypeDestructArray.isEmpty () ||
[+] 		(!m_baseTypeDestructArray.isEmpty() ||
[-] 		!m_memberPropertyDestructArray.isEmpty () ||
[+] 		!m_memberPropertyDestructArray.isEmpty() ||
[-] 		result = createDefaultMethod (FunctionKind_Destructor) != NULL;
[+] 		result = createDefaultMethod(FunctionKind_Destructor) != NULL;
[-] 	m_size = m_classStructType->getSize ();
[+] 	m_size = m_classStructType->getSize();
[-] 	m_alignment = m_classStructType->getAlignment ();
[+] 	m_alignment = m_classStructType->getAlignment();
[-] ClassType::addVirtualFunction (Function* function)
[+] ClassType::addVirtualFunction(Function* function)
[-] 	ASSERT (function->m_storageKind == StorageKind_Abstract || function->m_storageKind == StorageKind_Virtual);
[+] 	ASSERT(function->m_storageKind == StorageKind_Abstract || function->m_storageKind == StorageKind_Virtual);
[-] 	ASSERT (function->m_virtualOriginClassType == NULL); // not layed out yet
[+] 	ASSERT(function->m_virtualOriginClassType == NULL); // not layed out yet
[-] 	function->m_classVTableIndex = m_vtable.getCount ();
[+] 	function->m_classVTableIndex = m_vtable.getCount();
[-] 	FunctionPtrType* pointerType = function->getType ()->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe);
[+] 	FunctionPtrType* pointerType = function->getType()->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe);
[-] 	getVTableStructType ()->createField (pointerType);
[+] 	getVTableStructType()->createField(pointerType);
[-] 	m_vtable.append (function);
[+] 	m_vtable.append(function);
[-] ClassType::overrideVirtualFunction (Function* function)
[+] ClassType::overrideVirtualFunction(Function* function)
[-] 	ASSERT (function->m_storageKind == StorageKind_Override);
[+] 	ASSERT(function->m_storageKind == StorageKind_Override);
[-] 	ASSERT (function->m_virtualOriginClassType == NULL); // not layed out yet
[+] 	ASSERT(function->m_virtualOriginClassType == NULL); // not layed out yet
[-] 	FunctionKind functionKind = function->getFunctionKind ();
[+] 	FunctionKind functionKind = function->getFunctionKind();
[-] 	ModuleItem* member = findItemTraverse (
[+] 	ModuleItem* member = findItemTraverse(
[-] 		err::setFormatStringError ("cannot override '%s': method not found", function->m_tag.sz ());
[+] 		err::setFormatStringError("cannot override '%s': method not found", function->m_tag.sz ());
[-] 	ModuleItemKind itemKind = member->getItemKind ();
[+] 	ModuleItemKind itemKind = member->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				function->m_tag.sz ()
[+] 				function->m_tag.sz()
[-] 		overridenFunction = (Function*) member;
[+] 		overridenFunction = (Function*)member;
[-] 		switch (functionKind)
[+] 		switch(functionKind)
[-] 			overridenFunction = ((Property*) member)->getGetter ();
[+] 			overridenFunction = ((Property*)member)->getGetter();
[-] 			overridenFunction = ((Property*) member)->getSetter ();
[+] 			overridenFunction = ((Property*)member)->getSetter();
[-] 				err::setFormatStringError ("cannot override '%s': property has no setter", function->m_tag.sz ());
[+] 				err::setFormatStringError("cannot override '%s': property has no setter", function->m_tag.sz ());
[-] 			err::setFormatStringError ("cannot override '%s': function kind mismatch", function->m_tag.sz ());
[+] 			err::setFormatStringError("cannot override '%s': function kind mismatch", function->m_tag.sz ());
[-] 		err::setFormatStringError ("cannot override '%s': not a method or property", function->m_tag.sz ());
[+] 		err::setFormatStringError("cannot override '%s': not a method or property", function->m_tag.sz ());
[-] 	overridenFunction = overridenFunction->findShortOverload (function->getType ()->getShortType ());
[+] 	overridenFunction = overridenFunction->findShortOverload(function->getType()->getShortType());
[-] 		err::setFormatStringError ("cannot override '%s': method signature mismatch", function->m_tag.sz ());
[+] 		err::setFormatStringError("cannot override '%s': method signature mismatch", function->m_tag.sz ());
[-] 	if (!overridenFunction->isVirtual ())
[+] 	if (!overridenFunction->isVirtual())
[-] 		err::setFormatStringError ("cannot override '%s': method is not virtual", function->m_tag.sz ());
[+] 		err::setFormatStringError("cannot override '%s': method is not virtual", function->m_tag.sz ());
[-] 	AXL_TODO ("virtual multipliers")
[+] 	AXL_TODO("virtual multipliers")
[-] 	ClassPtrType* thisArgType = (ClassPtrType*) overridenFunction->m_type->getThisArgType ();
[+] 	ClassPtrType* thisArgType = (ClassPtrType*)overridenFunction->m_type->getThisArgType();
[-] 	ASSERT (thisArgType->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(thisArgType->getTypeKind() == TypeKind_ClassPtr);
[-] 	FunctionArg* origThisArg = function->m_type->m_argArray [0];
[+] 	FunctionArg* origThisArg = function->m_type->m_argArray[0];
[-] 	FunctionArg* thisArg = m_module->m_typeMgr.getSimpleFunctionArg (StorageKind_This, thisArgType, origThisArg->getPtrTypeFlags ());
[+] 	FunctionArg* thisArg = m_module->m_typeMgr.getSimpleFunctionArg(StorageKind_This, thisArgType, origThisArg->getPtrTypeFlags());
[-] 	if (function->m_type->getFlags () & ModuleItemFlag_User)
[+] 	if (function->m_type->getFlags() & ModuleItemFlag_User)
[-] 		function->m_type->m_argArray [0] = thisArg;
[+] 		function->m_type->m_argArray[0] = thisArg;
[-] 		sl::Array <FunctionArg*> argArray = function->m_type->m_argArray;
[+] 		sl::Array<FunctionArg*> argArray = function->m_type->m_argArray;
[-] 		argArray.ensureExclusive ();
[+] 		argArray.ensureExclusive();
[-] 		argArray [0] = thisArg;
[+] 		argArray[0] = thisArg;
[-] 		function->m_type = m_module->m_typeMgr.getFunctionType (
[+] 		function->m_type = m_module->m_typeMgr.getFunctionType(
[-] 			function->m_type->getReturnType (),
[+] 			function->m_type->getReturnType(),
[-] 			function->m_type->getFlags ()
[+] 			function->m_type->getFlags()
[-] 	ASSERT (VTableIndex < m_vtable.getCount ());
[+] 	ASSERT(VTableIndex < m_vtable.getCount());
[-] 	m_vtable [VTableIndex] = function;
[+] 	m_vtable[VTableIndex] = function;
[-] ClassType::createVTableVariable ()
[+] ClassType::createVTableVariable()
[-] 	ASSERT (m_vtableStructType);
[+] 	ASSERT(m_vtableStructType);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <llvm::Constant*> llvmVTable (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<llvm::Constant*> llvmVTable(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	size_t count = m_vtable.getCount ();
[+] 	size_t count = m_vtable.getCount();
[-] 	llvmVTable.setCount (count);
[+] 	llvmVTable.setCount(count);
[-] 		Function* function = m_vtable [i];
[+] 		Function* function = m_vtable[i];
[-] 		if (function->getStorageKind () == StorageKind_Abstract)
[+] 		if (function->getStorageKind() == StorageKind_Abstract)
[-] 			function = function->getType ()->getAbstractFunction ();
[+] 			function = function->getType()->getAbstractFunction();
[-] 		llvmVTable [i] = function->getLlvmFunction ();
[+] 		llvmVTable[i] = function->getLlvmFunction();
[-] 	llvm::Constant* llvmVTableConst = llvm::ConstantStruct::get (
[+] 	llvm::Constant* llvmVTableConst = llvm::ConstantStruct::get(
[-] 		(llvm::StructType*) m_vtableStructType->getLlvmType (),
[+] 		(llvm::StructType*)m_vtableStructType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Constant*> (llvmVTable, count)
[+] 		llvm::ArrayRef<llvm::Constant*> (llvmVTable, count)
[-] 	m_vtableVariable = m_module->m_variableMgr.createSimpleStaticVariable (
[+] 	m_vtableVariable = m_module->m_variableMgr.createSimpleStaticVariable(
[-] 		Value (llvmVTableConst, m_vtableStructType)
[+] 		Value(llvmVTableConst, m_vtableStructType)
[-] ClassType::compile ()
[+] ClassType::compile()
[-] 	if (m_staticConstructor && !(m_staticConstructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_staticConstructor && !(m_staticConstructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultStaticConstructor ();
[+] 		result = compileDefaultStaticConstructor();
[-] 	if (m_constructor && !(m_constructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_constructor && !(m_constructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultConstructor ();
[+] 		result = compileDefaultConstructor();
[-] 	if (m_destructor && !(m_destructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_destructor && !(m_destructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultDestructor ();
[+] 		result = compileDefaultDestructor();
[-] ClassType::markGcRoots (
[+] ClassType::markGcRoots(
[-] 	Box* box = (Box*) p;
[+] 	Box* box = (Box*)p;
[-] 	IfaceHdr* iface = (IfaceHdr*) (box + 1);
[+] 	IfaceHdr* iface = (IfaceHdr*)(box + 1);
[-] 		ASSERT (!iface->m_vtable);
[+] 		ASSERT(!iface->m_vtable);
[-] 	ASSERT (iface->m_box == box && box->m_type == this);
[+] 	ASSERT(iface->m_box == box && box->m_type == this);
[-] 	markGcRootsImpl (iface, gcHeap);
[+] 	markGcRootsImpl(iface, gcHeap);
[-] ClassType::markGcRootsImpl (
[+] ClassType::markGcRootsImpl(
[-] 	ClassType* boxType = (ClassType*) iface->m_box->m_type;
[+] 	ClassType* boxType = (ClassType*)iface->m_box->m_type;
[-] 	ASSERT (boxType == this || boxType->findBaseTypeTraverse (this));
[+] 	ASSERT(boxType == this || boxType->findBaseTypeTraverse(this));
[-] 	char* p = (char*) iface;
[+] 	char* p = (char*)iface;
[-] 	size_t count = m_gcRootBaseTypeArray.getCount ();
[+] 	size_t count = m_gcRootBaseTypeArray.getCount();
[-] 		BaseTypeSlot* slot = m_gcRootBaseTypeArray [i];
[+] 		BaseTypeSlot* slot = m_gcRootBaseTypeArray[i];
[-] 		Type* type = slot->getType ();
[+] 		Type* type = slot->getType();
[-] 		char* p2  = p + slot->getOffset ();
[+] 		char* p2  = p + slot->getOffset();
[-] 		if (type->getTypeKind () == TypeKind_Class)
[+] 		if (type->getTypeKind() == TypeKind_Class)
[-] 			((ClassType*) type)->markGcRootsImpl ((IfaceHdr*) p2, gcHeap);
[+] 			((ClassType*)type)->markGcRootsImpl((IfaceHdr*)p2, gcHeap);
[-] 			type->markGcRoots (p2, gcHeap);
[+] 			type->markGcRoots(p2, gcHeap);
[-] 	count = m_gcRootMemberFieldArray.getCount ();
[+] 	count = m_gcRootMemberFieldArray.getCount();
[-] 		StructField* field = m_gcRootMemberFieldArray [i];
[+] 		StructField* field = m_gcRootMemberFieldArray[i];
[-] 		Type* type = field->getType ();
[+] 		Type* type = field->getType();
[-] 		char* p2 = p + field->getOffset ();
[+] 		char* p2 = p + field->getOffset();
[-] 		type->markGcRoots (p2, gcHeap);
[+] 		type->markGcRoots(p2, gcHeap);
[-] 		m_markOpaqueGcRootsFunc (iface, gcHeap);
[+] 		m_markOpaqueGcRootsFunc(iface, gcHeap);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClosureClassType.cpp
----------------------
[-] ClosureClassType::createSignature (
[+] ClosureClassType::createSignature(
[-] 	signature.appendFormat (
[+] 	signature.appendFormat(
[-] 		targetType->getSignature ().sz (),
[+] 		targetType->getSignature().sz(),
[-] 		thunkType->getSignature ().sz ()
[+] 		thunkType->getSignature().sz()
[-] 		signature.appendFormat ("%d:%s", closureMap [i], argTypeArray [i]->getSignature ().sz ());
[+] 		signature.appendFormat("%d:%s", closureMap [i], argTypeArray [i]->getSignature ().sz ());
[-] 	signature.appendFormat ("::%d)", thisArgIdx);
[+] 	signature.appendFormat("::%d)", thisArgIdx);
[-] ClosureClassType::buildArgValueList (
[+] ClosureClassType::buildArgValueList(
[-] 	sl::BoxList <Value>* argValueList
[+] 	sl::BoxList<Value>* argValueList
[-] 	size_t fieldCount = m_memberFieldArray.getCount ();
[+] 	size_t fieldCount = m_memberFieldArray.getCount();
[-] 		if (i == m_closureMap [iClosure])
[+] 		if (i == m_closureMap[iClosure])
[-] 			m_module->m_operatorMgr.getClassField (closureValue, m_memberFieldArray [fieldIdx], NULL, &argValue);
[+] 			m_module->m_operatorMgr.getClassField(closureValue, m_memberFieldArray[fieldIdx], NULL, &argValue);
[-] 			argValue = thunkArgValueArray [iThunk];
[+] 			argValue = thunkArgValueArray[iThunk];
[-] 		argValueList->insertTail (argValue);
[+] 		argValueList->insertTail(argValue);
[-] 		argValueList->insertTail (thunkArgValueArray [iThunk]);
[+] 		argValueList->insertTail(thunkArgValueArray[iThunk]);
[-] ClosureClassType::strengthen (IfaceHdr* p)
[+] ClosureClassType::strengthen(IfaceHdr* p)
[-] 	StructField* field = getFieldByIndex (m_thisArgFieldIdx);
[+] 	StructField* field = getFieldByIndex(m_thisArgFieldIdx);
[-] 	ASSERT (field && field->getType ()->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(field && field->getType()->getTypeKind() == TypeKind_ClassPtr);
[-] 	void* p2 = (char*) p + field->getOffset ();
[+] 	void* p2 = (char*)p + field->getOffset();
[-] 	return jnc::strengthenClassPtr (*(IfaceHdr**) p2) ? p : NULL;
[+] 	return jnc::strengthenClassPtr(*(IfaceHdr**) p2) ? p : NULL;
[-] FunctionClosureClassType::FunctionClosureClassType ()
[+] FunctionClosureClassType::FunctionClosureClassType()
[-] FunctionClosureClassType::compile ()
[+] FunctionClosureClassType::compile()
[-] 	ASSERT (m_thunkFunction);
[+] 	ASSERT(m_thunkFunction);
[-] 	bool result = ClassType::compile ();
[+] 	bool result = ClassType::compile();
[-] 	size_t argCount = m_thunkFunction->getType ()->getArgArray ().getCount ();
[+] 	size_t argCount = m_thunkFunction->getType()->getArgArray().getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (m_thunkFunction, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(m_thunkFunction, argValueArray, argCount);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 	m_module->m_operatorMgr.getClassField (thisValue, m_memberFieldArray [0], NULL, &pfnValue);
[+] 	m_module->m_operatorMgr.getClassField(thisValue, m_memberFieldArray[0], NULL, &pfnValue);
[-] 	sl::BoxList <Value> argValueList;
[+] 	sl::BoxList<Value> argValueList;
[-] 	buildArgValueList (thisValue, argValueArray, argCount, &argValueList);
[+] 	buildArgValueList(thisValue, argValueArray, argCount, &argValueList);
[-] 	result = m_module->m_operatorMgr.callOperator (pfnValue, &argValueList, &returnValue);
[+] 	result = m_module->m_operatorMgr.callOperator(pfnValue, &argValueList, &returnValue);
[-] 	if (m_thunkFunction->getType ()->getReturnType ()->getTypeKind () != TypeKind_Void)
[+] 	if (m_thunkFunction->getType()->getReturnType()->getTypeKind() != TypeKind_Void)
[-] 		result = m_module->m_controlFlowMgr.ret (returnValue);
[+] 		result = m_module->m_controlFlowMgr.ret(returnValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] PropertyClosureClassType::PropertyClosureClassType ()
[+] PropertyClosureClassType::PropertyClosureClassType()
[-] PropertyClosureClassType::compile ()
[+] PropertyClosureClassType::compile()
[-] 	ASSERT (m_thunkProperty);
[+] 	ASSERT(m_thunkProperty);
[-] 	bool result = ClassType::compile ();
[+] 	bool result = ClassType::compile();
[-] 	Function* getter = m_thunkProperty->getGetter ();
[+] 	Function* getter = m_thunkProperty->getGetter();
[-] 	Function* setter = m_thunkProperty->getSetter ();
[+] 	Function* setter = m_thunkProperty->getSetter();
[-] 	Function* binder = m_thunkProperty->getBinder ();
[+] 	Function* binder = m_thunkProperty->getBinder();
[-] 		result = compileAccessor (binder);
[+] 		result = compileAccessor(binder);
[-] 	result = compileAccessor (getter);
[+] 	result = compileAccessor(getter);
[-] 		size_t overloadCount = setter->getOverloadCount ();
[+] 		size_t overloadCount = setter->getOverloadCount();
[-] 			Function* overload = setter->getOverload (i);
[+] 			Function* overload = setter->getOverload(i);
[-] 			result = compileAccessor (overload);
[+] 			result = compileAccessor(overload);
[-] PropertyClosureClassType::compileAccessor (Function* accessor)
[+] PropertyClosureClassType::compileAccessor(Function* accessor)
[-] 	ASSERT (accessor->getProperty () == m_thunkProperty);
[+] 	ASSERT(accessor->getProperty() == m_thunkProperty);
[-] 	size_t argCount = accessor->getType ()->getArgArray ().getCount ();
[+] 	size_t argCount = accessor->getType()->getArgArray().getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (accessor, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(accessor, argValueArray, argCount);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 	result = m_module->m_operatorMgr.getClassField (thisValue, m_memberFieldArray [0], NULL, &propertyPtrValue);
[+] 	result = m_module->m_operatorMgr.getClassField(thisValue, m_memberFieldArray[0], NULL, &propertyPtrValue);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	FunctionKind accessorKind = accessor->getFunctionKind ();
[+] 	FunctionKind accessorKind = accessor->getFunctionKind();
[-] 	switch (accessorKind)
[+] 	switch(accessorKind)
[-] 		result = m_module->m_operatorMgr.getPropertyBinder (propertyPtrValue, &pfnValue);
[+] 		result = m_module->m_operatorMgr.getPropertyBinder(propertyPtrValue, &pfnValue);
[-] 		result = m_module->m_operatorMgr.getPropertyGetter (propertyPtrValue, &pfnValue);
[+] 		result = m_module->m_operatorMgr.getPropertyGetter(propertyPtrValue, &pfnValue);
[-] 		result = m_module->m_operatorMgr.getPropertySetter (propertyPtrValue, argValueArray [argCount - 1], &pfnValue);
[+] 		result = m_module->m_operatorMgr.getPropertySetter(propertyPtrValue, argValueArray[argCount - 1], &pfnValue);
[-] 		err::setFormatStringError ("invalid property accessor '%s' in property closure", getFunctionKindString (accessorKind));
[+] 		err::setFormatStringError("invalid property accessor '%s' in property closure", getFunctionKindString (accessorKind));
[-] 	sl::BoxList <Value> argValueList;
[+] 	sl::BoxList<Value> argValueList;
[-] 	buildArgValueList (thisValue, argValueArray, argCount, &argValueList);
[+] 	buildArgValueList(thisValue, argValueArray, argCount, &argValueList);
[-] 	result = m_module->m_operatorMgr.callOperator (pfnValue, &argValueList, &returnValue);
[+] 	result = m_module->m_operatorMgr.callOperator(pfnValue, &argValueList, &returnValue);
[-] 	if (accessor->getType ()->getReturnType ()->getTypeKind () != TypeKind_Void)
[+] 	if (accessor->getType()->getReturnType()->getTypeKind() != TypeKind_Void)
[-] 		result = m_module->m_controlFlowMgr.ret (returnValue);
[+] 		result = m_module->m_controlFlowMgr.ret(returnValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DataClosureClassType::DataClosureClassType ()
[+] DataClosureClassType::DataClosureClassType()
[-] DataClosureClassType::createSignature (
[+] DataClosureClassType::createSignature(
[-] 	signature.appendFormat (
[+] 	signature.appendFormat(
[-] 		targetType->getTypeString ().sz (),
[+] 		targetType->getTypeString().sz(),
[-] 		thunkType->getTypeString ().sz ()
[+] 		thunkType->getTypeString().sz()
[-] DataClosureClassType::compile ()
[+] DataClosureClassType::compile()
[-] 	ASSERT (m_thunkProperty);
[+] 	ASSERT(m_thunkProperty);
[-] 	bool result = ClassType::compile ();
[+] 	bool result = ClassType::compile();
[-] 	Function* getter = m_thunkProperty->getGetter ();
[+] 	Function* getter = m_thunkProperty->getGetter();
[-] 	Function* setter = m_thunkProperty->getSetter ();
[+] 	Function* setter = m_thunkProperty->getSetter();
[-] 	result = compileGetter (getter);
[+] 	result = compileGetter(getter);
[-] 		size_t overloadCount = setter->getOverloadCount ();
[+] 		size_t overloadCount = setter->getOverloadCount();
[-] 			Function* overload = setter->getOverload (i);
[+] 			Function* overload = setter->getOverload(i);
[-] 			result = compileSetter (overload);
[+] 			result = compileSetter(overload);
[-] DataClosureClassType::compileGetter (Function* getter)
[+] DataClosureClassType::compileGetter(Function* getter)
[-] 	m_module->m_functionMgr.internalPrologue (getter);
[+] 	m_module->m_functionMgr.internalPrologue(getter);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 		m_module->m_operatorMgr.getClassField (thisValue, m_memberFieldArray [0], NULL, &ptrValue) &&
[+] 		m_module->m_operatorMgr.getClassField(thisValue, m_memberFieldArray[0], NULL, &ptrValue) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, &ptrValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, &ptrValue) &&
[-] 		m_module->m_controlFlowMgr.ret (ptrValue);
[+] 		m_module->m_controlFlowMgr.ret(ptrValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DataClosureClassType::compileSetter (Function* setter)
[+] DataClosureClassType::compileSetter(Function* setter)
[-] 	m_module->m_functionMgr.internalPrologue (setter, &argValue, 1);
[+] 	m_module->m_functionMgr.internalPrologue(setter, &argValue, 1);
[-] 	Value thisValue = m_module->m_functionMgr.getThisValue ();
[+] 	Value thisValue = m_module->m_functionMgr.getThisValue();
[-] 	ASSERT (thisValue);
[+] 	ASSERT(thisValue);
[-] 		m_module->m_operatorMgr.getClassField (thisValue, m_memberFieldArray [0], NULL, &ptrValue) &&
[+] 		m_module->m_operatorMgr.getClassField(thisValue, m_memberFieldArray[0], NULL, &ptrValue) &&
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, &ptrValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Indir, &ptrValue) &&
[-] 		m_module->m_operatorMgr.storeDataRef (ptrValue, argValue);
[+] 		m_module->m_operatorMgr.storeDataRef(ptrValue, argValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_DataPtrType.cpp
----------------------
[-] DataPtrType::DataPtrType ()
[+] DataPtrType::DataPtrType()
[-] 	m_size = sizeof (DataPtr);
[+] 	m_size = sizeof(DataPtr);
[-] DataPtrType::createSignature (
[+] DataPtrType::createSignature(
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 	signature += getPtrTypeFlagSignature (flags);
[+] 	signature += getPtrTypeFlagSignature(flags);
[-] 	signature += baseType->getSignature ();
[+] 	signature += baseType->getSignature();
[-] DataPtrType::prepareTypeString ()
[+] DataPtrType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = m_targetType->getTypeStringPrefix () + getPointerStringSuffix ();
[+] 	tuple->m_typeStringPrefix = m_targetType->getTypeStringPrefix() + getPointerStringSuffix();
[-] 	tuple->m_typeStringSuffix = m_targetType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix = m_targetType->getTypeStringSuffix();
[-] DataPtrType::prepareDoxyLinkedText ()
[+] DataPtrType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix = m_targetType->getDoxyLinkedTextPrefix () + getPointerStringSuffix ();
[+] 	tuple->m_doxyLinkedTextPrefix = m_targetType->getDoxyLinkedTextPrefix() + getPointerStringSuffix();
[-] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getDoxyLinkedTextSuffix();
[-] DataPtrType::getPointerStringSuffix ()
[+] DataPtrType::getPointerStringSuffix()
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_flags);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_flags);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		string += getDataPtrTypeKindString (m_ptrTypeKind);
[+] 		string += getDataPtrTypeKindString(m_ptrTypeKind);
[-] 	if (m_targetType->getTypeKind () == TypeKind_Array)
[+] 	if (m_targetType->getTypeKind() == TypeKind_Array)
[-] DataPtrType::prepareLlvmType ()
[+] DataPtrType::prepareLlvmType()
[-] 		m_ptrTypeKind == DataPtrTypeKind_Normal ? m_module->m_typeMgr.getStdType (StdType_DataPtrStruct)->getLlvmType () :
[+] 		m_ptrTypeKind == DataPtrTypeKind_Normal ? m_module->m_typeMgr.getStdType(StdType_DataPtrStruct)->getLlvmType() :
[-] 		m_targetType->getTypeKind () != TypeKind_Void ? llvm::PointerType::get (m_targetType->getLlvmType (), 0) :
[+] 		m_targetType->getTypeKind() != TypeKind_Void ? llvm::PointerType::get(m_targetType->getLlvmType(), 0) :
[-] 		m_module->m_typeMgr.getStdType (StdType_BytePtr)->getLlvmType ();
[+] 		m_module->m_typeMgr.getStdType(StdType_BytePtr)->getLlvmType();
[-] DataPtrType::prepareLlvmDiType ()
[+] DataPtrType::prepareLlvmDiType()
[-] 		m_ptrTypeKind == DataPtrTypeKind_Normal ? m_module->m_typeMgr.getStdType (StdType_DataPtrStruct)->getLlvmDiType () :
[+] 		m_ptrTypeKind == DataPtrTypeKind_Normal ? m_module->m_typeMgr.getStdType(StdType_DataPtrStruct)->getLlvmDiType() :
[-] 		m_targetType->getTypeKind () != TypeKind_Void ? m_module->m_llvmDiBuilder.createPointerType (m_targetType) :
[+] 		m_targetType->getTypeKind() != TypeKind_Void ? m_module->m_llvmDiBuilder.createPointerType(m_targetType) :
[-] 		m_module->m_typeMgr.getStdType (StdType_BytePtr)->getLlvmDiType ();
[+] 		m_module->m_typeMgr.getStdType(StdType_BytePtr)->getLlvmDiType();
[-] DataPtrType::markGcRoots (
[+] DataPtrType::markGcRoots(
[-] 	ASSERT (m_ptrTypeKind == DataPtrTypeKind_Normal);
[+] 	ASSERT(m_ptrTypeKind == DataPtrTypeKind_Normal);
[-] 	DataPtr* ptr = (DataPtr*) p;
[+] 	DataPtr* ptr = (DataPtr*)p;
[-] 	gcHeap->weakMark (ptr->m_validator->m_validatorBox);
[+] 	gcHeap->weakMark(ptr->m_validator->m_validatorBox);
[-] 	gcHeap->markData (ptr->m_validator->m_targetBox);
[+] 	gcHeap->markData(ptr->m_validator->m_targetBox);
[-] DataPtrType::calcFoldedDualType (
[+] DataPtrType::calcFoldedDualType(
[-] 	ASSERT (isDualType (this));
[+] 	ASSERT(isDualType(this));
[-] 		m_module->m_typeMgr.foldDualType (m_targetType, isAlien, isContainerConst) :
[+] 		m_module->m_typeMgr.foldDualType(m_targetType, isAlien, isContainerConst) :
[-] 	return m_module->m_typeMgr.getDataPtrType (targetType, m_typeKind, m_ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getDataPtrType(targetType, m_typeKind, m_ptrTypeKind, flags);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_DerivableType.cpp
----------------------
[-] BaseTypeSlot::BaseTypeSlot ()
[+] BaseTypeSlot::BaseTypeSlot()
[-] BaseTypeCoord::BaseTypeCoord ():
[+] BaseTypeCoord::BaseTypeCoord():
[-] 	m_llvmIndexArray (ref::BufKind_Field, m_buffer, sizeof (m_buffer))
[+] 	m_llvmIndexArray(ref::BufKind_Field, m_buffer, sizeof(m_buffer))
[-] DerivableType::DerivableType ():
[+] DerivableType::DerivableType():
[-] 	NamedTypeBlock (this)
[+] 	NamedTypeBlock(this)
[-] DerivableType::getMemberMethodType (
[+] DerivableType::getMemberMethodType(
[-] 	return m_module->m_typeMgr.getMemberMethodType (this, shortType, thisArgTypeFlags);
[+] 	return m_module->m_typeMgr.getMemberMethodType(this, shortType, thisArgTypeFlags);
[-] DerivableType::getMemberPropertyType (PropertyType* shortType)
[+] DerivableType::getMemberPropertyType(PropertyType* shortType)
[-] 	return m_module->m_typeMgr.getMemberPropertyType (this, shortType);
[+] 	return m_module->m_typeMgr.getMemberPropertyType(this, shortType);
[-] DerivableType::findItemInExtensionNamespaces (const sl::StringRef& name)
[+] DerivableType::findItemInExtensionNamespaces(const sl::StringRef& name)
[-] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	Namespace* nspace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 		ModuleItem* item = nspace->getUsingSet ()->findExtensionItem (this, name);
[+] 		ModuleItem* item = nspace->getUsingSet()->findExtensionItem(this, name);
[-] 		nspace = nspace->getParentNamespace ();
[+] 		nspace = nspace->getParentNamespace();
[-] 	if (!m_baseTypeList.isEmpty ())
[+] 	if (!m_baseTypeList.isEmpty())
[-] 		err::setFormatStringError ("'%s' has base types, cannot use indexed member operator", getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has base types, cannot use indexed member operator", getTypeString ().sz ());
[-] 	size_t count = m_memberFieldArray.getCount ();
[+] 	size_t count = m_memberFieldArray.getCount();
[-] 		err::setFormatStringError ("index '%d' is out of bounds", index);
[+] 		err::setFormatStringError("index '%d' is out of bounds", index);
[-] 	return m_memberFieldArray [index];
[+] 	return m_memberFieldArray[index];
[-] DerivableType::getDefaultConstructor ()
[+] DerivableType::getDefaultConstructor()
[-] 	ASSERT (m_constructor);
[+] 	ASSERT(m_constructor);
[-] 	Type* thisArgType = getThisArgType (PtrTypeFlag_Safe);
[+] 	Type* thisArgType = getThisArgType(PtrTypeFlag_Safe);
[-] 	sl::BoxListEntry <Value> thisArgValue;
[+] 	sl::BoxListEntry<Value> thisArgValue;
[-] 	thisArgValue.m_value.setType (thisArgType);
[+] 	thisArgValue.m_value.setType(thisArgType);
[-] 	sl::AuxList <sl::BoxListEntry <Value> > argList;
[+] 	sl::AuxList<sl::BoxListEntry<Value> > argList;
[-] 	argList.insertTail (&thisArgValue);
[+] 	argList.insertTail(&thisArgValue);
[-] 	m_defaultConstructor = m_constructor->chooseOverload (argList);
[+] 	m_defaultConstructor = m_constructor->chooseOverload(argList);
[-] 		err::setFormatStringError ("'%s' has no default constructor", getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' has no default constructor", getTypeString ().sz ());
[-] DerivableType::getIndexerProperty (Type* argType)
[+] DerivableType::getIndexerProperty(Type* argType)
[-] 	ASSERT (!(m_flags & ModuleItemFlag_LayoutReady));
[+] 	ASSERT(!(m_flags & ModuleItemFlag_LayoutReady));
[-] 	sl::StringHashTableIterator <Property*> it = m_indexerPropertyMap.visit (argType->getSignature ());
[+] 	sl::StringHashTableIterator<Property*> it = m_indexerPropertyMap.visit(argType->getSignature());
[-] 	Property* prop = m_module->m_functionMgr.createProperty (PropertyKind_Internal, m_tag + ".m_indexer");
[+] 	Property* prop = m_module->m_functionMgr.createProperty(PropertyKind_Internal, m_tag + ".m_indexer");
[-] DerivableType::chooseIndexerProperty (const Value& opValue)
[+] DerivableType::chooseIndexerProperty(const Value& opValue)
[-] 	sl::StringHashTableIterator <Property*> it = m_indexerPropertyMap.getHead ();
[+] 	sl::StringHashTableIterator<Property*> it = m_indexerPropertyMap.getHead();
[-] 		FunctionArg* indexArg = prop->m_getter->getType ()->getArgArray () [1];
[+] 		FunctionArg* indexArg = prop->m_getter->getType()->getArgArray() [1];
[-] 		CastKind castKind = m_module->m_operatorMgr.getCastKind (opValue, indexArg->getType ());
[+] 		CastKind castKind = m_module->m_operatorMgr.getCastKind(opValue, indexArg->getType());
[-] 		err::setFormatStringError ("none of the %d indexer properties accept the specified index argument", m_indexerPropertyMap.getCount ());
[+] 		err::setFormatStringError("none of the %d indexer properties accept the specified index argument", m_indexerPropertyMap.getCount ());
[-] 		err::setFormatStringError ("ambiguous call to overloaded function");
[+] 		err::setFormatStringError("ambiguous call to overloaded function");
[-] DerivableType::getBaseTypeByIndex (size_t index)
[+] DerivableType::getBaseTypeByIndex(size_t index)
[-] 	size_t count = m_baseTypeArray.getCount ();
[+] 	size_t count = m_baseTypeArray.getCount();
[-] 		err::setFormatStringError ("index '%d' is out of bounds", index);
[+] 		err::setFormatStringError("index '%d' is out of bounds", index);
[-] 	return m_baseTypeArray [index];
[+] 	return m_baseTypeArray[index];
[-] DerivableType::addBaseType (Type* type)
[+] DerivableType::addBaseType(Type* type)
[-] 	BaseTypeSlot* slot = AXL_MEM_NEW (BaseTypeSlot);
[+] 	BaseTypeSlot* slot = AXL_MEM_NEW(BaseTypeSlot);
[-] 	slot->m_type = (DerivableType*) type;
[+] 	slot->m_type = (DerivableType*)type;
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup ((Type**) &slot->m_type);
[+] 		((ImportType*)type)->addFixup((Type**) &slot->m_type);
[-] 	m_baseTypeList.insertTail (slot);
[+] 	m_baseTypeList.insertTail(slot);
[-] 	m_baseTypeArray.append (slot);
[+] 	m_baseTypeArray.append(slot);
[-] DerivableType::findBaseTypeOffset (Type* type)
[+] DerivableType::findBaseTypeOffset(Type* type)
[-] 	bool result = findBaseTypeTraverse (type, &coord);
[+] 	bool result = findBaseTypeTraverse(type, &coord);
[-] DerivableType::addMethod (Function* function)
[+] DerivableType::addMethod(Function* function)
[-] 	StorageKind storageKind = function->getStorageKind ();
[+] 	StorageKind storageKind = function->getStorageKind();
[-] 	FunctionKind functionKind = function->getFunctionKind ();
[+] 	FunctionKind functionKind = function->getFunctionKind();
[-] 	uint_t functionKindFlags = getFunctionKindFlags (functionKind);
[+] 	uint_t functionKindFlags = getFunctionKindFlags(functionKind);
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 			err::setFormatStringError ("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[+] 			err::setFormatStringError("static method cannot be '%s'", getPtrTypeFlagString (thisArgTypeFlags).sz ());
[-] 		function->convertToMemberMethod (this);
[+] 		function->convertToMemberMethod(this);
[-] 		err::setFormatStringError ("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[-] 	sl::Array <FunctionArg*> argArray;
[+] 	sl::Array<FunctionArg*> argArray;
[-] 	switch (functionKind)
[+] 	switch(functionKind)
[-] 		m_module->m_functionMgr.addStaticConstructor (this);
[+] 		m_module->m_functionMgr.addStaticConstructor(this);
[-] 		overloadIdx = addFunction (function);
[+] 		overloadIdx = addFunction(function);
[-] 			m_memberMethodArray.append (function);
[+] 			m_memberMethodArray.append(function);
[-] 		if (m_unaryOperatorTable.isEmpty ())
[+] 		if (m_unaryOperatorTable.isEmpty())
[-] 			m_unaryOperatorTable.setCountZeroConstruct (UnOpKind__Count);
[+] 			m_unaryOperatorTable.setCountZeroConstruct(UnOpKind__Count);
[-] 		target = &m_unaryOperatorTable [function->getUnOpKind ()];
[+] 		target = &m_unaryOperatorTable[function->getUnOpKind()];
[-] 		if (m_binaryOperatorTable.isEmpty ())
[+] 		if (m_binaryOperatorTable.isEmpty())
[-] 			m_binaryOperatorTable.setCountZeroConstruct (BinOpKind__Count);
[+] 			m_binaryOperatorTable.setCountZeroConstruct(BinOpKind__Count);
[-] 		target = &m_binaryOperatorTable [function->getBinOpKind ()];
[+] 		target = &m_binaryOperatorTable[function->getBinOpKind()];
[-] 		argArray = function->getType ()->getArgArray ();
[+] 		argArray = function->getType()->getArgArray();
[-] 		if (argArray.getCount () < 2)
[+] 		if (argArray.getCount() < 2)
[-] 			err::setFormatStringError ("indexer property getter should take at least one index argument");
[+] 			err::setFormatStringError("indexer property getter should take at least one index argument");
[-] 		indexerProperty = getIndexerProperty (argArray [1]->getType ());
[+] 		indexerProperty = getIndexerProperty(argArray[1]->getType());
[-] 		argArray = function->getType ()->getArgArray ();
[+] 		argArray = function->getType()->getArgArray();
[-] 		if (argArray.getCount () < 3)
[+] 		if (argArray.getCount() < 3)
[-] 			err::setFormatStringError ("indexer property setter should take at least one index argument");
[+] 			err::setFormatStringError("indexer property setter should take at least one index argument");
[-] 		indexerProperty = getIndexerProperty (argArray [1]->getType ());
[+] 		indexerProperty = getIndexerProperty(argArray[1]->getType());
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getFunctionKindString (functionKind),
[+] 			getFunctionKindString(functionKind),
[-] 			getTypeString ().sz ()
[+] 			getTypeString().sz()
[-] 	function->m_tag.format ("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[+] 	function->m_tag.format("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			getTypeString ().sz (),
[+] 			getTypeString().sz(),
[-] 			getFunctionKindString (functionKind)
[+] 			getFunctionKindString(functionKind)
[-] 		bool result = (*target)->addOverload (function) != -1;
[+] 		bool result = (*target)->addOverload(function) != -1;
[-] DerivableType::addProperty (Property* prop)
[+] DerivableType::addProperty(Property* prop)
[-] 	ASSERT (prop->isNamed ());
[+] 	ASSERT(prop->isNamed());
[-] 	bool result = addItem (prop);
[+] 	bool result = addItem(prop);
[-] 	StorageKind storageKind = prop->getStorageKind ();
[+] 	StorageKind storageKind = prop->getStorageKind();
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 		err::setFormatStringError ("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[+] 		err::setFormatStringError("invalid storage specifier '%s' for method member", getStorageKindString (storageKind));
[-] 	m_memberPropertyArray.append (prop);
[+] 	m_memberPropertyArray.append(prop);
[-] DerivableType::createDefaultMethod (
[+] DerivableType::createDefaultMethod(
[-] 	FunctionType* type = (FunctionType*) m_module->m_typeMgr.getStdType (StdType_SimpleFunction);
[+] 	FunctionType* type = (FunctionType*)m_module->m_typeMgr.getStdType(StdType_SimpleFunction);
[-] 	Function* function = m_module->m_functionMgr.createFunction (functionKind, type);
[+] 	Function* function = m_module->m_functionMgr.createFunction(functionKind, type);
[-] 	function->m_tag.format ("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[+] 	function->m_tag.format("%s.%s", m_tag.sz (), getFunctionKindString (functionKind));
[-] 	bool result = addMethod (function);
[+] 	bool result = addMethod(function);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] DerivableType::compileDefaultStaticConstructor ()
[+] DerivableType::compileDefaultStaticConstructor()
[-] 	ASSERT (m_staticConstructor);
[+] 	ASSERT(m_staticConstructor);
[-] 	m_module->m_functionMgr.internalPrologue (m_staticConstructor);
[+] 	m_module->m_functionMgr.internalPrologue(m_staticConstructor);
[-] 	bool result = initializeStaticFields ();
[+] 	bool result = initializeStaticFields();
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DerivableType::compileDefaultConstructor ()
[+] DerivableType::compileDefaultConstructor()
[-] 	ASSERT (m_constructor);
[+] 	ASSERT(m_constructor);
[-] 	m_module->m_functionMgr.internalPrologue (m_constructor, &thisValue, 1);
[+] 	m_module->m_functionMgr.internalPrologue(m_constructor, &thisValue, 1);
[-] 		callBaseTypeConstructors (thisValue) &&
[+] 		callBaseTypeConstructors(thisValue) &&
[-] 		callMemberFieldConstructors (thisValue) &&
[+] 		callMemberFieldConstructors(thisValue) &&
[-] 		initializeMemberFields (thisValue) &&
[+] 		initializeMemberFields(thisValue) &&
[-] 		callMemberPropertyConstructors (thisValue);
[+] 		callMemberPropertyConstructors(thisValue);
[-] 		result = m_module->m_operatorMgr.callOperator (m_preconstructor, thisValue);
[+] 		result = m_module->m_operatorMgr.callOperator(m_preconstructor, thisValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DerivableType::compileDefaultDestructor ()
[+] DerivableType::compileDefaultDestructor()
[-] 	ASSERT (m_destructor);
[+] 	ASSERT(m_destructor);
[-] 	m_module->m_functionMgr.internalPrologue (m_destructor, &argValue, 1);
[+] 	m_module->m_functionMgr.internalPrologue(m_destructor, &argValue, 1);
[-] 		callMemberPropertyDestructors (argValue) &&
[+] 		callMemberPropertyDestructors(argValue) &&
[-] 		callBaseTypeDestructors (argValue);
[+] 		callBaseTypeDestructors(argValue);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] DerivableType::callBaseTypeConstructors (const Value& thisValue)
[+] DerivableType::callBaseTypeConstructors(const Value& thisValue)
[-] 	size_t count = m_baseTypeConstructArray.getCount ();
[+] 	size_t count = m_baseTypeConstructArray.getCount();
[-] 		BaseTypeSlot* slot = m_baseTypeConstructArray [i];
[+] 		BaseTypeSlot* slot = m_baseTypeConstructArray[i];
[-] 		Function* constructor = slot->m_type->getDefaultConstructor ();
[+] 		Function* constructor = slot->m_type->getDefaultConstructor();
[-] 		result = m_module->m_operatorMgr.callOperator (constructor, thisValue);
[+] 		result = m_module->m_operatorMgr.callOperator(constructor, thisValue);
[-] DerivableType::callBaseTypeDestructors (const Value& thisValue)
[+] DerivableType::callBaseTypeDestructors(const Value& thisValue)
[-] 	size_t count = m_baseTypeDestructArray.getCount ();
[+] 	size_t count = m_baseTypeDestructArray.getCount();
[-] 		BaseTypeSlot* slot = m_baseTypeDestructArray [i];
[+] 		BaseTypeSlot* slot = m_baseTypeDestructArray[i];
[-] 		Function* destructor = slot->m_type->getDestructor ();
[+] 		Function* destructor = slot->m_type->getDestructor();
[-] 		ASSERT (destructor);
[+] 		ASSERT(destructor);
[-] 		result = m_module->m_operatorMgr.callOperator (destructor, thisValue);
[+] 		result = m_module->m_operatorMgr.callOperator(destructor, thisValue);
[-] DerivableType::findBaseTypeTraverseImpl (
[+] DerivableType::findBaseTypeTraverseImpl(
[-] 	sl::StringHashTableIterator <BaseTypeSlot*> it = m_baseTypeMap.find (type->getSignature ());
[+] 	sl::StringHashTableIterator<BaseTypeSlot*> it = m_baseTypeMap.find(type->getSignature());
[-] 		coord->m_llvmIndexArray.setCount (level + 1);
[+] 		coord->m_llvmIndexArray.setCount(level + 1);
[-] 		coord->m_llvmIndexArray [level] = slot->m_llvmIndex;
[+] 		coord->m_llvmIndexArray[level] = slot->m_llvmIndex;
[-] 	sl::Iterator <BaseTypeSlot> slotIt = m_baseTypeList.getHead ();
[+] 	sl::Iterator<BaseTypeSlot> slotIt = m_baseTypeList.getHead();
[-] 		ASSERT (slot->m_type);
[+] 		ASSERT(slot->m_type);
[-] 		bool result = slot->m_type->findBaseTypeTraverseImpl (type, coord, level + 1);
[+] 		bool result = slot->m_type->findBaseTypeTraverseImpl(type, coord, level + 1);
[-] 				coord->m_llvmIndexArray [level] = slot->m_llvmIndex;
[+] 				coord->m_llvmIndexArray[level] = slot->m_llvmIndex;
[-] DerivableType::findItemTraverseImpl (
[+] DerivableType::findItemTraverseImpl(
[-] 		item = findItem (name);
[+] 		item = findItem(name);
[-] 				coord->m_llvmIndexArray.setCount (level);
[+] 				coord->m_llvmIndexArray.setCount(level);
[-] 					unionCoord.m_type = (UnionType*) this;
[+] 					unionCoord.m_type = (UnionType*)this;
[-] 					coord->m_unionCoordArray.insert (0, unionCoord);
[+] 					coord->m_unionCoordArray.insert(0, unionCoord);
[-] 		size_t count = m_unnamedFieldArray.getCount ();
[+] 		size_t count = m_unnamedFieldArray.getCount();
[-] 			StructField* field = m_unnamedFieldArray [i];
[+] 			StructField* field = m_unnamedFieldArray[i];
[-] 			if (field->getType ()->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 			if (field->getType()->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 				DerivableType* type = (DerivableType*) field->getType ();
[+] 				DerivableType* type = (DerivableType*)field->getType();
[-] 				item = type->findItemTraverseImpl (name, coord, modFlags, nextLevel);
[+] 				item = type->findItemTraverseImpl(name, coord, modFlags, nextLevel);
[-] 						coord->m_llvmIndexArray [level] = field->m_llvmIndex;
[+] 						coord->m_llvmIndexArray[level] = field->m_llvmIndex;
[-] 							unionCoord.m_type = (UnionType*) this;
[+] 							unionCoord.m_type = (UnionType*)this;
[-] 							coord->m_unionCoordArray.insert (0, unionCoord);
[+] 							coord->m_unionCoordArray.insert(0, unionCoord);
[-] 		item = findItemInExtensionNamespaces (name);
[+] 		item = findItemInExtensionNamespaces(name);
[-] 		sl::Iterator <BaseTypeSlot> slotIt = m_baseTypeList.getHead ();
[+] 		sl::Iterator<BaseTypeSlot> slotIt = m_baseTypeList.getHead();
[-] 			if (slot->m_type->getTypeKindFlags () & TypeKindFlag_Import) // unresolved yet
[+] 			if (slot->m_type->getTypeKindFlags() & TypeKindFlag_Import) // unresolved yet
[-] 			item = baseType->findItemTraverseImpl (name, coord, modFlags, nextLevel);
[+] 			item = baseType->findItemTraverseImpl(name, coord, modFlags, nextLevel);
[-] 					coord->m_llvmIndexArray [level] = slot->m_llvmIndex;
[+] 					coord->m_llvmIndexArray[level] = slot->m_llvmIndex;
[-] 		item = m_parentNamespace->findItemTraverse (name, coord, flags);
[+] 		item = m_parentNamespace->findItemTraverse(name, coord, flags);
[-] DerivableType::generateDocumentation (
[+] DerivableType::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	indexXml->appendFormat (
[+] 	indexXml->appendFormat(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 		getQualifiedName ().sz ()
[+] 		getQualifiedName().sz()
[-] 		result = m_constructor->generateDocumentation (outputDir, &constructorXml, indexXml);
[+] 		result = m_constructor->generateDocumentation(outputDir, &constructorXml, indexXml);
[-] 		result = m_destructor->generateDocumentation (outputDir, &destructorXml, indexXml);
[+] 		result = m_destructor->generateDocumentation(outputDir, &destructorXml, indexXml);
[-] 	result = Namespace::generateMemberDocumentation (outputDir, &memberXml, indexXml, true);
[+] 	result = Namespace::generateMemberDocumentation(outputDir, &memberXml, indexXml, true);
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	sl::Iterator <BaseTypeSlot> it = m_baseTypeList.getHead ();
[+] 	sl::Iterator<BaseTypeSlot> it = m_baseTypeList.getHead();
[-] 		DerivableType* baseType = it->getType ();
[+] 		DerivableType* baseType = it->getType();
[-] 		sl::String refId = baseType->getDoxyBlock ()->getRefId ();
[+] 		sl::String refId = baseType->getDoxyBlock()->getRefId();
[-] 		Unit* unit = baseType->getParentUnit ();
[+] 		Unit* unit = baseType->getParentUnit();
[-] 		ExtensionLib* lib = unit ? unit->getLib () : NULL;
[+] 		ExtensionLib* lib = unit ? unit->getLib() : NULL;
[-] 			itemXml->appendFormat ("<basecompoundref importid='%s/%s'>", lib->m_guid->getString ().sz (), refId.sz ());
[+] 			itemXml->appendFormat("<basecompoundref importid='%s/%s'>", lib->m_guid->getString ().sz (), refId.sz ());
[-] 			itemXml->appendFormat ("<basecompoundref refid='%s'>", refId.sz ());
[+] 			itemXml->appendFormat("<basecompoundref refid='%s'>", refId.sz ());
[-] 		itemXml->appendFormat ("%s</basecompoundref>\n", baseType->getQualifiedName ().sz ());
[+] 		itemXml->appendFormat("%s</basecompoundref>\n", baseType->getQualifiedName ().sz ());
[-] 	if (!constructorXml.isEmpty () || !destructorXml.isEmpty ())
[+] 	if (!constructorXml.isEmpty() || !destructorXml.isEmpty())
[-] 		itemXml->append ("<sectiondef>\n");
[+] 		itemXml->append("<sectiondef>\n");
[-] 		itemXml->append (constructorXml);
[+] 		itemXml->append(constructorXml);
[-] 		itemXml->append (destructorXml);
[+] 		itemXml->append(destructorXml);
[-] 		itemXml->append ("</sectiondef>\n\n");
[+] 		itemXml->append("</sectiondef>\n\n");
[-] 	itemXml->append (memberXml);
[+] 	itemXml->append(memberXml);
[-] 	sl::String footnoteXml = doxyBlock->getFootnoteString ();
[+] 	sl::String footnoteXml = doxyBlock->getFootnoteString();
[-] 	if (!footnoteXml.isEmpty ())
[+] 	if (!footnoteXml.isEmpty())
[-] 		itemXml->append ("<sectiondef>\n");
[+] 		itemXml->append("<sectiondef>\n");
[-] 		itemXml->append (footnoteXml);
[+] 		itemXml->append(footnoteXml);
[-] 		itemXml->append ("</sectiondef>\n");
[+] 		itemXml->append("</sectiondef>\n");
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</compounddef>\n");
[+] 	itemXml->append("</compounddef>\n");
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_EnumType.cpp
----------------------
[-] getEnumTypeFlagString (EnumTypeFlag flag)
[+] getEnumTypeFlagString(EnumTypeFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag >> 12);
[+] 	size_t i = sl::getLoBitIdx32(flag >> 12);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getEnumTypeFlagString (uint_t flags)
[+] getEnumTypeFlagString(uint_t flags)
[-] 	if (!string.isEmpty ())
[+] 	if (!string.isEmpty())
[-] 		string.chop (1);
[+] 		string.chop(1);
[-] EnumConst::generateDocumentation (
[+] EnumConst::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	if (!m_initializer.isEmpty ())
[+] 	if (!m_initializer.isEmpty())
[-] 		itemXml->appendFormat (
[+] 		itemXml->appendFormat(
[-] 			getInitializerString ().sz ()
[+] 			getInitializerString().sz()
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append ("</enumvalue>\n");
[+] 	itemXml->append("</enumvalue>\n");
[-] EnumType::EnumType ()
[+] EnumType::EnumType()
[-] EnumType::createConst (
[+] EnumType::createConst(
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	EnumConst* enumConst = AXL_MEM_NEW (EnumConst);
[+] 	EnumConst* enumConst = AXL_MEM_NEW(EnumConst);
[-] 	enumConst->m_tag = m_tag.isEmpty () ? name : m_tag + "." + name;
[+] 	enumConst->m_tag = m_tag.isEmpty() ? name : m_tag + "." + name;
[-] 		sl::takeOver (&enumConst->m_initializer, initializer);
[+] 		sl::takeOver(&enumConst->m_initializer, initializer);
[-] 	m_constList.insertTail (enumConst);
[+] 	m_constList.insertTail(enumConst);
[-] 	m_constArray.append (enumConst);
[+] 	m_constArray.append(enumConst);
[-] 	bool result = addItem (enumConst);
[+] 	bool result = addItem(enumConst);
[-] EnumType::calcLayout ()
[+] EnumType::calcLayout()
[-] 	if (!(m_baseType->getTypeKindFlags () & TypeKindFlag_Integer))
[+] 	if (!(m_baseType->getTypeKindFlags() & TypeKindFlag_Integer))
[-] 		err::setFormatStringError ("enum base type must be integer type");
[+] 		err::setFormatStringError("enum base type must be integer type");
[-] 	m_size = m_baseType->getSize ();
[+] 	m_size = m_baseType->getSize();
[-] 	m_alignment = m_baseType->getAlignment ();
[+] 	m_alignment = m_baseType->getAlignment();
[-] 		m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 	m_module->m_namespaceMgr.openNamespace (this);
[+] 	m_module->m_namespaceMgr.openNamespace(this);
[-] 		sl::Iterator <EnumConst> constIt = m_constList.getHead ();
[+] 		sl::Iterator<EnumConst> constIt = m_constList.getHead();
[-] 			if (!constIt->m_initializer.isEmpty ())
[+] 			if (!constIt->m_initializer.isEmpty())
[-] 				result = m_module->m_operatorMgr.parseConstIntegerExpression (constIt->m_initializer, &value);
[+] 				result = m_module->m_operatorMgr.parseConstIntegerExpression(constIt->m_initializer, &value);
[-] 			if (value > 0xffffffff && m_baseType->getSize () < 8)
[+] 			if (value > 0xffffffff && m_baseType->getSize() < 8)
[-] 				err::setFormatStringError ("enum const '%lld' is too big", value);
[+] 				err::setFormatStringError("enum const '%lld' is too big", value);
[-] 			value = value ? 2 << sl::getHiBitIdx64 (value) : 1;
[+] 			value = value ? 2 << sl::getHiBitIdx64(value) : 1;
[-] 		sl::Iterator <EnumConst> constIt = m_constList.getHead ();
[+] 		sl::Iterator<EnumConst> constIt = m_constList.getHead();
[-] 			if (!constIt->m_initializer.isEmpty ())
[+] 			if (!constIt->m_initializer.isEmpty())
[-] 				result = m_module->m_operatorMgr.parseConstIntegerExpression (constIt->m_initializer, &value);
[+] 				result = m_module->m_operatorMgr.parseConstIntegerExpression(constIt->m_initializer, &value);
[-] 			if (value > 0xffffffff && m_baseType->getSize () < 8)
[+] 			if (value > 0xffffffff && m_baseType->getSize() < 8)
[-] 				err::setFormatStringError ("enum const '%lld' is too big", value);
[+] 				err::setFormatStringError("enum const '%lld' is too big", value);
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] EnumType::generateDocumentation (
[+] EnumType::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	bool result = Namespace::generateMemberDocumentation (outputDir, &memberXml, indexXml, false);
[+] 	bool result = Namespace::generateMemberDocumentation(outputDir, &memberXml, indexXml, false);
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	if (m_name.isEmpty ())
[+] 	if (m_name.isEmpty())
[-] 	sl::String modifierString = getEnumTypeFlagString (flags);
[+] 	sl::String modifierString = getEnumTypeFlagString(flags);
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 		itemXml->appendFormat ("<modifiers>%s</modifiers>\n", modifierString.sz ());
[+] 		itemXml->appendFormat("<modifiers>%s</modifiers>\n", modifierString.sz ());
[-] 	itemXml->append (memberXml);
[+] 	itemXml->append(memberXml);
[-] 	sl::String footnoteXml = doxyBlock->getFootnoteString ();
[+] 	sl::String footnoteXml = doxyBlock->getFootnoteString();
[-] 	if (!footnoteXml.isEmpty ())
[+] 	if (!footnoteXml.isEmpty())
[-] 		itemXml->append (footnoteXml);
[+] 		itemXml->append(footnoteXml);
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionArg.cpp
----------------------
[-] FunctionArg::FunctionArg ()
[+] FunctionArg::FunctionArg()
[-] FunctionArg::getArgString ()
[+] FunctionArg::getArgString()
[-] 	string = m_type->getTypeStringPrefix ();
[+] 	string = m_type->getTypeStringPrefix();
[-] 	else if (!m_name.isEmpty ())
[+] 	else if (!m_name.isEmpty())
[-] 	sl::String suffix = m_type->getTypeStringSuffix ();
[+] 	sl::String suffix = m_type->getTypeStringSuffix();
[-] 	if (!suffix.isEmpty ())
[+] 	if (!suffix.isEmpty())
[-] 	if (!m_initializer.isEmpty ())
[+] 	if (!m_initializer.isEmpty())
[-] 		string += getInitializerString ();
[+] 		string += getInitializerString();
[-] FunctionArg::getArgDoxyLinkedText ()
[+] FunctionArg::getArgDoxyLinkedText()
[-] 	string = m_type->getDoxyLinkedTextPrefix ();
[+] 	string = m_type->getDoxyLinkedTextPrefix();
[-] 	else if (!m_name.isEmpty ())
[+] 	else if (!m_name.isEmpty())
[-] 	sl::String suffix = m_type->getDoxyLinkedTextSuffix ();
[+] 	sl::String suffix = m_type->getDoxyLinkedTextSuffix();
[-] 	if (!suffix.isEmpty ())
[+] 	if (!suffix.isEmpty())
[-] 	if (!m_initializer.isEmpty ())
[+] 	if (!m_initializer.isEmpty())
[-] 		string += getInitializerString ();
[+] 		string += getInitializerString();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionPtrType.cpp
----------------------
[-] getFunctionPtrTypeKindString (FunctionPtrTypeKind ptrTypeKind)
[+] getFunctionPtrTypeKindString(FunctionPtrTypeKind ptrTypeKind)
[-] 	static const char* stringTable [FunctionPtrTypeKind__Count] =
[+] 	static const char* stringTable[FunctionPtrTypeKind__Count] =
[-] 	return (size_t) ptrTypeKind < FunctionPtrTypeKind__Count ?
[+] 	return (size_t)ptrTypeKind < FunctionPtrTypeKind__Count ?
[-] 		stringTable [ptrTypeKind] :
[+] 		stringTable[ptrTypeKind] :
[-] FunctionPtrType::FunctionPtrType ()
[+] FunctionPtrType::FunctionPtrType()
[-] 	m_size = sizeof (FunctionPtr);
[+] 	m_size = sizeof(FunctionPtr);
[-] FunctionPtrType::getMulticastType ()
[+] FunctionPtrType::getMulticastType()
[-] 	return m_module->m_typeMgr.getMulticastType (this);
[+] 	return m_module->m_typeMgr.getMulticastType(this);
[-] FunctionPtrType::createSignature (
[+] FunctionPtrType::createSignature(
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 	signature += getPtrTypeFlagSignature (flags);
[+] 	signature += getPtrTypeFlagSignature(flags);
[-] 	signature += functionType->getSignature ();
[+] 	signature += functionType->getSignature();
[-] FunctionPtrType::getTypeModifierString ()
[+] FunctionPtrType::getTypeModifierString()
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_flags);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_flags);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		string += getFunctionPtrTypeKindString (m_ptrTypeKind);
[+] 		string += getFunctionPtrTypeKindString(m_ptrTypeKind);
[-] 	if (!string.isEmpty ())
[+] 	if (!string.isEmpty())
[-] 		string.chop (1);
[+] 		string.chop(1);
[-] FunctionPtrType::prepareTypeString ()
[+] FunctionPtrType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = m_targetType->getReturnType ();
[+] 	Type* returnType = m_targetType->getReturnType();
[-] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix ();
[+] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 	tuple->m_typeStringSuffix = m_targetType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix = m_targetType->getTypeStringSuffix();
[-] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix();
[-] FunctionPtrType::prepareDoxyLinkedText ()
[+] FunctionPtrType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = m_targetType->getReturnType ();
[+] 	Type* returnType = m_targetType->getReturnType();
[-] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getDoxyLinkedTextSuffix();
[-] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix();
[-] FunctionPtrType::prepareDoxyTypeString ()
[+] FunctionPtrType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	getTypeStringTuple ()->m_doxyTypeString += m_targetType->getDoxyArgString ();
[+] 	getTypeStringTuple()->m_doxyTypeString += m_targetType->getDoxyArgString();
[-] FunctionPtrType::prepareLlvmType ()
[+] FunctionPtrType::prepareLlvmType()
[-] 		m_module->m_typeMgr.getStdType (StdType_FunctionPtrStruct)->getLlvmType () :
[+] 		m_module->m_typeMgr.getStdType(StdType_FunctionPtrStruct)->getLlvmType() :
[-] 		llvm::PointerType::get (m_targetType->getLlvmType (), 0);
[+] 		llvm::PointerType::get(m_targetType->getLlvmType(), 0);
[-] FunctionPtrType::prepareLlvmDiType ()
[+] FunctionPtrType::prepareLlvmDiType()
[-] 		m_module->m_typeMgr.getStdType (StdType_FunctionPtrStruct)->getLlvmDiType () :
[+] 		m_module->m_typeMgr.getStdType(StdType_FunctionPtrStruct)->getLlvmDiType() :
[-] 		m_module->m_llvmDiBuilder.createPointerType (m_targetType);
[+] 		m_module->m_llvmDiBuilder.createPointerType(m_targetType);
[-] FunctionPtrType::markGcRoots (
[+] FunctionPtrType::markGcRoots(
[-] 	ASSERT (m_ptrTypeKind == FunctionPtrTypeKind_Normal || m_ptrTypeKind == FunctionPtrTypeKind_Weak);
[+] 	ASSERT(m_ptrTypeKind == FunctionPtrTypeKind_Normal || m_ptrTypeKind == FunctionPtrTypeKind_Weak);
[-] 	FunctionPtr* ptr = (FunctionPtr*) p;
[+] 	FunctionPtr* ptr = (FunctionPtr*)p;
[-] 		gcHeap->markClass (box);
[+] 		gcHeap->markClass(box);
[-] 	else if (isClassType (box->m_type, ClassTypeKind_FunctionClosure))
[+] 	else if (isClassType(box->m_type, ClassTypeKind_FunctionClosure))
[-] 		gcHeap->weakMarkClosureClass (box);
[+] 		gcHeap->weakMarkClosureClass(box);
[-] 		gcHeap->weakMark (box);
[+] 		gcHeap->weakMark(box);
[-] FunctionPtrType::calcLayout ()
[+] FunctionPtrType::calcLayout()
[-] 	bool result = m_targetType->ensureLayout ();
[+] 	bool result = m_targetType->ensureLayout();
[-] 	sl::String signature = createSignature (
[+] 	sl::String signature = createSignature(
[-] 	m_module->m_typeMgr.updateTypeSignature (this, signature);
[+] 	m_module->m_typeMgr.updateTypeSignature(this, signature);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionType.cpp
----------------------
[-] FunctionType::FunctionType ()
[+] FunctionType::FunctionType()
[-] FunctionType::getThisTargetType ()
[+] FunctionType::getThisTargetType()
[-] 	Type* thisArgType = getThisArgType ();
[+] 	Type* thisArgType = getThisArgType();
[-] 	TypeKind thisArgTypeKind = thisArgType->getTypeKind ();
[+] 	TypeKind thisArgTypeKind = thisArgType->getTypeKind();
[-] 	switch (thisArgTypeKind)
[+] 	switch(thisArgTypeKind)
[-] 		return ((ClassPtrType*) thisArgType)->getTargetType ();
[+] 		return ((ClassPtrType*)thisArgType)->getTargetType();
[-] 		return (DerivableType*) ((DataPtrType*) thisArgType)->getTargetType ();
[+] 		return (DerivableType*)((DataPtrType*)thisArgType)->getTargetType();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] FunctionType::getArgSignature ()
[+] FunctionType::getArgSignature()
[-] 	if (m_argSignature.isEmpty ())
[+] 	if (m_argSignature.isEmpty())
[-] 		m_argSignature = createArgSignature ();
[+] 		m_argSignature = createArgSignature();
[-] FunctionType::getFunctionPtrType (
[+] FunctionType::getFunctionPtrType(
[-] 	return m_module->m_typeMgr.getFunctionPtrType (this, typeKind, ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getFunctionPtrType(this, typeKind, ptrTypeKind, flags);
[-] FunctionType::getMulticastType ()
[+] FunctionType::getMulticastType()
[-] 	return m_module->m_typeMgr.getMulticastType (this);
[+] 	return m_module->m_typeMgr.getMulticastType(this);
[-] FunctionType::getMemberMethodType (
[+] FunctionType::getMemberMethodType(
[-] 	return m_module->m_typeMgr.getMemberMethodType (parentType, this, thisArgTypeFlags);
[+] 	return m_module->m_typeMgr.getMemberMethodType(parentType, this, thisArgTypeFlags);
[-] FunctionType::getStdObjectMemberMethodType ()
[+] FunctionType::getStdObjectMemberMethodType()
[-] 	return m_module->m_typeMgr.getStdObjectMemberMethodType (this);
[+] 	return m_module->m_typeMgr.getStdObjectMemberMethodType(this);
[-] FunctionType::getAbstractFunction ()
[+] FunctionType::getAbstractFunction()
[-] 	Function* function = m_module->m_functionMgr.createFunction (FunctionKind_Internal, "abstractFunction", this);
[+] 	Function* function = m_module->m_functionMgr.createFunction(FunctionKind_Internal, "abstractFunction", this);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] FunctionType::compile ()
[+] FunctionType::compile()
[-] 	ASSERT (m_abstractFunction);
[+] 	ASSERT(m_abstractFunction);
[-] 	m_module->m_functionMgr.internalPrologue (m_abstractFunction);
[+] 	m_module->m_functionMgr.internalPrologue(m_abstractFunction);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] FunctionType::createArgSignature (
[+] FunctionType::createArgSignature(
[-] 		Type* type = argTypeArray [i];
[+] 		Type* type = argTypeArray[i];
[-] 		string += type->getSignature ();
[+] 		string += type->getSignature();
[-] FunctionType::createArgSignature (
[+] FunctionType::createArgSignature(
[-] 		FunctionArg* arg = argArray [i];
[+] 		FunctionArg* arg = argArray[i];
[-] 		string += arg->getType ()->getSignature ();
[+] 		string += arg->getType()->getSignature();
[-] FunctionType::createFlagSignature (uint_t flags)
[+] FunctionType::createFlagSignature(uint_t flags)
[-] FunctionType::createSignature (
[+] FunctionType::createSignature(
[-] 	string += createFlagSignature (flags);
[+] 	string += createFlagSignature(flags);
[-] 	string += getCallConvSignature (callConv->getCallConvKind ());
[+] 	string += getCallConvSignature(callConv->getCallConvKind());
[-] 	string += returnType->getSignature ();
[+] 	string += returnType->getSignature();
[-] 	string += createArgSignature (argTypeArray, argCount, flags);
[+] 	string += createArgSignature(argTypeArray, argCount, flags);
[-] FunctionType::createSignature (
[+] FunctionType::createSignature(
[-] 	string += createFlagSignature (flags);
[+] 	string += createFlagSignature(flags);
[-] 	string += getCallConvSignature (callConv->getCallConvKind ());
[+] 	string += getCallConvSignature(callConv->getCallConvKind());
[-] 	string += returnType->getSignature ();
[+] 	string += returnType->getSignature();
[-] 	string += createArgSignature (argArray, argCount, flags);
[+] 	string += createArgSignature(argArray, argCount, flags);
[-] FunctionType::getTypeModifierString ()
[+] FunctionType::getTypeModifierString()
[-] 	if (!m_callConv->isDefault ())
[+] 	if (!m_callConv->isDefault())
[-] 		string = m_callConv->getCallConvDisplayString ();
[+] 		string = m_callConv->getCallConvDisplayString();
[-] 	if (!string.isEmpty ())
[+] 	if (!string.isEmpty())
[-] 		string.chop (1);
[+] 		string.chop(1);
[-] FunctionType::prepareTypeString ()
[+] FunctionType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix ();
[+] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 	if (!m_argArray.isEmpty ())
[+] 	if (!m_argArray.isEmpty())
[-] 		tuple->m_typeStringSuffix += m_argArray [0]->getArgString ();
[+] 		tuple->m_typeStringSuffix += m_argArray[0]->getArgString();
[-] 		size_t count = m_argArray.getCount ();
[+] 		size_t count = m_argArray.getCount();
[-] 			tuple->m_typeStringSuffix += m_argArray [i]->getArgString ();
[+] 			tuple->m_typeStringSuffix += m_argArray[i]->getArgString();
[-] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix();
[-] FunctionType::prepareDoxyLinkedText ()
[+] FunctionType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 		tuple->m_doxyLinkedTextPrefix += getTypeModifierString ();
[+] 		tuple->m_doxyLinkedTextPrefix += getTypeModifierString();
[-] 	if (!m_argArray.isEmpty ())
[+] 	if (!m_argArray.isEmpty())
[-] 		tuple->m_doxyLinkedTextSuffix += m_argArray [0]->getArgDoxyLinkedText ();
[+] 		tuple->m_doxyLinkedTextSuffix += m_argArray[0]->getArgDoxyLinkedText();
[-] 		size_t count = m_argArray.getCount ();
[+] 		size_t count = m_argArray.getCount();
[-] 			tuple->m_doxyLinkedTextSuffix += m_argArray [i]->getArgDoxyLinkedText ();
[+] 			tuple->m_doxyLinkedTextSuffix += m_argArray[i]->getArgDoxyLinkedText();
[-] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix();
[-] FunctionType::prepareDoxyTypeString ()
[+] FunctionType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	getTypeStringTuple ()->m_doxyTypeString += getDoxyArgString ();
[+] 	getTypeStringTuple()->m_doxyTypeString += getDoxyArgString();
[-] FunctionType::prepareLlvmType ()
[+] FunctionType::prepareLlvmType()
[-] 	m_callConv->prepareFunctionType (this);
[+] 	m_callConv->prepareFunctionType(this);
[-] 	ASSERT (m_llvmType);
[+] 	ASSERT(m_llvmType);
[-] FunctionType::prepareLlvmDiType ()
[+] FunctionType::prepareLlvmDiType()
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createSubroutineType (this);
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createSubroutineType(this);
[-] FunctionType::calcLayout ()
[+] FunctionType::calcLayout()
[-] 	result = m_returnType->ensureLayout ();
[+] 	result = m_returnType->ensureLayout();
[-] 	size_t argCount = m_argArray.getCount ();
[+] 	size_t argCount = m_argArray.getCount();
[-] 		result = m_argArray [i]->getType ()->ensureLayout ();
[+] 		result = m_argArray[i]->getType()->ensureLayout();
[-] 		result = m_shortType->ensureLayout ();
[+] 		result = m_shortType->ensureLayout();
[-] 	sl::String signature = createSignature (
[+] 	sl::String signature = createSignature(
[-] 		m_argArray.getCount (),
[+] 		m_argArray.getCount(),
[-] 	m_module->m_typeMgr.updateTypeSignature (this, signature);
[+] 	m_module->m_typeMgr.updateTypeSignature(this, signature);
[-] FunctionType::getDoxyArgString ()
[+] FunctionType::getDoxyArgString()
[-] 	size_t count = m_argArray.getCount ();
[+] 	size_t count = m_argArray.getCount();
[-] 		FunctionArg* arg = m_argArray [i];
[+] 		FunctionArg* arg = m_argArray[i];
[-] 		if (arg->getStorageKind () == StorageKind_This)
[+] 		if (arg->getStorageKind() == StorageKind_This)
[-] 		Type* type = arg->getType ();
[+] 		Type* type = arg->getType();
[-] 		string.appendFormat (
[+] 		string.appendFormat(
[-] 			arg->getName ().sz (),
[+] 			arg->getName().sz(),
[-] 			type->getDoxyLinkedTextPrefix ().sz (),
[+] 			type->getDoxyLinkedTextPrefix().sz(),
[-] 			type->getTypeStringSuffix ().sz ()
[+] 			type->getTypeStringSuffix().sz()
[-] 		if (!arg->getInitializer ().isEmpty ())
[+] 		if (!arg->getInitializer().isEmpty())
[-] 			string.appendFormat (
[+] 			string.appendFormat(
[-] 				arg->getInitializerString ().sz ()
[+] 				arg->getInitializerString().sz()
[-] 		string.append ("</param>\n");
[+] 		string.append("</param>\n");
[-] 		string.append (
[+] 		string.append(
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionTypeOverload.cpp
----------------------
[-] FunctionTypeOverload::findOverload (FunctionType* type) const
[+] FunctionTypeOverload::findOverload(FunctionType* type) const
[-] 	if (type->cmp (m_type) == 0)
[+] 	if (type->cmp(m_type) == 0)
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		if (type->cmp (overloadType) == 0)
[+] 		if (type->cmp(overloadType) == 0)
[-] FunctionTypeOverload::findShortOverload (FunctionType* type) const
[+] FunctionTypeOverload::findShortOverload(FunctionType* type) const
[-] 	if (type->cmp (m_type->getShortType ()) == 0)
[+] 	if (type->cmp(m_type->getShortType()) == 0)
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		if (type->cmp (overloadType->getShortType ()) == 0)
[+] 		if (type->cmp(overloadType->getShortType()) == 0)
[-] FunctionTypeOverload::chooseOverload (
[+] FunctionTypeOverload::chooseOverload(
[-] 	ASSERT (m_type);
[+] 	ASSERT(m_type);
[-] 	Module* module = m_type->getModule ();
[+] 	Module* module = m_type->getModule();
[-] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind (m_type, argArray, argCount);
[+] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind(m_type, argArray, argCount);
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		CastKind castKind = module->m_operatorMgr.getArgCastKind (overloadType, argArray, argCount);
[+] 		CastKind castKind = module->m_operatorMgr.getArgCastKind(overloadType, argArray, argCount);
[-] 		err::setFormatStringError ("none of the %d overloads accept the specified argument list", count + 1);
[+] 		err::setFormatStringError("none of the %d overloads accept the specified argument list", count + 1);
[-] 		err::setFormatStringError ("ambiguous call to overloaded function");
[+] 		err::setFormatStringError("ambiguous call to overloaded function");
[-] FunctionTypeOverload::chooseOverload (
[+] FunctionTypeOverload::chooseOverload(
[-] 	ASSERT (m_type);
[+] 	ASSERT(m_type);
[-] 	Module* module = m_type->getModule ();
[+] 	Module* module = m_type->getModule();
[-] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind (m_type, argValueArray, argCount);
[+] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind(m_type, argValueArray, argCount);
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		CastKind castKind = module->m_operatorMgr.getArgCastKind (overloadType, argValueArray, argCount);
[+] 		CastKind castKind = module->m_operatorMgr.getArgCastKind(overloadType, argValueArray, argCount);
[-] 		err::setFormatStringError ("none of the %d overloads accept the specified argument list", count + 1);
[+] 		err::setFormatStringError("none of the %d overloads accept the specified argument list", count + 1);
[-] 		err::setFormatStringError ("ambiguous call to overloaded function");
[+] 		err::setFormatStringError("ambiguous call to overloaded function");
[-] FunctionTypeOverload::chooseOverload (
[+] FunctionTypeOverload::chooseOverload(
[-] 	const sl::ConstBoxList <Value>& argList,
[+] 	const sl::ConstBoxList<Value>& argList,
[-] 	ASSERT (m_type);
[+] 	ASSERT(m_type);
[-] 	Module* module = m_type->getModule ();
[+] 	Module* module = m_type->getModule();
[-] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind (m_type, argList);
[+] 	CastKind bestCastKind = module->m_operatorMgr.getArgCastKind(m_type, argList);
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		CastKind castKind = module->m_operatorMgr.getArgCastKind (overloadType, argList);
[+] 		CastKind castKind = module->m_operatorMgr.getArgCastKind(overloadType, argList);
[-] 		err::setFormatStringError ("none of the %d overloads accept the specified argument list", count + 1);
[+] 		err::setFormatStringError("none of the %d overloads accept the specified argument list", count + 1);
[-] 		err::setFormatStringError ("ambiguous call to overloaded function");
[+] 		err::setFormatStringError("ambiguous call to overloaded function");
[-] FunctionTypeOverload::chooseSetterOverload (
[+] FunctionTypeOverload::chooseSetterOverload(
[-] 	ASSERT (m_type);
[+] 	ASSERT(m_type);
[-] 	Module* module = m_type->getModule ();
[+] 	Module* module = m_type->getModule();
[-] 	size_t setterValueIdx = m_type->getArgArray ().getCount () - 1;
[+] 	size_t setterValueIdx = m_type->getArgArray().getCount() - 1;
[-] 	ASSERT (setterValueIdx != -1);
[+] 	ASSERT(setterValueIdx != -1);
[-] 	Type* setterValueArgType = m_type->getArgArray () [setterValueIdx]->getType ();
[+] 	Type* setterValueArgType = m_type->getArgArray() [setterValueIdx]->getType();
[-] 	CastKind bestCastKind = module->m_operatorMgr.getCastKind (value, setterValueArgType);
[+] 	CastKind bestCastKind = module->m_operatorMgr.getCastKind(value, setterValueArgType);
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		Type* setterValueArgType = overloadType->getArgArray () [setterValueIdx]->getType ();
[+] 		Type* setterValueArgType = overloadType->getArgArray() [setterValueIdx]->getType();
[-] 		CastKind castKind = module->m_operatorMgr.getCastKind (value, setterValueArgType);
[+] 		CastKind castKind = module->m_operatorMgr.getCastKind(value, setterValueArgType);
[-] 		err::setFormatStringError ("none of the %d overloads accept the specified argument list", count + 1);
[+] 		err::setFormatStringError("none of the %d overloads accept the specified argument list", count + 1);
[-] 		err::setFormatStringError ("ambiguous call to overloaded function");
[+] 		err::setFormatStringError("ambiguous call to overloaded function");
[-] FunctionTypeOverload::addOverload (FunctionType* type)
[+] FunctionTypeOverload::addOverload(FunctionType* type)
[-] 	else if (type->getArgSignature ().cmp (m_type->getArgSignature ()) == 0)
[+] 	else if (type->getArgSignature().cmp(m_type->getArgSignature()) == 0)
[-] 		err::setFormatStringError ("illegal function overload: duplicate argument signature");
[+] 		err::setFormatStringError("illegal function overload: duplicate argument signature");
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		FunctionType* overloadType = m_overloadArray [i];
[+] 		FunctionType* overloadType = m_overloadArray[i];
[-] 		if (type->getArgSignature ().cmp (overloadType->getArgSignature ()) == 0)
[+] 		if (type->getArgSignature().cmp(overloadType->getArgSignature()) == 0)
[-] 			err::setFormatStringError ("illegal function overload: duplicate argument signature");
[+] 			err::setFormatStringError("illegal function overload: duplicate argument signature");
[-] 	m_overloadArray.append (type);
[+] 	m_overloadArray.append(type);
[-] 	return m_overloadArray.getCount ();
[+] 	return m_overloadArray.getCount();
[-] FunctionTypeOverload::copy (
[+] FunctionTypeOverload::copy(
[-] 		m_type = typeArray [0];
[+] 		m_type = typeArray[0];
[-] 		m_overloadArray.copy (typeArray + 1, count - 1);
[+] 		m_overloadArray.copy(typeArray + 1, count - 1);
[-] 		m_overloadArray.clear ();
[+] 		m_overloadArray.clear();
[-] FunctionTypeOverload::ensureLayout ()
[+] FunctionTypeOverload::ensureLayout()
[-] 	result = m_type->ensureLayout ();
[+] 	result = m_type->ensureLayout();
[-] 	size_t count = m_overloadArray.getCount ();
[+] 	size_t count = m_overloadArray.getCount();
[-] 		result = m_overloadArray [i]->ensureLayout ();
[+] 		result = m_overloadArray[i]->ensureLayout();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ImportType.cpp
----------------------
[-] ImportType::applyFixups ()
[+] ImportType::applyFixups()
[-] 	ASSERT (m_actualType);
[+] 	ASSERT(m_actualType);
[-] 	size_t count = m_fixupArray.getCount ();
[+] 	size_t count = m_fixupArray.getCount();
[-] 		*m_fixupArray [i] = m_actualType;
[+] 		*m_fixupArray[i] = m_actualType;
[-] NamedImportType::NamedImportType ()
[+] NamedImportType::NamedImportType()
[-] NamedImportType::getImportPtrType (
[+] NamedImportType::getImportPtrType(
[-] 	return m_module->m_typeMgr.getImportPtrType (this, typeModifiers, flags);
[+] 	return m_module->m_typeMgr.getImportPtrType(this, typeModifiers, flags);
[-] NamedImportType::createSignature (
[+] NamedImportType::createSignature(
[-] 	sl::String signature = sl::formatString ("ZN%s", anchorNamespace->createQualifiedName (name).sz ());
[+] 	sl::String signature = sl::formatString("ZN%s", anchorNamespace->createQualifiedName (name).sz ());
[-] 	if (!orphanName.isEmpty ())
[+] 	if (!orphanName.isEmpty())
[-] 		signature += orphanName.getFullName ();
[+] 		signature += orphanName.getFullName();
[-] NamedImportType::setAnchorName (const QualifiedName& name)
[+] NamedImportType::setAnchorName(const QualifiedName& name)
[-] 	if (!m_fixupArray.isEmpty ())
[+] 	if (!m_fixupArray.isEmpty())
[-] 		return m_module->m_typeMgr.getNamedImportType (m_name, m_anchorNamespace, name);
[+] 		return m_module->m_typeMgr.getNamedImportType(m_name, m_anchorNamespace, name);
[-] 	ASSERT (m_anchorName.isEmpty ());
[+] 	ASSERT(m_anchorName.isEmpty());
[-] 	m_qualifiedName = m_anchorNamespace->createQualifiedName (name);
[+] 	m_qualifiedName = m_anchorNamespace->createQualifiedName(name);
[-] 	m_qualifiedName += m_name.getFullName ();
[+] 	m_qualifiedName += m_name.getFullName();
[-] 	sl::String signature = createSignature (m_name, m_anchorNamespace, m_anchorName);
[+] 	sl::String signature = createSignature(m_name, m_anchorNamespace, m_anchorName);
[-] 	m_module->m_typeMgr.updateTypeSignature (this, signature);
[+] 	m_module->m_typeMgr.updateTypeSignature(this, signature);
[-] ImportPtrType::ImportPtrType ()
[+] ImportPtrType::ImportPtrType()
[-] ImportPtrType::prepareTypeString ()
[+] ImportPtrType::prepareTypeString()
[-] 	ASSERT (m_targetType);
[+] 	ASSERT(m_targetType);
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 		tuple->m_typeStringPrefix = m_actualType->getTypeStringPrefix ();
[+] 		tuple->m_typeStringPrefix = m_actualType->getTypeStringPrefix();
[-] 		tuple->m_typeStringSuffix = m_actualType->getTypeStringSuffix ();
[+] 		tuple->m_typeStringSuffix = m_actualType->getTypeStringSuffix();
[-] 		tuple->m_typeStringPrefix += getTypeModifierString (m_typeModifiers);
[+] 		tuple->m_typeStringPrefix += getTypeModifierString(m_typeModifiers);
[-] 	tuple->m_typeStringPrefix += m_targetType->getQualifiedName ();
[+] 	tuple->m_typeStringPrefix += m_targetType->getQualifiedName();
[-] ImportIntModType::ImportIntModType ()
[+] ImportIntModType::ImportIntModType()
[-] ImportIntModType::prepareTypeString ()
[+] ImportIntModType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 		tuple->m_typeStringPrefix = m_actualType->getTypeStringPrefix ();
[+] 		tuple->m_typeStringPrefix = m_actualType->getTypeStringPrefix();
[-] 		tuple->m_typeStringPrefix += getTypeModifierString (m_typeModifiers);
[+] 		tuple->m_typeStringPrefix += getTypeModifierString(m_typeModifiers);
[-] 	tuple->m_typeStringPrefix += m_importType->getQualifiedName ();
[+] 	tuple->m_typeStringPrefix += m_importType->getQualifiedName();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_McSnapshotClassType.cpp
----------------------
[-] McSnapshotClassType::McSnapshotClassType ()
[+] McSnapshotClassType::McSnapshotClassType()
[-] 	memset (m_fieldArray, 0, sizeof (m_fieldArray));
[+] 	memset(m_fieldArray, 0, sizeof(m_fieldArray));
[-] 	memset (m_methodArray, 0, sizeof (m_methodArray));
[+] 	memset(m_methodArray, 0, sizeof(m_methodArray));
[-] McSnapshotClassType::prepareTypeString ()
[+] McSnapshotClassType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix += m_targetType->getTypeModifierString ();
[+] 	tuple->m_typeStringPrefix += m_targetType->getTypeModifierString();
[-] 	tuple->m_typeStringSuffix = m_targetType->getTargetType ()->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix = m_targetType->getTargetType()->getTypeStringSuffix();
[-] McSnapshotClassType::prepareDoxyLinkedText ()
[+] McSnapshotClassType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix += m_targetType->getTypeModifierString ();
[+] 	tuple->m_doxyLinkedTextPrefix += m_targetType->getTypeModifierString();
[-] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getTargetType ()->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getTargetType()->getDoxyLinkedTextSuffix();
[-] McSnapshotClassType::prepareDoxyTypeString ()
[+] McSnapshotClassType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	getTypeStringTuple ()->m_doxyTypeString += m_targetType->getTargetType ()->getDoxyArgString ();
[+] 	getTypeStringTuple()->m_doxyTypeString += m_targetType->getTargetType()->getDoxyArgString();
[-] McSnapshotClassType::compileCallMethod ()
[+] McSnapshotClassType::compileCallMethod()
[-] 	Function* function = m_methodArray [McSnapshotMethodKind_Call];
[+] 	Function* function = m_methodArray[McSnapshotMethodKind_Call];
[-] 	sl::Array <FunctionArg*> argArray = function->getType ()->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = function->getType()->getArgArray();
[-] 	size_t argCount = argArray.getCount ();
[+] 	size_t argCount = argArray.getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (function, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(function, argValueArray, argCount);
[-] 	sl::BoxList <Value> argValueList;
[+] 	sl::BoxList<Value> argValueList;
[-] 		argValueList.insertTail (argValueArray [i]);
[+] 		argValueList.insertTail(argValueArray[i]);
[-] 	Type* ptrType = m_targetType->getDataPtrType_c ();
[+] 	Type* ptrType = m_targetType->getDataPtrType_c();
[-] 	int32_t ptrGepIdxArray [] = { 0, 1, 0 };
[+] 	int32_t ptrGepIdxArray[] = { 0, 1, 0 };
[-] 	m_module->m_llvmIrBuilder.createAlloca (ptrType, "ptr", NULL, &ptrVariable);
[+] 	m_module->m_llvmIrBuilder.createAlloca(ptrType, "ptr", NULL, &ptrVariable);
[-] 	m_module->m_llvmIrBuilder.createGep (argValueArray [0], ptrGepIdxArray, countof (ptrGepIdxArray), NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createGep(argValueArray[0], ptrGepIdxArray, countof(ptrGepIdxArray), NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (ptrValue, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(ptrValue, NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createBitCast (ptrValue, ptrType, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createBitCast(ptrValue, ptrType, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createStore (ptrValue, ptrVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(ptrValue, ptrVariable);
[-] 	int32_t countGepIdxArray [] = { 0, 2 };
[+] 	int32_t countGepIdxArray[] = { 0, 2 };
[-] 	m_module->m_llvmIrBuilder.createGep (argValueArray [0], countGepIdxArray, countof (countGepIdxArray), NULL, &countValue);
[+] 	m_module->m_llvmIrBuilder.createGep(argValueArray[0], countGepIdxArray, countof(countGepIdxArray), NULL, &countValue);
[-] 	m_module->m_llvmIrBuilder.createLoad (countValue, countValue.getType (), &countValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(countValue, countValue.getType(), &countValue);
[-] 	m_module->m_llvmIrBuilder.createGep (ptrValue, countValue, ptrType, &ptrEndValue);
[+] 	m_module->m_llvmIrBuilder.createGep(ptrValue, countValue, ptrType, &ptrEndValue);
[-] 	BasicBlock* conditionBlock = m_module->m_controlFlowMgr.createBlock ("call_loop_cond");
[+] 	BasicBlock* conditionBlock = m_module->m_controlFlowMgr.createBlock("call_loop_cond");
[-] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock ("call_loop_body");
[+] 	BasicBlock* bodyBlock = m_module->m_controlFlowMgr.createBlock("call_loop_body");
[-] 	BasicBlock* followBlock = m_module->m_controlFlowMgr.createBlock ("call_loop_follow");
[+] 	BasicBlock* followBlock = m_module->m_controlFlowMgr.createBlock("call_loop_follow");
[-] 	m_module->m_controlFlowMgr.follow (conditionBlock);
[+] 	m_module->m_controlFlowMgr.follow(conditionBlock);
[-] 	m_module->m_llvmIrBuilder.createLoad (ptrVariable, NULL, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(ptrVariable, NULL, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createGe_u (ptrValue, ptrEndValue, &cmpValue);
[+] 	m_module->m_llvmIrBuilder.createGe_u(ptrValue, ptrEndValue, &cmpValue);
[-] 	m_module->m_controlFlowMgr.conditionalJump (cmpValue, followBlock, bodyBlock, bodyBlock);
[+] 	m_module->m_controlFlowMgr.conditionalJump(cmpValue, followBlock, bodyBlock, bodyBlock);
[-] 	m_module->m_llvmIrBuilder.createLoad (ptrValue, m_targetType, &pfnValue);
[+] 	m_module->m_llvmIrBuilder.createLoad(ptrValue, m_targetType, &pfnValue);
[-] 	m_module->m_operatorMgr.callOperator (pfnValue, &argValueList);
[+] 	m_module->m_operatorMgr.callOperator(pfnValue, &argValueList);
[-] 	m_module->m_llvmIrBuilder.createGep (ptrValue, 1, ptrType, &ptrValue);
[+] 	m_module->m_llvmIrBuilder.createGep(ptrValue, 1, ptrType, &ptrValue);
[-] 	m_module->m_llvmIrBuilder.createStore (ptrValue, ptrVariable);
[+] 	m_module->m_llvmIrBuilder.createStore(ptrValue, ptrVariable);
[-] 	m_module->m_controlFlowMgr.jump (conditionBlock, followBlock);
[+] 	m_module->m_controlFlowMgr.jump(conditionBlock, followBlock);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_MulticastClassType.cpp
----------------------
[-] MulticastClassType::MulticastClassType ()
[+] MulticastClassType::MulticastClassType()
[-] 	memset (m_fieldArray, 0, sizeof (m_fieldArray));
[+] 	memset(m_fieldArray, 0, sizeof(m_fieldArray));
[-] 	memset (m_methodArray, 0, sizeof (m_methodArray));
[+] 	memset(m_methodArray, 0, sizeof(m_methodArray));
[-] MulticastClassType::prepareTypeString ()
[+] MulticastClassType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_typeStringPrefix = m_targetType->getTypeModifierString ();
[+] 	tuple->m_typeStringPrefix = m_targetType->getTypeModifierString();
[-] 	tuple->m_typeStringSuffix = m_targetType->getTargetType ()->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix = m_targetType->getTargetType()->getTypeStringSuffix();
[-] MulticastClassType::prepareDoxyLinkedText ()
[+] MulticastClassType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix = m_targetType->getTypeModifierString ();
[+] 	tuple->m_doxyLinkedTextPrefix = m_targetType->getTypeModifierString();
[-] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getTargetType ()->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix = m_targetType->getTargetType()->getDoxyLinkedTextSuffix();
[-] MulticastClassType::prepareDoxyTypeString ()
[+] MulticastClassType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	getTypeStringTuple ()->m_doxyTypeString += m_targetType->getTargetType ()->getDoxyArgString ();
[+] 	getTypeStringTuple()->m_doxyTypeString += m_targetType->getTargetType()->getDoxyArgString();
[-] MulticastClassType::compileCallMethod ()
[+] MulticastClassType::compileCallMethod()
[-] 	Function* function = m_methodArray [MulticastMethodKind_Call];
[+] 	Function* function = m_methodArray[MulticastMethodKind_Call];
[-] 	size_t argCount = function->getType ()->getArgArray ().getCount ();
[+] 	size_t argCount = function->getType()->getArgArray().getCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Value> argValueArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Value> argValueArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argValueArray.setCount (argCount);
[+] 	argValueArray.setCount(argCount);
[-] 	m_module->m_functionMgr.internalPrologue (function, argValueArray, argCount);
[+] 	m_module->m_functionMgr.internalPrologue(function, argValueArray, argCount);
[-] 	Function* getSnapshot = m_methodArray [MulticastMethodKind_GetSnapshot];
[+] 	Function* getSnapshot = m_methodArray[MulticastMethodKind_GetSnapshot];
[-] 	result = m_module->m_operatorMgr.callOperator (getSnapshot, argValueArray [0], &snapshotValue);
[+] 	result = m_module->m_operatorMgr.callOperator(getSnapshot, argValueArray[0], &snapshotValue);
[-] 	sl::BoxList <Value> argList;
[+] 	sl::BoxList<Value> argList;
[-] 		argList.insertTail (argValueArray [i]);
[+] 		argList.insertTail(argValueArray[i]);
[-] 	m_module->m_operatorMgr.callOperator (snapshotValue, &argList);
[+] 	m_module->m_operatorMgr.callOperator(snapshotValue, &argList);
[-] 	m_module->m_controlFlowMgr.ret ();
[+] 	m_module->m_controlFlowMgr.ret();
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_NamedTypeBlock.cpp
----------------------
[-] NamedTypeBlock::NamedTypeBlock (ModuleItem* parent)
[+] NamedTypeBlock::NamedTypeBlock(ModuleItem* parent)
[-] NamedTypeBlock::getParentNamespaceImpl ()
[+] NamedTypeBlock::getParentNamespaceImpl()
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		m_parent->getItemKind () == ModuleItemKind_Property ||
[+] 		m_parent->getItemKind() == ModuleItemKind_Property ||
[-] 		m_parent->getItemKind () == ModuleItemKind_Type &&
[+] 		m_parent->getItemKind() == ModuleItemKind_Type &&
[-] 		(((Type*) m_parent)->getTypeKindFlags () & TypeKindFlag_Derivable));
[+] 		(((Type*)m_parent)->getTypeKindFlags() & TypeKindFlag_Derivable));
[-] 	return  m_parent->getItemKind () == ModuleItemKind_Property ?
[+] 	return  m_parent->getItemKind() == ModuleItemKind_Property ?
[-] 		(Namespace*) (Property*) m_parent :
[+] 		(Namespace*)(Property*)m_parent :
[-] 		(Namespace*) (DerivableType*) m_parent;
[+] 		(Namespace*)(DerivableType*)m_parent;
[-] NamedTypeBlock::getParentUnitImpl ()
[+] NamedTypeBlock::getParentUnitImpl()
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		m_parent->getItemKind () == ModuleItemKind_Property ||
[+] 		m_parent->getItemKind() == ModuleItemKind_Property ||
[-] 		m_parent->getItemKind () == ModuleItemKind_Type &&
[+] 		m_parent->getItemKind() == ModuleItemKind_Type &&
[-] 		(((Type*) m_parent)->getTypeKindFlags () & TypeKindFlag_Derivable));
[+] 		(((Type*)m_parent)->getTypeKindFlags() & TypeKindFlag_Derivable));
[-] 	return  m_parent->getItemKind () == ModuleItemKind_Property ?
[+] 	return  m_parent->getItemKind() == ModuleItemKind_Property ?
[-] 		((Property*) m_parent)->getParentUnit () :
[+] 		((Property*)m_parent)->getParentUnit() :
[-] 		((DerivableType*) m_parent)->getParentUnit ();
[+] 		((DerivableType*)m_parent)->getParentUnit();
[-] NamedTypeBlock::createMethod (
[+] NamedTypeBlock::createMethod(
[-] 	sl::String qualifiedName = getParentNamespaceImpl ()->createQualifiedName (name);
[+] 	sl::String qualifiedName = getParentNamespaceImpl()->createQualifiedName(name);
[-] 	Function* function = m_parent->getModule ()->m_functionMgr.createFunction (FunctionKind_Normal, shortType);
[+] 	Function* function = m_parent->getModule()->m_functionMgr.createFunction(FunctionKind_Normal, shortType);
[-] 	bool result = addMethod (function);
[+] 	bool result = addMethod(function);
[-] NamedTypeBlock::createUnnamedMethod (
[+] NamedTypeBlock::createUnnamedMethod(
[-] 	Function* function = m_parent->getModule ()->m_functionMgr.createFunction (functionKind, shortType);
[+] 	Function* function = m_parent->getModule()->m_functionMgr.createFunction(functionKind, shortType);
[-] 	function->m_tag.format (
[+] 	function->m_tag.format(
[-] 		getParentNamespaceImpl ()->getQualifiedName ().sz (),
[+] 		getParentNamespaceImpl()->getQualifiedName().sz(),
[-] 		getFunctionKindString (functionKind)
[+] 		getFunctionKindString(functionKind)
[-] 	bool result = addMethod (function);
[+] 	bool result = addMethod(function);
[-] NamedTypeBlock::createProperty (
[+] NamedTypeBlock::createProperty(
[-] 	sl::String qualifiedName = getParentNamespaceImpl ()->createQualifiedName (name);
[+] 	sl::String qualifiedName = getParentNamespaceImpl()->createQualifiedName(name);
[-] 	Property* prop = m_parent->getModule ()->m_functionMgr.createProperty (name, qualifiedName);
[+] 	Property* prop = m_parent->getModule()->m_functionMgr.createProperty(name, qualifiedName);
[-] 		addProperty (prop) &&
[+] 		addProperty(prop) &&
[-] 		prop->create (shortType);
[+] 		prop->create(shortType);
[-] NamedTypeBlock::initializeStaticFields ()
[+] NamedTypeBlock::initializeStaticFields()
[-] 	Module* module = m_parent->getModule ();
[+] 	Module* module = m_parent->getModule();
[-] 	Unit* unit = getParentUnitImpl ();
[+] 	Unit* unit = getParentUnitImpl();
[-] 		module->m_unitMgr.setCurrentUnit (unit);
[+] 		module->m_unitMgr.setCurrentUnit(unit);
[-] 	module->m_namespaceMgr.openNamespace (getParentNamespaceImpl ());
[+] 	module->m_namespaceMgr.openNamespace(getParentNamespaceImpl());
[-] 	size_t count = m_initializedStaticFieldArray.getCount ();
[+] 	size_t count = m_initializedStaticFieldArray.getCount();
[-] 		Variable* staticField = m_initializedStaticFieldArray [i];
[+] 		Variable* staticField = m_initializedStaticFieldArray[i];
[-] 		result = module->m_variableMgr.initializeVariable (staticField);
[+] 		result = module->m_variableMgr.initializeVariable(staticField);
[-] 	module->m_namespaceMgr.closeNamespace ();
[+] 	module->m_namespaceMgr.closeNamespace();
[-] NamedTypeBlock::initializeMemberFields (const Value& thisValue)
[+] NamedTypeBlock::initializeMemberFields(const Value& thisValue)
[-] 	Module* module = m_parent->getModule ();
[+] 	Module* module = m_parent->getModule();
[-] 	Unit* unit = getParentUnitImpl ();
[+] 	Unit* unit = getParentUnitImpl();
[-] 		module->m_unitMgr.setCurrentUnit (unit);
[+] 		module->m_unitMgr.setCurrentUnit(unit);
[-] 	module->m_namespaceMgr.openNamespace (getParentNamespaceImpl ());
[+] 	module->m_namespaceMgr.openNamespace(getParentNamespaceImpl());
[-] 	size_t count = m_initializedMemberFieldArray.getCount ();
[+] 	size_t count = m_initializedMemberFieldArray.getCount();
[-] 		StructField* field = m_initializedMemberFieldArray [i];
[+] 		StructField* field = m_initializedMemberFieldArray[i];
[-] 		result = module->m_operatorMgr.getField (thisValue, field, NULL, &fieldValue);
[+] 		result = module->m_operatorMgr.getField(thisValue, field, NULL, &fieldValue);
[-] 		result = module->m_operatorMgr.parseInitializer (
[+] 		result = module->m_operatorMgr.parseInitializer(
[-] 	module->m_namespaceMgr.closeNamespace ();
[+] 	module->m_namespaceMgr.closeNamespace();
[-] NamedTypeBlock::callMemberFieldConstructors (const Value& thisValue)
[+] NamedTypeBlock::callMemberFieldConstructors(const Value& thisValue)
[-] 	Module* module = m_parent->getModule ();
[+] 	Module* module = m_parent->getModule();
[-] 	size_t count = m_memberFieldConstructArray.getCount ();
[+] 	size_t count = m_memberFieldConstructArray.getCount();
[-] 		StructField* field = m_memberFieldConstructArray [i];
[+] 		StructField* field = m_memberFieldConstructArray[i];
[-] 		result = module->m_operatorMgr.getField (thisValue, field, NULL, &fieldValue);
[+] 		result = module->m_operatorMgr.getField(thisValue, field, NULL, &fieldValue);
[-] 		ASSERT (field->getType ()->getTypeKindFlags () & TypeKindFlag_Derivable);
[+] 		ASSERT(field->getType()->getTypeKindFlags() & TypeKindFlag_Derivable);
[-] 		DerivableType* type = (DerivableType*) field->getType ();
[+] 		DerivableType* type = (DerivableType*)field->getType();
[-] 		Function* constructor = type->getDefaultConstructor ();
[+] 		Function* constructor = type->getDefaultConstructor();
[-] 		ASSERT (constructor); // otherwise, would not be on member-field-construct array
[+] 		ASSERT(constructor); // otherwise, would not be on member-field-construct array
[-] 		result = module->m_operatorMgr.callOperator (constructor, fieldValue);
[+] 		result = module->m_operatorMgr.callOperator(constructor, fieldValue);
[-] NamedTypeBlock::callMemberPropertyConstructors (const Value& thisValue)
[+] NamedTypeBlock::callMemberPropertyConstructors(const Value& thisValue)
[-] 	Module* module = m_parent->getModule ();
[+] 	Module* module = m_parent->getModule();
[-] 	size_t count = m_memberPropertyConstructArray.getCount ();
[+] 	size_t count = m_memberPropertyConstructArray.getCount();
[-] 		Property* prop = m_memberPropertyConstructArray [i];
[+] 		Property* prop = m_memberPropertyConstructArray[i];
[-] 		Function* constructor = prop->getConstructor ();
[+] 		Function* constructor = prop->getConstructor();
[-] 		ASSERT (constructor);
[+] 		ASSERT(constructor);
[-] 		result = module->m_operatorMgr.callOperator (constructor, thisValue);
[+] 		result = module->m_operatorMgr.callOperator(constructor, thisValue);
[-] NamedTypeBlock::callMemberPropertyDestructors (const Value& thisValue)
[+] NamedTypeBlock::callMemberPropertyDestructors(const Value& thisValue)
[-] 	Module* module = m_parent->getModule ();
[+] 	Module* module = m_parent->getModule();
[-] 	size_t count = m_memberPropertyDestructArray.getCount ();
[+] 	size_t count = m_memberPropertyDestructArray.getCount();
[-] 		Property* prop = m_memberPropertyDestructArray [i];
[+] 		Property* prop = m_memberPropertyDestructArray[i];
[-] 		Function* destructor = prop->getDestructor ();
[+] 		Function* destructor = prop->getDestructor();
[-] 		ASSERT (destructor);
[+] 		ASSERT(destructor);
[-] 		result = module->m_operatorMgr.callOperator (destructor, thisValue);
[+] 		result = module->m_operatorMgr.callOperator(destructor, thisValue);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_PropertyPtrType.cpp
----------------------
[-] getPropertyPtrTypeKindString (PropertyPtrTypeKind ptrTypeKind)
[+] getPropertyPtrTypeKindString(PropertyPtrTypeKind ptrTypeKind)
[-] 	static const char* stringTable [PropertyPtrTypeKind__Count] =
[+] 	static const char* stringTable[PropertyPtrTypeKind__Count] =
[-] 	return (size_t) ptrTypeKind < PropertyPtrTypeKind__Count ?
[+] 	return (size_t)ptrTypeKind < PropertyPtrTypeKind__Count ?
[-] 		stringTable [ptrTypeKind] :
[+] 		stringTable[ptrTypeKind] :
[-] PropertyPtrType::PropertyPtrType ()
[+] PropertyPtrType::PropertyPtrType()
[-] 	m_size = sizeof (PropertyPtr);
[+] 	m_size = sizeof(PropertyPtr);
[-] PropertyPtrType::createSignature (
[+] PropertyPtrType::createSignature(
[-] 	switch (ptrTypeKind)
[+] 	switch(ptrTypeKind)
[-] 	signature += getPtrTypeFlagSignature (flags);
[+] 	signature += getPtrTypeFlagSignature(flags);
[-] 	signature += propertyType->getSignature ();
[+] 	signature += propertyType->getSignature();
[-] PropertyPtrType::prepareTypeString ()
[+] PropertyPtrType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = m_targetType->getReturnType ();
[+] 	Type* returnType = m_targetType->getReturnType();
[-] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix ();
[+] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix();
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_flags);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_flags);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		tuple->m_typeStringPrefix += getPropertyPtrTypeKindString (m_ptrTypeKind);
[+] 		tuple->m_typeStringPrefix += getPropertyPtrTypeKindString(m_ptrTypeKind);
[-] 	if (m_targetType->isIndexed ())
[+] 	if (m_targetType->isIndexed())
[-] 		tuple->m_typeStringSuffix += m_targetType->getGetterType ()->getTypeStringSuffix ();
[+] 		tuple->m_typeStringSuffix += m_targetType->getGetterType()->getTypeStringSuffix();
[-] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix();
[-] PropertyPtrType::prepareDoxyLinkedText ()
[+] PropertyPtrType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = m_targetType->getReturnType ();
[+] 	Type* returnType = m_targetType->getReturnType();
[-] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix();
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_flags);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_flags);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		tuple->m_doxyLinkedTextPrefix += getPropertyPtrTypeKindString (m_ptrTypeKind);
[+] 		tuple->m_doxyLinkedTextPrefix += getPropertyPtrTypeKindString(m_ptrTypeKind);
[-] 	if (m_targetType->isIndexed ())
[+] 	if (m_targetType->isIndexed())
[-] 		tuple->m_doxyLinkedTextSuffix += m_targetType->getGetterType ()->getDoxyLinkedTextSuffix ();
[+] 		tuple->m_doxyLinkedTextSuffix += m_targetType->getGetterType()->getDoxyLinkedTextSuffix();
[-] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix();
[-] PropertyPtrType::prepareDoxyTypeString ()
[+] PropertyPtrType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	if (m_targetType->isIndexed ())
[+] 	if (m_targetType->isIndexed())
[-] 		getTypeStringTuple ()->m_doxyTypeString += m_targetType->getGetterType ()->getDoxyArgString ();
[+] 		getTypeStringTuple()->m_doxyTypeString += m_targetType->getGetterType()->getDoxyArgString();
[-] PropertyPtrType::prepareLlvmType ()
[+] PropertyPtrType::prepareLlvmType()
[-] 		m_module->m_typeMgr.getStdType (StdType_PropertyPtrStruct)->getLlvmType () :
[+] 		m_module->m_typeMgr.getStdType(StdType_PropertyPtrStruct)->getLlvmType() :
[-] 		m_targetType->getVTableStructType ()->getDataPtrType_c ()->getLlvmType ();
[+] 		m_targetType->getVTableStructType()->getDataPtrType_c()->getLlvmType();
[-] PropertyPtrType::prepareLlvmDiType ()
[+] PropertyPtrType::prepareLlvmDiType()
[-] 		m_module->m_typeMgr.getStdType (StdType_PropertyPtrStruct)->getLlvmDiType () :
[+] 		m_module->m_typeMgr.getStdType(StdType_PropertyPtrStruct)->getLlvmDiType() :
[-] 		m_targetType->getVTableStructType ()->getDataPtrType_c ()->getLlvmDiType ();
[+] 		m_targetType->getVTableStructType()->getDataPtrType_c()->getLlvmDiType();
[-] PropertyPtrType::markGcRoots (
[+] PropertyPtrType::markGcRoots(
[-] 	ASSERT (m_ptrTypeKind == PropertyPtrTypeKind_Normal || m_ptrTypeKind == PropertyPtrTypeKind_Weak);
[+] 	ASSERT(m_ptrTypeKind == PropertyPtrTypeKind_Normal || m_ptrTypeKind == PropertyPtrTypeKind_Weak);
[-] 	PropertyPtr* ptr = (PropertyPtr*) p;
[+] 	PropertyPtr* ptr = (PropertyPtr*)p;
[-] 		gcHeap->markClass (box);
[+] 		gcHeap->markClass(box);
[-] 	else if (isClassType (box->m_type, ClassTypeKind_PropertyClosure))
[+] 	else if (isClassType(box->m_type, ClassTypeKind_PropertyClosure))
[-] 		gcHeap->weakMarkClosureClass (box);
[+] 		gcHeap->weakMarkClosureClass(box);
[-] 		gcHeap->weakMark (box);
[+] 		gcHeap->weakMark(box);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_PropertyType.cpp
----------------------
[-] getPropertyTypeFlagString (PropertyTypeFlag flag)
[+] getPropertyTypeFlagString(PropertyTypeFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag >> 16);
[+] 	size_t i = sl::getLoBitIdx32(flag >> 16);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getPropertyTypeFlagString (uint_t flags)
[+] getPropertyTypeFlagString(uint_t flags)
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	PropertyTypeFlag flag = getFirstPropertyTypeFlag (flags);
[+] 	PropertyTypeFlag flag = getFirstPropertyTypeFlag(flags);
[-] 	sl::String string = getPropertyTypeFlagString (flag);
[+] 	sl::String string = getPropertyTypeFlagString(flag);
[-] 		flag = getFirstPropertyTypeFlag (flags);
[+] 		flag = getFirstPropertyTypeFlag(flags);
[-] 		string += getPropertyTypeFlagString (flag);
[+] 		string += getPropertyTypeFlagString(flag);
[-] getPropertyTypeFlagsFromModifiers (uint_t modifiers)
[+] getPropertyTypeFlagsFromModifiers(uint_t modifiers)
[-] PropertyType::PropertyType ()
[+] PropertyType::PropertyType()
[-] PropertyType::getPropertyPtrType (
[+] PropertyType::getPropertyPtrType(
[-] 	return m_module->m_typeMgr.getPropertyPtrType (this, typeKind, ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getPropertyPtrType(this, typeKind, ptrTypeKind, flags);
[-] PropertyType::getMemberPropertyType (ClassType* classType)
[+] PropertyType::getMemberPropertyType(ClassType* classType)
[-] 	return m_module->m_typeMgr.getMemberPropertyType (classType, this);
[+] 	return m_module->m_typeMgr.getMemberPropertyType(classType, this);
[-] PropertyType::getStdObjectMemberPropertyType ()
[+] PropertyType::getStdObjectMemberPropertyType()
[-] 	return m_module->m_typeMgr.getStdObjectMemberPropertyType (this);
[+] 	return m_module->m_typeMgr.getStdObjectMemberPropertyType(this);
[-] 	return m_module->m_typeMgr.getShortPropertyType (this);
[+] 	return m_module->m_typeMgr.getShortPropertyType(this);
[-] PropertyType::getVTableStructType ()
[+] PropertyType::getVTableStructType()
[-] 	return m_module->m_typeMgr.getPropertyVTableStructType (this);
[+] 	return m_module->m_typeMgr.getPropertyVTableStructType(this);
[-] PropertyType::createSignature (
[+] PropertyType::createSignature(
[-] 	string += getterType->getSignature ();
[+] 	string += getterType->getSignature();
[-] 	size_t overloadCount = setterType.getOverloadCount ();
[+] 	size_t overloadCount = setterType.getOverloadCount();
[-] 		FunctionType* overloadType = setterType.getOverload (i);
[+] 		FunctionType* overloadType = setterType.getOverload(i);
[-] 		string += overloadType->getSignature ();
[+] 		string += overloadType->getSignature();
[-] PropertyType::getTypeModifierString ()
[+] PropertyType::getTypeModifierString()
[-] 	size_t argCount = m_getterType->getArgArray ().getCount ();
[+] 	size_t argCount = m_getterType->getArgArray().getCount();
[-] 	if (argCount >= 2 || argCount == 1 && !m_getterType->isMemberMethodType ())
[+] 	if (argCount >= 2 || argCount == 1 && !m_getterType->isMemberMethodType())
[-] 	if (!string.isEmpty ())
[+] 	if (!string.isEmpty())
[-] 		string.chop (1);
[+] 		string.chop(1);
[-] PropertyType::prepareTypeString ()
[+] PropertyType::prepareTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = getReturnType ();
[+] 	Type* returnType = getReturnType();
[-] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix ();
[+] 	tuple->m_typeStringPrefix = returnType->getTypeStringPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 	if (isIndexed ())
[+] 	if (isIndexed())
[-] 		tuple->m_typeStringSuffix = m_getterType->getTypeStringSuffix ();
[+] 		tuple->m_typeStringSuffix = m_getterType->getTypeStringSuffix();
[-] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix ();
[+] 	tuple->m_typeStringSuffix += returnType->getTypeStringSuffix();
[-] PropertyType::prepareDoxyLinkedText ()
[+] PropertyType::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	Type* returnType = getReturnType ();
[+] 	Type* returnType = getReturnType();
[-] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = returnType->getDoxyLinkedTextPrefix();
[-] 	sl::String modifierString = getTypeModifierString ();
[+] 	sl::String modifierString = getTypeModifierString();
[-] 	if (!modifierString.isEmpty ())
[+] 	if (!modifierString.isEmpty())
[-] 	if (isIndexed ())
[+] 	if (isIndexed())
[-] 		tuple->m_doxyLinkedTextSuffix = m_getterType->getDoxyLinkedTextSuffix ();
[+] 		tuple->m_doxyLinkedTextSuffix = m_getterType->getDoxyLinkedTextSuffix();
[-] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix += returnType->getDoxyLinkedTextSuffix();
[-] PropertyType::prepareDoxyTypeString ()
[+] PropertyType::prepareDoxyTypeString()
[-] 	Type::prepareDoxyTypeString ();
[+] 	Type::prepareDoxyTypeString();
[-] 	if (isIndexed ())
[+] 	if (isIndexed())
[-] 		getTypeStringTuple ()->m_doxyTypeString += m_getterType->getDoxyArgString ();
[+] 		getTypeStringTuple()->m_doxyTypeString += m_getterType->getDoxyArgString();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ReactorClassType.cpp
----------------------
[-] getReactorMethod (
[+] getReactorMethod(
[-] 	static const char* nameTable [ReactorMethod__Count] =
[+] 	static const char* nameTable[ReactorMethod__Count] =
[-] 	ASSERT (method < countof (nameTable));
[+] 	ASSERT(method < countof(nameTable));
[-] 	ClassType* reactorType = (ClassType*) module->m_typeMgr.getStdType (StdType_ReactorBase);
[+] 	ClassType* reactorType = (ClassType*)module->m_typeMgr.getStdType(StdType_ReactorBase);
[-] 	Function* function = reactorType->getMemberMethodArray () [method];
[+] 	Function* function = reactorType->getMemberMethodArray() [method];
[-] 	ASSERT (function->getName () == nameTable [method]);
[+] 	ASSERT(function->getName() == nameTable[method]);
[-] ReactorClassType::ReactorClassType ()
[+] ReactorClassType::ReactorClassType()
[-] ReactorClassType::createOnEventHandler (
[+] ReactorClassType::createOnEventHandler(
[-] 	Function* function = createUnnamedMethod (StorageKind_Member, FunctionKind_Internal, type);
[+] 	Function* function = createUnnamedMethod(StorageKind_Member, FunctionKind_Internal, type);
[-] 	sl::HashTableIterator <size_t, Function*> it = m_onEventMap.visit (reactionIdx);
[+] 	sl::HashTableIterator<size_t, Function*> it = m_onEventMap.visit(reactionIdx);
[-] 	ASSERT (!it->m_value);
[+] 	ASSERT(!it->m_value);
[-] ReactorClassType::setBody (sl::BoxList <Token>* tokenList)
[+] ReactorClassType::setBody(sl::BoxList<Token>* tokenList)
[-] 	if (!m_body.isEmpty ())
[+] 	if (!m_body.isEmpty())
[-] 		err::setFormatStringError ("'%s' already has a body", m_tag.sz ());
[+] 		err::setFormatStringError("'%s' already has a body", m_tag.sz ());
[-] 	sl::takeOver (&m_body, tokenList);
[+] 	sl::takeOver(&m_body, tokenList);
[-] 	m_module->markForCompile (this);
[+] 	m_module->markForCompile(this);
[-] ReactorClassType::calcLayout ()
[+] ReactorClassType::calcLayout()
[-] 	if (m_body.isEmpty ())
[+] 	if (m_body.isEmpty())
[-] 		err::setFormatStringError ("reactor '%s' has no body", m_tag.sz ());
[+] 		err::setFormatStringError("reactor '%s' has no body", m_tag.sz ());
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	Function* prevFunction = m_module->m_functionMgr.setCurrentFunction (m_reaction); // we need some method for OperatorMgr::getThisValueType to work
[+] 	Function* prevFunction = m_module->m_functionMgr.setCurrentFunction(m_reaction); // we need some method for OperatorMgr::getThisValueType to work
[-] 	m_module->m_namespaceMgr.openNamespace (this);
[+] 	m_module->m_namespaceMgr.openNamespace(this);
[-] 	result = parser.parseTokenList (SymbolKind_reactor_body_0, m_body, false);
[+] 	result = parser.parseTokenList(SymbolKind_reactor_body_0, m_body, false);
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
[-] 	m_module->m_functionMgr.setCurrentFunction (prevFunction);
[+] 	m_module->m_functionMgr.setCurrentFunction(prevFunction);
[-] 	return ClassType::calcLayout ();
[+] 	return ClassType::calcLayout();
[-] ReactorClassType::compile ()
[+] ReactorClassType::compile()
[-] 	bool result = ClassType::compile (); // compile default constructor & destructor
[+] 	bool result = ClassType::compile(); // compile default constructor & destructor
[-] 	ASSERT (!m_body.isEmpty ());
[+] 	ASSERT(!m_body.isEmpty());
[-] 	const Token::Pos* pos = &m_body.getHead ()->m_pos;
[+] 	const Token::Pos* pos = &m_body.getHead()->m_pos;
[-] 		m_module->m_unitMgr.setCurrentUnit (m_parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(m_parentUnit);
[-] 	Value argValueArray [2];
[+] 	Value argValueArray[2];
[-] 	m_module->m_namespaceMgr.openNamespace (this);
[+] 	m_module->m_namespaceMgr.openNamespace(this);
[-] 	m_module->m_functionMgr.internalPrologue (m_reaction, argValueArray, countof (argValueArray), pos);
[+] 	m_module->m_functionMgr.internalPrologue(m_reaction, argValueArray, countof(argValueArray), pos);
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	parser.m_reactionIdxArgValue = argValueArray [1];
[+] 	parser.m_reactionIdxArgValue = argValueArray[1];
[-] 	result = parser.parseTokenList (SymbolKind_reactor_body, m_body, true);
[+] 	result = parser.parseTokenList(SymbolKind_reactor_body, m_body, true);
[-] 	m_module->m_functionMgr.internalEpilogue ();
[+] 	m_module->m_functionMgr.internalEpilogue();
[-] 	m_module->m_namespaceMgr.closeNamespace ();
[+] 	m_module->m_namespaceMgr.closeNamespace();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_StdType.cpp
----------------------
[-] getStdTypeSource (StdType stdType)
[+] getStdTypeSource(StdType stdType)
[-] 	static StdItemSource sourceTable [StdType__Count] =
[+] 	static StdItemSource sourceTable[StdType__Count] =
[-] 			lengthof (schedulerTypeSrc),
[+] 			lengthof(schedulerTypeSrc),
[-] 			lengthof (regexMatchTypeSrc),
[+] 			lengthof(regexMatchTypeSrc),
[-] 			lengthof (regexStateTypeSrc),
[+] 			lengthof(regexStateTypeSrc),
[-] 			lengthof (regexDfaTypeSrc),
[+] 			lengthof(regexDfaTypeSrc),
[-] 			lengthof (promiseTypeSrc),
[+] 			lengthof(promiseTypeSrc),
[-] 			lengthof (promisifierTypeSrc),
[+] 			lengthof(promisifierTypeSrc),
[-] 			lengthof (dynamicLibTypeSrc),
[+] 			lengthof(dynamicLibTypeSrc),
[-] 			lengthof (dynamicLayoutTypeSrc),
[+] 			lengthof(dynamicLayoutTypeSrc),
[-] 			lengthof (fmtLiteralTypeSrc),
[+] 			lengthof(fmtLiteralTypeSrc),
[-] 			lengthof (int64Int64TypeSrc),
[+] 			lengthof(int64Int64TypeSrc),
[-] 			lengthof (fp64Fp64TypeSrc),
[+] 			lengthof(fp64Fp64TypeSrc),
[-] 			lengthof (int64Fp64TypeSrc),
[+] 			lengthof(int64Fp64TypeSrc),
[-] 			lengthof (fp64Int64TypeSrc),
[+] 			lengthof(fp64Int64TypeSrc),
[-] 	ASSERT ((size_t) stdType < StdType__Count);
[+] 	ASSERT((size_t)stdType < StdType__Count);
[-] 	return &sourceTable [stdType];
[+] 	return &sourceTable[stdType];
[-] LazyStdType::getActualItem ()
[+] LazyStdType::getActualItem()
[-] 	return m_module->m_typeMgr.getStdType (m_stdType);
[+] 	return m_module->m_typeMgr.getStdType(m_stdType);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_StructType.cpp
----------------------
[-] StructField::StructField ()
[+] StructField::StructField()
[-] StructField::generateDocumentation (
[+] StructField::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	bool isMulticast = isClassType (m_type, ClassTypeKind_Multicast);
[+] 	bool isMulticast = isClassType(m_type, ClassTypeKind_Multicast);
[-] 	itemXml->format ("<memberdef kind='%s' id='%s'", kind, doxyBlock->getRefId ().sz ());
[+] 	itemXml->format("<memberdef kind='%s' id='%s'", kind, doxyBlock->getRefId ().sz ());
[-] 		itemXml->appendFormat (" prot='%s'", getAccessKindString (m_accessKind));
[+] 		itemXml->appendFormat(" prot='%s'", getAccessKindString (m_accessKind));
[-] 		itemXml->append (" static='yes'");
[+] 		itemXml->append(" static='yes'");
[-] 		itemXml->append (" tls='yes'");
[+] 		itemXml->append(" tls='yes'");
[-] 		itemXml->append (" const='yes'");
[+] 		itemXml->append(" const='yes'");
[-] 		itemXml->append (" readonly='yes'");
[+] 		itemXml->append(" readonly='yes'");
[-] 	itemXml->appendFormat (">\n<name>%s</name>\n", m_name.sz ());
[+] 	itemXml->appendFormat(">\n<name>%s</name>\n", m_name.sz ());
[-] 	itemXml->append (m_type->getDoxyTypeString ());
[+] 	itemXml->append(m_type->getDoxyTypeString());
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_ptrTypeFlags & ~PtrTypeFlag_DualEvent);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_ptrTypeFlags & ~PtrTypeFlag_DualEvent);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		itemXml->appendFormat ("<modifiers>%s</modifiers>\n", ptrTypeFlagString.sz ());
[+] 		itemXml->appendFormat("<modifiers>%s</modifiers>\n", ptrTypeFlagString.sz ());
[-] 	if (!m_initializer.isEmpty ())
[+] 	if (!m_initializer.isEmpty())
[-] 		itemXml->appendFormat ("<initializer>= %s</initializer>\n", getInitializerString ().sz ());
[+] 		itemXml->appendFormat("<initializer>= %s</initializer>\n", getInitializerString ().sz ());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
[-] StructType::StructType ()
[+] StructType::StructType()
[-] StructType::prepareLlvmType ()
[+] StructType::prepareLlvmType()
[-] 	m_llvmType = llvm::StructType::create (*m_module->getLlvmContext (), m_tag.sz ());
[+] 	m_llvmType = llvm::StructType::create(*m_module->getLlvmContext(), m_tag.sz());
[-] StructType::createFieldImpl (
[+] StructType::createFieldImpl(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 		err::setFormatStringError ("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[-] 	StructField* field = m_module->m_typeMgr.createStructField (
[+] 	StructField* field = m_module->m_typeMgr.createStructField(
[-] 	if (!field->m_constructor.isEmpty () ||
[+] 	if (!field->m_constructor.isEmpty() ||
[-] 		!field->m_initializer.isEmpty ())
[+] 		!field->m_initializer.isEmpty())
[-] 		m_initializedMemberFieldArray.append (field);
[+] 		m_initializedMemberFieldArray.append(field);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		m_unnamedFieldArray.append (field);
[+] 		m_unnamedFieldArray.append(field);
[-] 	else if (name [0] != '!') // internal field
[+] 	else if (name[0] != '!') // internal field
[-] 		bool result = addItem (field);
[+] 		bool result = addItem(field);
[-] 	m_memberFieldArray.append (field);
[+] 	m_memberFieldArray.append(field);
[-] StructType::append (StructType* type)
[+] StructType::append(StructType* type)
[-] 	sl::Iterator <BaseTypeSlot> slot = type->m_baseTypeList.getHead ();
[+] 	sl::Iterator<BaseTypeSlot> slot = type->m_baseTypeList.getHead();
[-] 		result = addBaseType (slot->m_type) != NULL;
[+] 		result = addBaseType(slot->m_type) != NULL;
[-] 	sl::Array <StructField*> fieldArray = type->getMemberFieldArray ();
[+] 	sl::Array<StructField*> fieldArray = type->getMemberFieldArray();
[-] 	size_t count = fieldArray.getCount ();
[+] 	size_t count = fieldArray.getCount();
[-] 		StructField* field = fieldArray [i];
[+] 		StructField* field = fieldArray[i];
[-] 			createField (field->m_name, field->m_bitFieldBaseType, field->m_bitCount, field->m_ptrTypeFlags) != NULL:
[+] 			createField(field->m_name, field->m_bitFieldBaseType, field->m_bitCount, field->m_ptrTypeFlags) != NULL:
[-] 			createField (field->m_name, field->m_type, 0, field->m_ptrTypeFlags) != NULL;
[+] 			createField(field->m_name, field->m_type, 0, field->m_ptrTypeFlags) != NULL;
[-] StructType::calcLayout ()
[+] StructType::calcLayout()
[-] 	sl::Iterator <BaseTypeSlot> slotIt = m_baseTypeList.getHead ();
[+] 	sl::Iterator<BaseTypeSlot> slotIt = m_baseTypeList.getHead();
[-] 		if (!(slot->m_type->getTypeKindFlags () & TypeKindFlag_Derivable) ||
[+] 		if (!(slot->m_type->getTypeKindFlags() & TypeKindFlag_Derivable) ||
[-] 			(slot->m_type->getFlags () & TypeFlag_Dynamic) ||
[+] 			(slot->m_type->getFlags() & TypeFlag_Dynamic) ||
[-] 			slot->m_type->getTypeKind () == TypeKind_Class)
[+] 			slot->m_type->getTypeKind() == TypeKind_Class)
[-] 			err::setFormatStringError ("'%s' cannot be a base type of a struct", slot->m_type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'%s' cannot be a base type of a struct", slot->m_type->getTypeString ().sz ());
[-] 		sl::StringHashTableIterator <BaseTypeSlot*> it = m_baseTypeMap.visit (slot->m_type->getSignature ());
[+] 		sl::StringHashTableIterator<BaseTypeSlot*> it = m_baseTypeMap.visit(slot->m_type->getSignature());
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				slot->m_type->getTypeString ().sz ()
[+] 				slot->m_type->getTypeString().sz()
[-] 		result = slot->m_type->ensureLayout ();
[+] 		result = slot->m_type->ensureLayout();
[-] 		if (slot->m_type->getFlags () & TypeFlag_GcRoot)
[+] 		if (slot->m_type->getFlags() & TypeFlag_GcRoot)
[-] 			m_gcRootBaseTypeArray.append (slot);
[+] 			m_gcRootBaseTypeArray.append(slot);
[-] 		if (slot->m_type->getConstructor ())
[+] 		if (slot->m_type->getConstructor())
[-] 			m_baseTypeConstructArray.append (slot);
[+] 			m_baseTypeConstructArray.append(slot);
[-] 		result = layoutField (
[+] 		result = layoutField(
[-] 	size_t count = m_memberFieldArray.getCount ();
[+] 	size_t count = m_memberFieldArray.getCount();
[-] 		StructField* field = m_memberFieldArray [i];
[+] 		StructField* field = m_memberFieldArray[i];
[-] 		result = layoutField (field);
[+] 		result = layoutField(field);
[-] 	if ((m_flags & TypeFlag_Dynamic) && m_dynamicFieldArray.isEmpty ())
[+] 	if ((m_flags & TypeFlag_Dynamic) && m_dynamicFieldArray.isEmpty())
[-] 		err::setFormatStringError ("dynamic struct '%s' has no dynamic fields", m_qualifiedName.sz ());
[+] 		err::setFormatStringError("dynamic struct '%s' has no dynamic fields", m_qualifiedName.sz ());
[-] 		insertPadding (m_fieldAlignedSize - m_fieldActualSize);
[+] 		insertPadding(m_fieldAlignedSize - m_fieldActualSize);
[-] 		size_t count = m_memberFieldArray.getCount ();
[+] 		size_t count = m_memberFieldArray.getCount();
[-] 			StructField* field = m_memberFieldArray [i];
[+] 			StructField* field = m_memberFieldArray[i];
[-] 			Type* type = field->getType ();
[+] 			Type* type = field->getType();
[-] 			uint_t fieldTypeFlags = type->getFlags ();
[+] 			uint_t fieldTypeFlags = type->getFlags();
[-] 				m_gcRootMemberFieldArray.append (field);
[+] 				m_gcRootMemberFieldArray.append(field);
[-] 			if ((type->getTypeKindFlags () & TypeKindFlag_Derivable) && ((DerivableType*) type)->getConstructor ())
[+] 			if ((type->getTypeKindFlags() & TypeKindFlag_Derivable) && ((DerivableType*)type)->getConstructor())
[-] 				m_memberFieldConstructArray.append (field);
[+] 				m_memberFieldConstructArray.append(field);
[-] 		count = m_memberPropertyArray.getCount ();
[+] 		count = m_memberPropertyArray.getCount();
[-] 			Property* prop = m_memberPropertyArray [i];
[+] 			Property* prop = m_memberPropertyArray[i];
[-] 			result = prop->ensureLayout ();
[+] 			result = prop->ensureLayout();
[-] 			if (prop->getConstructor ())
[+] 			if (prop->getConstructor())
[-] 				m_memberPropertyConstructArray.append (prop);
[+] 				m_memberPropertyConstructArray.append(prop);
[-] 		if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty ())
[+] 		if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty())
[-] 			result = createDefaultMethod (FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[+] 			result = createDefaultMethod(FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[-] 			!m_baseTypeConstructArray.isEmpty () ||
[+] 			!m_baseTypeConstructArray.isEmpty() ||
[-] 			!m_memberFieldConstructArray.isEmpty () ||
[+] 			!m_memberFieldConstructArray.isEmpty() ||
[-] 			!m_initializedMemberFieldArray.isEmpty () ||
[+] 			!m_initializedMemberFieldArray.isEmpty() ||
[-] 			!m_memberPropertyConstructArray.isEmpty ()))
[+] 			!m_memberPropertyConstructArray.isEmpty()))
[-] 			result = createDefaultMethod (FunctionKind_Constructor) != NULL;
[+] 			result = createDefaultMethod(FunctionKind_Constructor) != NULL;
[-] 		(((ClassType*) m_parentNamespace)->getFlags () & ClassTypeFlag_Opaque) &&
[+] 		(((ClassType*)m_parentNamespace)->getFlags() & ClassTypeFlag_Opaque) &&
[-] 		!(m_module->getCompileFlags () & ModuleCompileFlag_IgnoreOpaqueClassTypeInfo)
[+] 		!(m_module->getCompileFlags() & ModuleCompileFlag_IgnoreOpaqueClassTypeInfo)
[-] 		ClassType* classType = (ClassType*) m_parentNamespace;
[+] 		ClassType* classType = (ClassType*)m_parentNamespace;
[-] 		const OpaqueClassTypeInfo* typeInfo = m_module->m_extensionLibMgr.findOpaqueClassTypeInfo (classType->getQualifiedName ());
[+] 		const OpaqueClassTypeInfo* typeInfo = m_module->m_extensionLibMgr.findOpaqueClassTypeInfo(classType->getQualifiedName());
[-] 			err::setFormatStringError ("opaque class type info is missing for '%s'", classType->getTypeString ().sz ());
[+] 			err::setFormatStringError("opaque class type info is missing for '%s'", classType->getTypeString ().sz ());
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				getTypeString ().sz (),
[+] 				getTypeString().sz(),
[-] 			ArrayType* opaqueDataType = m_module->m_typeMgr.getArrayType (
[+] 			ArrayType* opaqueDataType = m_module->m_typeMgr.getArrayType(
[-] 				m_module->m_typeMgr.getPrimitiveType (TypeKind_Char),
[+] 				m_module->m_typeMgr.getPrimitiveType(TypeKind_Char),
[-] 			StructField* field = createField (opaqueDataType);
[+] 			StructField* field = createField(opaqueDataType);
[-] 			result = layoutField (field);
[+] 			result = layoutField(field);
[-] 			ASSERT (result);
[+] 			ASSERT(result);
[-] 		m_module->m_typeMgr.getStdType (StdType_DynamicLayout); // ensure jnc.DynamicLayout is present
[+] 		m_module->m_typeMgr.getStdType(StdType_DynamicLayout); // ensure jnc.DynamicLayout is present
[-] 		llvm::StructType* llvmStructType = (llvm::StructType*) getLlvmType ();
[+] 		llvm::StructType* llvmStructType = (llvm::StructType*)getLlvmType();
[-] 		llvmStructType->setBody (
[+] 		llvmStructType->setBody(
[-] 			llvm::ArrayRef <llvm::Type*> (m_llvmFieldTypeArray, m_llvmFieldTypeArray.getCount ()),
[+] 			llvm::ArrayRef<llvm::Type*> (m_llvmFieldTypeArray, m_llvmFieldTypeArray.getCount()),
[-] StructType::compile ()
[+] StructType::compile()
[-] 	if (m_staticConstructor && !(m_staticConstructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_staticConstructor && !(m_staticConstructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultStaticConstructor ();
[+] 		result = compileDefaultStaticConstructor();
[-] 	if (m_constructor && !(m_constructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_constructor && !(m_constructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultConstructor ();
[+] 		result = compileDefaultConstructor();
[-] StructType::layoutField (StructField* field)
[+] StructType::layoutField(StructField* field)
[-] 	if (m_structTypeKind != StructTypeKind_IfaceStruct && field->m_type->getTypeKind () == TypeKind_Class)
[+] 	if (m_structTypeKind != StructTypeKind_IfaceStruct && field->m_type->getTypeKind() == TypeKind_Class)
[-] 		err::setFormatStringError ("class '%s' cannot be a struct member", field->m_type->getTypeString ().sz ());
[+] 		err::setFormatStringError("class '%s' cannot be a struct member", field->m_type->getTypeString ().sz ());
[-] 		field->pushSrcPosError ();
[+] 		field->pushSrcPosError();
[-] 	if ((m_flags & TypeFlag_Dynamic) && field->m_type->getTypeKind () == TypeKind_Array)
[+] 	if ((m_flags & TypeFlag_Dynamic) && field->m_type->getTypeKind() == TypeKind_Array)
[-] 		result = ((ArrayType*) field->m_type)->ensureDynamicLayout (this, field);
[+] 		result = ((ArrayType*)field->m_type)->ensureDynamicLayout(this, field);
[-] 		result = field->m_type->ensureLayout ();
[+] 		result = field->m_type->ensureLayout();
[-] 		layoutBitField (
[+] 		layoutBitField(
[-] 		layoutField (
[+] 		layoutField(
[-] 		field->m_prevDynamicFieldIndex = m_dynamicFieldArray.getCount () - 1;
[+] 		field->m_prevDynamicFieldIndex = m_dynamicFieldArray.getCount() - 1;
[-] 		if (field->m_type->getFlags () & TypeFlag_Dynamic)
[+] 		if (field->m_type->getFlags() & TypeFlag_Dynamic)
[-] 			m_dynamicFieldArray.append (field);
[+] 			m_dynamicFieldArray.append(field);
[-] 	else if (field->m_type->getFlags () & TypeFlag_Dynamic)
[+] 	else if (field->m_type->getFlags() & TypeFlag_Dynamic)
[-] 		err::setFormatStringError ("dynamic '%s' cannot be a struct member", field->m_type->getTypeString ().sz ());
[+] 		err::setFormatStringError("dynamic '%s' cannot be a struct member", field->m_type->getTypeString ().sz ());
[-] 		field->pushSrcPosError ();
[+] 		field->pushSrcPosError();
[-] StructType::layoutField (
[+] StructType::layoutField(
[-] 		m_alignment = AXL_MIN (alignment, m_fieldAlignment);
[+] 		m_alignment = AXL_MIN(alignment, m_fieldAlignment);
[-] 	size_t offset = getFieldOffset (alignment);
[+] 	size_t offset = getFieldOffset(alignment);
[-] 		insertPadding (offset - m_fieldActualSize);
[+] 		insertPadding(offset - m_fieldActualSize);
[-] 		*llvmIndex = (uint_t) m_llvmFieldTypeArray.getCount ();
[+] 		*llvmIndex = (uint_t)m_llvmFieldTypeArray.getCount();
[-] 		m_llvmFieldTypeArray.append (llvmType);
[+] 		m_llvmFieldTypeArray.append(llvmType);
[-] 	setFieldActualSize (offset + size);
[+] 	setFieldActualSize(offset + size);
[-] StructType::layoutBitField (
[+] StructType::layoutBitField(
[-] 	size_t baseBitCount = baseType->getSize () * 8;
[+] 	size_t baseBitCount = baseType->getSize() * 8;
[-] 		err::setFormatStringError ("type of bit field too small for number of bits");
[+] 		err::setFormatStringError("type of bit field too small for number of bits");
[-] 	bool isMerged = m_lastBitFieldType && m_lastBitFieldType->getBaseType ()->cmp (baseType) == 0;
[+] 	bool isMerged = m_lastBitFieldType && m_lastBitFieldType->getBaseType()->cmp(baseType) == 0;
[-] 	if (baseType->getTypeKindFlags () & TypeKindFlag_BigEndian)
[+] 	if (baseType->getTypeKindFlags() & TypeKindFlag_BigEndian)
[-] 			size_t lastBitOffset = m_lastBitFieldType->getBitOffset ();
[+] 			size_t lastBitOffset = m_lastBitFieldType->getBitOffset();
[-] 			size_t lastBitOffset = m_lastBitFieldType->getBitOffset () + m_lastBitFieldType->getBitCount ();
[+] 			size_t lastBitOffset = m_lastBitFieldType->getBitOffset() + m_lastBitFieldType->getBitCount();
[-] 	BitFieldType* type = m_module->m_typeMgr.getBitFieldType (baseType, bitOffset, bitCount);
[+] 	BitFieldType* type = m_module->m_typeMgr.getBitFieldType(baseType, bitOffset, bitCount);
[-] 		*llvmIndex = (uint_t) m_llvmFieldTypeArray.getCount () - 1;
[+] 		*llvmIndex = (uint_t)m_llvmFieldTypeArray.getCount() - 1;
[-] 	size_t alignment = type->getAlignment ();
[+] 	size_t alignment = type->getAlignment();
[-] 		m_alignment = AXL_MIN (alignment, m_fieldAlignment);
[+] 		m_alignment = AXL_MIN(alignment, m_fieldAlignment);
[-] 	size_t offset = getFieldOffset (alignment);
[+] 	size_t offset = getFieldOffset(alignment);
[-] 		insertPadding (offset - m_fieldActualSize);
[+] 		insertPadding(offset - m_fieldActualSize);
[-] 		*llvmIndex = (uint_t) m_llvmFieldTypeArray.getCount ();
[+] 		*llvmIndex = (uint_t)m_llvmFieldTypeArray.getCount();
[-] 		m_llvmFieldTypeArray.append (type->getLlvmType ());
[+] 		m_llvmFieldTypeArray.append(type->getLlvmType());
[-] 	setFieldActualSize (offset + type->getSize ());
[+] 	setFieldActualSize(offset + type->getSize());
[-] StructType::getFieldOffset (size_t alignment)
[+] StructType::getFieldOffset(size_t alignment)
[-] StructType::setFieldActualSize (size_t size)
[+] StructType::setFieldActualSize(size_t size)
[-] StructType::insertPadding (size_t size)
[+] StructType::insertPadding(size_t size)
[-] 	ArrayType* type = m_module->m_typeMgr.getArrayType (m_module->m_typeMgr.getPrimitiveType (TypeKind_Char), size);
[+] 	ArrayType* type = m_module->m_typeMgr.getArrayType(m_module->m_typeMgr.getPrimitiveType(TypeKind_Char), size);
[-] 	m_llvmFieldTypeArray.append (type->getLlvmType ());
[+] 	m_llvmFieldTypeArray.append(type->getLlvmType());
[-] StructType::prepareLlvmDiType ()
[+] StructType::prepareLlvmDiType()
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createEmptyStructType (this);
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createEmptyStructType(this);
[-] 	m_module->m_llvmDiBuilder.setStructTypeBody (this);
[+] 	m_module->m_llvmDiBuilder.setStructTypeBody(this);
[-] StructType::markGcRoots (
[+] StructType::markGcRoots(
[-] 	char* p = (char*) _p;
[+] 	char* p = (char*)_p;
[-] 	size_t count = m_gcRootBaseTypeArray.getCount ();
[+] 	size_t count = m_gcRootBaseTypeArray.getCount();
[-] 		BaseTypeSlot* slot = m_gcRootBaseTypeArray [i];
[+] 		BaseTypeSlot* slot = m_gcRootBaseTypeArray[i];
[-] 		slot->getType ()->markGcRoots (p + slot->getOffset (), gcHeap);
[+] 		slot->getType()->markGcRoots(p + slot->getOffset(), gcHeap);
[-] 	count = m_gcRootMemberFieldArray.getCount ();
[+] 	count = m_gcRootMemberFieldArray.getCount();
[-] 		StructField* field = m_gcRootMemberFieldArray [i];
[+] 		StructField* field = m_gcRootMemberFieldArray[i];
[-] 		field->getType ()->markGcRoots (p + field->getOffset (), gcHeap);
[+] 		field->getType()->markGcRoots(p + field->getOffset(), gcHeap);
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_Type.cpp
----------------------
[-] getInt32TypeKind (int32_t integer)
[+] getInt32TypeKind(int32_t integer)
[-] 		(uint32_t) integer <= UINT8_MAX ? TypeKind_Int8_u :
[+] 		(uint32_t)integer <= UINT8_MAX ? TypeKind_Int8_u :
[-] 		(uint32_t) integer <= UINT16_MAX ? TypeKind_Int16_u : TypeKind_Int32;
[+] 		(uint32_t)integer <= UINT16_MAX ? TypeKind_Int16_u : TypeKind_Int32;
[-] getInt32TypeKind_u (uint32_t integer)
[+] getInt32TypeKind_u(uint32_t integer)
[-] getInt64TypeKind (int64_t integer)
[+] getInt64TypeKind(int64_t integer)
[-] 		(uint64_t) integer <= UINT8_MAX ? TypeKind_Int8_u :
[+] 		(uint64_t)integer <= UINT8_MAX ? TypeKind_Int8_u :
[-] 		(uint64_t) integer <= UINT16_MAX ? TypeKind_Int16_u :
[+] 		(uint64_t)integer <= UINT16_MAX ? TypeKind_Int16_u :
[-] 		(uint64_t) integer <= UINT32_MAX ? TypeKind_Int32_u : TypeKind_Int64;
[+] 		(uint64_t)integer <= UINT32_MAX ? TypeKind_Int32_u : TypeKind_Int64;
[-] getInt64TypeKind_u (uint64_t integer)
[+] getInt64TypeKind_u(uint64_t integer)
[-] getLlvmTypeString (llvm::Type* llvmType)
[+] getLlvmTypeString(llvm::Type* llvmType)
[-] 	llvm::raw_string_ostream stream (s);
[+] 	llvm::raw_string_ostream stream(s);
[-] 	llvmType->print (stream);
[+] 	llvmType->print(stream);
[-] 	return stream.str ().c_str ();
[+] 	return stream.str().c_str();
[-] getPtrTypeFlagString (PtrTypeFlag flag)
[+] getPtrTypeFlagString(PtrTypeFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag >> 12);
[+] 	size_t i = sl::getLoBitIdx32(flag >> 12);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getPtrTypeFlagString (uint_t flags)
[+] getPtrTypeFlagString(uint_t flags)
[-] 	if (!string.isEmpty ())
[+] 	if (!string.isEmpty())
[-] 		string.chop (1);
[+] 		string.chop(1);
[-] getPtrTypeFlagSignature (uint_t flags)
[+] getPtrTypeFlagSignature(uint_t flags)
[-] getPtrTypeFlagsFromModifiers (uint_t modifiers)
[+] getPtrTypeFlagsFromModifiers(uint_t modifiers)
[-] Type::Type ()
[+] Type::Type()
[-] Type::~Type ()
[+] Type::~Type()
[-] 		AXL_MEM_DELETE (m_typeStringTuple);
[+] 		AXL_MEM_DELETE(m_typeStringTuple);
[-] Type::getTypeStringTuple ()
[+] Type::getTypeStringTuple()
[-] 		m_typeStringTuple = AXL_MEM_NEW (TypeStringTuple);
[+] 		m_typeStringTuple = AXL_MEM_NEW(TypeStringTuple);
[-] Type::getTypeString ()
[+] Type::getTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (!tuple->m_typeString.isEmpty ())
[+] 	if (!tuple->m_typeString.isEmpty())
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	ASSERT (!tuple->m_typeStringPrefix.isEmpty ());
[+] 	ASSERT(!tuple->m_typeStringPrefix.isEmpty());
[-] 	if (!tuple->m_typeStringSuffix.isEmpty ())
[+] 	if (!tuple->m_typeStringSuffix.isEmpty())
[-] Type::getTypeStringPrefix ()
[+] Type::getTypeStringPrefix()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (tuple->m_typeStringPrefix.isEmpty ())
[+] 	if (tuple->m_typeStringPrefix.isEmpty())
[-] 		prepareTypeString ();
[+] 		prepareTypeString();
[-] 		ASSERT (!tuple->m_typeStringPrefix.isEmpty ());
[+] 		ASSERT(!tuple->m_typeStringPrefix.isEmpty());
[-] Type::getTypeStringSuffix ()
[+] Type::getTypeStringSuffix()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (tuple->m_typeStringPrefix.isEmpty ()) // this is not a typo, we still need to check prefix string!
[+] 	if (tuple->m_typeStringPrefix.isEmpty()) // this is not a typo, we still need to check prefix string!
[-] 		prepareTypeString ();
[+] 		prepareTypeString();
[-] 		ASSERT (!tuple->m_typeStringPrefix.isEmpty ());
[+] 		ASSERT(!tuple->m_typeStringPrefix.isEmpty());
[-] Type::getDoxyTypeString ()
[+] Type::getDoxyTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (tuple->m_doxyTypeString.isEmpty ())
[+] 	if (tuple->m_doxyTypeString.isEmpty())
[-] 		prepareDoxyTypeString ();
[+] 		prepareDoxyTypeString();
[-] 		ASSERT (!tuple->m_doxyTypeString.isEmpty ());
[+] 		ASSERT(!tuple->m_doxyTypeString.isEmpty());
[-] Type::getDoxyLinkedTextPrefix ()
[+] Type::getDoxyLinkedTextPrefix()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (tuple->m_doxyLinkedTextPrefix.isEmpty ())
[+] 	if (tuple->m_doxyLinkedTextPrefix.isEmpty())
[-] 		prepareDoxyLinkedText ();
[+] 		prepareDoxyLinkedText();
[-] 		ASSERT (!tuple->m_doxyLinkedTextPrefix.isEmpty ());
[+] 		ASSERT(!tuple->m_doxyLinkedTextPrefix.isEmpty());
[-] Type::getDoxyLinkedTextSuffix ()
[+] Type::getDoxyLinkedTextSuffix()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	if (tuple->m_doxyLinkedTextPrefix.isEmpty ()) // this is not a typo, we still need to check prefix string!
[+] 	if (tuple->m_doxyLinkedTextPrefix.isEmpty()) // this is not a typo, we still need to check prefix string!
[-] 		prepareDoxyLinkedText ();
[+] 		prepareDoxyLinkedText();
[-] 		ASSERT (!tuple->m_doxyLinkedTextPrefix.isEmpty ());
[+] 		ASSERT(!tuple->m_doxyLinkedTextPrefix.isEmpty());
[-] Type::getLlvmType ()
[+] Type::getLlvmType()
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	ASSERT (m_llvmType);
[+] 	ASSERT(m_llvmType);
[-] Type::getLlvmDiType ()
[+] Type::getLlvmDiType()
[-] 		return llvm::DIType_vn ();
[+] 		return llvm::DIType_vn();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	ASSERT (m_llvmDiType);
[+] 	ASSERT(m_llvmDiType);
[-] Type::getUndefValue ()
[+] Type::getUndefValue()
[-] 	llvm::Value* llvmValue = llvm::UndefValue::get (getLlvmType ());
[+] 	llvm::Value* llvmValue = llvm::UndefValue::get(getLlvmType());
[-] 	return Value (llvmValue, this);
[+] 	return Value(llvmValue, this);
[-] Type::getZeroValue ()
[+] Type::getZeroValue()
[-] 	AXL_TODO ("Type::getZeroValue () probably should return ValueKind_Const")
[+] 	AXL_TODO("Type::getZeroValue () probably should return ValueKind_Const")
[-] 	llvm::Value* llvmValue = llvm::Constant::getNullValue (getLlvmType ());
[+] 	llvm::Value* llvmValue = llvm::Constant::getNullValue(getLlvmType());
[-] 	return Value (llvmValue, this);
[+] 	return Value(llvmValue, this);
[-] Type::getErrorCodeValue ()
[+] Type::getErrorCodeValue()
[-] 	uint_t typeKindFlags = getTypeKindFlags ();
[+] 	uint_t typeKindFlags = getTypeKindFlags();
[-] 	ASSERT (typeKindFlags & TypeKindFlag_ErrorCode);
[+] 	ASSERT(typeKindFlags & TypeKindFlag_ErrorCode);
[-] 		return getZeroValue ();
[+] 		return getZeroValue();
[-] 	errorCodeValue.createConst (&minusOne, this);
[+] 	errorCodeValue.createConst(&minusOne, this);
[-] Type::getArrayType (size_t elementCount)
[+] Type::getArrayType(size_t elementCount)
[-] 	return m_module->m_typeMgr.getArrayType (this, elementCount);
[+] 	return m_module->m_typeMgr.getArrayType(this, elementCount);
[-] Type::getDataPtrType (
[+] Type::getDataPtrType(
[-] 	return m_module->m_typeMgr.getDataPtrType (this, typeKind, ptrTypeKind, flags);
[+] 	return m_module->m_typeMgr.getDataPtrType(this, typeKind, ptrTypeKind, flags);
[-] Type::getSimpleFunctionArg (uint_t ptrTypeFlags)
[+] Type::getSimpleFunctionArg(uint_t ptrTypeFlags)
[-] 	return m_module->m_typeMgr.getSimpleFunctionArg (this, ptrTypeFlags);
[+] 	return m_module->m_typeMgr.getSimpleFunctionArg(this, ptrTypeFlags);
[-] Type::prepareTypeString ()
[+] Type::prepareTypeString()
[-] 	static const char* stringTable [TypeKind__PrimitiveTypeCount] =
[+] 	static const char* stringTable[TypeKind__PrimitiveTypeCount] =
[-] 	ASSERT (m_typeKind < TypeKind__PrimitiveTypeCount);
[+] 	ASSERT(m_typeKind < TypeKind__PrimitiveTypeCount);
[-] 	getTypeStringTuple ()->m_typeStringPrefix = stringTable [m_typeKind];
[+] 	getTypeStringTuple()->m_typeStringPrefix = stringTable[m_typeKind];
[-] Type::prepareDoxyLinkedText ()
[+] Type::prepareDoxyLinkedText()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyLinkedTextPrefix = getTypeStringPrefix ();
[+] 	tuple->m_doxyLinkedTextPrefix = getTypeStringPrefix();
[-] 	tuple->m_doxyLinkedTextSuffix = getTypeStringSuffix ();
[+] 	tuple->m_doxyLinkedTextSuffix = getTypeStringSuffix();
[-] Type::prepareDoxyTypeString ()
[+] Type::prepareDoxyTypeString()
[-] 	TypeStringTuple* tuple = getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = getTypeStringTuple();
[-] 	tuple->m_doxyTypeString += getDoxyLinkedTextPrefix ();
[+] 	tuple->m_doxyTypeString += getDoxyLinkedTextPrefix();
[-] 	AXL_TODO ("add compile-option for whether to use doxy-linked-text instead of plain-text")
[+] 	AXL_TODO("add compile-option for whether to use doxy-linked-text instead of plain-text")
[-] 	sl::String suffix = getTypeStringSuffix ();
[+] 	sl::String suffix = getTypeStringSuffix();
[-] 	if (!suffix.isEmpty ()) // suffix should be ready by now
[+] 	if (!suffix.isEmpty()) // suffix should be ready by now
[-] Type::prepareLlvmType ()
[+] Type::prepareLlvmType()
[-] 	ASSERT (m_typeKind < TypeKind__PrimitiveTypeCount);
[+] 	ASSERT(m_typeKind < TypeKind__PrimitiveTypeCount);
[-] 	switch (m_typeKind)
[+] 	switch(m_typeKind)
[-] 		m_llvmType = llvm::Type::getVoidTy (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getVoidTy(*m_module->getLlvmContext());
[-] 		m_llvmType = m_module->m_typeMgr.getStdType (StdType_VariantStruct)->getLlvmType ();
[+] 		m_llvmType = m_module->m_typeMgr.getStdType(StdType_VariantStruct)->getLlvmType();
[-] 		m_llvmType = llvm::Type::getInt1Ty (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getInt1Ty(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getInt8Ty (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getInt8Ty(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getInt16Ty (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getInt16Ty(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getInt32Ty (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getInt32Ty(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getInt64Ty (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getInt64Ty(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getFloatTy (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getFloatTy(*m_module->getLlvmContext());
[-] 		m_llvmType = llvm::Type::getDoubleTy (*m_module->getLlvmContext ());
[+] 		m_llvmType = llvm::Type::getDoubleTy(*m_module->getLlvmContext());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Type::prepareLlvmDiType ()
[+] Type::prepareLlvmDiType()
[-] 	ASSERT (m_typeKind < TypeKind__PrimitiveTypeCount);
[+] 	ASSERT(m_typeKind < TypeKind__PrimitiveTypeCount);
[-] 		m_llvmDiType = m_module->m_typeMgr.getStdType (StdType_VariantStruct)->getLlvmDiType ();
[+] 		m_llvmDiType = m_module->m_typeMgr.getStdType(StdType_VariantStruct)->getLlvmDiType();
[-] 	LlvmDiType llvmDiTypeTable [TypeKind__PrimitiveTypeCount] =
[+] 	LlvmDiType llvmDiTypeTable[TypeKind__PrimitiveTypeCount] =
[-] 	LlvmDiType* diType = &llvmDiTypeTable [m_typeKind];
[+] 	LlvmDiType* diType = &llvmDiTypeTable[m_typeKind];
[-] 	ASSERT (diType->m_size);
[+] 	ASSERT(diType->m_size);
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createBasicType (
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createBasicType(
[-] Type::markGcRoots (
[+] Type::markGcRoots(
[-] 	ASSERT (m_typeKind == TypeKind_Variant);
[+] 	ASSERT(m_typeKind == TypeKind_Variant);
[-] 	Variant* variant = (Variant*) p;
[+] 	Variant* variant = (Variant*)p;
[-] 		variant->m_type->markGcRoots (p, gcHeap);
[+] 		variant->m_type->markGcRoots(p, gcHeap);
[-] NamedType::prepareDoxyLinkedText ()
[+] NamedType::prepareDoxyLinkedText()
[-] 	if (!m_parentUnit || m_parentUnit->getLib ()) // don't reference imported libraries
[+] 	if (!m_parentUnit || m_parentUnit->getLib()) // don't reference imported libraries
[-] 		Type::prepareDoxyLinkedText ();
[+] 		Type::prepareDoxyLinkedText();
[-] 	sl::String refId = getDoxyBlock ()->getRefId ();
[+] 	sl::String refId = getDoxyBlock()->getRefId();
[-] 	getTypeStringTuple ()->m_doxyLinkedTextPrefix.format ("<ref refid=\"%s\">%s</ref>", refId.sz (), m_tag.sz ());
[+] 	getTypeStringTuple()->m_doxyLinkedTextPrefix.format("<ref refid=\"%s\">%s</ref>", refId.sz (), m_tag.sz ());
[-] Typedef::Typedef ()
[+] Typedef::Typedef()
[-] Typedef::getShadowType ()
[+] Typedef::getShadowType()
[-] 		m_shadowType = m_module->m_typeMgr.createTypedefShadowType (this);
[+] 		m_shadowType = m_module->m_typeMgr.createTypedefShadowType(this);
[-] Typedef::generateDocumentation (
[+] Typedef::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	itemXml->format (
[+] 	itemXml->format(
[-] 		doxyBlock->getRefId ().sz (),
[+] 		doxyBlock->getRefId().sz(),
[-] 		m_name.sz ()
[+] 		m_name.sz()
[-] 	itemXml->append (m_type->getDoxyTypeString ());
[+] 	itemXml->append(m_type->getDoxyTypeString());
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
[-] TypedefShadowType::prepareDoxyLinkedText ()
[+] TypedefShadowType::prepareDoxyLinkedText()
[-] 	Unit* unit = m_typedef->getParentUnit ();
[+] 	Unit* unit = m_typedef->getParentUnit();
[-] 	if (!unit || unit->getLib ()) // don't reference imported libraries
[+] 	if (!unit || unit->getLib()) // don't reference imported libraries
[-] 		Type::prepareDoxyLinkedText ();
[+] 		Type::prepareDoxyLinkedText();
[-] 	sl::String refId = m_typedef->getDoxyBlock ()->getRefId ();
[+] 	sl::String refId = m_typedef->getDoxyBlock()->getRefId();
[-] 	getTypeStringTuple ()->m_doxyLinkedTextPrefix.format ("<ref refid=\"%s\">%s</ref>", refId.sz (), m_tag.sz ());
[+] 	getTypeStringTuple()->m_doxyLinkedTextPrefix.format("<ref refid=\"%s\">%s</ref>", refId.sz (), m_tag.sz ());
[-] TypedefShadowType::calcLayout ()
[+] TypedefShadowType::calcLayout()
[-] 	Type* type = m_typedef->getType ();
[+] 	Type* type = m_typedef->getType();
[-] 	m_size = type->getSize ();
[+] 	m_size = type->getSize();
[-] 	m_alignment = type->getAlignment ();
[+] 	m_alignment = type->getAlignment();
[-] 	m_signature = type->getSignature ();
[+] 	m_signature = type->getSignature();
[-] getSimpleType (
[+] getSimpleType(
[-] 	return module->m_typeMgr.getPrimitiveType (typeKind);
[+] 	return module->m_typeMgr.getPrimitiveType(typeKind);
[-] getSimpleType (
[+] getSimpleType(
[-] 	return module->m_typeMgr.getStdType (stdType);
[+] 	return module->m_typeMgr.getStdType(stdType);
[-] getModuleItemType (ModuleItem* item)
[+] getModuleItemType(ModuleItem* item)
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		return (Type*) item;
[+] 		return (Type*)item;
[-] 		return ((Typedef*) item)->getType ();
[+] 		return ((Typedef*)item)->getType();
[-] 		return ((Alias*) item)->getType ();
[+] 		return ((Alias*)item)->getType();
[-] 		return ((Variable*) item)->getType ();
[+] 		return ((Variable*)item)->getType();
[-] 		return ((FunctionArg*) item)->getType ();
[+] 		return ((FunctionArg*)item)->getType();
[-] 		return ((Function*) item)->getType ();
[+] 		return ((Function*)item)->getType();
[-] 		return ((Property*) item)->getType ();
[+] 		return ((Property*)item)->getType();
[-] 		return ((EnumConst*) item)->getParentEnumType ();
[+] 		return ((EnumConst*)item)->getParentEnumType();
[-] 		return ((StructField*) item)->getType ();
[+] 		return ((StructField*)item)->getType();
[-] getDirectRefType (
[+] getDirectRefType(
[-] 	return type->getTypeKind () == TypeKind_Class ?
[+] 	return type->getTypeKind() == TypeKind_Class ?
[-] 		(Type*) ((ClassType*) type)->getClassPtrType (
[+] 		(Type*)((ClassType*)type)->getClassPtrType(
[-] 		(Type*) type->getDataPtrType (
[+] 		(Type*)type->getDataPtrType(
[-] isDisposableType (Type* type)
[+] isDisposableType(Type* type)
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_ClassPtr)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_ClassPtr)
[-] 		type = ((ClassPtrType*) type)->getTargetType ();
[+] 		type = ((ClassPtrType*)type)->getTargetType();
[-] 	else if (type->getTypeKindFlags () & TypeKindFlag_DataPtr)
[+] 	else if (type->getTypeKindFlags() & TypeKindFlag_DataPtr)
[-] 		type = ((DataPtrType*) type)->getTargetType ();
[+] 		type = ((DataPtrType*)type)->getTargetType();
[-] 	if (!(type->getTypeKindFlags () & TypeKindFlag_Derivable))
[+] 	if (!(type->getTypeKindFlags() & TypeKindFlag_Derivable))
[-] 	DerivableType* derivableType = (DerivableType*) type;
[+] 	DerivableType* derivableType = (DerivableType*)type;
[-] 	ModuleItem* item = derivableType->findItem ("dispose");
[+] 	ModuleItem* item = derivableType->findItem("dispose");
[-] 	ModuleItemKind itemKind = item->getItemKind ();
[+] 	ModuleItemKind itemKind = item->getItemKind();
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		functionType = ((Function*) item)->getType ();
[+] 		functionType = ((Function*)item)->getType();
[-] 		functionType = (FunctionType*) ((Alias*) item)->getType ();
[+] 		functionType = (FunctionType*)((Alias*)item)->getType();
[-] 		if (functionType->getTypeKind () != TypeKind_Function)
[+] 		if (functionType->getTypeKind() != TypeKind_Function)
[-] 			if (functionType->getTypeKind () == TypeKind_Void)
[+] 			if (functionType->getTypeKind() == TypeKind_Void)
[-] 	AXL_TODO ("double-check function type - must be thiscall, no arguments")
[+] 	AXL_TODO("double-check function type - must be thiscall, no arguments")
[-] isSafePtrType (Type* type)
[+] isSafePtrType(Type* type)
[-] 		(type->getTypeKindFlags () & TypeKindFlag_Ptr) &&
[+] 		(type->getTypeKindFlags() & TypeKindFlag_Ptr) &&
[-] 		(type->getFlags () & PtrTypeFlag_Safe);
[+] 		(type->getFlags() & PtrTypeFlag_Safe);
[-] isWeakPtrType (Type* type)
[+] isWeakPtrType(Type* type)
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return ((ClassPtrType*) type)->getPtrTypeKind () == ClassPtrTypeKind_Weak;
[+] 		return ((ClassPtrType*)type)->getPtrTypeKind() == ClassPtrTypeKind_Weak;
[-] 		return ((FunctionPtrType*) type)->getPtrTypeKind () == FunctionPtrTypeKind_Weak;
[+] 		return ((FunctionPtrType*)type)->getPtrTypeKind() == FunctionPtrTypeKind_Weak;
[-] 		return ((PropertyPtrType*) type)->getPtrTypeKind () == PropertyPtrTypeKind_Weak;
[+] 		return ((PropertyPtrType*)type)->getPtrTypeKind() == PropertyPtrTypeKind_Weak;
[-] getWeakPtrType (Type* type)
[+] getWeakPtrType(Type* type)
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return ((ClassPtrType*) type)->getWeakPtrType ();
[+] 		return ((ClassPtrType*)type)->getWeakPtrType();
[-] 		return ((FunctionPtrType*) type)->getWeakPtrType ();
[+] 		return ((FunctionPtrType*)type)->getWeakPtrType();
[-] 		return ((PropertyPtrType*) type)->getWeakPtrType ();
[+] 		return ((PropertyPtrType*)type)->getWeakPtrType();
----------------------
27/02/2019 18:02:14 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_TypeMgr.cpp
----------------------
[-] TypeMgr::TypeMgr ()
[+] TypeMgr::TypeMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 	setupAllPrimitiveTypes ();
[+] 	setupAllPrimitiveTypes();
[-] 	setupStdTypedefArray ();
[+] 	setupStdTypedefArray();
[-] 	setupCallConvArray ();
[+] 	setupCallConvArray();
[-] 	memset (m_stdTypeArray, 0, sizeof (m_stdTypeArray));
[+] 	memset(m_stdTypeArray, 0, sizeof(m_stdTypeArray));
[-] 	memset (m_lazyStdTypeArray, 0, sizeof (m_lazyStdTypeArray));
[+] 	memset(m_lazyStdTypeArray, 0, sizeof(m_lazyStdTypeArray));
[-] TypeMgr::clear ()
[+] TypeMgr::clear()
[-] 	m_arrayTypeList.clear ();
[+] 	m_arrayTypeList.clear();
[-] 	m_bitFieldTypeList.clear ();
[+] 	m_bitFieldTypeList.clear();
[-] 	m_enumTypeList.clear ();
[+] 	m_enumTypeList.clear();
[-] 	m_structTypeList.clear ();
[+] 	m_structTypeList.clear();
[-] 	m_unionTypeList.clear ();
[+] 	m_unionTypeList.clear();
[-] 	m_classTypeList.clear ();
[+] 	m_classTypeList.clear();
[-] 	m_functionTypeList.clear ();
[+] 	m_functionTypeList.clear();
[-] 	m_propertyTypeList.clear ();
[+] 	m_propertyTypeList.clear();
[-] 	m_dataPtrTypeList.clear ();
[+] 	m_dataPtrTypeList.clear();
[-] 	m_classPtrTypeList.clear ();
[+] 	m_classPtrTypeList.clear();
[-] 	m_functionPtrTypeList.clear ();
[+] 	m_functionPtrTypeList.clear();
[-] 	m_propertyPtrTypeList.clear ();
[+] 	m_propertyPtrTypeList.clear();
[-] 	m_namedImportTypeList.clear ();
[+] 	m_namedImportTypeList.clear();
[-] 	m_importPtrTypeList.clear ();
[+] 	m_importPtrTypeList.clear();
[-] 	m_importIntModTypeList.clear ();
[+] 	m_importIntModTypeList.clear();
[-] 	m_reactorClassTypeList.clear ();
[+] 	m_reactorClassTypeList.clear();
[-] 	m_functionClosureClassTypeList.clear ();
[+] 	m_functionClosureClassTypeList.clear();
[-] 	m_propertyClosureClassTypeList.clear ();
[+] 	m_propertyClosureClassTypeList.clear();
[-] 	m_dataClosureClassTypeList.clear ();
[+] 	m_dataClosureClassTypeList.clear();
[-] 	m_multicastClassTypeList.clear ();
[+] 	m_multicastClassTypeList.clear();
[-] 	m_mcSnapshotClassTypeList.clear ();
[+] 	m_mcSnapshotClassTypeList.clear();
[-] 	m_typedefShadowTypeList.clear ();
[+] 	m_typedefShadowTypeList.clear();
[-] 	m_simplePropertyTypeTupleList.clear ();
[+] 	m_simplePropertyTypeTupleList.clear();
[-] 	m_functionArgTupleList.clear ();
[+] 	m_functionArgTupleList.clear();
[-] 	m_dataPtrTypeTupleList.clear ();
[+] 	m_dataPtrTypeTupleList.clear();
[-] 	m_classPtrTypeTupleList.clear ();
[+] 	m_classPtrTypeTupleList.clear();
[-] 	m_functionPtrTypeTupleList.clear ();
[+] 	m_functionPtrTypeTupleList.clear();
[-] 	m_propertyPtrTypeTupleList.clear ();
[+] 	m_propertyPtrTypeTupleList.clear();
[-] 	m_dualTypeTupleList.clear ();
[+] 	m_dualTypeTupleList.clear();
[-] 	m_typedefList.clear ();
[+] 	m_typedefList.clear();
[-] 	m_lazyStdTypeList.clear ();
[+] 	m_lazyStdTypeList.clear();
[-] 	m_functionArgList.clear ();
[+] 	m_functionArgList.clear();
[-] 	m_structFieldList.clear ();
[+] 	m_structFieldList.clear();
[-] 	m_typeMap.clear ();
[+] 	m_typeMap.clear();
[-] 	m_unresolvedNamedImportTypeArray.clear ();
[+] 	m_unresolvedNamedImportTypeArray.clear();
[-] 	m_unresolvedImportPtrTypeArray.clear ();
[+] 	m_unresolvedImportPtrTypeArray.clear();
[-] 	m_unresolvedImportIntModTypeArray.clear ();
[+] 	m_unresolvedImportIntModTypeArray.clear();
[-] 	setupAllPrimitiveTypes ();
[+] 	setupAllPrimitiveTypes();
[-] 	memset (m_stdTypeArray, 0, sizeof (m_stdTypeArray));
[+] 	memset(m_stdTypeArray, 0, sizeof(m_stdTypeArray));
[-] 	memset (m_lazyStdTypeArray, 0, sizeof (m_lazyStdTypeArray));
[+] 	memset(m_lazyStdTypeArray, 0, sizeof(m_lazyStdTypeArray));
[-] TypeMgr::getStdType (StdType stdType)
[+] TypeMgr::getStdType(StdType stdType)
[-] 	ASSERT ((size_t) stdType < StdType__Count);
[+] 	ASSERT((size_t)stdType < StdType__Count);
[-] 	if (m_stdTypeArray [stdType])
[+] 	if (m_stdTypeArray[stdType])
[-] 		return m_stdTypeArray [stdType];
[+] 		return m_stdTypeArray[stdType];
[-] 	switch (stdType)
[+] 	switch(stdType)
[-] 		type = getPrimitiveType (TypeKind_Int8_u)->getDataPtrType_c ();
[+] 		type = getPrimitiveType(TypeKind_Int8_u)->getDataPtrType_c();
[-] 		type = getPrimitiveType (TypeKind_Char)->getDataPtrType_c (TypeKind_DataPtr, PtrTypeFlag_Const);
[+] 		type = getPrimitiveType(TypeKind_Char)->getDataPtrType_c(TypeKind_DataPtr, PtrTypeFlag_Const);
[-] 		type = createIfaceHdrType ();
[+] 		type = createIfaceHdrType();
[-] 		type = getStdType (StdType_IfaceHdr)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_IfaceHdr)->getDataPtrType_c();
[-] 		type = createBoxType ();
[+] 		type = createBoxType();
[-] 		type = getStdType (StdType_Box)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_Box)->getDataPtrType_c();
[-] 		type = createDataBoxType ();
[+] 		type = createDataBoxType();
[-] 		type = getStdType (StdType_DataBox)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_DataBox)->getDataPtrType_c();
[-] 		type = createDynamicArrayBoxType ();
[+] 		type = createDynamicArrayBoxType();
[-] 		type = getStdType (StdType_DynamicArrayBox)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_DynamicArrayBox)->getDataPtrType_c();
[-] 		type = createStaticDataBoxType ();
[+] 		type = createStaticDataBoxType();
[-] 		type = getStdType (StdType_StaticDataBox)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_StaticDataBox)->getDataPtrType_c();
[-] 		type = createDataPtrValidatorType ();
[+] 		type = createDataPtrValidatorType();
[-] 		type = getStdType (StdType_DataPtrValidator)->getDataPtrType_c ();
[+] 		type = getStdType(StdType_DataPtrValidator)->getDataPtrType_c();
[-] 		type = createDataPtrStructType ();
[+] 		type = createDataPtrStructType();
[-] 		type = createFunctionPtrStructType ();
[+] 		type = createFunctionPtrStructType();
[-] 		type = createVariantStructType ();
[+] 		type = createVariantStructType();
[-] 		type = createGcShadowStackFrameType ();
[+] 		type = createGcShadowStackFrameType();
[-] 		type = createSjljFrameType ();
[+] 		type = createSjljFrameType();
[-] 		type = createAbstractClassType ();
[+] 		type = createAbstractClassType();
[-] 		type = ((ClassType*) getStdType (StdType_AbstractClass))->getClassPtrType ();
[+] 		type = ((ClassType*)getStdType(StdType_AbstractClass))->getClassPtrType();
[-] 		type = createAbstractDataType ();
[+] 		type = createAbstractDataType();
[-] 		type = getStdType (StdType_AbstractData)->getDataPtrType ();
[+] 		type = getStdType(StdType_AbstractData)->getDataPtrType();
[-] 		type = getFunctionType (getPrimitiveType (TypeKind_Void), NULL, 0, 0);
[+] 		type = getFunctionType(getPrimitiveType(TypeKind_Void), NULL, 0, 0);
[-] 		type = getMulticastType ((FunctionType*) getStdType (StdType_SimpleFunction));
[+] 		type = getMulticastType((FunctionType*)getStdType(StdType_SimpleFunction));
[-] 		type = ((ClassType*) getStdType (StdType_SimpleMulticast))->getClassPtrType (ClassPtrTypeKind_Normal);
[+] 		type = ((ClassType*)getStdType(StdType_SimpleMulticast))->getClassPtrType(ClassPtrTypeKind_Normal);
[-] 		type = getFunctionType (getStdType (StdType_SimpleEventPtr), NULL, 0);
[+] 		type = getFunctionType(getStdType(StdType_SimpleEventPtr), NULL, 0);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("RegexMatch");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("RegexMatch");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("RegexState");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("RegexState");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("RegexDfa");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("RegexDfa");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("Promise");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("Promise");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = ((ClassType*) getStdType (StdType_Promise))->getClassPtrType (ClassPtrTypeKind_Normal);
[+] 		type = ((ClassType*)getStdType(StdType_Promise))->getClassPtrType(ClassPtrTypeKind_Normal);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("Promisifier");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("Promisifier");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("DynamicLib");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("DynamicLib");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = (Type*) m_module->m_namespaceMgr.getStdNamespace (StdNamespace_Jnc)->findItemByName ("Scheduler");
[+] 		type = (Type*)m_module->m_namespaceMgr.getStdNamespace(StdNamespace_Jnc)->findItemByName("Scheduler");
[-] 			type = parseStdType (stdType);
[+] 			type = parseStdType(stdType);
[-] 		type = createReactorBaseType ();
[+] 		type = createReactorBaseType();
[-] 		type = createReactorClosureType ();
[+] 		type = createReactorClosureType();
[-] 		type = parseStdType (stdType);
[+] 		type = parseStdType(stdType);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	m_stdTypeArray [stdType] = type;
[+] 	m_stdTypeArray[stdType] = type;
[-] TypeMgr::getLazyStdType (StdType stdType)
[+] TypeMgr::getLazyStdType(StdType stdType)
[-] 	ASSERT ((size_t) stdType < StdType__Count);
[+] 	ASSERT((size_t)stdType < StdType__Count);
[-] 	if (m_lazyStdTypeArray [stdType])
[+] 	if (m_lazyStdTypeArray[stdType])
[-] 		return m_lazyStdTypeArray [stdType];
[+] 		return m_lazyStdTypeArray[stdType];
[-] 	LazyStdType* type = AXL_MEM_NEW (LazyStdType);
[+] 	LazyStdType* type = AXL_MEM_NEW(LazyStdType);
[-] 	m_lazyStdTypeList.insertTail (type);
[+] 	m_lazyStdTypeList.insertTail(type);
[-] 	m_lazyStdTypeArray [stdType] = type;
[+] 	m_lazyStdTypeArray[stdType] = type;
[-] pushImportSrcPosError (NamedImportType* importType)
[+] pushImportSrcPosError(NamedImportType* importType)
[-] 	lex::pushSrcPosError (
[+] 	lex::pushSrcPosError(
[-] 		importType->getParentUnit ()->getFilePath (),
[+] 		importType->getParentUnit()->getFilePath(),
[-] 		*importType->getPos ()
[+] 		*importType->getPos()
[-] TypeMgr::resolveImportTypes ()
[+] TypeMgr::resolveImportTypes()
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <NamedImportType*> superImportTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<NamedImportType*> superImportTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		!m_unresolvedNamedImportTypeArray.isEmpty () ||
[+] 		!m_unresolvedNamedImportTypeArray.isEmpty() ||
[-] 		!m_unresolvedImportPtrTypeArray.isEmpty () ||
[+] 		!m_unresolvedImportPtrTypeArray.isEmpty() ||
[-] 		!m_unresolvedImportIntModTypeArray.isEmpty ()
[+] 		!m_unresolvedImportIntModTypeArray.isEmpty()
[-] 		superImportTypeArray.clear ();
[+] 		superImportTypeArray.clear();
[-] 		sl::Array <NamedImportType*> unresolvedNamedImportTypeArray = m_unresolvedNamedImportTypeArray;
[+] 		sl::Array<NamedImportType*> unresolvedNamedImportTypeArray = m_unresolvedNamedImportTypeArray;
[-] 		sl::Array <ImportPtrType*> unresolvedImportPtrTypeArray = m_unresolvedImportPtrTypeArray;
[+] 		sl::Array<ImportPtrType*> unresolvedImportPtrTypeArray = m_unresolvedImportPtrTypeArray;
[-] 		sl::Array <ImportIntModType*> unresolvedImportIntModTypeArray = m_unresolvedImportIntModTypeArray;
[+] 		sl::Array<ImportIntModType*> unresolvedImportIntModTypeArray = m_unresolvedImportIntModTypeArray;
[-] 		m_unresolvedNamedImportTypeArray.clear ();
[+] 		m_unresolvedNamedImportTypeArray.clear();
[-] 		m_unresolvedImportIntModTypeArray.clear ();
[+] 		m_unresolvedImportIntModTypeArray.clear();
[-] 		m_unresolvedImportPtrTypeArray.clear ();
[+] 		m_unresolvedImportPtrTypeArray.clear();
[-] 		size_t count = unresolvedNamedImportTypeArray.getCount ();
[+] 		size_t count = unresolvedNamedImportTypeArray.getCount();
[-] 			NamedImportType* importType = unresolvedNamedImportTypeArray [i];
[+] 			NamedImportType* importType = unresolvedNamedImportTypeArray[i];
[-] 			if (!importType->m_anchorName.isEmpty ())
[+] 			if (!importType->m_anchorName.isEmpty())
[-] 				ModuleItem* item = anchorNamespace->findItemTraverse (importType->m_anchorName);
[+] 				ModuleItem* item = anchorNamespace->findItemTraverse(importType->m_anchorName);
[-] 				anchorNamespace = item ? item->getNamespace () : NULL;
[+] 				anchorNamespace = item ? item->getNamespace() : NULL;
[-] 			ModuleItem* item = anchorNamespace ? anchorNamespace->findItemTraverse (importType->m_name) : NULL;
[+] 			ModuleItem* item = anchorNamespace ? anchorNamespace->findItemTraverse(importType->m_name) : NULL;
[-] 				err::setFormatStringError ("unresolved import '%s'", importType->getTypeString ().sz ());
[+] 				err::setFormatStringError("unresolved import '%s'", importType->getTypeString ().sz ());
[-] 				pushImportSrcPosError (importType);
[+] 				pushImportSrcPosError(importType);
[-] 			ModuleItemKind itemKind = item->getItemKind ();
[+] 			ModuleItemKind itemKind = item->getItemKind();
[-] 			switch (itemKind)
[+] 			switch(itemKind)
[-] 				importType->m_actualType = (Type*) item;
[+] 				importType->m_actualType = (Type*)item;
[-] 				importType->m_actualType = (m_module->getCompileFlags () & ModuleCompileFlag_KeepTypedefShadow) ?
[+] 				importType->m_actualType = (m_module->getCompileFlags() & ModuleCompileFlag_KeepTypedefShadow) ?
[-] 					((Typedef*) item)->getShadowType () :
[+] 					((Typedef*)item)->getShadowType() :
[-] 					((Typedef*) item)->getType ();
[+] 					((Typedef*)item)->getType();
[-] 				if (importType->m_actualType->getTypeKind () == TypeKind_NamedImport)
[+] 				if (importType->m_actualType->getTypeKind() == TypeKind_NamedImport)
[-] 					superImportTypeArray.append (importType);
[+] 					superImportTypeArray.append(importType);
[-] 				err::setFormatStringError ("'%s' is not a type", importType->getTypeString ().sz ());
[+] 				err::setFormatStringError("'%s' is not a type", importType->getTypeString ().sz ());
[-] 				pushImportSrcPosError (importType);
[+] 				pushImportSrcPosError(importType);
[-] 			importType->applyFixups ();
[+] 			importType->applyFixups();
[-] 		count = superImportTypeArray.getCount ();
[+] 		count = superImportTypeArray.getCount();
[-] 			NamedImportType* superImportType = superImportTypeArray [i];
[+] 			NamedImportType* superImportType = superImportTypeArray[i];
[-] 				ImportType* importType = (ImportType*) type;
[+] 				ImportType* importType = (ImportType*)type;
[-] 					err::setFormatStringError ("'%s': import loop detected", importType->getTypeString ().sz ());
[+] 					err::setFormatStringError("'%s': import loop detected", importType->getTypeString ().sz ());
[-] 					pushImportSrcPosError (superImportType);
[+] 					pushImportSrcPosError(superImportType);
[-] 				ImportType* importType = (ImportType*) type;
[+] 				ImportType* importType = (ImportType*)type;
[-] 				importType->applyFixups ();
[+] 				importType->applyFixups();
[-] 		count = unresolvedImportIntModTypeArray.getCount ();
[+] 		count = unresolvedImportIntModTypeArray.getCount();
[-] 			ImportIntModType* importType = unresolvedImportIntModTypeArray [i];
[+] 			ImportIntModType* importType = unresolvedImportIntModTypeArray[i];
[-] 			Type* type = typeCalc.calcIntModType (
[+] 			Type* type = typeCalc.calcIntModType(
[-] 			importType->applyFixups ();
[+] 			importType->applyFixups();
[-] 		count = unresolvedImportPtrTypeArray.getCount ();
[+] 		count = unresolvedImportPtrTypeArray.getCount();
[-] 			ImportPtrType* importType = unresolvedImportPtrTypeArray [i];
[+] 			ImportPtrType* importType = unresolvedImportPtrTypeArray[i];
[-] 			Type* type = typeCalc.calcPtrType (
[+] 			Type* type = typeCalc.calcPtrType(
[-] 			if (importType->getFlags () & PtrTypeFlag_Safe)
[+] 			if (importType->getFlags() & PtrTypeFlag_Safe)
[-] 				type = getCheckedPtrType (type);
[+] 				type = getCheckedPtrType(type);
[-] 			importType->applyFixups ();
[+] 			importType->applyFixups();
[-] TypeMgr::updateTypeSignature (
[+] TypeMgr::updateTypeSignature(
[-] 	m_typeMap.erase (type->m_typeMapIt);
[+] 	m_typeMap.erase(type->m_typeMapIt);
[-] 	type->m_typeMapIt = m_typeMap.visit (signature);
[+] 	type->m_typeMapIt = m_typeMap.visit(signature);
[-] TypeMgr::getBitFieldType (
[+] TypeMgr::getBitFieldType(
[-] 	sl::String signature = BitFieldType::createSignature (baseType, bitOffset, bitCount);
[+] 	sl::String signature = BitFieldType::createSignature(baseType, bitOffset, bitCount);
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		BitFieldType* type = (BitFieldType*) it->m_value;
[+] 		BitFieldType* type = (BitFieldType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	BitFieldType* type = AXL_MEM_NEW (BitFieldType);
[+] 	BitFieldType* type = AXL_MEM_NEW(BitFieldType);
[-] 	m_bitFieldTypeList.insertTail (type);
[+] 	m_bitFieldTypeList.insertTail(type);
[-] 	if (baseType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (baseType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) baseType)->addFixup (&type->m_baseType);
[+] 		((ImportType*)baseType)->addFixup(&type->m_baseType);
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::createAutoSizeArrayType (Type* elementType)
[+] TypeMgr::createAutoSizeArrayType(Type* elementType)
[-] 	ArrayType* type = AXL_MEM_NEW (ArrayType);
[+] 	ArrayType* type = AXL_MEM_NEW(ArrayType);
[-] 	m_arrayTypeList.insertTail (type);
[+] 	m_arrayTypeList.insertTail(type);
[-] 	if (elementType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (elementType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) elementType)->addFixup (&type->m_elementType);
[+] 		((ImportType*)elementType)->addFixup(&type->m_elementType);
[-] 	if (!m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (!m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true); // can't calclayout yet
[+] 		m_module->markForLayout(type, true); // can't calclayout yet
[-] TypeMgr::createArrayType (
[+] TypeMgr::createArrayType(
[-] 	sl::BoxList <Token>* elementCountInitializer
[+] 	sl::BoxList<Token>* elementCountInitializer
[-] 	ArrayType* type = AXL_MEM_NEW (ArrayType);
[+] 	ArrayType* type = AXL_MEM_NEW(ArrayType);
[-] 	sl::takeOver (&type->m_elementCountInitializer, elementCountInitializer);
[+] 	sl::takeOver(&type->m_elementCountInitializer, elementCountInitializer);
[-] 	type->m_parentUnit = m_module->m_unitMgr.getCurrentUnit ();
[+] 	type->m_parentUnit = m_module->m_unitMgr.getCurrentUnit();
[-] 	type->m_parentNamespace = m_module->m_namespaceMgr.getCurrentNamespace ();
[+] 	type->m_parentNamespace = m_module->m_namespaceMgr.getCurrentNamespace();
[-] 	m_arrayTypeList.insertTail (type);
[+] 	m_arrayTypeList.insertTail(type);
[-] 	if (elementType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (elementType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) elementType)->addFixup (&type->m_elementType);
[+] 		((ImportType*)elementType)->addFixup(&type->m_elementType);
[-] 	if (!m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (!m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::getArrayType (
[+] TypeMgr::getArrayType(
[-] 	sl::String signature = ArrayType::createSignature (elementType, elementCount);
[+] 	sl::String signature = ArrayType::createSignature(elementType, elementCount);
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		ArrayType* type = (ArrayType*) it->m_value;
[+] 		ArrayType* type = (ArrayType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	ArrayType* type = AXL_MEM_NEW (ArrayType);
[+] 	ArrayType* type = AXL_MEM_NEW(ArrayType);
[-] 	m_arrayTypeList.insertTail (type);
[+] 	m_arrayTypeList.insertTail(type);
[-] 	if (elementType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (elementType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) elementType)->addFixup (&type->m_elementType);
[+] 		((ImportType*)elementType)->addFixup(&type->m_elementType);
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::createTypedef (
[+] TypeMgr::createTypedef(
[-] 	Typedef* tdef = AXL_MEM_NEW (Typedef);
[+] 	Typedef* tdef = AXL_MEM_NEW(Typedef);
[-] 	m_typedefList.insertTail (tdef);
[+] 	m_typedefList.insertTail(tdef);
[-] TypeMgr::createTypedefShadowType (Typedef* tdef)
[+] TypeMgr::createTypedefShadowType(Typedef* tdef)
[-] 	TypedefShadowType* type = AXL_MEM_NEW (TypedefShadowType);
[+] 	TypedefShadowType* type = AXL_MEM_NEW(TypedefShadowType);
[-] 	type->m_signature.format ("T%s", tdef->m_qualifiedName.sz ());
[+] 	type->m_signature.format("T%s", tdef->m_qualifiedName.sz ());
[-] 	m_typedefShadowTypeList.insertTail (type);
[+] 	m_typedefShadowTypeList.insertTail(type);
[-] TypeMgr::createEnumType (
[+] TypeMgr::createEnumType(
[-] 	EnumType* type = AXL_MEM_NEW (EnumType);
[+] 	EnumType* type = AXL_MEM_NEW(EnumType);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		type->m_signature.format ("%s%d", signaturePrefix, m_unnamedEnumTypeCounter);
[+] 		type->m_signature.format("%s%d", signaturePrefix, m_unnamedEnumTypeCounter);
[-] 		type->m_tag.format (".UnnamedEnum%d", m_unnamedEnumTypeCounter);
[+] 		type->m_tag.format(".UnnamedEnum%d", m_unnamedEnumTypeCounter);
[-] 		type->m_signature.format ("%s%s", signaturePrefix, qualifiedName.sz ());
[+] 		type->m_signature.format("%s%s", signaturePrefix, qualifiedName.sz ());
[-] 		type->addItem (type);
[+] 		type->addItem(type);
[-] 		baseType = getPrimitiveType (TypeKind_Int);
[+] 		baseType = getPrimitiveType(TypeKind_Int);
[-] 	m_enumTypeList.insertTail (type);
[+] 	m_enumTypeList.insertTail(type);
[-] 	if (baseType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (baseType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) baseType)->addFixup (&type->m_baseType);
[+] 		((ImportType*)baseType)->addFixup(&type->m_baseType);
[-] 	m_module->markForLayout (type, true);
[+] 	m_module->markForLayout(type, true);
[-] TypeMgr::createStructType (
[+] TypeMgr::createStructType(
[-] 	StructType* type = AXL_MEM_NEW (StructType);
[+] 	StructType* type = AXL_MEM_NEW(StructType);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		type->m_signature.format ("S%d", m_unnamedStructTypeCounter);
[+] 		type->m_signature.format("S%d", m_unnamedStructTypeCounter);
[-] 		type->m_tag.format (".UnnamedStruct%d", m_unnamedStructTypeCounter);
[+] 		type->m_tag.format(".UnnamedStruct%d", m_unnamedStructTypeCounter);
[-] 		type->m_signature.format ("S%s", qualifiedName.sz ());
[+] 		type->m_signature.format("S%s", qualifiedName.sz ());
[-] 		type->addItem (type);
[+] 		type->addItem(type);
[-] 	m_structTypeList.insertTail (type);
[+] 	m_structTypeList.insertTail(type);
[-] 	m_module->markForLayout (type, true);
[+] 	m_module->markForLayout(type, true);
[-] TypeMgr::createUnionType (
[+] TypeMgr::createUnionType(
[-] 	UnionType* type = AXL_MEM_NEW (UnionType);
[+] 	UnionType* type = AXL_MEM_NEW(UnionType);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		type->m_signature.format ("U%d", m_unnamedUnionTypeCounter);
[+] 		type->m_signature.format("U%d", m_unnamedUnionTypeCounter);
[-] 		type->m_tag.format (".UnamedUnion%d", m_unnamedUnionTypeCounter);
[+] 		type->m_tag.format(".UnamedUnion%d", m_unnamedUnionTypeCounter);
[-] 		type->m_signature.format ("U%s", qualifiedName.sz ());
[+] 		type->m_signature.format("U%s", qualifiedName.sz ());
[-] 		type->addItem (type);
[+] 		type->addItem(type);
[-] 	m_module->markForLayout (type, true); // before child struct
[+] 	m_module->markForLayout(type, true); // before child struct
[-] 		StructType* unionStructType = createUnnamedStructType ();
[+] 		StructType* unionStructType = createUnnamedStructType();
[-] 		unionStructType->m_tag.format ("%s.Struct", type->m_tag.sz ());
[+] 		unionStructType->m_tag.format("%s.Struct", type->m_tag.sz ());
[-] 	m_unionTypeList.insertTail (type);
[+] 	m_unionTypeList.insertTail(type);
[-] TypeMgr::createClassType (
[+] TypeMgr::createClassType(
[-] 	switch (classTypeKind)
[+] 	switch(classTypeKind)
[-] 		type = AXL_MEM_NEW (ReactorClassType);
[+] 		type = AXL_MEM_NEW(ReactorClassType);
[-] 		m_reactorClassTypeList.insertTail ((ReactorClassType*) type);
[+] 		m_reactorClassTypeList.insertTail((ReactorClassType*)type);
[-] 		type = AXL_MEM_NEW (FunctionClosureClassType);
[+] 		type = AXL_MEM_NEW(FunctionClosureClassType);
[-] 		m_functionClosureClassTypeList.insertTail ((FunctionClosureClassType*) type);
[+] 		m_functionClosureClassTypeList.insertTail((FunctionClosureClassType*)type);
[-] 		type = AXL_MEM_NEW (PropertyClosureClassType);
[+] 		type = AXL_MEM_NEW(PropertyClosureClassType);
[-] 		m_propertyClosureClassTypeList.insertTail ((PropertyClosureClassType*) type);
[+] 		m_propertyClosureClassTypeList.insertTail((PropertyClosureClassType*)type);
[-] 		type = AXL_MEM_NEW (DataClosureClassType);
[+] 		type = AXL_MEM_NEW(DataClosureClassType);
[-] 		m_dataClosureClassTypeList.insertTail ((DataClosureClassType*) type);
[+] 		m_dataClosureClassTypeList.insertTail((DataClosureClassType*)type);
[-] 		type = AXL_MEM_NEW (MulticastClassType);
[+] 		type = AXL_MEM_NEW(MulticastClassType);
[-] 		m_multicastClassTypeList.insertTail ((MulticastClassType*) type);
[+] 		m_multicastClassTypeList.insertTail((MulticastClassType*)type);
[-] 		type = AXL_MEM_NEW (McSnapshotClassType);
[+] 		type = AXL_MEM_NEW(McSnapshotClassType);
[-] 		m_mcSnapshotClassTypeList.insertTail ((McSnapshotClassType*) type);
[+] 		m_mcSnapshotClassTypeList.insertTail((McSnapshotClassType*)type);
[-] 		type = AXL_MEM_NEW (ClassType);
[+] 		type = AXL_MEM_NEW(ClassType);
[-] 		m_classTypeList.insertTail (type);
[+] 		m_classTypeList.insertTail(type);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		type->m_signature.format ("CC%d", m_unnamedClassTypeCounter);
[+] 		type->m_signature.format("CC%d", m_unnamedClassTypeCounter);
[-] 		type->m_tag.format (".UnnamedClass%d", m_unnamedClassTypeCounter);
[+] 		type->m_tag.format(".UnnamedClass%d", m_unnamedClassTypeCounter);
[-] 		type->m_signature.format ("CC%s", qualifiedName.sz ());
[+] 		type->m_signature.format("CC%s", qualifiedName.sz ());
[-] 		type->addItem (type);
[+] 		type->addItem(type);
[-] 	m_module->markForLayout (type, true); // before child structs
[+] 	m_module->markForLayout(type, true); // before child structs
[-] 	StructType* ifaceStructType = createUnnamedStructType (fieldAlignment);
[+] 	StructType* ifaceStructType = createUnnamedStructType(fieldAlignment);
[-] 	ifaceStructType->m_tag.format ("%s.Iface", type->m_tag.sz ());
[+] 	ifaceStructType->m_tag.format("%s.Iface", type->m_tag.sz ());
[-] 	StructType* classStructType = createUnnamedStructType (fieldAlignment);
[+] 	StructType* classStructType = createUnnamedStructType(fieldAlignment);
[-] 	classStructType->m_tag.format ("%s.Class", type->m_tag.sz ());
[+] 	classStructType->m_tag.format("%s.Class", type->m_tag.sz ());
[-] 	classStructType->createField ("!m_box", getStdType (StdType_Box));
[+] 	classStructType->createField("!m_box", getStdType (StdType_Box));
[-] 	classStructType->createField ("!m_iface", ifaceStructType);
[+] 	classStructType->createField("!m_iface", ifaceStructType);
[-] TypeMgr::createFunctionArg (
[+] TypeMgr::createFunctionArg(
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	FunctionArg* functionArg = AXL_MEM_NEW (FunctionArg);
[+] 	FunctionArg* functionArg = AXL_MEM_NEW(FunctionArg);
[-] 		sl::takeOver (&functionArg->m_initializer, initializer);
[+] 		sl::takeOver(&functionArg->m_initializer, initializer);
[-] 	m_functionArgList.insertTail (functionArg);
[+] 	m_functionArgList.insertTail(functionArg);
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup (&functionArg->m_type);
[+] 		((ImportType*)type)->addFixup(&functionArg->m_type);
[-] TypeMgr::createStructField (
[+] TypeMgr::createStructField(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	StructField* field = AXL_MEM_NEW (StructField);
[+] 	StructField* field = AXL_MEM_NEW(StructField);
[-] 		sl::takeOver (&field->m_constructor, constructor);
[+] 		sl::takeOver(&field->m_constructor, constructor);
[-] 		sl::takeOver (&field->m_initializer, initializer);
[+] 		sl::takeOver(&field->m_initializer, initializer);
[-] 	m_structFieldList.insertTail (field);
[+] 	m_structFieldList.insertTail(field);
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup (&field->m_type);
[+] 		((ImportType*)type)->addFixup(&field->m_type);
[-] 			((ImportType*) type)->addFixup (&field->m_bitFieldBaseType);
[+] 			((ImportType*)type)->addFixup(&field->m_bitFieldBaseType);
[-] TypeMgr::getSimpleFunctionArg (
[+] TypeMgr::getSimpleFunctionArg(
[-] 	FunctionArgTuple* tuple = getFunctionArgTuple (type);
[+] 	FunctionArgTuple* tuple = getFunctionArgTuple(type);
[-] 	if (tuple->m_argArray [i1] [i2] [i3])
[+] 	if (tuple->m_argArray[i1] [i2] [i3])
[-] 		return tuple->m_argArray [i1] [i2] [i3];
[+] 		return tuple->m_argArray[i1] [i2] [i3];
[-] 	FunctionArg* arg = createFunctionArg (sl::String (), type, ptrTypeFlags);
[+] 	FunctionArg* arg = createFunctionArg(sl::String(), type, ptrTypeFlags);
[-] 	tuple->m_argArray [i1] [i2] [i3] = arg;
[+] 	tuple->m_argArray[i1] [i2] [i3] = arg;
[-] TypeMgr::getFunctionType (
[+] TypeMgr::getFunctionType(
[-] 	const sl::Array <FunctionArg*>& argArray,
[+] 	const sl::Array<FunctionArg*>& argArray,
[-] 	ASSERT (callConv && returnType);
[+] 	ASSERT(callConv && returnType);
[-] 	sl::String signature = FunctionType::createSignature (
[+] 	sl::String signature = FunctionType::createSignature(
[-] 		argArray.getCount (),
[+] 		argArray.getCount(),
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		FunctionType* type = (FunctionType*) it->m_value;
[+] 		FunctionType* type = (FunctionType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	FunctionType* type = AXL_MEM_NEW (FunctionType);
[+] 	FunctionType* type = AXL_MEM_NEW(FunctionType);
[-] 	m_functionTypeList.insertTail (type);
[+] 	m_functionTypeList.insertTail(type);
[-] 	if (returnType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (returnType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) returnType)->addFixup (&type->m_returnType);
[+] 		((ImportType*)returnType)->addFixup(&type->m_returnType);
[-] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::getFunctionType (
[+] TypeMgr::getFunctionType(
[-] 	ASSERT (callConv && returnType);
[+] 	ASSERT(callConv && returnType);
[-] 	sl::Array <FunctionArg*> argArray;
[+] 	sl::Array<FunctionArg*> argArray;
[-] 	argArray.setCount (argCount);
[+] 	argArray.setCount(argCount);
[-] 		FunctionArg* arg = getSimpleFunctionArg (argTypeArray [i]);
[+] 		FunctionArg* arg = getSimpleFunctionArg(argTypeArray[i]);
[-] 		argArray [i] = arg;
[+] 		argArray[i] = arg;
[-] 	sl::String signature = FunctionType::createSignature (
[+] 	sl::String signature = FunctionType::createSignature(
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		FunctionType* type = (FunctionType*) it->m_value;
[+] 		FunctionType* type = (FunctionType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	FunctionType* type = AXL_MEM_NEW (FunctionType);
[+] 	FunctionType* type = AXL_MEM_NEW(FunctionType);
[-] 	m_functionTypeList.insertTail (type);
[+] 	m_functionTypeList.insertTail(type);
[-] 	if (returnType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (returnType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) returnType)->addFixup (&type->m_returnType);
[+] 		((ImportType*)returnType)->addFixup(&type->m_returnType);
[-] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::createUserFunctionType (
[+] TypeMgr::createUserFunctionType(
[-] 	const sl::Array <FunctionArg*>& argArray,
[+] 	const sl::Array<FunctionArg*>& argArray,
[-] 	ASSERT (callConv && returnType);
[+] 	ASSERT(callConv && returnType);
[-] 	sl::String signature = FunctionType::createSignature (
[+] 	sl::String signature = FunctionType::createSignature(
[-] 		argArray.getCount (),
[+] 		argArray.getCount(),
[-] 	FunctionType* type = AXL_MEM_NEW (FunctionType);
[+] 	FunctionType* type = AXL_MEM_NEW(FunctionType);
[-] 		returnType = m_module->m_typeMgr.getStdType (StdType_PromisePtr);
[+] 		returnType = m_module->m_typeMgr.getStdType(StdType_PromisePtr);
[-] 	m_functionTypeList.insertTail (type);
[+] 	m_functionTypeList.insertTail(type);
[-] 	if (returnType->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (returnType->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) returnType)->addFixup (&type->m_returnType);
[+] 		((ImportType*)returnType)->addFixup(&type->m_returnType);
[-] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::getMemberMethodType (
[+] TypeMgr::getMemberMethodType(
[-] 	if (!isClassType (parentType, ClassTypeKind_Abstract)) // std object members are miscellaneous closures
[+] 	if (!isClassType(parentType, ClassTypeKind_Abstract)) // std object members are miscellaneous closures
[-] 	Type* thisArgType = parentType->getThisArgType (thisArgPtrTypeFlags);
[+] 	Type* thisArgType = parentType->getThisArgType(thisArgPtrTypeFlags);
[-] 	FunctionArg* thisArg = getSimpleFunctionArg (StorageKind_This, thisArgType);
[+] 	FunctionArg* thisArg = getSimpleFunctionArg(StorageKind_This, thisArgType);
[-] 	sl::Array <FunctionArg*> argArray = functionType->m_argArray;
[+] 	sl::Array<FunctionArg*> argArray = functionType->m_argArray;
[-] 	argArray.insert (0, thisArg);
[+] 	argArray.insert(0, thisArg);
[-] 		memberMethodType = createUserFunctionType (
[+] 		memberMethodType = createUserFunctionType(
[-] 		memberMethodType = getFunctionType (
[+] 		memberMethodType = getFunctionType(
[-] TypeMgr::getStdObjectMemberMethodType (FunctionType* functionType)
[+] TypeMgr::getStdObjectMemberMethodType(FunctionType* functionType)
[-] 	ClassType* classType = (ClassType*) getStdType (StdType_AbstractClass);
[+] 	ClassType* classType = (ClassType*)getStdType(StdType_AbstractClass);
[-] 	functionType->m_stdObjectMemberMethodType = classType->getMemberMethodType (functionType);
[+] 	functionType->m_stdObjectMemberMethodType = classType->getMemberMethodType(functionType);
[-] TypeMgr::getPropertyType (
[+] TypeMgr::getPropertyType(
[-] 	sl::String signature = PropertyType::createSignature (getterType, setterType, flags);
[+] 	sl::String signature = PropertyType::createSignature(getterType, setterType, flags);
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		PropertyType* type = (PropertyType*) it->m_value;
[+] 		PropertyType* type = (PropertyType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	if (setterType.isEmpty ())
[+] 	if (setterType.isEmpty())
[-] 	PropertyType* type = AXL_MEM_NEW (PropertyType);
[+] 	PropertyType* type = AXL_MEM_NEW(PropertyType);
[-] 		FunctionType* binderType = (FunctionType*) getStdType (StdType_Binder);
[+] 		FunctionType* binderType = (FunctionType*)getStdType(StdType_Binder);
[-] 		if (getterType->isMemberMethodType ())
[+] 		if (getterType->isMemberMethodType())
[-] 			binderType = binderType->getMemberMethodType (getterType->getThisTargetType (), PtrTypeFlag_Const);
[+] 			binderType = binderType->getMemberMethodType(getterType->getThisTargetType(), PtrTypeFlag_Const);
[-] 	m_propertyTypeList.insertTail (type);
[+] 	m_propertyTypeList.insertTail(type);
[-] TypeMgr::getSimplePropertyType (
[+] TypeMgr::getSimplePropertyType(
[-] 	SimplePropertyTypeTuple* tuple = getSimplePropertyTypeTuple (returnType);
[+] 	SimplePropertyTypeTuple* tuple = getSimplePropertyTypeTuple(returnType);
[-] 	uint_t callConvFlags = callConv->getFlags ();
[+] 	uint_t callConvFlags = callConv->getFlags();
[-] 	if (tuple->m_propertyTypeArray [i1] [i2] [i3])
[+] 	if (tuple->m_propertyTypeArray[i1] [i2] [i3])
[-] 		return tuple->m_propertyTypeArray [i1] [i2] [i3];
[+] 		return tuple->m_propertyTypeArray[i1] [i2] [i3];
[-] 	FunctionType* getterType = getFunctionType (callConv, returnType, NULL, 0, 0);
[+] 	FunctionType* getterType = getFunctionType(callConv, returnType, NULL, 0, 0);
[-] 		propertyType = getPropertyType (getterType, NULL, flags);
[+] 		propertyType = getPropertyType(getterType, NULL, flags);
[-] 		Type* voidType = &m_primitiveTypeArray [TypeKind_Void];
[+] 		Type* voidType = &m_primitiveTypeArray[TypeKind_Void];
[-] 		FunctionType* setterType = getFunctionType (callConv, voidType, &returnType, 1, 0);
[+] 		FunctionType* setterType = getFunctionType(callConv, voidType, &returnType, 1, 0);
[-] 		propertyType = getPropertyType (getterType, setterType, flags);
[+] 		propertyType = getPropertyType(getterType, setterType, flags);
[-] 	tuple->m_propertyTypeArray [i1] [i2] [i3] = propertyType;
[+] 	tuple->m_propertyTypeArray[i1] [i2] [i3] = propertyType;
[-] TypeMgr::getIndexedPropertyType (
[+] TypeMgr::getIndexedPropertyType(
[-] 	FunctionType* getterType = getFunctionType (callConv, returnType, indexArgTypeArray, indexArgCount, 0);
[+] 	FunctionType* getterType = getFunctionType(callConv, returnType, indexArgTypeArray, indexArgCount, 0);
[-] 		return getPropertyType (getterType, NULL, flags);
[+] 		return getPropertyType(getterType, NULL, flags);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Type*> argTypeArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Type*> argTypeArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	argTypeArray.copy (indexArgTypeArray, indexArgCount);
[+] 	argTypeArray.copy(indexArgTypeArray, indexArgCount);
[-] 	argTypeArray.append (returnType);
[+] 	argTypeArray.append(returnType);
[-] 	Type* voidType = &m_primitiveTypeArray [TypeKind_Void];
[+] 	Type* voidType = &m_primitiveTypeArray[TypeKind_Void];
[-] 	FunctionType* setterType = getFunctionType (callConv, voidType, argTypeArray, indexArgCount + 1, 0);
[+] 	FunctionType* setterType = getFunctionType(callConv, voidType, argTypeArray, indexArgCount + 1, 0);
[-] 	return getPropertyType (getterType, setterType, flags);
[+] 	return getPropertyType(getterType, setterType, flags);
[-] TypeMgr::getIndexedPropertyType (
[+] TypeMgr::getIndexedPropertyType(
[-] 	const sl::Array <FunctionArg*>& argArray,
[+] 	const sl::Array<FunctionArg*>& argArray,
[-] 	FunctionType* getterType = getFunctionType (callConv, returnType, argArray, 0);
[+] 	FunctionType* getterType = getFunctionType(callConv, returnType, argArray, 0);
[-] 		return getPropertyType (getterType, NULL, flags);
[+] 		return getPropertyType(getterType, NULL, flags);
[-] 	sl::Array <FunctionArg*> setterArgArray = argArray;
[+] 	sl::Array<FunctionArg*> setterArgArray = argArray;
[-] 	setterArgArray.append (returnType->getSimpleFunctionArg ());
[+] 	setterArgArray.append(returnType->getSimpleFunctionArg());
[-] 	Type* voidType = &m_primitiveTypeArray [TypeKind_Void];
[+] 	Type* voidType = &m_primitiveTypeArray[TypeKind_Void];
[-] 	FunctionType* setterType = getFunctionType (callConv, voidType, setterArgArray, 0);
[+] 	FunctionType* setterType = getFunctionType(callConv, voidType, setterArgArray, 0);
[-] 	return getPropertyType (getterType, setterType, flags);
[+] 	return getPropertyType(getterType, setterType, flags);
[-] TypeMgr::createIndexedPropertyType (
[+] TypeMgr::createIndexedPropertyType(
[-] 	const sl::Array <FunctionArg*>& argArray,
[+] 	const sl::Array<FunctionArg*>& argArray,
[-] 	FunctionType* getterType = createUserFunctionType (callConv, returnType, argArray, 0);
[+] 	FunctionType* getterType = createUserFunctionType(callConv, returnType, argArray, 0);
[-] 		return getPropertyType (getterType, NULL, flags);
[+] 		return getPropertyType(getterType, NULL, flags);
[-] 	sl::Array <FunctionArg*> setterArgArray = argArray;
[+] 	sl::Array<FunctionArg*> setterArgArray = argArray;
[-] 	setterArgArray.append (returnType->getSimpleFunctionArg ());
[+] 	setterArgArray.append(returnType->getSimpleFunctionArg());
[-] 	Type* voidType = &m_primitiveTypeArray [TypeKind_Void];
[+] 	Type* voidType = &m_primitiveTypeArray[TypeKind_Void];
[-] 	FunctionType* setterType = createUserFunctionType (callConv, voidType, setterArgArray, 0);
[+] 	FunctionType* setterType = createUserFunctionType(callConv, voidType, setterArgArray, 0);
[-] 	return getPropertyType (getterType, setterType, flags);
[+] 	return getPropertyType(getterType, setterType, flags);
[-] TypeMgr::getMemberPropertyType (
[+] TypeMgr::getMemberPropertyType(
[-] 	FunctionType* getterType = getMemberMethodType (
[+] 	FunctionType* getterType = getMemberMethodType(
[-] 	size_t setterTypeOverloadCount = propertyType->m_setterType.getOverloadCount ();
[+] 	size_t setterTypeOverloadCount = propertyType->m_setterType.getOverloadCount();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <FunctionType*> setterTypeOverloadArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<FunctionType*> setterTypeOverloadArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	setterTypeOverloadArray.setCount (setterTypeOverloadCount);
[+] 	setterTypeOverloadArray.setCount(setterTypeOverloadCount);
[-] 		FunctionType* overloadType = propertyType->m_setterType.getOverload (i);
[+] 		FunctionType* overloadType = propertyType->m_setterType.getOverload(i);
[-] 		setterTypeOverloadArray [i] = getMemberMethodType (parentType, overloadType);
[+] 		setterTypeOverloadArray[i] = getMemberMethodType(parentType, overloadType);
[-] 	PropertyType* memberPropertyType = getPropertyType (
[+] 	PropertyType* memberPropertyType = getPropertyType(
[-] 		FunctionTypeOverload (setterTypeOverloadArray, setterTypeOverloadCount),
[+] 		FunctionTypeOverload(setterTypeOverloadArray, setterTypeOverloadCount),
[-] TypeMgr::getStdObjectMemberPropertyType (PropertyType* propertyType)
[+] TypeMgr::getStdObjectMemberPropertyType(PropertyType* propertyType)
[-] 	ClassType* classType = (ClassType*) getStdType (StdType_AbstractClass);
[+] 	ClassType* classType = (ClassType*)getStdType(StdType_AbstractClass);
[-] 	propertyType->m_stdObjectMemberPropertyType = classType->getMemberPropertyType (propertyType);
[+] 	propertyType->m_stdObjectMemberPropertyType = classType->getMemberPropertyType(propertyType);
[-] TypeMgr::getShortPropertyType (PropertyType* propertyType)
[+] TypeMgr::getShortPropertyType(PropertyType* propertyType)
[-] 	if (!propertyType->isMemberPropertyType ())
[+] 	if (!propertyType->isMemberPropertyType())
[-] 	FunctionType* getterType = propertyType->m_getterType->getShortType ();
[+] 	FunctionType* getterType = propertyType->m_getterType->getShortType();
[-] 	size_t setterCount = propertyType->m_setterType.getOverloadCount ();
[+] 	size_t setterCount = propertyType->m_setterType.getOverloadCount();
[-] 		FunctionType* type = propertyType->m_setterType.getOverload (i)->getShortType ();
[+] 		FunctionType* type = propertyType->m_setterType.getOverload(i)->getShortType();
[-] 		setterType.addOverload (type);
[+] 		setterType.addOverload(type);
[-] 	propertyType->m_shortType = getPropertyType (getterType, setterType, propertyType->m_flags);
[+] 	propertyType->m_shortType = getPropertyType(getterType, setterType, propertyType->m_flags);
[-] TypeMgr::getMulticastType (FunctionPtrType* functionPtrType)
[+] TypeMgr::getMulticastType(FunctionPtrType* functionPtrType)
[-] 	Type* returnType = functionPtrType->getTargetType ()->getReturnType ();
[+] 	Type* returnType = functionPtrType->getTargetType()->getReturnType();
[-] 	if (returnType->getTypeKind () != TypeKind_Void)
[+] 	if (returnType->getTypeKind() != TypeKind_Void)
[-] 		err::setFormatStringError ("multicast cannot only return 'void', not '%s'", returnType->getTypeString ().sz ());
[+] 		err::setFormatStringError("multicast cannot only return 'void', not '%s'", returnType->getTypeString ().sz ());
[-] 	MulticastClassType* type = (MulticastClassType*) createUnnamedClassType (ClassTypeKind_Multicast);
[+] 	MulticastClassType* type = (MulticastClassType*)createUnnamedClassType(ClassTypeKind_Multicast);
[-] 	type->m_fieldArray [MulticastFieldKind_Lock] = type->createField ("!m_lock", getPrimitiveType (TypeKind_IntPtr), 0, PtrTypeFlag_Volatile);
[+] 	type->m_fieldArray[MulticastFieldKind_Lock] = type->createField("!m_lock", getPrimitiveType (TypeKind_IntPtr), 0, PtrTypeFlag_Volatile);
[-] 	type->m_fieldArray [MulticastFieldKind_PtrArray] = type->createField ("!m_arrayPtr", functionPtrType->getDataPtrType ());
[+] 	type->m_fieldArray[MulticastFieldKind_PtrArray] = type->createField("!m_arrayPtr", functionPtrType->getDataPtrType ());
[-] 	type->m_fieldArray [MulticastFieldKind_Count] = type->createField ("!m_count", getPrimitiveType (TypeKind_SizeT));
[+] 	type->m_fieldArray[MulticastFieldKind_Count] = type->createField("!m_count", getPrimitiveType (TypeKind_SizeT));
[-] 	type->m_fieldArray [MulticastFieldKind_MaxCount] = type->createField ("!m_maxCount", getPrimitiveType (TypeKind_SizeT));
[+] 	type->m_fieldArray[MulticastFieldKind_MaxCount] = type->createField("!m_maxCount", getPrimitiveType (TypeKind_SizeT));
[-] 	type->m_fieldArray [MulticastFieldKind_HandleTable] = type->createField ("!m_handleTable", getPrimitiveType (TypeKind_IntPtr));
[+] 	type->m_fieldArray[MulticastFieldKind_HandleTable] = type->createField("!m_handleTable", getPrimitiveType (TypeKind_IntPtr));
[-] 	bool isThin = functionPtrType->getPtrTypeKind () == FunctionPtrTypeKind_Thin;
[+] 	bool isThin = functionPtrType->getPtrTypeKind() == FunctionPtrTypeKind_Thin;
[-] 	methodType = getFunctionType ();
[+] 	methodType = getFunctionType();
[-] 	method = type->createUnnamedMethod (StorageKind_Member, FunctionKind_Destructor, methodType);
[+] 	method = type->createUnnamedMethod(StorageKind_Member, FunctionKind_Destructor, methodType);
[-] 	methodType = getFunctionType ();
[+] 	methodType = getFunctionType();
[-] 	method = type->createMethod (StorageKind_Member, "clear", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "clear", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_Clear] = method;
[+] 	type->m_methodArray[MulticastMethodKind_Clear] = method;
[-] 	returnType = getPrimitiveType (TypeKind_IntPtr);
[+] 	returnType = getPrimitiveType(TypeKind_IntPtr);
[-] 	methodType = getFunctionType (returnType, &argType, 1);
[+] 	methodType = getFunctionType(returnType, &argType, 1);
[-] 	method = type->createMethod (StorageKind_Member, "setup", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "setup", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_Setup] = method;
[+] 	type->m_methodArray[MulticastMethodKind_Setup] = method;
[-] 	method = type->createMethod (StorageKind_Member, "add", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "add", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_Add] = method;
[+] 	type->m_methodArray[MulticastMethodKind_Add] = method;
[-] 	argType = getPrimitiveType (TypeKind_IntPtr);
[+] 	argType = getPrimitiveType(TypeKind_IntPtr);
[-] 	methodType = getFunctionType (returnType, &argType, 1);
[+] 	methodType = getFunctionType(returnType, &argType, 1);
[-] 	method = type->createMethod (StorageKind_Member, "remove", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "remove", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_Remove] = method;
[+] 	type->m_methodArray[MulticastMethodKind_Remove] = method;
[-] 	returnType = functionPtrType->getNormalPtrType ();
[+] 	returnType = functionPtrType->getNormalPtrType();
[-] 	methodType = getFunctionType (returnType, NULL, 0);
[+] 	methodType = getFunctionType(returnType, NULL, 0);
[-] 	method = type->createMethod (StorageKind_Member, "getSnapshot", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "getSnapshot", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_GetSnapshot] = method;
[+] 	type->m_methodArray[MulticastMethodKind_GetSnapshot] = method;
[-] 	methodType = functionPtrType->getTargetType ();
[+] 	methodType = functionPtrType->getTargetType();
[-] 	method = type->createMethod (StorageKind_Member, "call", methodType);
[+] 	method = type->createMethod(StorageKind_Member, "call", methodType);
[-] 	type->m_methodArray [MulticastMethodKind_Call] = method;
[+] 	type->m_methodArray[MulticastMethodKind_Call] = method;
[-] 	type->m_binaryOperatorTable.setCountZeroConstruct (BinOpKind__Count);
[+] 	type->m_binaryOperatorTable.setCountZeroConstruct(BinOpKind__Count);
[-] 	type->m_binaryOperatorTable [BinOpKind_RefAssign] = type->m_methodArray [MulticastMethodKind_Setup];
[+] 	type->m_binaryOperatorTable[BinOpKind_RefAssign] = type->m_methodArray[MulticastMethodKind_Setup];
[-] 	type->m_binaryOperatorTable [BinOpKind_AddAssign] = type->m_methodArray [MulticastMethodKind_Add];
[+] 	type->m_binaryOperatorTable[BinOpKind_AddAssign] = type->m_methodArray[MulticastMethodKind_Add];
[-] 	type->m_binaryOperatorTable [BinOpKind_SubAssign] = type->m_methodArray [MulticastMethodKind_Remove];
[+] 	type->m_binaryOperatorTable[BinOpKind_SubAssign] = type->m_methodArray[MulticastMethodKind_Remove];
[-] 	type->m_callOperator = type->m_methodArray [MulticastMethodKind_Call];
[+] 	type->m_callOperator = type->m_methodArray[MulticastMethodKind_Call];
[-] 	McSnapshotClassType* snapshotType = (McSnapshotClassType*) createUnnamedClassType (ClassTypeKind_McSnapshot);
[+] 	McSnapshotClassType* snapshotType = (McSnapshotClassType*)createUnnamedClassType(ClassTypeKind_McSnapshot);
[-] 	snapshotType->m_targetType = functionPtrType->getUnWeakPtrType ();
[+] 	snapshotType->m_targetType = functionPtrType->getUnWeakPtrType();
[-] 	snapshotType->m_fieldArray [McSnapshotFieldKind_PtrArray] = snapshotType->createField ("!m_arrayPtr", functionPtrType->getDataPtrType ());
[+] 	snapshotType->m_fieldArray[McSnapshotFieldKind_PtrArray] = snapshotType->createField("!m_arrayPtr", functionPtrType->getDataPtrType ());
[-] 	snapshotType->m_fieldArray [McSnapshotFieldKind_Count] = snapshotType->createField ("!m_count", getPrimitiveType (TypeKind_SizeT));
[+] 	snapshotType->m_fieldArray[McSnapshotFieldKind_Count] = snapshotType->createField("!m_count", getPrimitiveType (TypeKind_SizeT));
[-] 	methodType = functionPtrType->getTargetType ();
[+] 	methodType = functionPtrType->getTargetType();
[-] 	snapshotType->m_methodArray [McSnapshotMethodKind_Call] = snapshotType->createMethod (StorageKind_Member, "call", methodType);
[+] 	snapshotType->m_methodArray[McSnapshotMethodKind_Call] = snapshotType->createMethod(StorageKind_Member, "call", methodType);
[-] 	if (!m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (!m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type);
[+] 		m_module->markForLayout(type);
[-] 		m_module->markForLayout (type->m_snapshotType);
[+] 		m_module->markForLayout(type->m_snapshotType);
[-] 			type->m_snapshotType->ensureLayout ();
[+] 			type->m_snapshotType->ensureLayout();
[-] 	m_module->markForCompile (type);
[+] 	m_module->markForCompile(type);
[-] 	m_module->markForCompile (type->m_snapshotType);
[+] 	m_module->markForCompile(type->m_snapshotType);
[-] TypeMgr::createReactorBaseType ()
[+] TypeMgr::createReactorBaseType()
[-] 	Type* voidType = getPrimitiveType (TypeKind_Void);
[+] 	Type* voidType = getPrimitiveType(TypeKind_Void);
[-] 	Type* eventPtrType = getStdType (StdType_SimpleEventPtr);
[+] 	Type* eventPtrType = getStdType(StdType_SimpleEventPtr);
[-] 	Type* abstractPtrType = getStdType (StdType_AbstractClassPtr); // onevent statement can have different event types
[+] 	Type* abstractPtrType = getStdType(StdType_AbstractClassPtr); // onevent statement can have different event types
[-] 	FunctionType* simpleFunctionType = (FunctionType*) getStdType (StdType_SimpleFunction);
[+] 	FunctionType* simpleFunctionType = (FunctionType*)getStdType(StdType_SimpleFunction);
[-] 	FunctionType* addOnChangedBindingType = getFunctionType (voidType, &eventPtrType, 1);
[+] 	FunctionType* addOnChangedBindingType = getFunctionType(voidType, &eventPtrType, 1);
[-] 	FunctionType* addOnEventBindingType = getFunctionType (voidType, &abstractPtrType, 1);
[+] 	FunctionType* addOnEventBindingType = getFunctionType(voidType, &abstractPtrType, 1);
[-] 	ClassType* type = createClassType ("ReactorBase", "jnc.ReactorBase", 8, ClassTypeFlag_Opaque);
[+] 	ClassType* type = createClassType("ReactorBase", "jnc.ReactorBase", 8, ClassTypeFlag_Opaque);
[-] 	type->createField ("m_activationCountLimit", getPrimitiveType (TypeKind_SizeT));
[+] 	type->createField("m_activationCountLimit", getPrimitiveType (TypeKind_SizeT));
[-] 	type->createDefaultMethod (FunctionKind_Constructor, StorageKind_Member, ModuleItemFlag_User); // no need to auto-generate ctor
[+] 	type->createDefaultMethod(FunctionKind_Constructor, StorageKind_Member, ModuleItemFlag_User); // no need to auto-generate ctor
[-] 	type->createDefaultMethod (FunctionKind_Destructor, StorageKind_Member, ModuleItemFlag_User); // no need to auto-generate dtor
[+] 	type->createDefaultMethod(FunctionKind_Destructor, StorageKind_Member, ModuleItemFlag_User); // no need to auto-generate dtor
[-] 	type->createMethod (StorageKind_Member, "start", simpleFunctionType);
[+] 	type->createMethod(StorageKind_Member, "start", simpleFunctionType);
[-] 	type->createMethod (StorageKind_Member, "stop", simpleFunctionType);
[+] 	type->createMethod(StorageKind_Member, "stop", simpleFunctionType);
[-] 	type->createMethod (StorageKind_Member, "restart", simpleFunctionType);
[+] 	type->createMethod(StorageKind_Member, "restart", simpleFunctionType);
[-] 	type->createMethod (StorageKind_Member, "!addOnChangedBinding", addOnChangedBindingType);
[+] 	type->createMethod(StorageKind_Member, "!addOnChangedBinding", addOnChangedBindingType);
[-] 	type->createMethod (StorageKind_Member, "!addOnEventBinding", addOnEventBindingType);
[+] 	type->createMethod(StorageKind_Member, "!addOnEventBinding", addOnEventBindingType);
[-] 	type->createMethod (StorageKind_Member, "!resetOnChangedBindings", simpleFunctionType);
[+] 	type->createMethod(StorageKind_Member, "!resetOnChangedBindings", simpleFunctionType);
[-] TypeMgr::createReactorType (
[+] TypeMgr::createReactorType(
[-] 	ReactorClassType* type = (ReactorClassType*) createClassType (ClassTypeKind_Reactor, name, qualifiedName);
[+] 	ReactorClassType* type = (ReactorClassType*)createClassType(ClassTypeKind_Reactor, name, qualifiedName);
[-] 	type->addBaseType (getStdType (StdType_ReactorBase));
[+] 	type->addBaseType(getStdType(StdType_ReactorBase));
[-] 	Type* voidType = getPrimitiveType (TypeKind_Void);
[+] 	Type* voidType = getPrimitiveType(TypeKind_Void);
[-] 	Type* sizeType = getPrimitiveType (TypeKind_SizeT);
[+] 	Type* sizeType = getPrimitiveType(TypeKind_SizeT);
[-] 		reactionType = getFunctionType (voidType, (Type**) &sizeType, 1);
[+] 		reactionType = getFunctionType(voidType, (Type**) &sizeType, 1);
[-] 		Type* argTypeArray [] = { parentType->getClassPtrType (), sizeType };
[+] 		Type* argTypeArray[] = { parentType->getClassPtrType(), sizeType };
[-] 		reactionType = getFunctionType (voidType, argTypeArray, 2);
[+] 		reactionType = getFunctionType(voidType, argTypeArray, 2);
[-] 	type->m_reaction = type->createMethod (StorageKind_Member, "!reaction", reactionType);
[+] 	type->m_reaction = type->createMethod(StorageKind_Member, "!reaction", reactionType);
[-] 	m_module->markForCompile (type);
[+] 	m_module->markForCompile(type);
[-] 	getStdType (StdType_ReactorClosure); // ensure closure type is created
[+] 	getStdType(StdType_ReactorClosure); // ensure closure type is created
[-] TypeMgr::createReactorClosureType ()
[+] TypeMgr::createReactorClosureType()
[-] 	FunctionClosureClassType* type = (FunctionClosureClassType*) createClassType (ClassTypeKind_FunctionClosure, "ReactorClosure", "jnc.ReactorClosure");
[+] 	FunctionClosureClassType* type = (FunctionClosureClassType*)createClassType(ClassTypeKind_FunctionClosure, "ReactorClosure", "jnc.ReactorClosure");
[-] 	type->createField ("m_self", type->getClassPtrType ());
[+] 	type->createField("m_self", type->getClassPtrType ());
[-] 	type->createField ("m_event", getStdType (StdType_BytePtr));
[+] 	type->createField("m_event", getStdType (StdType_BytePtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::getFunctionClosureClassType (
[+] TypeMgr::getFunctionClosureClassType(
[-] 	sl::String signature = ClosureClassType::createSignature (
[+] 	sl::String signature = ClosureClassType::createSignature(
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		FunctionClosureClassType* type = (FunctionClosureClassType*) it->m_value;
[+] 		FunctionClosureClassType* type = (FunctionClosureClassType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	FunctionClosureClassType* type = (FunctionClosureClassType*) createUnnamedClassType (ClassTypeKind_FunctionClosure);
[+] 	FunctionClosureClassType* type = (FunctionClosureClassType*)createUnnamedClassType(ClassTypeKind_FunctionClosure);
[-] 	type->m_closureMap.copy (closureMap, argCount);
[+] 	type->m_closureMap.copy(closureMap, argCount);
[-] 	type->createField ("m_target", targetType->getFunctionPtrType (FunctionPtrTypeKind_Thin));
[+] 	type->createField("m_target", targetType->getFunctionPtrType (FunctionPtrTypeKind_Thin));
[-] 		argFieldName.format ("m_arg%d", i);
[+] 		argFieldName.format("m_arg%d", i);
[-] 		type->createField (argFieldName, argTypeArray [i]);
[+] 		type->createField(argFieldName, argTypeArray[i]);
[-] 	Function* thunkFunction = m_module->m_functionMgr.createFunction (FunctionKind_Internal, "thunkFunction", thunkType);
[+] 	Function* thunkFunction = m_module->m_functionMgr.createFunction(FunctionKind_Internal, "thunkFunction", thunkType);
[-] 	type->addMethod (thunkFunction);
[+] 	type->addMethod(thunkFunction);
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] 	m_module->markForCompile (type);
[+] 	m_module->markForCompile(type);
[-] TypeMgr::getPropertyClosureClassType (
[+] TypeMgr::getPropertyClosureClassType(
[-] 	sl::String signature = ClosureClassType::createSignature (
[+] 	sl::String signature = ClosureClassType::createSignature(
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		PropertyClosureClassType* type = (PropertyClosureClassType*) it->m_value;
[+] 		PropertyClosureClassType* type = (PropertyClosureClassType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	PropertyClosureClassType* type = (PropertyClosureClassType*) createUnnamedClassType (ClassTypeKind_PropertyClosure);
[+] 	PropertyClosureClassType* type = (PropertyClosureClassType*)createUnnamedClassType(ClassTypeKind_PropertyClosure);
[-] 	type->m_closureMap.copy (closureMap, argCount);
[+] 	type->m_closureMap.copy(closureMap, argCount);
[-] 	type->createField ("m_target", targetType->getPropertyPtrType (PropertyPtrTypeKind_Thin));
[+] 	type->createField("m_target", targetType->getPropertyPtrType (PropertyPtrTypeKind_Thin));
[-] 		argFieldName.format ("m_arg%d", i);
[+] 		argFieldName.format("m_arg%d", i);
[-] 		type->createField (argFieldName, argTypeArray [i]);
[+] 		type->createField(argFieldName, argTypeArray[i]);
[-] 	Property* thunkProperty = m_module->m_functionMgr.createProperty (PropertyKind_Normal, "m_thunkProperty");
[+] 	Property* thunkProperty = m_module->m_functionMgr.createProperty(PropertyKind_Normal, "m_thunkProperty");
[-] 	type->addProperty (thunkProperty);
[+] 	type->addProperty(thunkProperty);
[-] 	thunkProperty->create (thunkType);
[+] 	thunkProperty->create(thunkType);
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] 	m_module->markForCompile (type);
[+] 	m_module->markForCompile(type);
[-] TypeMgr::getDataClosureClassType (
[+] TypeMgr::getDataClosureClassType(
[-] 	sl::String signature = DataClosureClassType::createSignature (targetType, thunkType);
[+] 	sl::String signature = DataClosureClassType::createSignature(targetType, thunkType);
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		DataClosureClassType* type = (DataClosureClassType*) it->m_value;
[+] 		DataClosureClassType* type = (DataClosureClassType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	DataClosureClassType* type = (DataClosureClassType*) createUnnamedClassType (ClassTypeKind_DataClosure);
[+] 	DataClosureClassType* type = (DataClosureClassType*)createUnnamedClassType(ClassTypeKind_DataClosure);
[-] 	type->createField ("!m_target", targetType->getDataPtrType ());
[+] 	type->createField("!m_target", targetType->getDataPtrType ());
[-] 	Property* thunkProperty = m_module->m_functionMgr.createProperty (PropertyKind_Normal, "m_thunkProperty");
[+] 	Property* thunkProperty = m_module->m_functionMgr.createProperty(PropertyKind_Normal, "m_thunkProperty");
[-] 	type->addProperty (thunkProperty);
[+] 	type->addProperty(thunkProperty);
[-] 	thunkProperty->create (thunkType);
[+] 	thunkProperty->create(thunkType);
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] 	m_module->markForCompile (type);
[+] 	m_module->markForCompile(type);
[-] TypeMgr::getDataPtrType (
[+] TypeMgr::getDataPtrType(
[-] 	ASSERT ((size_t) ptrTypeKind < DataPtrTypeKind__Count);
[+] 	ASSERT((size_t)ptrTypeKind < DataPtrTypeKind__Count);
[-] 	ASSERT (targetType->getTypeKind () != TypeKind_NamedImport); // for imports, GetImportPtrType () should be called
[+] 	ASSERT(targetType->getTypeKind() != TypeKind_NamedImport); // for imports, GetImportPtrType () should be called
[-] 	ASSERT (typeKind != TypeKind_DataRef || targetType->m_typeKind != TypeKind_DataRef); // double reference
[+] 	ASSERT(typeKind != TypeKind_DataRef || targetType->m_typeKind != TypeKind_DataRef); // double reference
[-] 	if (isDualType (targetType))
[+] 	if (isDualType(targetType))
[-] 	DataPtrTypeTuple* tuple = getDataPtrTypeTuple (targetType);
[+] 	DataPtrTypeTuple* tuple = getDataPtrTypeTuple(targetType);
[-] 	if (tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5])
[+] 	if (tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5])
[-] 		return tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5];
[+] 		return tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5];
[-] 	size_t size = ptrTypeKind == DataPtrTypeKind_Normal ? sizeof (DataPtr) : sizeof (void*);
[+] 	size_t size = ptrTypeKind == DataPtrTypeKind_Normal ? sizeof(DataPtr) : sizeof(void*);
[-] 	DataPtrType* type = AXL_MEM_NEW (DataPtrType);
[+] 	DataPtrType* type = AXL_MEM_NEW(DataPtrType);
[-] 	type->m_signature = DataPtrType::createSignature (targetType, typeKind, ptrTypeKind, flags);
[+] 	type->m_signature = DataPtrType::createSignature(targetType, typeKind, ptrTypeKind, flags);
[-] 	type->m_alignment = sizeof (void*);
[+] 	type->m_alignment = sizeof(void*);
[-] 	m_dataPtrTypeList.insertTail (type);
[+] 	m_dataPtrTypeList.insertTail(type);
[-] 	tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5] = type;
[+] 	tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5] = type;
[-] TypeMgr::getClassPtrType (
[+] TypeMgr::getClassPtrType(
[-] 	ASSERT ((size_t) ptrTypeKind < ClassPtrTypeKind__Count);
[+] 	ASSERT((size_t)ptrTypeKind < ClassPtrTypeKind__Count);
[-] 		ASSERT (targetType->getClassTypeKind () == ClassTypeKind_Multicast);
[+] 		ASSERT(targetType->getClassTypeKind() == ClassTypeKind_Multicast);
[-] 		tuple = getEventClassPtrTypeTuple ((MulticastClassType*) targetType);
[+] 		tuple = getEventClassPtrTypeTuple((MulticastClassType*)targetType);
[-] 		tuple = getClassPtrTypeTuple (targetType);
[+] 		tuple = getClassPtrTypeTuple(targetType);
[-] 	if (tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5])
[+] 	if (tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5])
[-] 		return tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5];
[+] 		return tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5];
[-] 	ClassPtrType* type = AXL_MEM_NEW (ClassPtrType);
[+] 	ClassPtrType* type = AXL_MEM_NEW(ClassPtrType);
[-] 	type->m_signature = ClassPtrType::createSignature (targetType, typeKind, ptrTypeKind, flags);
[+] 	type->m_signature = ClassPtrType::createSignature(targetType, typeKind, ptrTypeKind, flags);
[-] 	m_classPtrTypeList.insertTail (type);
[+] 	m_classPtrTypeList.insertTail(type);
[-] 	tuple->m_ptrTypeArray [i1] [i2] [i3] [i4] [i5] = type;
[+] 	tuple->m_ptrTypeArray[i1] [i2] [i3] [i4] [i5] = type;
[-] TypeMgr::getFunctionPtrType (
[+] TypeMgr::getFunctionPtrType(
[-] 	ASSERT (typeKind == TypeKind_FunctionPtr || typeKind == TypeKind_FunctionRef);
[+] 	ASSERT(typeKind == TypeKind_FunctionPtr || typeKind == TypeKind_FunctionRef);
[-] 	ASSERT ((size_t) ptrTypeKind < FunctionPtrTypeKind__Count);
[+] 	ASSERT((size_t)ptrTypeKind < FunctionPtrTypeKind__Count);
[-] 	FunctionPtrTypeTuple* tuple = getFunctionPtrTypeTuple (functionType);
[+] 	FunctionPtrTypeTuple* tuple = getFunctionPtrTypeTuple(functionType);
[-] 	if (tuple->m_ptrTypeArray [i1] [i2] [i3])
[+] 	if (tuple->m_ptrTypeArray[i1] [i2] [i3])
[-] 		return tuple->m_ptrTypeArray [i1] [i2] [i3];
[+] 		return tuple->m_ptrTypeArray[i1] [i2] [i3];
[-] 	size_t size = ptrTypeKind == FunctionPtrTypeKind_Thin ? sizeof (void*) : sizeof (FunctionPtr);
[+] 	size_t size = ptrTypeKind == FunctionPtrTypeKind_Thin ? sizeof(void*) : sizeof(FunctionPtr);
[-] 	FunctionPtrType* type = AXL_MEM_NEW (FunctionPtrType);
[+] 	FunctionPtrType* type = AXL_MEM_NEW(FunctionPtrType);
[-] 	type->m_signature = FunctionPtrType::createSignature (functionType, typeKind, ptrTypeKind, flags);
[+] 	type->m_signature = FunctionPtrType::createSignature(functionType, typeKind, ptrTypeKind, flags);
[-] 	type->m_alignment = sizeof (void*);
[+] 	type->m_alignment = sizeof(void*);
[-] 	m_functionPtrTypeList.insertTail (type);
[+] 	m_functionPtrTypeList.insertTail(type);
[-] 	tuple->m_ptrTypeArray [i1] [i2] [i3] = type;
[+] 	tuple->m_ptrTypeArray[i1] [i2] [i3] = type;
[-] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope ())
[+] 	if (m_parseStdTypeLevel || !m_module->m_namespaceMgr.getCurrentScope())
[-] 		m_module->markForLayout (type, true);
[+] 		m_module->markForLayout(type, true);
[-] 		bool result = type->ensureLayout ();
[+] 		bool result = type->ensureLayout();
[-] TypeMgr::getPropertyPtrType (
[+] TypeMgr::getPropertyPtrType(
[-] 	ASSERT (typeKind == TypeKind_PropertyPtr || typeKind == TypeKind_PropertyRef);
[+] 	ASSERT(typeKind == TypeKind_PropertyPtr || typeKind == TypeKind_PropertyRef);
[-] 	ASSERT ((size_t) ptrTypeKind < PropertyPtrTypeKind__Count);
[+] 	ASSERT((size_t)ptrTypeKind < PropertyPtrTypeKind__Count);
[-] 	PropertyPtrTypeTuple* tuple = getPropertyPtrTypeTuple (propertyType);
[+] 	PropertyPtrTypeTuple* tuple = getPropertyPtrTypeTuple(propertyType);
[-] 	if (tuple->m_ptrTypeArray [i1] [i2] [i3])
[+] 	if (tuple->m_ptrTypeArray[i1] [i2] [i3])
[-] 		return tuple->m_ptrTypeArray [i1] [i2] [i3];
[+] 		return tuple->m_ptrTypeArray[i1] [i2] [i3];
[-] 	size_t size = ptrTypeKind == PropertyPtrTypeKind_Thin ? sizeof (void*) : sizeof (PropertyPtr);
[+] 	size_t size = ptrTypeKind == PropertyPtrTypeKind_Thin ? sizeof(void*) : sizeof(PropertyPtr);
[-] 	PropertyPtrType* type = AXL_MEM_NEW (PropertyPtrType);
[+] 	PropertyPtrType* type = AXL_MEM_NEW(PropertyPtrType);
[-] 	type->m_signature = PropertyPtrType::createSignature (propertyType, typeKind, ptrTypeKind, flags);
[+] 	type->m_signature = PropertyPtrType::createSignature(propertyType, typeKind, ptrTypeKind, flags);
[-] 	type->m_alignment = sizeof (void*);
[+] 	type->m_alignment = sizeof(void*);
[-] 	m_propertyPtrTypeList.insertTail (type);
[+] 	m_propertyPtrTypeList.insertTail(type);
[-] 	tuple->m_ptrTypeArray [i1] [i2] [i3] = type;
[+] 	tuple->m_ptrTypeArray[i1] [i2] [i3] = type;
[-] TypeMgr::getPropertyVTableStructType (PropertyType* propertyType)
[+] TypeMgr::getPropertyVTableStructType(PropertyType* propertyType)
[-] 	StructType* type = createUnnamedStructType ();
[+] 	StructType* type = createUnnamedStructType();
[-] 	type->m_tag.format ("%s.VTable", propertyType->getTypeString ().sz ());
[+] 	type->m_tag.format("%s.VTable", propertyType->getTypeString ().sz ());
[-] 	if (propertyType->getFlags () & PropertyTypeFlag_Bindable)
[+] 	if (propertyType->getFlags() & PropertyTypeFlag_Bindable)
[-] 		type->createField ("!m_binder", propertyType->m_binderType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[+] 		type->createField("!m_binder", propertyType->m_binderType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[-] 	type->createField ("!m_getter", propertyType->m_getterType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[+] 	type->createField("!m_getter", propertyType->m_getterType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[-] 	size_t setterTypeOverloadCount = propertyType->m_setterType.getOverloadCount ();
[+] 	size_t setterTypeOverloadCount = propertyType->m_setterType.getOverloadCount();
[-] 		setterFieldName.format ("!m_setter%d", i);
[+] 		setterFieldName.format("!m_setter%d", i);
[-] 		FunctionType* setterType = propertyType->m_setterType.getOverload (i);
[+] 		FunctionType* setterType = propertyType->m_setterType.getOverload(i);
[-] 		type->createField (setterFieldName, setterType->getFunctionPtrType (FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[+] 		type->createField(setterFieldName, setterType->getFunctionPtrType(FunctionPtrTypeKind_Thin, PtrTypeFlag_Safe));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::getNamedImportType (
[+] TypeMgr::getNamedImportType(
[-] 	ASSERT (anchorNamespace->getNamespaceKind () != NamespaceKind_Scope);
[+] 	ASSERT(anchorNamespace->getNamespaceKind() != NamespaceKind_Scope);
[-] 	sl::String signature = NamedImportType::createSignature (name, anchorNamespace, anchorName);
[+] 	sl::String signature = NamedImportType::createSignature(name, anchorNamespace, anchorName);
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		NamedImportType* type = (NamedImportType*) it->m_value;
[+] 		NamedImportType* type = (NamedImportType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	NamedImportType* type = AXL_MEM_NEW (NamedImportType);
[+] 	NamedImportType* type = AXL_MEM_NEW(NamedImportType);
[-] 	if (anchorName.isEmpty ())
[+] 	if (anchorName.isEmpty())
[-] 		type->m_qualifiedName = anchorNamespace->createQualifiedName (name);
[+] 		type->m_qualifiedName = anchorNamespace->createQualifiedName(name);
[-] 		type->m_qualifiedName = anchorNamespace->createQualifiedName (anchorName);
[+] 		type->m_qualifiedName = anchorNamespace->createQualifiedName(anchorName);
[-] 		type->m_qualifiedName += name.getFullName ();
[+] 		type->m_qualifiedName += name.getFullName();
[-] 	m_namedImportTypeList.insertTail (type);
[+] 	m_namedImportTypeList.insertTail(type);
[-] 	m_unresolvedNamedImportTypeArray.append (type);
[+] 	m_unresolvedNamedImportTypeArray.append(type);
[-] TypeMgr::getImportPtrType (
[+] TypeMgr::getImportPtrType(
[-] 	sl::String signature = ImportPtrType::createSignature (
[+] 	sl::String signature = ImportPtrType::createSignature(
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		ImportPtrType* type = (ImportPtrType*) it->m_value;
[+] 		ImportPtrType* type = (ImportPtrType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	ImportPtrType* type = AXL_MEM_NEW (ImportPtrType);
[+] 	ImportPtrType* type = AXL_MEM_NEW(ImportPtrType);
[-] 	m_importPtrTypeList.insertTail (type);
[+] 	m_importPtrTypeList.insertTail(type);
[-] 	m_unresolvedImportPtrTypeArray.append (type);
[+] 	m_unresolvedImportPtrTypeArray.append(type);
[-] TypeMgr::getImportIntModType (
[+] TypeMgr::getImportIntModType(
[-] 	sl::String signature = ImportIntModType::createSignature (
[+] 	sl::String signature = ImportIntModType::createSignature(
[-] 	sl::StringHashTableIterator <Type*> it = m_typeMap.visit (signature);
[+] 	sl::StringHashTableIterator<Type*> it = m_typeMap.visit(signature);
[-] 		ImportIntModType* type = (ImportIntModType*) it->m_value;
[+] 		ImportIntModType* type = (ImportIntModType*)it->m_value;
[-] 		ASSERT (type->m_signature == signature);
[+] 		ASSERT(type->m_signature == signature);
[-] 	ImportIntModType* type = AXL_MEM_NEW (ImportIntModType);
[+] 	ImportIntModType* type = AXL_MEM_NEW(ImportIntModType);
[-] 	m_importIntModTypeList.insertTail (type);
[+] 	m_importIntModTypeList.insertTail(type);
[-] 	m_unresolvedImportIntModTypeArray.append (type);
[+] 	m_unresolvedImportIntModTypeArray.append(type);
[-] TypeMgr::getCheckedPtrType (Type* type)
[+] TypeMgr::getCheckedPtrType(Type* type)
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return ((DataPtrType*) type)->getCheckedPtrType ();
[+] 		return ((DataPtrType*)type)->getCheckedPtrType();
[-] 		return ((ClassPtrType*) type)->getCheckedPtrType ();
[+] 		return ((ClassPtrType*)type)->getCheckedPtrType();
[-] 		return ((FunctionPtrType*) type)->getCheckedPtrType ();
[+] 		return ((FunctionPtrType*)type)->getCheckedPtrType();
[-] 		return ((PropertyPtrType*) type)->getCheckedPtrType ();
[+] 		return ((PropertyPtrType*)type)->getCheckedPtrType();
[-] 		return ((ImportPtrType*) type)->getCheckedPtrType ();
[+] 		return ((ImportPtrType*)type)->getCheckedPtrType();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] TypeMgr::foldDualType (
[+] TypeMgr::foldDualType(
[-] 	ASSERT (isDualType (type));
[+] 	ASSERT(isDualType(type));
[-] 	DualTypeTuple* tuple = getDualTypeTuple (type);
[+] 	DualTypeTuple* tuple = getDualTypeTuple(type);
[-] 	Type* foldedType = tuple->m_typeArray [isAlien] [isContainerConst];
[+] 	Type* foldedType = tuple->m_typeArray[isAlien] [isContainerConst];
[-] 		foldedType = type->calcFoldedDualType (isAlien, isContainerConst);
[+] 		foldedType = type->calcFoldedDualType(isAlien, isContainerConst);
[-] 		tuple->m_typeArray [isAlien] [isContainerConst] = foldedType;
[+] 		tuple->m_typeArray[isAlien] [isContainerConst] = foldedType;
[-] TypeMgr::getDualTypeTuple (Type* type)
[+] TypeMgr::getDualTypeTuple(Type* type)
[-] 	DualTypeTuple* tuple = AXL_MEM_ZERO_NEW (DualTypeTuple);
[+] 	DualTypeTuple* tuple = AXL_MEM_ZERO_NEW(DualTypeTuple);
[-] 	m_dualTypeTupleList.insertTail (tuple);
[+] 	m_dualTypeTupleList.insertTail(tuple);
[-] TypeMgr::getSimplePropertyTypeTuple (Type* type)
[+] TypeMgr::getSimplePropertyTypeTuple(Type* type)
[-] 	SimplePropertyTypeTuple* tuple = AXL_MEM_ZERO_NEW (SimplePropertyTypeTuple);
[+] 	SimplePropertyTypeTuple* tuple = AXL_MEM_ZERO_NEW(SimplePropertyTypeTuple);
[-] 	m_simplePropertyTypeTupleList.insertTail (tuple);
[+] 	m_simplePropertyTypeTupleList.insertTail(tuple);
[-] TypeMgr::getFunctionArgTuple (Type* type)
[+] TypeMgr::getFunctionArgTuple(Type* type)
[-] 	FunctionArgTuple* tuple = AXL_MEM_ZERO_NEW (FunctionArgTuple);
[+] 	FunctionArgTuple* tuple = AXL_MEM_ZERO_NEW(FunctionArgTuple);
[-] 	m_functionArgTupleList.insertTail (tuple);
[+] 	m_functionArgTupleList.insertTail(tuple);
[-] TypeMgr::getDataPtrTypeTuple (Type* type)
[+] TypeMgr::getDataPtrTypeTuple(Type* type)
[-] 	DataPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW (DataPtrTypeTuple);
[+] 	DataPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW(DataPtrTypeTuple);
[-] 	m_dataPtrTypeTupleList.insertTail (tuple);
[+] 	m_dataPtrTypeTupleList.insertTail(tuple);
[-] TypeMgr::getClassPtrTypeTuple (ClassType* classType)
[+] TypeMgr::getClassPtrTypeTuple(ClassType* classType)
[-] 	ClassPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW (ClassPtrTypeTuple);
[+] 	ClassPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW(ClassPtrTypeTuple);
[-] 	m_classPtrTypeTupleList.insertTail (tuple);
[+] 	m_classPtrTypeTupleList.insertTail(tuple);
[-] TypeMgr::getEventClassPtrTypeTuple (MulticastClassType* classType)
[+] TypeMgr::getEventClassPtrTypeTuple(MulticastClassType* classType)
[-] 	ClassPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW (ClassPtrTypeTuple);
[+] 	ClassPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW(ClassPtrTypeTuple);
[-] 	m_classPtrTypeTupleList.insertTail (tuple);
[+] 	m_classPtrTypeTupleList.insertTail(tuple);
[-] TypeMgr::getFunctionPtrTypeTuple (FunctionType* functionType)
[+] TypeMgr::getFunctionPtrTypeTuple(FunctionType* functionType)
[-] 	FunctionPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW (FunctionPtrTypeTuple);
[+] 	FunctionPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW(FunctionPtrTypeTuple);
[-] 	m_functionPtrTypeTupleList.insertTail (tuple);
[+] 	m_functionPtrTypeTupleList.insertTail(tuple);
[-] TypeMgr::getPropertyPtrTypeTuple (PropertyType* propertyType)
[+] TypeMgr::getPropertyPtrTypeTuple(PropertyType* propertyType)
[-] 	PropertyPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW (PropertyPtrTypeTuple);
[+] 	PropertyPtrTypeTuple* tuple = AXL_MEM_ZERO_NEW(PropertyPtrTypeTuple);
[-] 	m_propertyPtrTypeTupleList.insertTail (tuple);
[+] 	m_propertyPtrTypeTupleList.insertTail(tuple);
[-] TypeMgr::setupAllPrimitiveTypes ()
[+] TypeMgr::setupAllPrimitiveTypes()
[-] 	setupPrimitiveType (TypeKind_Void,      0, "v");
[+] 	setupPrimitiveType(TypeKind_Void,      0, "v");
[-] 	setupPrimitiveType (TypeKind_Variant,   sizeof (Variant), "z");
[+] 	setupPrimitiveType(TypeKind_Variant,   sizeof(Variant), "z");
[-] 	setupPrimitiveType (TypeKind_Bool,      1, "b");
[+] 	setupPrimitiveType(TypeKind_Bool,      1, "b");
[-] 	setupPrimitiveType (TypeKind_Int8,      1, "is1");
[+] 	setupPrimitiveType(TypeKind_Int8,      1, "is1");
[-] 	setupPrimitiveType (TypeKind_Int8_u,    1, "iu1");
[+] 	setupPrimitiveType(TypeKind_Int8_u,    1, "iu1");
[-] 	setupPrimitiveType (TypeKind_Int16,     2, "is2");
[+] 	setupPrimitiveType(TypeKind_Int16,     2, "is2");
[-] 	setupPrimitiveType (TypeKind_Int16_u,   2, "iu2");
[+] 	setupPrimitiveType(TypeKind_Int16_u,   2, "iu2");
[-] 	setupPrimitiveType (TypeKind_Int32,     4, "is4");
[+] 	setupPrimitiveType(TypeKind_Int32,     4, "is4");
[-] 	setupPrimitiveType (TypeKind_Int32_u,   4, "iu4");
[+] 	setupPrimitiveType(TypeKind_Int32_u,   4, "iu4");
[-] 	setupPrimitiveType (TypeKind_Int64,     8, "is8");
[+] 	setupPrimitiveType(TypeKind_Int64,     8, "is8");
[-] 	setupPrimitiveType (TypeKind_Int64_u,   8, "iu8");
[+] 	setupPrimitiveType(TypeKind_Int64_u,   8, "iu8");
[-] 	setupPrimitiveType (TypeKind_Int16_be,  2, "ibs2");
[+] 	setupPrimitiveType(TypeKind_Int16_be,  2, "ibs2");
[-] 	setupPrimitiveType (TypeKind_Int16_beu, 2, "ibu2");
[+] 	setupPrimitiveType(TypeKind_Int16_beu, 2, "ibu2");
[-] 	setupPrimitiveType (TypeKind_Int32_be,  4, "ibs4");
[+] 	setupPrimitiveType(TypeKind_Int32_be,  4, "ibs4");
[-] 	setupPrimitiveType (TypeKind_Int32_beu, 4, "ibu4");
[+] 	setupPrimitiveType(TypeKind_Int32_beu, 4, "ibu4");
[-] 	setupPrimitiveType (TypeKind_Int64_be,  8, "ibs8");
[+] 	setupPrimitiveType(TypeKind_Int64_be,  8, "ibs8");
[-] 	setupPrimitiveType (TypeKind_Int64_beu, 8, "ibu8");
[+] 	setupPrimitiveType(TypeKind_Int64_beu, 8, "ibu8");
[-] 	setupPrimitiveType (TypeKind_Float,     4, "f4");
[+] 	setupPrimitiveType(TypeKind_Float,     4, "f4");
[-] 	setupPrimitiveType (TypeKind_Double,    8, "f8");
[+] 	setupPrimitiveType(TypeKind_Double,    8, "f8");
[-] 	Type* type = &m_primitiveTypeArray [TypeKind_Variant];
[+] 	Type* type = &m_primitiveTypeArray[TypeKind_Variant];
[-] TypeMgr::setupStdTypedefArray ()
[+] TypeMgr::setupStdTypedefArray()
[-] 	setupStdTypedef (StdTypedef_uint_t,    TypeKind_Int_u,    "uint_t");
[+] 	setupStdTypedef(StdTypedef_uint_t,    TypeKind_Int_u,    "uint_t");
[-] 	setupStdTypedef (StdTypedef_intptr_t,  TypeKind_IntPtr,   "intptr_t");
[+] 	setupStdTypedef(StdTypedef_intptr_t,  TypeKind_IntPtr,   "intptr_t");
[-] 	setupStdTypedef (StdTypedef_uintptr_t, TypeKind_IntPtr_u, "uintptr_t");
[+] 	setupStdTypedef(StdTypedef_uintptr_t, TypeKind_IntPtr_u, "uintptr_t");
[-] 	setupStdTypedef (StdTypedef_size_t,    TypeKind_SizeT,    "size_t");
[+] 	setupStdTypedef(StdTypedef_size_t,    TypeKind_SizeT,    "size_t");
[-] 	setupStdTypedef (StdTypedef_int8_t,    TypeKind_Int8,     "int8_t");
[+] 	setupStdTypedef(StdTypedef_int8_t,    TypeKind_Int8,     "int8_t");
[-] 	setupStdTypedef (StdTypedef_utf8_t,    TypeKind_Int8,     "utf8_t");
[+] 	setupStdTypedef(StdTypedef_utf8_t,    TypeKind_Int8,     "utf8_t");
[-] 	setupStdTypedef (StdTypedef_uint8_t,   TypeKind_Int8_u,   "uint8_t");
[+] 	setupStdTypedef(StdTypedef_uint8_t,   TypeKind_Int8_u,   "uint8_t");
[-] 	setupStdTypedef (StdTypedef_uchar_t,   TypeKind_Int8_u,   "uchar_t");
[+] 	setupStdTypedef(StdTypedef_uchar_t,   TypeKind_Int8_u,   "uchar_t");
[-] 	setupStdTypedef (StdTypedef_byte_t,    TypeKind_Int8_u,   "byte_t");
[+] 	setupStdTypedef(StdTypedef_byte_t,    TypeKind_Int8_u,   "byte_t");
[-] 	setupStdTypedef (StdTypedef_int16_t,   TypeKind_Int16,    "int16_t");
[+] 	setupStdTypedef(StdTypedef_int16_t,   TypeKind_Int16,    "int16_t");
[-] 	setupStdTypedef (StdTypedef_utf16_t,   TypeKind_Int16,    "utf16_t");
[+] 	setupStdTypedef(StdTypedef_utf16_t,   TypeKind_Int16,    "utf16_t");
[-] 	setupStdTypedef (StdTypedef_uint16_t,  TypeKind_Int16_u,  "uint16_t");
[+] 	setupStdTypedef(StdTypedef_uint16_t,  TypeKind_Int16_u,  "uint16_t");
[-] 	setupStdTypedef (StdTypedef_ushort_t,  TypeKind_Int16_u,  "ushort_t");
[+] 	setupStdTypedef(StdTypedef_ushort_t,  TypeKind_Int16_u,  "ushort_t");
[-] 	setupStdTypedef (StdTypedef_word_t,    TypeKind_Int16_u,  "word_t");
[+] 	setupStdTypedef(StdTypedef_word_t,    TypeKind_Int16_u,  "word_t");
[-] 	setupStdTypedef (StdTypedef_int32_t,   TypeKind_Int32,    "int32_t");
[+] 	setupStdTypedef(StdTypedef_int32_t,   TypeKind_Int32,    "int32_t");
[-] 	setupStdTypedef (StdTypedef_utf32_t,   TypeKind_Int32,    "utf32_t");
[+] 	setupStdTypedef(StdTypedef_utf32_t,   TypeKind_Int32,    "utf32_t");
[-] 	setupStdTypedef (StdTypedef_uint32_t,  TypeKind_Int32_u,  "uint32_t");
[+] 	setupStdTypedef(StdTypedef_uint32_t,  TypeKind_Int32_u,  "uint32_t");
[-] 	setupStdTypedef (StdTypedef_dword_t,   TypeKind_Int32_u,  "dword_t");
[+] 	setupStdTypedef(StdTypedef_dword_t,   TypeKind_Int32_u,  "dword_t");
[-] 	setupStdTypedef (StdTypedef_int64_t,   TypeKind_Int64,    "int64_t");
[+] 	setupStdTypedef(StdTypedef_int64_t,   TypeKind_Int64,    "int64_t");
[-] 	setupStdTypedef (StdTypedef_uint64_t,  TypeKind_Int64_u,  "uint64_t");
[+] 	setupStdTypedef(StdTypedef_uint64_t,  TypeKind_Int64_u,  "uint64_t");
[-] 	setupStdTypedef (StdTypedef_ulong_t,   TypeKind_Int64_u,  "ulong_t");
[+] 	setupStdTypedef(StdTypedef_ulong_t,   TypeKind_Int64_u,  "ulong_t");
[-] 	setupStdTypedef (StdTypedef_qword_t,   TypeKind_Int64_u,  "qword_t");
[+] 	setupStdTypedef(StdTypedef_qword_t,   TypeKind_Int64_u,  "qword_t");
[-] TypeMgr::setupCallConvArray ()
[+] TypeMgr::setupCallConvArray()
[-] 	m_callConvArray [CallConvKind_Jnccall_msc32]  = &m_jnccallCallConv_msc32;
[+] 	m_callConvArray[CallConvKind_Jnccall_msc32]  = &m_jnccallCallConv_msc32;
[-] 	m_callConvArray [CallConvKind_Jnccall_msc64]  = &m_jnccallCallConv_msc64;
[+] 	m_callConvArray[CallConvKind_Jnccall_msc64]  = &m_jnccallCallConv_msc64;
[-] 	m_callConvArray [CallConvKind_Jnccall_gcc32]  = &m_jnccallCallConv_gcc32;
[+] 	m_callConvArray[CallConvKind_Jnccall_gcc32]  = &m_jnccallCallConv_gcc32;
[-] 	m_callConvArray [CallConvKind_Jnccall_gcc64]  = &m_jnccallCallConv_gcc64;
[+] 	m_callConvArray[CallConvKind_Jnccall_gcc64]  = &m_jnccallCallConv_gcc64;
[-] 	m_callConvArray [CallConvKind_Jnccall_arm32]  = &m_jnccallCallConv_arm32;
[+] 	m_callConvArray[CallConvKind_Jnccall_arm32]  = &m_jnccallCallConv_arm32;
[-] 	m_callConvArray [CallConvKind_Jnccall_arm64]  = &m_jnccallCallConv_arm64;
[+] 	m_callConvArray[CallConvKind_Jnccall_arm64]  = &m_jnccallCallConv_arm64;
[-] 	m_callConvArray [CallConvKind_Cdecl_msc32]    = &m_cdeclCallConv_msc32;
[+] 	m_callConvArray[CallConvKind_Cdecl_msc32]    = &m_cdeclCallConv_msc32;
[-] 	m_callConvArray [CallConvKind_Cdecl_msc64]    = &m_cdeclCallConv_msc64;
[+] 	m_callConvArray[CallConvKind_Cdecl_msc64]    = &m_cdeclCallConv_msc64;
[-] 	m_callConvArray [CallConvKind_Cdecl_gcc32]    = &m_cdeclCallConv_gcc32;
[+] 	m_callConvArray[CallConvKind_Cdecl_gcc32]    = &m_cdeclCallConv_gcc32;
[-] 	m_callConvArray [CallConvKind_Cdecl_gcc64]    = &m_cdeclCallConv_gcc64;
[+] 	m_callConvArray[CallConvKind_Cdecl_gcc64]    = &m_cdeclCallConv_gcc64;
[-] 	m_callConvArray [CallConvKind_Cdecl_arm32]    = &m_cdeclCallConv_arm32;
[+] 	m_callConvArray[CallConvKind_Cdecl_arm32]    = &m_cdeclCallConv_arm32;
[-] 	m_callConvArray [CallConvKind_Cdecl_arm64]    = &m_cdeclCallConv_arm64;
[+] 	m_callConvArray[CallConvKind_Cdecl_arm64]    = &m_cdeclCallConv_arm64;
[-] 	m_callConvArray [CallConvKind_Stdcall_msc32]  = &m_stdcallCallConv_msc32;
[+] 	m_callConvArray[CallConvKind_Stdcall_msc32]  = &m_stdcallCallConv_msc32;
[-] 	m_callConvArray [CallConvKind_Stdcall_gcc32]  = &m_stdcallCallConv_gcc32;
[+] 	m_callConvArray[CallConvKind_Stdcall_gcc32]  = &m_stdcallCallConv_gcc32;
[-] 	m_callConvArray [CallConvKind_Thiscall_msc32] = &m_thiscallCallConv_msc32;
[+] 	m_callConvArray[CallConvKind_Thiscall_msc32] = &m_thiscallCallConv_msc32;
[-] TypeMgr::setupPrimitiveType (
[+] TypeMgr::setupPrimitiveType(
[-] 	ASSERT (typeKind < TypeKind__PrimitiveTypeCount);
[+] 	ASSERT(typeKind < TypeKind__PrimitiveTypeCount);
[-] 	Type* type = &m_primitiveTypeArray [typeKind];
[+] 	Type* type = &m_primitiveTypeArray[typeKind];
[-] 	type->m_llvmDiType = llvm::DIType_vn ();
[+] 	type->m_llvmDiType = llvm::DIType_vn();
[-] TypeMgr::setupStdTypedef (
[+] TypeMgr::setupStdTypedef(
[-] 	ASSERT (stdTypedef < StdTypedef__Count);
[+] 	ASSERT(stdTypedef < StdTypedef__Count);
[-] 	ASSERT (typeKind < TypeKind__PrimitiveTypeCount);
[+] 	ASSERT(typeKind < TypeKind__PrimitiveTypeCount);
[-] 	Typedef* tdef = &m_stdTypedefArray [stdTypedef];
[+] 	Typedef* tdef = &m_stdTypedefArray[stdTypedef];
[-] 	tdef->m_type = &m_primitiveTypeArray [typeKind];
[+] 	tdef->m_type = &m_primitiveTypeArray[typeKind];
[-] TypeMgr::parseStdType (StdType stdType)
[+] TypeMgr::parseStdType(StdType stdType)
[-] 	const StdItemSource* source = getStdTypeSource (stdType);
[+] 	const StdItemSource* source = getStdTypeSource(stdType);
[-] 	ASSERT (source->m_source);
[+] 	ASSERT(source->m_source);
[-] 	return parseStdType (
[+] 	return parseStdType(
[-] 		sl::StringRef (source->m_source, source->m_length)
[+] 		sl::StringRef(source->m_source, source->m_length)
[-] TypeMgr::parseStdType (
[+] TypeMgr::parseStdType(
[-] 	lexer.create ("jnc_StdTypes.jnc", source);
[+] 	lexer.create("jnc_StdTypes.jnc", source);
[-] 		m_module->m_namespaceMgr.openStdNamespace (stdNamespace);
[+] 		m_module->m_namespaceMgr.openStdNamespace(stdNamespace);
[-] 	Unit* prevUnit = m_module->m_unitMgr.setCurrentUnit (m_module->m_unitMgr.getCoreLibUnit ());
[+] 	Unit* prevUnit = m_module->m_unitMgr.setCurrentUnit(m_module->m_unitMgr.getCoreLibUnit());
[-] 	ASSERT (prevUnit);
[+] 	ASSERT(prevUnit);
[-] 	Parser parser (m_module);
[+] 	Parser parser(m_module);
[-] 	parser.create (SymbolKind_named_type_specifier_save_type);
[+] 	parser.create(SymbolKind_named_type_specifier_save_type);
[-] 		const Token* token = lexer.getToken ();
[+] 		const Token* token = lexer.getToken();
[-] 		result = parser.parseToken (token);
[+] 		result = parser.parseToken(token);
[-] 			TRACE ("parse std type error: %s\n", err::getLastErrorDescription ().sz ());
[+] 			TRACE("parse std type error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 	m_module->m_unitMgr.setCurrentUnit (prevUnit);
[+] 	m_module->m_unitMgr.setCurrentUnit(prevUnit);
[-] 		m_module->m_namespaceMgr.closeNamespace ();
[+] 		m_module->m_namespaceMgr.closeNamespace();
[-] 	ASSERT (type);
[+] 	ASSERT(type);
[-] 	ModuleCompileState state = m_module->getCompileState ();
[+] 	ModuleCompileState state = m_module->getCompileState();
[-] 		result = m_module->postParseStdItem ();
[+] 		result = m_module->postParseStdItem();
[-] 			printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 		ASSERT (result);
[+] 		ASSERT(result);
[-] 		ASSERT (
[+] 		ASSERT(
[-] 			m_unresolvedNamedImportTypeArray.isEmpty () &&
[+] 			m_unresolvedNamedImportTypeArray.isEmpty() &&
[-] 			m_unresolvedImportPtrTypeArray.isEmpty () &&
[+] 			m_unresolvedImportPtrTypeArray.isEmpty() &&
[-] 			m_unresolvedImportIntModTypeArray.isEmpty ()
[+] 			m_unresolvedImportIntModTypeArray.isEmpty()
[-] TypeMgr::createAbstractClassType ()
[+] TypeMgr::createAbstractClassType()
[-] 	ClassType* type = createClassType (ClassTypeKind_Abstract, "AbstractClass", "jnc.AbstractClass");
[+] 	ClassType* type = createClassType(ClassTypeKind_Abstract, "AbstractClass", "jnc.AbstractClass");
[-] 	TypeStringTuple* tuple = type->getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = type->getTypeStringTuple();
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createAbstractDataType ()
[+] TypeMgr::createAbstractDataType()
[-] 	StructType* type = createStructType ("AbstractData", "jnc.AbstractData");
[+] 	StructType* type = createStructType("AbstractData", "jnc.AbstractData");
[-] 	TypeStringTuple* tuple = type->getTypeStringTuple ();
[+] 	TypeStringTuple* tuple = type->getTypeStringTuple();
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createIfaceHdrType ()
[+] TypeMgr::createIfaceHdrType()
[-] 	StructType* type = createStructType ("IfaceHdr", "jnc.IfaceHdr");
[+] 	StructType* type = createStructType("IfaceHdr", "jnc.IfaceHdr");
[-] 	type->createField ("!m_vtable", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_vtable", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_box", getStdType (StdType_BoxPtr));
[+] 	type->createField("!m_box", getStdType (StdType_BoxPtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createBoxType ()
[+] TypeMgr::createBoxType()
[-] 	StructType* type = createStructType ("Box", "jnc.Box");
[+] 	StructType* type = createStructType("Box", "jnc.Box");
[-] 	type->createField ("!m_type", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_type", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[+] 	type->createField("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createDataBoxType ()
[+] TypeMgr::createDataBoxType()
[-] 	StructType* type = createStructType ("DataBox", "jnc.DataBox");
[+] 	StructType* type = createStructType("DataBox", "jnc.DataBox");
[-] 	type->createField ("!m_type", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_type", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[+] 	type->createField("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[-] 	type->createField ("!m_validator", getStdType (StdType_DataPtrValidator));
[+] 	type->createField("!m_validator", getStdType (StdType_DataPtrValidator));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createDynamicArrayBoxType ()
[+] TypeMgr::createDynamicArrayBoxType()
[-] 	StructType* type = createStructType ("DynamicArrayBox", "jnc.DynamicArrayBox");
[+] 	StructType* type = createStructType("DynamicArrayBox", "jnc.DynamicArrayBox");
[-] 	type->createField ("!m_type", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_type", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[+] 	type->createField("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[-] 	type->createField ("!m_count", getPrimitiveType (TypeKind_Int64_u));
[+] 	type->createField("!m_count", getPrimitiveType (TypeKind_Int64_u));
[-] 	type->createField ("!m_validator", getStdType (StdType_DataPtrValidator));
[+] 	type->createField("!m_validator", getStdType (StdType_DataPtrValidator));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createStaticDataBoxType ()
[+] TypeMgr::createStaticDataBoxType()
[-] 	StructType* type = createStructType ("StaticDataBox", "jnc.StaticDataBox");
[+] 	StructType* type = createStructType("StaticDataBox", "jnc.StaticDataBox");
[-] 	type->createField ("!m_type", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_type", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[+] 	type->createField("!m_flags", getPrimitiveType (TypeKind_IntPtr_u));
[-] 	type->createField ("!m_p", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_p", getStdType (StdType_BytePtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createDataPtrValidatorType ()
[+] TypeMgr::createDataPtrValidatorType()
[-] 	StructType* type = createStructType ("DataPtrValidator", "jnc.DataPtrValidator");
[+] 	StructType* type = createStructType("DataPtrValidator", "jnc.DataPtrValidator");
[-] 	type->createField ("!m_validatorBox", getStdType (StdType_BoxPtr));
[+] 	type->createField("!m_validatorBox", getStdType (StdType_BoxPtr));
[-] 	type->createField ("!m_targetBox", getStdType (StdType_BoxPtr));
[+] 	type->createField("!m_targetBox", getStdType (StdType_BoxPtr));
[-] 	type->createField ("!m_rangeBegin", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_rangeBegin", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_rangeEnd", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_rangeEnd", getStdType (StdType_BytePtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createDataPtrStructType ()
[+] TypeMgr::createDataPtrStructType()
[-] 	StructType* type = createStructType ("DataPtr", "jnc.DataPtr");
[+] 	StructType* type = createStructType("DataPtr", "jnc.DataPtr");
[-] 	type->createField ("!m_p", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_p", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_validator", getStdType (StdType_DataPtrValidatorPtr));
[+] 	type->createField("!m_validator", getStdType (StdType_DataPtrValidatorPtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createFunctionPtrStructType ()
[+] TypeMgr::createFunctionPtrStructType()
[-] 	StructType* type = createStructType ("FunctionPtr", "jnc.FunctionPtr");
[+] 	StructType* type = createStructType("FunctionPtr", "jnc.FunctionPtr");
[-] 	type->createField ("!m_p", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_p", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_closure", getStdType (StdType_AbstractClassPtr));
[+] 	type->createField("!m_closure", getStdType (StdType_AbstractClassPtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createVariantStructType ()
[+] TypeMgr::createVariantStructType()
[-] 	StructType* type = createStructType ("Variant", "jnc.Variant");
[+] 	StructType* type = createStructType("Variant", "jnc.Variant");
[-] 	type->createField ("!m_data1", getPrimitiveType (TypeKind_IntPtr));
[+] 	type->createField("!m_data1", getPrimitiveType (TypeKind_IntPtr));
[-] 	type->createField ("!m_data2", getPrimitiveType (TypeKind_IntPtr));
[+] 	type->createField("!m_data2", getPrimitiveType (TypeKind_IntPtr));
[-] 	type->createField ("!m_padding", getPrimitiveType (TypeKind_Int32));
[+] 	type->createField("!m_padding", getPrimitiveType (TypeKind_Int32));
[-] 	type->createField ("!m_type", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_type", getStdType (StdType_BytePtr));
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createGcShadowStackFrameType ()
[+] TypeMgr::createGcShadowStackFrameType()
[-] 	StructType* type = createStructType ("GcShadowStackFrame", "jnc.GcShadowStackFrame");
[+] 	StructType* type = createStructType("GcShadowStackFrame", "jnc.GcShadowStackFrame");
[-] 	type->createField ("!m_prev", type->getDataPtrType_c ());
[+] 	type->createField("!m_prev", type->getDataPtrType_c ());
[-] 	type->createField ("!m_map", getStdType (StdType_BytePtr));
[+] 	type->createField("!m_map", getStdType (StdType_BytePtr));
[-] 	type->createField ("!m_gcRootArray", getStdType (StdType_BytePtr)->getDataPtrType_c ());
[+] 	type->createField("!m_gcRootArray", getStdType (StdType_BytePtr)->getDataPtrType_c ());
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
[-] TypeMgr::createSjljFrameType ()
[+] TypeMgr::createSjljFrameType()
[-] 	ArrayType* arrayType = getArrayType (getPrimitiveType (TypeKind_Char), sizeof (jmp_buf));
[+] 	ArrayType* arrayType = getArrayType(getPrimitiveType(TypeKind_Char), sizeof(jmp_buf));
[-] 	StructType* type = createStructType ("SjljFrame", "jnc.SjljFrame");
[+] 	StructType* type = createStructType("SjljFrame", "jnc.SjljFrame");
[-] 	type->createField ("!m_jmpBuf", arrayType);
[+] 	type->createField("!m_jmpBuf", arrayType);
[-] 	type->ensureLayout ();
[+] 	type->ensureLayout();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_UnionType.cpp
----------------------
[-] UnionType::UnionType ()
[+] UnionType::UnionType()
[-] UnionType::createFieldImpl (
[+] UnionType::createFieldImpl(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 		err::setFormatStringError ("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[+] 		err::setFormatStringError("'%s' is completed, cannot add fields to it", getTypeString ().sz ());
[-] 	StructField* field = m_module->m_typeMgr.createStructField (
[+] 	StructField* field = m_module->m_typeMgr.createStructField(
[-] 	if (!field->m_constructor.isEmpty () ||
[+] 	if (!field->m_constructor.isEmpty() ||
[-] 		!field->m_initializer.isEmpty ())
[+] 		!field->m_initializer.isEmpty())
[-] 		if (m_initializedMemberFieldArray.isEmpty ())
[+] 		if (m_initializedMemberFieldArray.isEmpty())
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				type->getTypeString ().sz (),
[+] 				type->getTypeString().sz(),
[-] 				m_initializedMemberFieldArray [0]->getName ().sz ()
[+] 				m_initializedMemberFieldArray[0]->getName().sz()
[-] 		m_initializedMemberFieldArray.append (field);
[+] 		m_initializedMemberFieldArray.append(field);
[-] 	m_memberFieldArray.append (field);
[+] 	m_memberFieldArray.append(field);
[-] 	if (name.isEmpty ())
[+] 	if (name.isEmpty())
[-] 		m_unnamedFieldArray.append (field);
[+] 		m_unnamedFieldArray.append(field);
[-] 	else if (name [0] != '!') // internal field
[+] 	else if (name[0] != '!') // internal field
[-] 		bool result = addItem (field);
[+] 		bool result = addItem(field);
[-] 	m_memberFieldArray.append (field);
[+] 	m_memberFieldArray.append(field);
[-] UnionType::calcLayout ()
[+] UnionType::calcLayout()
[-] 	size_t count = m_memberFieldArray.getCount ();
[+] 	size_t count = m_memberFieldArray.getCount();
[-] 		StructField* field = m_memberFieldArray [i];
[+] 		StructField* field = m_memberFieldArray[i];
[-] 		result = field->m_type->ensureLayout ();
[+] 		result = field->m_type->ensureLayout();
[-] 		uint_t fieldTypeFlags = field->m_type->getFlags ();
[+] 		uint_t fieldTypeFlags = field->m_type->getFlags();
[-] 		size_t fieldAlignment = field->m_type->getAlignment ();
[+] 		size_t fieldAlignment = field->m_type->getAlignment();
[-] 			err::setFormatStringError ("non-POD '%s' cannot be a union member", field->m_type->getTypeString ().sz ());
[+] 			err::setFormatStringError("non-POD '%s' cannot be a union member", field->m_type->getTypeString ().sz ());
[-] 			field->pushSrcPosError ();
[+] 			field->pushSrcPosError();
[-] 			err::setFormatStringError ("dynamic '%s' cannot be a union member", field->m_type->getTypeString ().sz ());
[+] 			err::setFormatStringError("dynamic '%s' cannot be a union member", field->m_type->getTypeString ().sz ());
[-] 			field->pushSrcPosError ();
[+] 			field->pushSrcPosError();
[-] 			field->m_type = m_module->m_typeMgr.getBitFieldType (field->m_bitFieldBaseType, 0, field->m_bitCount);
[+] 			field->m_type = m_module->m_typeMgr.getBitFieldType(field->m_bitFieldBaseType, 0, field->m_bitCount);
[-] 		if (!largestFieldType || field->m_type->getSize () > largestFieldType->getSize ())
[+] 		if (!largestFieldType || field->m_type->getSize() > largestFieldType->getSize())
[-] 		if (largestAlignment < field->m_type->getAlignment ())
[+] 		if (largestAlignment < field->m_type->getAlignment())
[-] 			largestAlignment = field->m_type->getAlignment ();
[+] 			largestAlignment = field->m_type->getAlignment();
[-] 	ASSERT (largestFieldType);
[+] 	ASSERT(largestFieldType);
[-] 	m_structType->createField (largestFieldType);
[+] 	m_structType->createField(largestFieldType);
[-] 	m_structType->m_alignment = AXL_MIN (largestAlignment, m_structType->m_fieldAlignment);
[+] 	m_structType->m_alignment = AXL_MIN(largestAlignment, m_structType->m_fieldAlignment);
[-] 	result = m_structType->ensureLayout ();
[+] 	result = m_structType->ensureLayout();
[-] 	if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty ())
[+] 	if (!m_staticConstructor && !m_initializedStaticFieldArray.isEmpty())
[-] 		result = createDefaultMethod (FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[+] 		result = createDefaultMethod(FunctionKind_StaticConstructor, StorageKind_Static) != NULL;
[-] 		!m_initializedMemberFieldArray.isEmpty ()))
[+] 		!m_initializedMemberFieldArray.isEmpty()))
[-] 		result = createDefaultMethod (FunctionKind_Constructor) != NULL;
[+] 		result = createDefaultMethod(FunctionKind_Constructor) != NULL;
[-] 	m_size = m_structType->getSize ();
[+] 	m_size = m_structType->getSize();
[-] 	m_alignment = m_structType->getAlignment ();
[+] 	m_alignment = m_structType->getAlignment();
[-] UnionType::compile ()
[+] UnionType::compile()
[-] 	if (m_staticConstructor && !(m_staticConstructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_staticConstructor && !(m_staticConstructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultStaticConstructor ();
[+] 		result = compileDefaultStaticConstructor();
[-] 	if (m_constructor && !(m_constructor->getFlags () & ModuleItemFlag_User))
[+] 	if (m_constructor && !(m_constructor->getFlags() & ModuleItemFlag_User))
[-] 		result = compileDefaultConstructor ();
[+] 		result = compileDefaultConstructor();
[-] UnionType::prepareLlvmDiType ()
[+] UnionType::prepareLlvmDiType()
[-] 	m_llvmDiType = m_module->m_llvmDiBuilder.createEmptyUnionType (this);
[+] 	m_llvmDiType = m_module->m_llvmDiBuilder.createEmptyUnionType(this);
[-] 	m_module->m_llvmDiBuilder.setUnionTypeBody (this);
[+] 	m_module->m_llvmDiBuilder.setUnionTypeBody(this);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ArrayType.h
----------------------
[-] 	sl::BoxList <Token> m_elementCountInitializer;
[+] 	sl::BoxList<Token> m_elementCountInitializer;
[-] 	ArrayType ();
[+] 	ArrayType();
[-] 	getElementType ()
[+] 	getElementType()
[-] 	getRootType ();
[+] 	getRootType();
[-] 	getElementCount ()
[+] 	getElementCount()
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getElementCountInitializer ()
[+] 	getElementCountInitializer()
[-] 	Function* getGetDynamicSizeFunction ()
[+] 	Function* getGetDynamicSizeFunction()
[-] 	createSignature (
[+] 	createSignature(
[-] 		return sl::formatString (
[+] 		return sl::formatString(
[-] 			elementType->getSignature ().sz ()
[+] 			elementType->getSignature().sz()
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	ensureDynamicLayout (
[+] 	ensureDynamicLayout(
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 		return calcLayoutImpl (NULL, NULL);
[+] 		return calcLayoutImpl(NULL, NULL);
[-] 	compile ();
[+] 	compile();
[-] 	calcLayoutImpl (
[+] 	calcLayoutImpl(
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	createDimensionString ();
[+] 	createDimensionString();
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		ASSERT (m_elementCount != -1);
[+] 		ASSERT(m_elementCount != -1);
[-] 		m_llvmType = llvm::ArrayType::get (m_elementType->getLlvmType (), m_elementCount);
[+] 		m_llvmType = llvm::ArrayType::get(m_elementType->getLlvmType(), m_elementCount);
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_BitFieldType.h
----------------------
[-] 	BitFieldType ();
[+] 	BitFieldType();
[-] 	getBaseType ()
[+] 	getBaseType()
[-] 	getBitOffset ()
[+] 	getBitOffset()
[-] 	getBitCount ()
[+] 	getBitCount()
[-] 	createSignature (
[+] 	createSignature(
[-] 		return sl::formatString (
[+] 		return sl::formatString(
[-] 			baseType->getSignature ().sz (),
[+] 			baseType->getSignature().sz(),
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		m_llvmType = m_baseType->getLlvmType ();
[+] 		m_llvmType = m_baseType->getLlvmType();
[-] 	prepareLlvmDiType ()
[+] 	prepareLlvmDiType()
[-] 		m_llvmDiType = m_baseType->getLlvmDiType ();
[+] 		m_llvmDiType = m_baseType->getLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClassPtrType.h
----------------------
[-] 	ClassPtrType ();
[+] 	ClassPtrType();
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	getCheckedPtrType ()
[+] 	getCheckedPtrType()
[-] 			m_targetType->getClassPtrType (m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[+] 			m_targetType->getClassPtrType(m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[-] 	getUnCheckedPtrType ()
[+] 	getUnCheckedPtrType()
[-] 			m_targetType->getClassPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[+] 			m_targetType->getClassPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[-] 	getUnConstPtrType ()
[+] 	getUnConstPtrType()
[-] 			m_targetType->getClassPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Const) :
[+] 			m_targetType->getClassPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Const) :
[-] 	getNormalPtrType ()
[+] 	getNormalPtrType()
[-] 			m_targetType->getClassPtrType (ClassPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getClassPtrType(ClassPtrTypeKind_Normal, m_flags) :
[-] 	getWeakPtrType ()
[+] 	getWeakPtrType()
[-] 			m_targetType->getClassPtrType (ClassPtrTypeKind_Weak, m_flags) :
[+] 			m_targetType->getClassPtrType(ClassPtrTypeKind_Weak, m_flags) :
[-] 	getUnWeakPtrType ()
[+] 	getUnWeakPtrType()
[-] 			m_targetType->getClassPtrType (ClassPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getClassPtrType(ClassPtrTypeKind_Normal, m_flags) :
[-] 	createSignature (
[+] 	createSignature(
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	prepareTypeString ()
[+] 	prepareTypeString()
[-] 		getTypeStringTuple ()->m_typeStringPrefix = m_targetType->getTypeString () + getPointerStringSuffix ();
[+] 		getTypeStringTuple()->m_typeStringPrefix = m_targetType->getTypeString() + getPointerStringSuffix();
[-] 	prepareDoxyLinkedText ()
[+] 	prepareDoxyLinkedText()
[-] 		getTypeStringTuple ()->m_doxyLinkedTextPrefix = m_targetType->getDoxyLinkedTextPrefix () + getPointerStringSuffix ();
[+] 		getTypeStringTuple()->m_doxyLinkedTextPrefix = m_targetType->getDoxyLinkedTextPrefix() + getPointerStringSuffix();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcFoldedDualType (
[+] 	calcFoldedDualType(
[-] 	getPointerStringSuffix ();
[+] 	getPointerStringSuffix();
[-] 	ClassPtrType* m_ptrTypeArray [2] [2] [3] [2] [2]; // ref x kind x const x volatile x checked
[+] 	ClassPtrType* m_ptrTypeArray[2] [2] [3] [2] [2]; // ref x kind x const x volatile x checked
[-] isClassPtrType (
[+] isClassPtrType(
[-] 		(type->getTypeKindFlags () & TypeKindFlag_ClassPtr) &&
[+] 		(type->getTypeKindFlags() & TypeKindFlag_ClassPtr) &&
[-] 		((ClassPtrType*) type)->getTargetType ()->getClassTypeKind () == classTypeKind;
[+] 		((ClassPtrType*)type)->getTargetType()->getClassTypeKind() == classTypeKind;
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClassType.h
----------------------
[-] 	sl::Array <BaseTypeSlot*> m_baseTypePrimeArray;
[+] 	sl::Array<BaseTypeSlot*> m_baseTypePrimeArray;
[-] 	sl::Array <StructField*> m_classMemberFieldArray;
[+] 	sl::Array<StructField*> m_classMemberFieldArray;
[-] 	sl::Array <Function*> m_virtualMethodArray;
[+] 	sl::Array<Function*> m_virtualMethodArray;
[-] 	sl::Array <Function*> m_overrideMethodArray;
[+] 	sl::Array<Function*> m_overrideMethodArray;
[-] 	sl::Array <Property*> m_virtualPropertyArray;
[+] 	sl::Array<Property*> m_virtualPropertyArray;
[-] 	sl::Array <Function*> m_vtable;
[+] 	sl::Array<Function*> m_vtable;
[-] 	ClassType ();
[+] 	ClassType();
[-] 	getClassTypeKind ()
[+] 	getClassTypeKind()
[-] 	getIfaceStructType ()
[+] 	getIfaceStructType()
[-] 		ASSERT (m_ifaceStructType);
[+] 		ASSERT(m_ifaceStructType);
[-] 	getClassStructType ()
[+] 	getClassStructType()
[-] 		ASSERT (m_classStructType);
[+] 		ASSERT(m_classStructType);
[-] 	getClassPtrType (
[+] 	getClassPtrType(
[-] 	getClassPtrType (
[+] 	getClassPtrType(
[-] 		return getClassPtrType (TypeKind_ClassPtr, ptrTypeKind, flags);
[+] 		return getClassPtrType(TypeKind_ClassPtr, ptrTypeKind, flags);
[-] 	getThisArgType (uint_t ptrTypeFlags)
[+] 	getThisArgType(uint_t ptrTypeFlags)
[-] 		return (Type*) getClassPtrType (ClassPtrTypeKind_Normal, ptrTypeFlags);
[+] 		return (Type*)getClassPtrType(ClassPtrTypeKind_Normal, ptrTypeFlags);
[-] 	getMarkOpaqueGcRootsFunc ()
[+] 	getMarkOpaqueGcRootsFunc()
[-] 	addMethod (Function* function);
[+] 	addMethod(Function* function);
[-] 	addProperty (Property* prop);
[+] 	addProperty(Property* prop);
[-] 	hasVTable ()
[+] 	hasVTable()
[-] 		return !m_vtable.isEmpty ();
[+] 		return !m_vtable.isEmpty();
[-] 	sl::Array <BaseTypeSlot*>
[+] 	sl::Array<BaseTypeSlot*>
[-] 	getBaseTypePrimeArray ()
[+] 	getBaseTypePrimeArray()
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getClassMemberFieldArray ()
[+] 	getClassMemberFieldArray()
[-] 	sl::Array <Function*>
[+] 	sl::Array<Function*>
[-] 	getVirtualMethodArray ()
[+] 	getVirtualMethodArray()
[-] 	sl::Array <Property*>
[+] 	sl::Array<Property*>
[-] 	getVirtualPropertyArray ()
[+] 	getVirtualPropertyArray()
[-] 	getVTableStructType ();
[+] 	getVTableStructType();
[-] 	getVTableVariable ()
[+] 	getVTableVariable()
[-] 	compile ();
[+] 	compile();
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	markGcRootsImpl (
[+] 	markGcRootsImpl(
[-] 	createFieldImpl (
[+] 	createFieldImpl(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		m_llvmType = getClassStructType ()->getLlvmType ();
[+] 		m_llvmType = getClassStructType()->getLlvmType();
[-] 	prepareLlvmDiType ()
[+] 	prepareLlvmDiType()
[-] 		m_llvmDiType = getClassStructType ()->getLlvmDiType ();
[+] 		m_llvmDiType = getClassStructType()->getLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	addVirtualFunction (Function* function);
[+] 	addVirtualFunction(Function* function);
[-] 	overrideVirtualFunction (Function* function);
[+] 	overrideVirtualFunction(Function* function);
[-] 	createVTableVariable ();
[+] 	createVTableVariable();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ClosureClassType.h
----------------------
[-] 	sl::Array <size_t> m_closureMap;
[+] 	sl::Array<size_t> m_closureMap;
[-] 	ClosureClassType ()
[+] 	ClosureClassType()
[-] 	getThisArgFieldIdx ()
[+] 	getThisArgFieldIdx()
[-] 	createSignature (
[+] 	createSignature(
[-] 	compile () = 0;
[+] 	compile() = 0;
[-] 	strengthen (IfaceHdr* p);
[+] 	strengthen(IfaceHdr* p);
[-] 	buildArgValueList (
[+] 	buildArgValueList(
[-] 		sl::BoxList <Value>* argValueList
[+] 		sl::BoxList<Value>* argValueList
[-] 	FunctionClosureClassType ();
[+] 	FunctionClosureClassType();
[-] 	getThunkFunction ()
[+] 	getThunkFunction()
[-] 	compile ();
[+] 	compile();
[-] 	PropertyClosureClassType ();
[+] 	PropertyClosureClassType();
[-] 	getThunkProperty ()
[+] 	getThunkProperty()
[-] 	compile ();
[+] 	compile();
[-] 	compileAccessor (Function* accessor);
[+] 	compileAccessor(Function* accessor);
[-] 	DataClosureClassType ();
[+] 	DataClosureClassType();
[-] 	getThunkProperty ()
[+] 	getThunkProperty()
[-] 	createSignature (
[+] 	createSignature(
[-] 	compile ();
[+] 	compile();
[-] 	compileGetter (Function* getter);
[+] 	compileGetter(Function* getter);
[-] 	compileSetter (Function* setter);
[+] 	compileSetter(Function* setter);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_DataPtrType.h
----------------------
[-] 	DataPtrType ();
[+] 	DataPtrType();
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	getCheckedPtrType ()
[+] 	getCheckedPtrType()
[-] 			m_targetType->getDataPtrType (m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[+] 			m_targetType->getDataPtrType(m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[-] 	getUnCheckedPtrType ()
[+] 	getUnCheckedPtrType()
[-] 			m_targetType->getDataPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[+] 			m_targetType->getDataPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[-] 	getUnConstPtrType ()
[+] 	getUnConstPtrType()
[-] 			m_targetType->getDataPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Const) :
[+] 			m_targetType->getDataPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Const) :
[-] 	createSignature (
[+] 	createSignature(
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcFoldedDualType (
[+] 	calcFoldedDualType(
[-] 	getPointerStringSuffix ();
[+] 	getPointerStringSuffix();
[-] 	DataPtrType* m_ptrTypeArray [2] [3] [3] [2] [2]; // ref x kind x const x volatile x safe
[+] 	DataPtrType* m_ptrTypeArray[2] [3] [3] [2] [2]; // ref x kind x const x volatile x safe
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_DerivableType.h
----------------------
[-] 	BaseTypeSlot ();
[+] 	BaseTypeSlot();
[-] 	getFlags () const
[+] 	getFlags() const
[-] 	getType () const
[+] 	getType() const
[-] 	getOffset () const
[+] 	getOffset() const
[-] 	getVTableIndex () const
[+] 	getVTableIndex() const
[-] 	getLlvmIndex () const
[+] 	getLlvmIndex() const
[-] 	AXL_DISABLE_COPY (BaseTypeCoord)
[+] 	AXL_DISABLE_COPY(BaseTypeCoord)
[-] 	char m_buffer [256];
[+] 	char m_buffer[256];
[-] 	sl::Array <int32_t> m_llvmIndexArray;
[+] 	sl::Array<int32_t> m_llvmIndexArray;
[-] 	BaseTypeCoord ();
[+] 	BaseTypeCoord();
[-] 	char m_buffer [256];
[+] 	char m_buffer[256];
[-] 	sl::Array <UnionCoord> m_unionCoordArray;
[+] 	sl::Array<UnionCoord> m_unionCoordArray;
[-] 	MemberCoord ():
[+] 	MemberCoord():
[-] 		m_unionCoordArray (ref::BufKind_Field, m_buffer, sizeof (m_buffer))
[+] 		m_unionCoordArray(ref::BufKind_Field, m_buffer, sizeof(m_buffer))
[-] 	sl::StringHashTable <BaseTypeSlot*> m_baseTypeMap;
[+] 	sl::StringHashTable<BaseTypeSlot*> m_baseTypeMap;
[-] 	sl::List <BaseTypeSlot> m_baseTypeList;
[+] 	sl::List<BaseTypeSlot> m_baseTypeList;
[-] 	sl::Array <BaseTypeSlot*> m_baseTypeArray;
[+] 	sl::Array<BaseTypeSlot*> m_baseTypeArray;
[-] 	sl::Array <BaseTypeSlot*> m_gcRootBaseTypeArray;
[+] 	sl::Array<BaseTypeSlot*> m_gcRootBaseTypeArray;
[-] 	sl::Array <BaseTypeSlot*> m_baseTypeConstructArray;
[+] 	sl::Array<BaseTypeSlot*> m_baseTypeConstructArray;
[-] 	sl::Array <BaseTypeSlot*> m_baseTypeDestructArray;
[+] 	sl::Array<BaseTypeSlot*> m_baseTypeDestructArray;
[-] 	sl::Array <Function*> m_unaryOperatorTable;
[+] 	sl::Array<Function*> m_unaryOperatorTable;
[-] 	sl::Array <Function*> m_binaryOperatorTable;
[+] 	sl::Array<Function*> m_binaryOperatorTable;
[-] 	sl::Array <Function*> m_castOperatorTable;
[+] 	sl::Array<Function*> m_castOperatorTable;
[-] 	sl::StringHashTable <Function*> m_castOperatorMap;
[+] 	sl::StringHashTable<Function*> m_castOperatorMap;
[-] 	sl::StringHashTable <Property*> m_indexerPropertyMap;
[+] 	sl::StringHashTable<Property*> m_indexerPropertyMap;
[-] 	DerivableType ();
[+] 	DerivableType();
[-] 	getThisArgType (uint_t ptrTypeFlags)
[+] 	getThisArgType(uint_t ptrTypeFlags)
[-] 		return (Type*) getDataPtrType (DataPtrTypeKind_Normal, ptrTypeFlags);
[+] 		return (Type*)getDataPtrType(DataPtrTypeKind_Normal, ptrTypeFlags);
[-] 	getMemberMethodType (
[+] 	getMemberMethodType(
[-] 	getMemberPropertyType (PropertyType* shortType);
[+] 	getMemberPropertyType(PropertyType* shortType);
[-] 	sl::ConstList <BaseTypeSlot>
[+] 	sl::ConstList<BaseTypeSlot>
[-] 	getBaseTypeList ()
[+] 	getBaseTypeList()
[-] 	sl::Array <BaseTypeSlot*>
[+] 	sl::Array<BaseTypeSlot*>
[-] 	getBaseTypeArray ()
[+] 	getBaseTypeArray()
[-] 	getBaseTypeByIndex (size_t index);
[+] 	getBaseTypeByIndex(size_t index);
[-] 	addBaseType (Type* type);
[+] 	addBaseType(Type* type);
[-] 	findBaseType (Type* type)
[+] 	findBaseType(Type* type)
[-] 		sl::StringHashTableIterator <BaseTypeSlot*> it = m_baseTypeMap.find (type->getSignature ());
[+] 		sl::StringHashTableIterator<BaseTypeSlot*> it = m_baseTypeMap.find(type->getSignature());
[-] 	findBaseTypeTraverse (
[+] 	findBaseTypeTraverse(
[-] 		return findBaseTypeTraverseImpl (type, coord, 0);
[+] 		return findBaseTypeTraverseImpl(type, coord, 0);
[-] 	findBaseTypeOffset (Type* type);
[+] 	findBaseTypeOffset(Type* type);
[-] 	sl::Array <BaseTypeSlot*>
[+] 	sl::Array<BaseTypeSlot*>
[-] 	getGcRootBaseTypeArray ()
[+] 	getGcRootBaseTypeArray()
[-] 	getSetAsType ()
[+] 	getSetAsType()
[-] 	getPreConstructor ()
[+] 	getPreConstructor()
[-] 	getDefaultConstructor ();
[+] 	getDefaultConstructor();
[-] 	getUnaryOperator (UnOpKind opKind)
[+] 	getUnaryOperator(UnOpKind opKind)
[-] 		return (size_t) opKind < m_unaryOperatorTable.getCount () ? m_unaryOperatorTable [opKind] : NULL;
[+] 		return (size_t)opKind < m_unaryOperatorTable.getCount() ? m_unaryOperatorTable[opKind] : NULL;
[-] 	getBinaryOperator (BinOpKind opKind)
[+] 	getBinaryOperator(BinOpKind opKind)
[-] 		return (size_t) opKind < m_binaryOperatorTable.getCount () ? m_binaryOperatorTable [opKind] : NULL;
[+] 		return (size_t)opKind < m_binaryOperatorTable.getCount() ? m_binaryOperatorTable[opKind] : NULL;
[-] 	getCastOperator (size_t i)
[+] 	getCastOperator(size_t i)
[-] 		return i < m_castOperatorTable.getCount () ? m_castOperatorTable [i] : NULL;
[+] 		return i < m_castOperatorTable.getCount() ? m_castOperatorTable[i] : NULL;
[-] 	getCastOperator (Type* type)
[+] 	getCastOperator(Type* type)
[-] 		sl::StringHashTableIterator <Function*> it = m_castOperatorMap.find (type->getSignature ());
[+] 		sl::StringHashTableIterator<Function*> it = m_castOperatorMap.find(type->getSignature());
[-] 	getCallOperator ()
[+] 	getCallOperator()
[-] 	getOperatorVararg ()
[+] 	getOperatorVararg()
[-] 	getOperatorCdeclVararg ()
[+] 	getOperatorCdeclVararg()
[-] 	hasIndexerProperties ()
[+] 	hasIndexerProperties()
[-] 		return !m_indexerPropertyMap.isEmpty ();
[+] 		return !m_indexerPropertyMap.isEmpty();
[-] 	chooseIndexerProperty (const Value& opValue);
[+] 	chooseIndexerProperty(const Value& opValue);
[-] 	getFieldByIndex (size_t index);
[+] 	getFieldByIndex(size_t index);
[-] 	addMethod (Function* function);
[+] 	addMethod(Function* function);
[-] 	addProperty (Property* prop);
[+] 	addProperty(Property* prop);
[-] 	callBaseTypeConstructors (const Value& thisValue);
[+] 	callBaseTypeConstructors(const Value& thisValue);
[-] 	callBaseTypeDestructors (const Value& thisValue);
[+] 	callBaseTypeDestructors(const Value& thisValue);
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	getIndexerProperty (Type* argType);
[+] 	getIndexerProperty(Type* argType);
[-] 	findItemInExtensionNamespaces (const sl::StringRef& name);
[+] 	findItemInExtensionNamespaces(const sl::StringRef& name);
[-] 	createDefaultMethod (
[+] 	createDefaultMethod(
[-] 	compileDefaultStaticConstructor ();
[+] 	compileDefaultStaticConstructor();
[-] 	compileDefaultConstructor ();
[+] 	compileDefaultConstructor();
[-] 	compileDefaultDestructor ();
[+] 	compileDefaultDestructor();
[-] 	findBaseTypeTraverseImpl (
[+] 	findBaseTypeTraverseImpl(
[-] 	findItemTraverseImpl (
[+] 	findItemTraverseImpl(
[-] 		return findItemTraverseImpl (name, coord, flags, 0);
[+] 		return findItemTraverseImpl(name, coord, flags, 0);
[-] 	findItemTraverseImpl (
[+] 	findItemTraverseImpl(
[-] isConstructibleType (Type* type)
[+] isConstructibleType(Type* type)
[-] 		(type->getTypeKindFlags () & TypeKindFlag_Derivable) &&
[+] 		(type->getTypeKindFlags() & TypeKindFlag_Derivable) &&
[-] 		((DerivableType*) type)->getConstructor () != NULL;
[+] 		((DerivableType*)type)->getConstructor() != NULL;
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_EnumType.h
----------------------
[-] getFirstEnumTypeFlag (uint_t flags)
[+] getFirstEnumTypeFlag(uint_t flags)
[-] 	return (EnumTypeFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (EnumTypeFlag)(1 << sl::getLoBitIdx(flags));
[-] getEnumTypeFlagString (EnumTypeFlag flag);
[+] getEnumTypeFlagString(EnumTypeFlag flag);
[-] getEnumTypeFlagString (uint_t flags);
[+] getEnumTypeFlagString(uint_t flags);
[-] 	EnumConst ()
[+] 	EnumConst()
[-] 	getParentEnumType ()
[+] 	getParentEnumType()
[-] 	getValue ()
[+] 	getValue()
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	sl::List <EnumConst> m_constList;
[+] 	sl::List<EnumConst> m_constList;
[-] 	sl::Array <EnumConst*> m_constArray;
[+] 	sl::Array<EnumConst*> m_constArray;
[-] 	EnumType ();
[+] 	EnumType();
[-] 	getBaseType ()
[+] 	getBaseType()
[-] 	sl::Array <EnumConst*>
[+] 	sl::Array<EnumConst*>
[-] 	getConstArray ()
[+] 	getConstArray()
[-] 	createConst (
[+] 	createConst(
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		m_llvmType = m_baseType->getLlvmType ();
[+] 		m_llvmType = m_baseType->getLlvmType();
[-] 	prepareLlvmDiType ()
[+] 	prepareLlvmDiType()
[-] 		m_llvmDiType = m_baseType->getLlvmDiType ();
[+] 		m_llvmDiType = m_baseType->getLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
[-] isBitFlagEnumType (Type* type)
[+] isBitFlagEnumType(Type* type)
[-] 		type->getTypeKind () == TypeKind_Enum &&
[+] 		type->getTypeKind() == TypeKind_Enum &&
[-] 		(((EnumType*) type)->getFlags () & EnumTypeFlag_BitFlag);
[+] 		(((EnumType*)type)->getFlags() & EnumTypeFlag_BitFlag);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionArg.h
----------------------
[-] 	FunctionArg ();
[+] 	FunctionArg();
[-] 	getType ()
[+] 	getType()
[-] 	getPtrTypeFlags ()
[+] 	getPtrTypeFlags()
[-] 	getArgString ();
[+] 	getArgString();
[-] 	getArgDoxyLinkedText ();
[+] 	getArgDoxyLinkedText();
[-] 	FunctionArg* m_argArray [2] [2] [2]; // this x const x volatile
[+] 	FunctionArg* m_argArray[2] [2] [2]; // this x const x volatile
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionPtrType.h
----------------------
[-] 	FunctionPtrType ();
[+] 	FunctionPtrType();
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	hasClosure ()
[+] 	hasClosure()
[-] 	getCheckedPtrType ()
[+] 	getCheckedPtrType()
[-] 			m_targetType->getFunctionPtrType (m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[+] 			m_targetType->getFunctionPtrType(m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[-] 	getUnCheckedPtrType ()
[+] 	getUnCheckedPtrType()
[-] 			m_targetType->getFunctionPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[+] 			m_targetType->getFunctionPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[-] 	getNormalPtrType ()
[+] 	getNormalPtrType()
[-] 			m_targetType->getFunctionPtrType (FunctionPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getFunctionPtrType(FunctionPtrTypeKind_Normal, m_flags) :
[-] 	getWeakPtrType ()
[+] 	getWeakPtrType()
[-] 			m_targetType->getFunctionPtrType (FunctionPtrTypeKind_Weak, m_flags) :
[+] 			m_targetType->getFunctionPtrType(FunctionPtrTypeKind_Weak, m_flags) :
[-] 	getUnWeakPtrType ()
[+] 	getUnWeakPtrType()
[-] 			m_targetType->getFunctionPtrType (FunctionPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getFunctionPtrType(FunctionPtrTypeKind_Normal, m_flags) :
[-] 	getMulticastType ();
[+] 	getMulticastType();
[-] 	getTypeModifierString ();
[+] 	getTypeModifierString();
[-] 	createSignature (
[+] 	createSignature(
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	FunctionPtrType* m_ptrTypeArray [2] [3] [2]; // ref x kind x checked
[+] 	FunctionPtrType* m_ptrTypeArray[2] [3] [2]; // ref x kind x checked
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionType.h
----------------------
[-] 	sl::Array <FunctionArg*> m_argArray;
[+] 	sl::Array<FunctionArg*> m_argArray;
[-] 	sl::Array <uint_t> m_argFlagArray; // args can be shared between func types
[+] 	sl::Array<uint_t> m_argFlagArray; // args can be shared between func types
[-] 	FunctionType ();
[+] 	FunctionType();
[-] 	getCallConv ()
[+] 	getCallConv()
[-] 	getReturnType ()
[+] 	getReturnType()
[-] 	getAsyncReturnType ()
[+] 	getAsyncReturnType()
[-] 		ASSERT (m_flags & FunctionTypeFlag_Async);
[+] 		ASSERT(m_flags & FunctionTypeFlag_Async);
[-] 	sl::Array <FunctionArg*>
[+] 	sl::Array<FunctionArg*>
[-] 	getArgArray ()
[+] 	getArgArray()
[-] 	sl::Array <uint_t>
[+] 	sl::Array<uint_t>
[-] 	getArgFlagArray ()
[+] 	getArgFlagArray()
[-] 	getArgSignature ();
[+] 	getArgSignature();
[-] 	getTypeModifierString ();
[+] 	getTypeModifierString();
[-] 	isMemberMethodType ()
[+] 	isMemberMethodType()
[-] 		return !m_argArray.isEmpty () && m_argArray [0]->getStorageKind () == StorageKind_This;
[+] 		return !m_argArray.isEmpty() && m_argArray[0]->getStorageKind() == StorageKind_This;
[-] 	getThisArgType ()
[+] 	getThisArgType()
[-] 		return isMemberMethodType () ? m_argArray [0]->getType () : NULL;
[+] 		return isMemberMethodType() ? m_argArray[0]->getType() : NULL;
[-] 	getThisTargetType ();
[+] 	getThisTargetType();
[-] 	getShortType ()
[+] 	getShortType()
[-] 	getMemberMethodType (
[+] 	getMemberMethodType(
[-] 	getStdObjectMemberMethodType ();
[+] 	getStdObjectMemberMethodType();
[-] 	getAbstractFunction ();
[+] 	getAbstractFunction();
[-] 	getFunctionPtrType (
[+] 	getFunctionPtrType(
[-] 	getFunctionPtrType (
[+] 	getFunctionPtrType(
[-] 		return getFunctionPtrType (TypeKind_FunctionPtr, ptrTypeKind, flags);
[+] 		return getFunctionPtrType(TypeKind_FunctionPtr, ptrTypeKind, flags);
[-] 	getMulticastType ();
[+] 	getMulticastType();
[-] 	createSignature (
[+] 	createSignature(
[-] 	createSignature (
[+] 	createSignature(
[-] 	createFlagSignature (uint_t flags);
[+] 	createFlagSignature(uint_t flags);
[-] 	createArgSignature (
[+] 	createArgSignature(
[-] 	createArgSignature (
[+] 	createArgSignature(
[-] 	createArgSignature ()
[+] 	createArgSignature()
[-] 		return createArgSignature (m_argArray, m_argArray.getCount (), m_flags);
[+] 		return createArgSignature(m_argArray, m_argArray.getCount(), m_flags);
[-] 	compile ();
[+] 	compile();
[-] 	getDoxyArgString ();
[+] 	getDoxyArgString();
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_FunctionTypeOverload.h
----------------------
[-] 	sl::Array <FunctionType*> m_overloadArray;
[+] 	sl::Array<FunctionType*> m_overloadArray;
[-] 	FunctionTypeOverload ()
[+] 	FunctionTypeOverload()
[-] 	FunctionTypeOverload (FunctionType* type)
[+] 	FunctionTypeOverload(FunctionType* type)
[-] 	FunctionTypeOverload (
[+] 	FunctionTypeOverload(
[-] 		copy (typeArray, count);
[+] 		copy(typeArray, count);
[-] 		m_overloadArray.clear ();
[+] 		m_overloadArray.clear();
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	isOverloaded () const
[+] 	isOverloaded() const
[-] 		return !m_overloadArray.isEmpty ();
[+] 		return !m_overloadArray.isEmpty();
[-] 	getOverloadCount () const
[+] 	getOverloadCount() const
[-] 		return m_type ? m_overloadArray.getCount () + 1 : 0;
[+] 		return m_type ? m_overloadArray.getCount() + 1 : 0;
[-] 	getOverload (size_t overloadIdx = 0) const
[+] 	getOverload(size_t overloadIdx = 0) const
[-] 			overloadIdx <= m_overloadArray.getCount () ? m_overloadArray [overloadIdx - 1] : NULL;
[+] 			overloadIdx <= m_overloadArray.getCount() ? m_overloadArray[overloadIdx - 1] : NULL;
[-] 	findOverload (FunctionType* type) const;
[+] 	findOverload(FunctionType* type) const;
[-] 	findShortOverload (FunctionType* type) const;
[+] 	findShortOverload(FunctionType* type) const;
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return chooseOverload (argArray, argArray.getCount (), castKind);
[+] 		return chooseOverload(argArray, argArray.getCount(), castKind);
[-] 	chooseOverload (
[+] 	chooseOverload(
[-] 		const sl::ConstBoxList <Value>& argList,
[+] 		const sl::ConstBoxList<Value>& argList,
[-] 	chooseSetterOverload (
[+] 	chooseSetterOverload(
[-] 	chooseSetterOverload (
[+] 	chooseSetterOverload(
[-] 		return chooseSetterOverload (functionType->getArgArray ().getBack ()->getType (), castKind);
[+] 		return chooseSetterOverload(functionType->getArgArray().getBack()->getType(), castKind);
[-] 	addOverload (FunctionType* type);
[+] 	addOverload(FunctionType* type);
[-] 	copy (
[+] 	copy(
[-] 	ensureLayout ();
[+] 	ensureLayout();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ImportType.h
----------------------
[-] 	sl::Array <Type**> m_fixupArray;
[+] 	sl::Array<Type**> m_fixupArray;
[-] 	ImportType ()
[+] 	ImportType()
[-] 	isResolved ()
[+] 	isResolved()
[-] 	getActualType ()
[+] 	getActualType()
[-] 		ASSERT (m_actualType);
[+] 		ASSERT(m_actualType);
[-] 	sl::Array <Type**>
[+] 	sl::Array<Type**>
[-] 	getFixupArray ()
[+] 	getFixupArray()
[-] 	addFixup (Type** type)
[+] 	addFixup(Type** type)
[-] 		m_fixupArray.append (type);
[+] 		m_fixupArray.append(type);
[-] 	applyFixups ();
[+] 	applyFixups();
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	prepareLlvmDiType ()
[+] 	prepareLlvmDiType()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	NamedImportType ();
[+] 	NamedImportType();
[-] 	getName ()
[+] 	getName()
[-] 	getAnchorNamespace ()
[+] 	getAnchorNamespace()
[-] 	getAnchorName ()
[+] 	getAnchorName()
[-] 	setAnchorName (const QualifiedName& name);
[+] 	setAnchorName(const QualifiedName& name);
[-] 	getQualifiedName ()
[+] 	getQualifiedName()
[-] 	getImportPtrType (
[+] 	getImportPtrType(
[-] 	createSignature (
[+] 	createSignature(
[-] 	prepareTypeString ()
[+] 	prepareTypeString()
[-] 		getTypeStringTuple ()->m_typeStringPrefix.format ("import %s", getQualifiedName ().sz ());
[+] 		getTypeStringTuple()->m_typeStringPrefix.format("import %s", getQualifiedName ().sz ());
[-] 	ImportPtrType ();
[+] 	ImportPtrType();
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	getTypeModifiers ()
[+] 	getTypeModifiers()
[-] 	getCheckedPtrType ()
[+] 	getCheckedPtrType()
[-] 			m_targetType->getImportPtrType (m_typeModifiers, m_flags | PtrTypeFlag_Safe) :
[+] 			m_targetType->getImportPtrType(m_typeModifiers, m_flags | PtrTypeFlag_Safe) :
[-] 	getUnCheckedPtrType ()
[+] 	getUnCheckedPtrType()
[-] 			m_targetType->getImportPtrType (m_typeModifiers, m_flags & ~PtrTypeFlag_Safe) :
[+] 			m_targetType->getImportPtrType(m_typeModifiers, m_flags & ~PtrTypeFlag_Safe) :
[-] 	createSignature (
[+] 	createSignature(
[-] 		return sl::formatString (
[+] 		return sl::formatString(
[-] 			importType->getQualifiedName ().sz (),
[+] 			importType->getQualifiedName().sz(),
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	ImportIntModType ();
[+] 	ImportIntModType();
[-] 	getImportType ()
[+] 	getImportType()
[-] 	getTypeModifiers ()
[+] 	getTypeModifiers()
[-] 	createSignature (
[+] 	createSignature(
[-] 		return sl::formatString (
[+] 		return sl::formatString(
[-] 			importType->getQualifiedName ().sz (),
[+] 			importType->getQualifiedName().sz(),
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_McSnapshotClassType.h
----------------------
[-] 	StructField* m_fieldArray [McSnapshotFieldKind__Count];
[+] 	StructField* m_fieldArray[McSnapshotFieldKind__Count];
[-] 	Function* m_methodArray [McSnapshotMethodKind__Count];
[+] 	Function* m_methodArray[McSnapshotMethodKind__Count];
[-] 	McSnapshotClassType ();
[+] 	McSnapshotClassType();
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	getFunctionType ()
[+] 	getFunctionType()
[-] 		return m_targetType->getTargetType ();
[+] 		return m_targetType->getTargetType();
[-] 	getField (McSnapshotFieldKind field)
[+] 	getField(McSnapshotFieldKind field)
[-] 		ASSERT (field < McSnapshotFieldKind__Count);
[+] 		ASSERT(field < McSnapshotFieldKind__Count);
[-] 		return m_fieldArray [field];
[+] 		return m_fieldArray[field];
[-] 	getMethod (McSnapshotMethodKind method)
[+] 	getMethod(McSnapshotMethodKind method)
[-] 		ASSERT (method < McSnapshotMethodKind__Count);
[+] 		ASSERT(method < McSnapshotMethodKind__Count);
[-] 		return m_methodArray [method];
[+] 		return m_methodArray[method];
[-] 	compile ()
[+] 	compile()
[-] 			ClassType::compile () &&
[+] 			ClassType::compile() &&
[-] 			compileCallMethod ();
[+] 			compileCallMethod();
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	compileCallMethod ();
[+] 	compileCallMethod();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_MulticastClassType.h
----------------------
[-] 	StructField* m_fieldArray [MulticastFieldKind__Count];
[+] 	StructField* m_fieldArray[MulticastFieldKind__Count];
[-] 	Function* m_methodArray [MulticastMethodKind__Count];
[+] 	Function* m_methodArray[MulticastMethodKind__Count];
[-] 	MulticastClassType ();
[+] 	MulticastClassType();
[-] 	getTargetType () const
[+] 	getTargetType() const
[-] 	getFunctionType () const
[+] 	getFunctionType() const
[-] 		return m_targetType->getTargetType ();
[+] 		return m_targetType->getTargetType();
[-] 	getField (MulticastFieldKind field) const
[+] 	getField(MulticastFieldKind field) const
[-] 		ASSERT (field < MulticastFieldKind__Count);
[+] 		ASSERT(field < MulticastFieldKind__Count);
[-] 		return m_fieldArray [field];
[+] 		return m_fieldArray[field];
[-] 	getMethod (MulticastMethodKind method) const
[+] 	getMethod(MulticastMethodKind method) const
[-] 		ASSERT (method < MulticastMethodKind__Count);
[+] 		ASSERT(method < MulticastMethodKind__Count);
[-] 		return m_methodArray [method];
[+] 		return m_methodArray[method];
[-] 	getSnapshotType () const
[+] 	getSnapshotType() const
[-] 	compile ()
[+] 	compile()
[-] 			ClassType::compile () &&
[+] 			ClassType::compile() &&
[-] 			compileCallMethod ();
[+] 			compileCallMethod();
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 			ClassType::calcLayout () &&
[+] 			ClassType::calcLayout() &&
[-] 			m_snapshotType->ensureLayout ();
[+] 			m_snapshotType->ensureLayout();
[-] 	compileCallMethod ();
[+] 	compileCallMethod();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_NamedTypeBlock.h
----------------------
[-] 	sl::Array <Variable*> m_staticFieldArray;
[+] 	sl::Array<Variable*> m_staticFieldArray;
[-] 	sl::Array <StructField*> m_memberFieldArray;
[+] 	sl::Array<StructField*> m_memberFieldArray;
[-] 	sl::Array <Function*> m_memberMethodArray;
[+] 	sl::Array<Function*> m_memberMethodArray;
[-] 	sl::Array <Property*> m_memberPropertyArray;
[+] 	sl::Array<Property*> m_memberPropertyArray;
[-] 	sl::Array <StructField*> m_unnamedFieldArray;
[+] 	sl::Array<StructField*> m_unnamedFieldArray;
[-] 	sl::Array <StructField*> m_gcRootMemberFieldArray;
[+] 	sl::Array<StructField*> m_gcRootMemberFieldArray;
[-] 	sl::Array <Variable*> m_initializedStaticFieldArray;
[+] 	sl::Array<Variable*> m_initializedStaticFieldArray;
[-] 	sl::Array <StructField*> m_initializedMemberFieldArray;
[+] 	sl::Array<StructField*> m_initializedMemberFieldArray;
[-] 	sl::Array <StructField*> m_memberFieldConstructArray;
[+] 	sl::Array<StructField*> m_memberFieldConstructArray;
[-] 	sl::Array <Property*> m_memberPropertyConstructArray;
[+] 	sl::Array<Property*> m_memberPropertyConstructArray;
[-] 	sl::Array <Property*> m_memberPropertyDestructArray;
[+] 	sl::Array<Property*> m_memberPropertyDestructArray;
[-] 	NamedTypeBlock (ModuleItem* parent);
[+] 	NamedTypeBlock(ModuleItem* parent);
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getStaticFieldArray () const
[+] 	getStaticFieldArray() const
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getMemberFieldArray () const
[+] 	getMemberFieldArray() const
[-] 	sl::Array <Function*>
[+] 	sl::Array<Function*>
[-] 	getMemberMethodArray () const
[+] 	getMemberMethodArray() const
[-] 	sl::Array <Property*>
[+] 	sl::Array<Property*>
[-] 	getMemberPropertyArray () const
[+] 	getMemberPropertyArray() const
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getInitializedStaticFieldArray () const
[+] 	getInitializedStaticFieldArray() const
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getInitializedMemberFieldArray () const
[+] 	getInitializedMemberFieldArray() const
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getUnnamedFieldArray () const
[+] 	getUnnamedFieldArray() const
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getGcRootMemberFieldArray () const
[+] 	getGcRootMemberFieldArray() const
[-] 	getPreConstructor () const
[+] 	getPreConstructor() const
[-] 	getConstructor () const
[+] 	getConstructor() const
[-] 	getDestructor () const
[+] 	getDestructor() const
[-] 	getStaticConstructor () const
[+] 	getStaticConstructor() const
[-] 	getStaticDestructor () const
[+] 	getStaticDestructor() const
[-] 	createField (
[+] 	createField(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 		return createFieldImpl (name, type, bitCount, ptrTypeFlags, constructor, initializer);
[+] 		return createFieldImpl(name, type, bitCount, ptrTypeFlags, constructor, initializer);
[-] 	createField (
[+] 	createField(
[-] 		return createFieldImpl (sl::String (), type, bitCount, ptrTypeFlags);
[+] 		return createFieldImpl(sl::String(), type, bitCount, ptrTypeFlags);
[-] 	createMethod (
[+] 	createMethod(
[-] 	createUnnamedMethod (
[+] 	createUnnamedMethod(
[-] 	createProperty (
[+] 	createProperty(
[-] 	addMethod (Function* function) = 0;
[+] 	addMethod(Function* function) = 0;
[-] 	addProperty (Property* prop) = 0;
[+] 	addProperty(Property* prop) = 0;
[-] 	initializeStaticFields ();
[+] 	initializeStaticFields();
[-] 	initializeMemberFields (const Value& thisValue);
[+] 	initializeMemberFields(const Value& thisValue);
[-] 	callMemberFieldConstructors (const Value& thisValue);
[+] 	callMemberFieldConstructors(const Value& thisValue);
[-] 	callMemberPropertyConstructors (const Value& thisValue);
[+] 	callMemberPropertyConstructors(const Value& thisValue);
[-] 	callMemberPropertyDestructors (const Value& thisValue);
[+] 	callMemberPropertyDestructors(const Value& thisValue);
[-] 	getParentNamespaceImpl ();
[+] 	getParentNamespaceImpl();
[-] 	getParentUnitImpl ();
[+] 	getParentUnitImpl();
[-] 	createFieldImpl (
[+] 	createFieldImpl(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_PropertyPtrType.h
----------------------
[-] 	PropertyPtrType ();
[+] 	PropertyPtrType();
[-] 	getPtrTypeKind ()
[+] 	getPtrTypeKind()
[-] 	getTargetType ()
[+] 	getTargetType()
[-] 	hasClosure ()
[+] 	hasClosure()
[-] 	getCheckedPtrType ()
[+] 	getCheckedPtrType()
[-] 			m_targetType->getPropertyPtrType (m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[+] 			m_targetType->getPropertyPtrType(m_typeKind, m_ptrTypeKind, m_flags | PtrTypeFlag_Safe) :
[-] 	getUnCheckedPtrType ()
[+] 	getUnCheckedPtrType()
[-] 			m_targetType->getPropertyPtrType (m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[+] 			m_targetType->getPropertyPtrType(m_typeKind, m_ptrTypeKind, m_flags & ~PtrTypeFlag_Safe) :
[-] 	getNormalPtrType ()
[+] 	getNormalPtrType()
[-] 			m_targetType->getPropertyPtrType (PropertyPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getPropertyPtrType(PropertyPtrTypeKind_Normal, m_flags) :
[-] 	getWeakPtrType ()
[+] 	getWeakPtrType()
[-] 			m_targetType->getPropertyPtrType (PropertyPtrTypeKind_Weak, m_flags) :
[+] 			m_targetType->getPropertyPtrType(PropertyPtrTypeKind_Weak, m_flags) :
[-] 	getUnWeakPtrType ()
[+] 	getUnWeakPtrType()
[-] 			m_targetType->getPropertyPtrType (PropertyPtrTypeKind_Normal, m_flags) :
[+] 			m_targetType->getPropertyPtrType(PropertyPtrTypeKind_Normal, m_flags) :
[-] 	createSignature (
[+] 	createSignature(
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	PropertyPtrType* m_ptrTypeArray [2] [3] [3]; // ref x kind x unsafe / checked
[+] 	PropertyPtrType* m_ptrTypeArray[2] [3] [3]; // ref x kind x unsafe / checked
[-] isBindableType (Type* type)
[+] isBindableType(Type* type)
[-] 		type->getTypeKind () == TypeKind_PropertyRef &&
[+] 		type->getTypeKind() == TypeKind_PropertyRef &&
[-] 		(((PropertyPtrType*) type)->getTargetType ()->getFlags () & PropertyTypeFlag_Bindable) != 0;
[+] 		(((PropertyPtrType*)type)->getTargetType()->getFlags() & PropertyTypeFlag_Bindable) != 0;
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_PropertyType.h
----------------------
[-] getFirstPropertyTypeFlag (uint_t flags)
[+] getFirstPropertyTypeFlag(uint_t flags)
[-] 	return (PropertyTypeFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (PropertyTypeFlag)(1 << sl::getLoBitIdx(flags));
[-] getPropertyTypeFlagString (PropertyTypeFlag flag);
[+] getPropertyTypeFlagString(PropertyTypeFlag flag);
[-] getPropertyTypeFlagString (uint_t flags);
[+] getPropertyTypeFlagString(uint_t flags);
[-] getFirstPropertyTypeFlagString (uint_t flags)
[+] getFirstPropertyTypeFlagString(uint_t flags)
[-] 	return getPropertyTypeFlagString (getFirstPropertyTypeFlag (flags));
[+] 	return getPropertyTypeFlagString(getFirstPropertyTypeFlag(flags));
[-] getPropertyPtrTypeKindString (PropertyPtrTypeKind ptrTypeKind);
[+] getPropertyPtrTypeKindString(PropertyPtrTypeKind ptrTypeKind);
[-] 	PropertyType ();
[+] 	PropertyType();
[-] 	isReadOnly ()
[+] 	isReadOnly()
[-] 		return m_setterType.isEmpty ();
[+] 		return m_setterType.isEmpty();
[-] 	isIndexed ()
[+] 	isIndexed()
[-] 		return !m_getterType->getArgArray ().isEmpty ();
[+] 		return !m_getterType->getArgArray().isEmpty();
[-] 	isMemberPropertyType ()
[+] 	isMemberPropertyType()
[-] 		return m_getterType->isMemberMethodType ();
[+] 		return m_getterType->isMemberMethodType();
[-] 	getThisArgType ()
[+] 	getThisArgType()
[-] 		return m_getterType->getThisArgType ();
[+] 		return m_getterType->getThisArgType();
[-] 	getThisTargetType ()
[+] 	getThisTargetType()
[-] 		return m_getterType->getThisTargetType ();
[+] 		return m_getterType->getThisTargetType();
[-] 	getGetterType ()
[+] 	getGetterType()
[-] 	getSetterType ()
[+] 	getSetterType()
[-] 	getBinderType ()
[+] 	getBinderType()
[-] 	getReturnType ()
[+] 	getReturnType()
[-] 		ASSERT (m_getterType);
[+] 		ASSERT(m_getterType);
[-] 		return m_getterType->getReturnType ();
[+] 		return m_getterType->getReturnType();
[-] 	getMemberPropertyType (ClassType* type);
[+] 	getMemberPropertyType(ClassType* type);
[-] 	getStdObjectMemberPropertyType ();
[+] 	getStdObjectMemberPropertyType();
[-] 	getPropertyPtrType (
[+] 	getPropertyPtrType(
[-] 	getPropertyPtrType (
[+] 	getPropertyPtrType(
[-] 		return getPropertyPtrType (TypeKind_PropertyPtr, ptrTypeKind, flags);
[+] 		return getPropertyPtrType(TypeKind_PropertyPtr, ptrTypeKind, flags);
[-] 	getVTableStructType ();
[+] 	getVTableStructType();
[-] 	getBindableEventName ()
[+] 	getBindableEventName()
[-] 	getTypeModifierString ();
[+] 	getTypeModifierString();
[-] 	createSignature (
[+] 	createSignature(
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	PropertyType* m_propertyTypeArray [3] [2] [2]; // call-conv-family x const x bindable
[+] 	PropertyType* m_propertyTypeArray[3] [2] [2]; // call-conv-family x const x bindable
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_ReactorClassType.h
----------------------
[-] getReactorMethod (
[+] getReactorMethod(
[-] 	sl::HashTable <size_t, Function*, sl::HashId <size_t> > m_onEventMap;
[+] 	sl::HashTable<size_t, Function*, sl::HashId<size_t> > m_onEventMap;
[-] 	sl::BoxList <Token> m_body;
[+] 	sl::BoxList<Token> m_body;
[-] 	ReactorClassType ();
[+] 	ReactorClassType();
[-] 	getParentType ()
[+] 	getParentType()
[-] 	getParentOffset ()
[+] 	getParentOffset()
[-] 	getReactionCount ()
[+] 	getReactionCount()
[-] 	getReaction ()
[+] 	getReaction()
[-] 	createOnEventHandler (
[+] 	createOnEventHandler(
[-] 	findOnEventHandler (size_t reactionIdx)
[+] 	findOnEventHandler(size_t reactionIdx)
[-] 		return m_onEventMap.findValue (reactionIdx, NULL);
[+] 		return m_onEventMap.findValue(reactionIdx, NULL);
[-] 	hasBody ()
[+] 	hasBody()
[-] 		return !m_body.isEmpty ();
[+] 		return !m_body.isEmpty();
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getBody ()
[+] 	getBody()
[-] 	setBody (sl::BoxList <Token>* tokenList);
[+] 	setBody(sl::BoxList<Token>* tokenList);
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	compile ();
[+] 	compile();
[-] isReactorClassTypeMember (ModuleItemDecl* itemDecl)
[+] isReactorClassTypeMember(ModuleItemDecl* itemDecl)
[-] 	Namespace* nspace = itemDecl->getParentNamespace ();
[+] 	Namespace* nspace = itemDecl->getParentNamespace();
[-] 		nspace->getNamespaceKind () == NamespaceKind_Type &&
[+] 		nspace->getNamespaceKind() == NamespaceKind_Type &&
[-] 		isClassType ((ClassType*) nspace, ClassTypeKind_Reactor);
[+] 		isClassType((ClassType*)nspace, ClassTypeKind_Reactor);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_StdType.h
----------------------
[-] getStdTypeSource (StdType stdType);
[+] getStdTypeSource(StdType stdType);
[-] 	LazyStdType ()
[+] 	LazyStdType()
[-] 	getActualItem ();
[+] 	getActualItem();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_StructType.h
----------------------
[-] 	sl::BoxList <Token> m_constructor;
[+] 	sl::BoxList<Token> m_constructor;
[-] 	StructField ();
[+] 	StructField();
[-] 	getType ()
[+] 	getType()
[-] 	getPtrTypeFlags ()
[+] 	getPtrTypeFlags()
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getConstructor ()
[+] 	getConstructor()
[-] 	getOffset ()
[+] 	getOffset()
[-] 	getLlvmIndex ()
[+] 	getLlvmIndex()
[-] 	getPrevDynamicFieldIndex ()
[+] 	getPrevDynamicFieldIndex()
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	sl::Array <StructField*> m_dynamicFieldArray;
[+] 	sl::Array<StructField*> m_dynamicFieldArray;
[-] 	sl::Array <llvm::Type*> m_llvmFieldTypeArray;
[+] 	sl::Array<llvm::Type*> m_llvmFieldTypeArray;
[-] 	StructType ();
[+] 	StructType();
[-] 	getStructTypeKind ()
[+] 	getStructTypeKind()
[-] 	getFieldAlignment ()
[+] 	getFieldAlignment()
[-] 	getFieldActualSize ()
[+] 	getFieldActualSize()
[-] 	getFieldAlignedSize ()
[+] 	getFieldAlignedSize()
[-] 	sl::Array <StructField*>
[+] 	sl::Array<StructField*>
[-] 	getDynamicFieldArray ()
[+] 	getDynamicFieldArray()
[-] 	append (StructType* type);
[+] 	append(StructType* type);
[-] 	compile ();
[+] 	compile();
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	createFieldImpl (
[+] 	createFieldImpl(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
[-] 	layoutField (StructField* field);
[+] 	layoutField(StructField* field);
[-] 	layoutField (
[+] 	layoutField(
[-] 	layoutField (
[+] 	layoutField(
[-] 			type->ensureLayout () &&
[+] 			type->ensureLayout() &&
[-] 			layoutField (
[+] 			layoutField(
[-] 				type->getLlvmType (),
[+] 				type->getLlvmType(),
[-] 				type->getSize (),
[+] 				type->getSize(),
[-] 				type->getAlignment (),
[+] 				type->getAlignment(),
[-] 	layoutBitField (
[+] 	layoutBitField(
[-] 	getFieldOffset (size_t alignment);
[+] 	getFieldOffset(size_t alignment);
[-] 	setFieldActualSize (size_t size);
[+] 	setFieldActualSize(size_t size);
[-] 	insertPadding (size_t size);
[+] 	insertPadding(size_t size);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_Type.h
----------------------
[-] getFirstPtrTypeFlag (uint_t flags)
[+] getFirstPtrTypeFlag(uint_t flags)
[-] 	return (PtrTypeFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (PtrTypeFlag)(1 << sl::getLoBitIdx(flags));
[-] getPtrTypeFlagString (PtrTypeFlag flag);
[+] getPtrTypeFlagString(PtrTypeFlag flag);
[-] getPtrTypeFlagString (uint_t flags);
[+] getPtrTypeFlagString(uint_t flags);
[-] getPtrTypeFlagSignature (uint_t flags);
[+] getPtrTypeFlagSignature(uint_t flags);
[-] getFirstPtrTypeFlagString (uint_t flags)
[+] getFirstPtrTypeFlagString(uint_t flags)
[-] 	return getPtrTypeFlagString (getFirstPtrTypeFlag (flags));
[+] 	return getPtrTypeFlagString(getFirstPtrTypeFlag(flags));
[-] getPtrTypeFlagsFromModifiers (uint_t modifiers);
[+] getPtrTypeFlagsFromModifiers(uint_t modifiers);
[-] getInt32TypeKind (int32_t integer);
[+] getInt32TypeKind(int32_t integer);
[-] getInt32TypeKind_u (uint32_t integer);
[+] getInt32TypeKind_u(uint32_t integer);
[-] getInt64TypeKind (int64_t integer);
[+] getInt64TypeKind(int64_t integer);
[-] getInt64TypeKind_u (uint64_t integer);
[+] getInt64TypeKind_u(uint64_t integer);
[-] getBigEndianIntegerTypeKind (TypeKind typeKind)
[+] getBigEndianIntegerTypeKind(TypeKind typeKind)
[-] 	return !(getTypeKindFlags (typeKind) & TypeKindFlag_BigEndian) ?
[+] 	return !(getTypeKindFlags(typeKind) & TypeKindFlag_BigEndian) ?
[-] 		(TypeKind) (typeKind + TypeKind__EndianDelta) :
[+] 		(TypeKind)(typeKind + TypeKind__EndianDelta) :
[-] getLittleEndianIntegerTypeKind (TypeKind typeKind)
[+] getLittleEndianIntegerTypeKind(TypeKind typeKind)
[-] 	return (getTypeKindFlags (typeKind) & TypeKindFlag_BigEndian) ?
[+] 	return (getTypeKindFlags(typeKind) & TypeKindFlag_BigEndian) ?
[-] 		(TypeKind) (typeKind - TypeKind__EndianDelta) :
[+] 		(TypeKind)(typeKind - TypeKind__EndianDelta) :
[-] getUnsignedIntegerTypeKind (TypeKind typeKind)
[+] getUnsignedIntegerTypeKind(TypeKind typeKind)
[-] 	return !(getTypeKindFlags (typeKind) & TypeKindFlag_Unsigned) ?
[+] 	return !(getTypeKindFlags(typeKind) & TypeKindFlag_Unsigned) ?
[-] 		(TypeKind) (typeKind + 1) :
[+] 		(TypeKind)(typeKind + 1) :
[-] getSignedIntegerTypeKind (TypeKind typeKind)
[+] getSignedIntegerTypeKind(TypeKind typeKind)
[-] 	return (getTypeKindFlags (typeKind) & TypeKindFlag_Unsigned) ?
[+] 	return (getTypeKindFlags(typeKind) & TypeKindFlag_Unsigned) ?
[-] 		(TypeKind) (typeKind - 1) :
[+] 		(TypeKind)(typeKind - 1) :
[-] isEquivalentIntegerTypeKind (
[+] isEquivalentIntegerTypeKind(
[-] 	return getSignedIntegerTypeKind (typeKind1) == getSignedIntegerTypeKind (typeKind2);
[+] 	return getSignedIntegerTypeKind(typeKind1) == getSignedIntegerTypeKind(typeKind2);
[-] getLlvmTypeString (llvm::Type* llvmType);
[+] getLlvmTypeString(llvm::Type* llvmType);
[-] 	Type* m_typeArray [2] [2]; // alien-friend x container-const-non-const
[+] 	Type* m_typeArray[2] [2]; // alien-friend x container-const-non-const
[-] 	sl::StringHashTableIterator <Type*> m_typeMapIt;
[+] 	sl::StringHashTableIterator<Type*> m_typeMapIt;
[-] 	Type ();
[+] 	Type();
[-] 	~Type ();
[+] 	~Type();
[-] 	getTypeKind ()
[+] 	getTypeKind()
[-] 	getTypeKindFlags ()
[+] 	getTypeKindFlags()
[-] 		return jnc::getTypeKindFlags (m_typeKind);
[+] 		return jnc::getTypeKindFlags(m_typeKind);
[-] 	getStdType ()
[+] 	getStdType()
[-] 	getSize ()
[+] 	getSize()
[-] 	getAlignment ()
[+] 	getAlignment()
[-] 	getSignature ()
[+] 	getSignature()
[-] 	getTypeString ();
[+] 	getTypeString();
[-] 	getTypeStringPrefix ();
[+] 	getTypeStringPrefix();
[-] 	getTypeStringSuffix ();
[+] 	getTypeStringSuffix();
[-] 	getDoxyTypeString ();
[+] 	getDoxyTypeString();
[-] 	getDoxyLinkedTextPrefix ();
[+] 	getDoxyLinkedTextPrefix();
[-] 	getDoxyLinkedTextSuffix ();
[+] 	getDoxyLinkedTextSuffix();
[-] 	getLlvmTypeString ()
[+] 	getLlvmTypeString()
[-] 		return ct::getLlvmTypeString (getLlvmType ());
[+] 		return ct::getLlvmTypeString(getLlvmType());
[-] 	getLlvmType ();
[+] 	getLlvmType();
[-] 	getLlvmDiType ();
[+] 	getLlvmDiType();
[-] 	getUndefValue ();
[+] 	getUndefValue();
[-] 	getZeroValue ();
[+] 	getZeroValue();
[-] 	getErrorCodeValue ();
[+] 	getErrorCodeValue();
[-] 	cmp (Type* type)
[+] 	cmp(Type* type)
[-] 		return type != this ? m_signature.cmp (type->m_signature) : 0;
[+] 		return type != this ? m_signature.cmp(type->m_signature) : 0;
[-] 	getArrayType (size_t elementCount);
[+] 	getArrayType(size_t elementCount);
[-] 	getDataPtrType (
[+] 	getDataPtrType(
[-] 	getDataPtrType (
[+] 	getDataPtrType(
[-] 		return getDataPtrType (TypeKind_DataPtr, ptrTypeKind, flags);
[+] 		return getDataPtrType(TypeKind_DataPtr, ptrTypeKind, flags);
[-] 	getDataPtrType_c (
[+] 	getDataPtrType_c(
[-] 		return getDataPtrType (typeKind, DataPtrTypeKind_Thin, flags);
[+] 		return getDataPtrType(typeKind, DataPtrTypeKind_Thin, flags);
[-] 	getSimpleFunctionArg (uint_t ptrTypeFlags = 0);
[+] 	getSimpleFunctionArg(uint_t ptrTypeFlags = 0);
[-] 	foldDualType (
[+] 	foldDualType(
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 	getTypeStringTuple ();
[+] 	getTypeStringTuple();
[-] 	prepareTypeString ();
[+] 	prepareTypeString();
[-] 	prepareDoxyTypeString ();
[+] 	prepareDoxyTypeString();
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareLlvmType ();
[+] 	prepareLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcLayout ()
[+] 	calcLayout()
[-] 		ASSERT (m_size && m_alignment);
[+] 		ASSERT(m_size && m_alignment);
[-] 	calcFoldedDualType (
[+] 	calcFoldedDualType(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	NamedType ()
[+] 	NamedType()
[-] 	prepareTypeString ()
[+] 	prepareTypeString()
[-] 		getTypeStringTuple ()->m_typeStringPrefix = m_tag;
[+] 		getTypeStringTuple()->m_typeStringPrefix = m_tag;
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	Typedef ();
[+] 	Typedef();
[-] 	getType ()
[+] 	getType()
[-] 	getShadowType ();
[+] 	getShadowType();
[-] 	generateDocumentation (
[+] 	generateDocumentation(
[-] 	TypedefShadowType ()
[+] 	TypedefShadowType()
[-] 	getTypedef ()
[+] 	getTypedef()
[-] 	prepareTypeString ()
[+] 	prepareTypeString()
[-] 		getTypeStringTuple ()->m_typeStringPrefix = m_tag;
[+] 		getTypeStringTuple()->m_typeStringPrefix = m_tag;
[-] 	prepareDoxyLinkedText ();
[+] 	prepareDoxyLinkedText();
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	prepareLlvmDiType ()
[+] 	prepareLlvmDiType()
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	calcLayout ();
[+] 	calcLayout();
[-] getSimpleType (
[+] getSimpleType(
[-] getSimpleType (
[+] getSimpleType(
[-] getModuleItemType (ModuleItem* item);
[+] getModuleItemType(ModuleItem* item);
[-] getDirectRefType (
[+] getDirectRefType(
[-] isDualType (Type* type)
[+] isDualType(Type* type)
[-] 	return (type->getFlags () & PtrTypeFlag__Dual) != 0;
[+] 	return (type->getFlags() & PtrTypeFlag__Dual) != 0;
[-] isDisposableType (Type* type);
[+] isDisposableType(Type* type);
[-] isWeakPtrType (Type* type);
[+] isWeakPtrType(Type* type);
[-] isSafePtrType (Type* type);
[+] isSafePtrType(Type* type);
[-] isWeakPtrType (Type* type);
[+] isWeakPtrType(Type* type);
[-] getWeakPtrType (Type* type);
[+] getWeakPtrType(Type* type);
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_TypeMgr.h
----------------------
[-] 	Type m_primitiveTypeArray [TypeKind__PrimitiveTypeCount];
[+] 	Type m_primitiveTypeArray[TypeKind__PrimitiveTypeCount];
[-] 	Type* m_stdTypeArray [StdType__Count];
[+] 	Type* m_stdTypeArray[StdType__Count];
[-] 	Typedef m_stdTypedefArray [StdTypedef__Count];
[+] 	Typedef m_stdTypedefArray[StdTypedef__Count];
[-] 	LazyStdType* m_lazyStdTypeArray [StdType__Count];
[+] 	LazyStdType* m_lazyStdTypeArray[StdType__Count];
[-] 	CallConv* m_callConvArray [CallConvKind__Count];
[+] 	CallConv* m_callConvArray[CallConvKind__Count];
[-] 	sl::List <ArrayType> m_arrayTypeList;
[+] 	sl::List<ArrayType> m_arrayTypeList;
[-] 	sl::List <BitFieldType> m_bitFieldTypeList;
[+] 	sl::List<BitFieldType> m_bitFieldTypeList;
[-] 	sl::List <EnumType> m_enumTypeList;
[+] 	sl::List<EnumType> m_enumTypeList;
[-] 	sl::List <StructType> m_structTypeList;
[+] 	sl::List<StructType> m_structTypeList;
[-] 	sl::List <UnionType> m_unionTypeList;
[+] 	sl::List<UnionType> m_unionTypeList;
[-] 	sl::List <ClassType> m_classTypeList;
[+] 	sl::List<ClassType> m_classTypeList;
[-] 	sl::List <FunctionType> m_functionTypeList;
[+] 	sl::List<FunctionType> m_functionTypeList;
[-] 	sl::List <PropertyType> m_propertyTypeList;
[+] 	sl::List<PropertyType> m_propertyTypeList;
[-] 	sl::List <DataPtrType> m_dataPtrTypeList;
[+] 	sl::List<DataPtrType> m_dataPtrTypeList;
[-] 	sl::List <ClassPtrType> m_classPtrTypeList;
[+] 	sl::List<ClassPtrType> m_classPtrTypeList;
[-] 	sl::List <FunctionPtrType> m_functionPtrTypeList;
[+] 	sl::List<FunctionPtrType> m_functionPtrTypeList;
[-] 	sl::List <PropertyPtrType> m_propertyPtrTypeList;
[+] 	sl::List<PropertyPtrType> m_propertyPtrTypeList;
[-] 	sl::List <NamedImportType> m_namedImportTypeList;
[+] 	sl::List<NamedImportType> m_namedImportTypeList;
[-] 	sl::List <ImportPtrType> m_importPtrTypeList;
[+] 	sl::List<ImportPtrType> m_importPtrTypeList;
[-] 	sl::List <ImportIntModType> m_importIntModTypeList;
[+] 	sl::List<ImportIntModType> m_importIntModTypeList;
[-] 	sl::List <ReactorClassType> m_reactorClassTypeList;
[+] 	sl::List<ReactorClassType> m_reactorClassTypeList;
[-] 	sl::List <FunctionClosureClassType> m_functionClosureClassTypeList;
[+] 	sl::List<FunctionClosureClassType> m_functionClosureClassTypeList;
[-] 	sl::List <PropertyClosureClassType> m_propertyClosureClassTypeList;
[+] 	sl::List<PropertyClosureClassType> m_propertyClosureClassTypeList;
[-] 	sl::List <DataClosureClassType> m_dataClosureClassTypeList;
[+] 	sl::List<DataClosureClassType> m_dataClosureClassTypeList;
[-] 	sl::List <MulticastClassType> m_multicastClassTypeList;
[+] 	sl::List<MulticastClassType> m_multicastClassTypeList;
[-] 	sl::List <McSnapshotClassType> m_mcSnapshotClassTypeList;
[+] 	sl::List<McSnapshotClassType> m_mcSnapshotClassTypeList;
[-] 	sl::List <TypedefShadowType> m_typedefShadowTypeList;
[+] 	sl::List<TypedefShadowType> m_typedefShadowTypeList;
[-] 	sl::List <Typedef> m_typedefList;
[+] 	sl::List<Typedef> m_typedefList;
[-] 	sl::List <LazyStdType> m_lazyStdTypeList;
[+] 	sl::List<LazyStdType> m_lazyStdTypeList;
[-] 	sl::List <FunctionArg> m_functionArgList;
[+] 	sl::List<FunctionArg> m_functionArgList;
[-] 	sl::List <StructField> m_structFieldList;
[+] 	sl::List<StructField> m_structFieldList;
[-] 	sl::List <SimplePropertyTypeTuple> m_simplePropertyTypeTupleList;
[+] 	sl::List<SimplePropertyTypeTuple> m_simplePropertyTypeTupleList;
[-] 	sl::List <FunctionArgTuple> m_functionArgTupleList;
[+] 	sl::List<FunctionArgTuple> m_functionArgTupleList;
[-] 	sl::List <DataPtrTypeTuple> m_dataPtrTypeTupleList;
[+] 	sl::List<DataPtrTypeTuple> m_dataPtrTypeTupleList;
[-] 	sl::List <ClassPtrTypeTuple> m_classPtrTypeTupleList;
[+] 	sl::List<ClassPtrTypeTuple> m_classPtrTypeTupleList;
[-] 	sl::List <FunctionPtrTypeTuple> m_functionPtrTypeTupleList;
[+] 	sl::List<FunctionPtrTypeTuple> m_functionPtrTypeTupleList;
[-] 	sl::List <PropertyPtrTypeTuple> m_propertyPtrTypeTupleList;
[+] 	sl::List<PropertyPtrTypeTuple> m_propertyPtrTypeTupleList;
[-] 	sl::List <DualTypeTuple> m_dualTypeTupleList;
[+] 	sl::List<DualTypeTuple> m_dualTypeTupleList;
[-] 	sl::StringHashTable <Type*> m_typeMap;
[+] 	sl::StringHashTable<Type*> m_typeMap;
[-] 	sl::Array <NamedImportType*> m_unresolvedNamedImportTypeArray;
[+] 	sl::Array<NamedImportType*> m_unresolvedNamedImportTypeArray;
[-] 	sl::Array <ImportPtrType*> m_unresolvedImportPtrTypeArray;
[+] 	sl::Array<ImportPtrType*> m_unresolvedImportPtrTypeArray;
[-] 	sl::Array <ImportIntModType*> m_unresolvedImportIntModTypeArray;
[+] 	sl::Array<ImportIntModType*> m_unresolvedImportIntModTypeArray;
[-] 	TypeMgr ();
[+] 	TypeMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	resolveImportTypes ();
[+] 	resolveImportTypes();
[-] 	updateTypeSignature (
[+] 	updateTypeSignature(
[-] 	sl::ConstList <ArrayType>
[+] 	sl::ConstList<ArrayType>
[-] 	getArrayTypeList ()
[+] 	getArrayTypeList()
[-] 	sl::ConstList <BitFieldType>
[+] 	sl::ConstList<BitFieldType>
[-] 	getBitFieldTypeList ()
[+] 	getBitFieldTypeList()
[-] 	sl::ConstList <EnumType>
[+] 	sl::ConstList<EnumType>
[-] 	getEnumTypeList ()
[+] 	getEnumTypeList()
[-] 	sl::ConstList <StructType>
[+] 	sl::ConstList<StructType>
[-] 	getStructTypeList ()
[+] 	getStructTypeList()
[-] 	sl::ConstList <UnionType>
[+] 	sl::ConstList<UnionType>
[-] 	getUnionTypeList ()
[+] 	getUnionTypeList()
[-] 	sl::ConstList <ClassType>
[+] 	sl::ConstList<ClassType>
[-] 	getClassTypeList ()
[+] 	getClassTypeList()
[-] 	sl::ConstList <FunctionType>
[+] 	sl::ConstList<FunctionType>
[-] 	getFunctionTypeList ()
[+] 	getFunctionTypeList()
[-] 	sl::ConstList <PropertyType>
[+] 	sl::ConstList<PropertyType>
[-] 	getPropertyTypeList ()
[+] 	getPropertyTypeList()
[-] 	sl::ConstList <DataPtrType>
[+] 	sl::ConstList<DataPtrType>
[-] 	getDataPtrTypeList ()
[+] 	getDataPtrTypeList()
[-] 	sl::ConstList <ClassPtrType>
[+] 	sl::ConstList<ClassPtrType>
[-] 	getClassPtrTypeList ()
[+] 	getClassPtrTypeList()
[-] 	sl::ConstList <FunctionPtrType>
[+] 	sl::ConstList<FunctionPtrType>
[-] 	getFunctionPtrTypeList ()
[+] 	getFunctionPtrTypeList()
[-] 	sl::ConstList <PropertyPtrType>
[+] 	sl::ConstList<PropertyPtrType>
[-] 	getPropertyPtrTypeList ()
[+] 	getPropertyPtrTypeList()
[-] 	sl::ConstList <NamedImportType>
[+] 	sl::ConstList<NamedImportType>
[-] 	getNamedImportTypeList ()
[+] 	getNamedImportTypeList()
[-] 	sl::ConstList <ImportPtrType>
[+] 	sl::ConstList<ImportPtrType>
[-] 	getImportPtrTypeList ()
[+] 	getImportPtrTypeList()
[-] 	sl::ConstList <ImportIntModType>
[+] 	sl::ConstList<ImportIntModType>
[-] 	getImportIntModTypeList ()
[+] 	getImportIntModTypeList()
[-] 	sl::ConstList <ReactorClassType>
[+] 	sl::ConstList<ReactorClassType>
[-] 	getReactorClassTypeList ()
[+] 	getReactorClassTypeList()
[-] 	sl::ConstList <FunctionClosureClassType>
[+] 	sl::ConstList<FunctionClosureClassType>
[-] 	getFunctionClosureClassTypeList ()
[+] 	getFunctionClosureClassTypeList()
[-] 	sl::ConstList <PropertyClosureClassType>
[+] 	sl::ConstList<PropertyClosureClassType>
[-] 	getPropertyClosureClassTypeList ()
[+] 	getPropertyClosureClassTypeList()
[-] 	sl::ConstList <DataClosureClassType>
[+] 	sl::ConstList<DataClosureClassType>
[-] 	getDataClosureClassTypeList ()
[+] 	getDataClosureClassTypeList()
[-] 	sl::ConstList <MulticastClassType>
[+] 	sl::ConstList<MulticastClassType>
[-] 	getMulticastClassTypeList ()
[+] 	getMulticastClassTypeList()
[-] 	sl::ConstList <McSnapshotClassType>
[+] 	sl::ConstList<McSnapshotClassType>
[-] 	getMcSnapshotClassTypeList ()
[+] 	getMcSnapshotClassTypeList()
[-] 	sl::ConstList <Typedef>
[+] 	sl::ConstList<Typedef>
[-] 	getTypedefList ()
[+] 	getTypedefList()
[-] 	getPrimitiveType (TypeKind typeKind)
[+] 	getPrimitiveType(TypeKind typeKind)
[-] 		ASSERT (typeKind < TypeKind__PrimitiveTypeCount);
[+] 		ASSERT(typeKind < TypeKind__PrimitiveTypeCount);
[-] 		return &m_primitiveTypeArray [typeKind];
[+] 		return &m_primitiveTypeArray[typeKind];
[-] 	isStdTypeUsed (StdType stdType)
[+] 	isStdTypeUsed(StdType stdType)
[-] 		ASSERT (stdType < StdType__Count);
[+] 		ASSERT(stdType < StdType__Count);
[-] 		return m_stdTypeArray [stdType] != NULL;
[+] 		return m_stdTypeArray[stdType] != NULL;
[-] 	getStdType (StdType stdType);
[+] 	getStdType(StdType stdType);
[-] 	getLazyStdType (StdType stdType);
[+] 	getLazyStdType(StdType stdType);
[-] 	getStdTypedef (StdTypedef stdTypedef)
[+] 	getStdTypedef(StdTypedef stdTypedef)
[-] 		ASSERT (stdTypedef < StdTypedef__Count);
[+] 		ASSERT(stdTypedef < StdTypedef__Count);
[-] 		return &m_stdTypedefArray [stdTypedef];
[+] 		return &m_stdTypedefArray[stdTypedef];
[-] 	getInt32Type (int32_t integer)
[+] 	getInt32Type(int32_t integer)
[-] 		return getPrimitiveType (getInt32TypeKind (integer));
[+] 		return getPrimitiveType(getInt32TypeKind(integer));
[-] 	getUInt32Type (uint32_t integer)
[+] 	getUInt32Type(uint32_t integer)
[-] 		return getPrimitiveType (getInt32TypeKind_u (integer));
[+] 		return getPrimitiveType(getInt32TypeKind_u(integer));
[-] 	getInt64Type (int64_t integer)
[+] 	getInt64Type(int64_t integer)
[-] 		return getPrimitiveType (getInt64TypeKind (integer));
[+] 		return getPrimitiveType(getInt64TypeKind(integer));
[-] 	getInt64Type_u (uint64_t integer)
[+] 	getInt64Type_u(uint64_t integer)
[-] 		return getPrimitiveType (getInt64TypeKind_u (integer));
[+] 		return getPrimitiveType(getInt64TypeKind_u(integer));
[-] 	getBitFieldType (
[+] 	getBitFieldType(
[-] 	createAutoSizeArrayType (Type* elementType);
[+] 	createAutoSizeArrayType(Type* elementType);
[-] 	createArrayType (
[+] 	createArrayType(
[-] 		sl::BoxList <Token>* elementCountInitializer
[+] 		sl::BoxList<Token>* elementCountInitializer
[-] 	getArrayType (
[+] 	getArrayType(
[-] 	createTypedef (
[+] 	createTypedef(
[-] 	createTypedefShadowType (Typedef* tdef);
[+] 	createTypedefShadowType(Typedef* tdef);
[-] 	createEnumType (
[+] 	createEnumType(
[-] 	createUnnamedEnumType (
[+] 	createUnnamedEnumType(
[-] 		return createEnumType (sl::String (), sl::String (), baseType, flags);
[+] 		return createEnumType(sl::String(), sl::String(), baseType, flags);
[-] 	createStructType (
[+] 	createStructType(
[-] 	createUnnamedStructType (
[+] 	createUnnamedStructType(
[-] 		return createStructType (sl::String (), sl::String (), fieldAlignment, flags);
[+] 		return createStructType(sl::String(), sl::String(), fieldAlignment, flags);
[-] 	createUnionType (
[+] 	createUnionType(
[-] 	createUnnamedUnionType (
[+] 	createUnnamedUnionType(
[-] 		return createUnionType (sl::String (), sl::String (), fieldAlignment, flags);
[+] 		return createUnionType(sl::String(), sl::String(), fieldAlignment, flags);
[-] 	createClassType (
[+] 	createClassType(
[-] 	createClassType (
[+] 	createClassType(
[-] 		return createClassType (ClassTypeKind_Normal, name, qualifiedName, fieldAlignment, flags);
[+] 		return createClassType(ClassTypeKind_Normal, name, qualifiedName, fieldAlignment, flags);
[-] 	createUnnamedClassType (
[+] 	createUnnamedClassType(
[-] 		return createClassType (classTypeKind,	sl::String (), sl::String (), fieldAlignment, flags);
[+] 		return createClassType(classTypeKind,	sl::String(), sl::String(), fieldAlignment, flags);
[-] 	createUnnamedClassType (
[+] 	createUnnamedClassType(
[-] 		return createClassType (ClassTypeKind_Normal, sl::String (), sl::String (), fieldAlignment, flags);
[+] 		return createClassType(ClassTypeKind_Normal, sl::String(), sl::String(), fieldAlignment, flags);
[-] 	createFunctionArg (
[+] 	createFunctionArg(
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	getSimpleFunctionArg (
[+] 	getSimpleFunctionArg(
[-] 	getSimpleFunctionArg (
[+] 	getSimpleFunctionArg(
[-] 		return getSimpleFunctionArg (StorageKind_Stack, type, ptrTypeFlags);
[+] 		return getSimpleFunctionArg(StorageKind_Stack, type, ptrTypeFlags);
[-] 	createStructField (
[+] 	createStructField(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	getCallConv (CallConvKind callConvKind)
[+] 	getCallConv(CallConvKind callConvKind)
[-] 		ASSERT (callConvKind < CallConvKind__Count);
[+] 		ASSERT(callConvKind < CallConvKind__Count);
[-] 		return m_callConvArray [callConvKind];
[+] 		return m_callConvArray[callConvKind];
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return getFunctionType (m_callConvArray [CallConvKind_Default], returnType, argArray, flags);
[+] 		return getFunctionType(m_callConvArray[CallConvKind_Default], returnType, argArray, flags);
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return getFunctionType (
[+] 		return getFunctionType(
[-] 			m_callConvArray [CallConvKind_Default],
[+] 			m_callConvArray[CallConvKind_Default],
[-] 			&m_primitiveTypeArray [TypeKind_Void],
[+] 			&m_primitiveTypeArray[TypeKind_Void],
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 		return getFunctionType (m_callConvArray [CallConvKind_Default], returnType, argType, argCount, flags);
[+] 		return getFunctionType(m_callConvArray[CallConvKind_Default], returnType, argType, argCount, flags);
[-] 	getFunctionType (
[+] 	getFunctionType(
[-] 		return getFunctionType (
[+] 		return getFunctionType(
[-] 			m_callConvArray [CallConvKind_Default],
[+] 			m_callConvArray[CallConvKind_Default],
[-] 			&m_primitiveTypeArray [TypeKind_Void],
[+] 			&m_primitiveTypeArray[TypeKind_Void],
[-] 	getFunctionType ()
[+] 	getFunctionType()
[-] 		return (FunctionType*) getStdType (StdType_SimpleFunction);
[+] 		return (FunctionType*)getStdType(StdType_SimpleFunction);
[-] 	createUserFunctionType (
[+] 	createUserFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 	createUserFunctionType (
[+] 	createUserFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return createUserFunctionType (m_callConvArray [CallConvKind_Default], returnType, argArray, flags);
[+] 		return createUserFunctionType(m_callConvArray[CallConvKind_Default], returnType, argArray, flags);
[-] 	createUserFunctionType (
[+] 	createUserFunctionType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return createUserFunctionType (
[+] 		return createUserFunctionType(
[-] 			m_callConvArray [CallConvKind_Default],
[+] 			m_callConvArray[CallConvKind_Default],
[-] 			&m_primitiveTypeArray [TypeKind_Void],
[+] 			&m_primitiveTypeArray[TypeKind_Void],
[-] 	getMemberMethodType (
[+] 	getMemberMethodType(
[-] 	getStdObjectMemberMethodType (FunctionType* functionType);
[+] 	getStdObjectMemberMethodType(FunctionType* functionType);
[-] 	getPropertyType (
[+] 	getPropertyType(
[-] 	getSimplePropertyType (
[+] 	getSimplePropertyType(
[-] 	getSimplePropertyType (
[+] 	getSimplePropertyType(
[-] 		return getSimplePropertyType (
[+] 		return getSimplePropertyType(
[-] 			m_callConvArray [CallConvKind_Default],
[+] 			m_callConvArray[CallConvKind_Default],
[-] 	getIndexedPropertyType (
[+] 	getIndexedPropertyType(
[-] 	getIndexedPropertyType (
[+] 	getIndexedPropertyType(
[-] 		return getIndexedPropertyType (NULL, returnType, indexArgType, indexArgCount, flags);
[+] 		return getIndexedPropertyType(NULL, returnType, indexArgType, indexArgCount, flags);
[-] 	getIndexedPropertyType (
[+] 	getIndexedPropertyType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 	getIndexedPropertyType (
[+] 	getIndexedPropertyType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return getIndexedPropertyType (NULL, returnType, argArray, flags);
[+] 		return getIndexedPropertyType(NULL, returnType, argArray, flags);
[-] 	createIndexedPropertyType (
[+] 	createIndexedPropertyType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 	createIndexedPropertyType (
[+] 	createIndexedPropertyType(
[-] 		const sl::Array <FunctionArg*>& argArray,
[+] 		const sl::Array<FunctionArg*>& argArray,
[-] 		return createIndexedPropertyType (NULL, returnType, argArray, flags);
[+] 		return createIndexedPropertyType(NULL, returnType, argArray, flags);
[-] 	getMemberPropertyType (
[+] 	getMemberPropertyType(
[-] 	getStdObjectMemberPropertyType (PropertyType* propertyType);
[+] 	getStdObjectMemberPropertyType(PropertyType* propertyType);
[-] 	getShortPropertyType (PropertyType* propertyType);
[+] 	getShortPropertyType(PropertyType* propertyType);
[-] 	getMulticastType (
[+] 	getMulticastType(
[-] 		return getMulticastType (getFunctionPtrType (functionType, ptrTypeKind));
[+] 		return getMulticastType(getFunctionPtrType(functionType, ptrTypeKind));
[-] 	getMulticastType (FunctionPtrType* functionPtrType);
[+] 	getMulticastType(FunctionPtrType* functionPtrType);
[-] 	createReactorBaseType ();
[+] 	createReactorBaseType();
[-] 	createReactorType (
[+] 	createReactorType(
[-] 	createReactorClosureType ();
[+] 	createReactorClosureType();
[-] 	getFunctionClosureClassType (
[+] 	getFunctionClosureClassType(
[-] 	getPropertyClosureClassType (
[+] 	getPropertyClosureClassType(
[-] 	getDataClosureClassType (
[+] 	getDataClosureClassType(
[-] 	getDataPtrType (
[+] 	getDataPtrType(
[-] 	getDataPtrType (
[+] 	getDataPtrType(
[-] 		return getDataPtrType (targetType, TypeKind_DataPtr, ptrTypeKind, flags);
[+] 		return getDataPtrType(targetType, TypeKind_DataPtr, ptrTypeKind, flags);
[-] 	getClassPtrType (
[+] 	getClassPtrType(
[-] 	getClassPtrType (
[+] 	getClassPtrType(
[-] 		return getClassPtrType (targetType, TypeKind_ClassPtr, ptrTypeKind, flags);
[+] 		return getClassPtrType(targetType, TypeKind_ClassPtr, ptrTypeKind, flags);
[-] 	getFunctionPtrType (
[+] 	getFunctionPtrType(
[-] 	getFunctionPtrType (
[+] 	getFunctionPtrType(
[-] 		return getFunctionPtrType (targetType, TypeKind_FunctionPtr, ptrTypeKind, flags);
[+] 		return getFunctionPtrType(targetType, TypeKind_FunctionPtr, ptrTypeKind, flags);
[-] 	getPropertyPtrType (
[+] 	getPropertyPtrType(
[-] 	getPropertyPtrType (
[+] 	getPropertyPtrType(
[-] 		return getPropertyPtrType (targetType, TypeKind_PropertyPtr, ptrTypeKind, flags);
[+] 		return getPropertyPtrType(targetType, TypeKind_PropertyPtr, ptrTypeKind, flags);
[-] 	getPropertyVTableStructType (PropertyType* propertyType);
[+] 	getPropertyVTableStructType(PropertyType* propertyType);
[-] 	getNamedImportType (
[+] 	getNamedImportType(
[-] 		const QualifiedName& anchorName = QualifiedName ()
[+] 		const QualifiedName& anchorName = QualifiedName()
[-] 	getImportPtrType (
[+] 	getImportPtrType(
[-] 	getImportIntModType (
[+] 	getImportIntModType(
[-] 	getCheckedPtrType (Type* type);
[+] 	getCheckedPtrType(Type* type);
[-] 	foldDualType (
[+] 	foldDualType(
[-] 	getDualTypeTuple (Type* type);
[+] 	getDualTypeTuple(Type* type);
[-] 	getSimplePropertyTypeTuple (Type* type);
[+] 	getSimplePropertyTypeTuple(Type* type);
[-] 	getFunctionArgTuple (Type* type);
[+] 	getFunctionArgTuple(Type* type);
[-] 	getDataPtrTypeTuple (Type* type);
[+] 	getDataPtrTypeTuple(Type* type);
[-] 	getClassPtrTypeTuple (ClassType* classType);
[+] 	getClassPtrTypeTuple(ClassType* classType);
[-] 	getEventClassPtrTypeTuple (MulticastClassType* classType);
[+] 	getEventClassPtrTypeTuple(MulticastClassType* classType);
[-] 	getFunctionPtrTypeTuple (FunctionType* functionType);
[+] 	getFunctionPtrTypeTuple(FunctionType* functionType);
[-] 	getPropertyPtrTypeTuple (PropertyType* propertyType);
[+] 	getPropertyPtrTypeTuple(PropertyType* propertyType);
[-] 	setupAllPrimitiveTypes ();
[+] 	setupAllPrimitiveTypes();
[-] 	setupStdTypedefArray ();
[+] 	setupStdTypedefArray();
[-] 	setupCallConvArray ();
[+] 	setupCallConvArray();
[-] 	setupPrimitiveType (
[+] 	setupPrimitiveType(
[-] 	setupStdTypedef (
[+] 	setupStdTypedef(
[-] 	parseStdType (StdType stdType);
[+] 	parseStdType(StdType stdType);
[-] 	parseStdType (
[+] 	parseStdType(
[-] 	createAbstractClassType ();
[+] 	createAbstractClassType();
[-] 	createAbstractDataType ();
[+] 	createAbstractDataType();
[-] 	createIfaceHdrType ();
[+] 	createIfaceHdrType();
[-] 	createBoxType ();
[+] 	createBoxType();
[-] 	createDataBoxType ();
[+] 	createDataBoxType();
[-] 	createDynamicArrayBoxType ();
[+] 	createDynamicArrayBoxType();
[-] 	createStaticDataBoxType ();
[+] 	createStaticDataBoxType();
[-] 	createDataPtrValidatorType ();
[+] 	createDataPtrValidatorType();
[-] 	createDataPtrStructType ();
[+] 	createDataPtrStructType();
[-] 	createFunctionPtrStructType ();
[+] 	createFunctionPtrStructType();
[-] 	createVariantStructType ();
[+] 	createVariantStructType();
[-] 	createGcShadowStackFrameType ();
[+] 	createGcShadowStackFrameType();
[-] 	createSjljFrameType ();
[+] 	createSjljFrameType();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_TypeMgr\jnc_ct_UnionType.h
----------------------
[-] 	UnionType ();
[+] 	UnionType();
[-] 	getStructType ()
[+] 	getStructType()
[-] 		ASSERT (m_structType);
[+] 		ASSERT(m_structType);
[-] 	compile ();
[+] 	compile();
[-] 	markGcRoots (
[+] 	markGcRoots(
[-] 		ASSERT (false); // unions are POD and hence are never GC roots
[+] 		ASSERT(false); // unions are POD and hence are never GC roots
[-] 	createFieldImpl (
[+] 	createFieldImpl(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	prepareLlvmType ()
[+] 	prepareLlvmType()
[-] 		m_llvmType = getStructType ()->getLlvmType ();
[+] 		m_llvmType = getStructType()->getLlvmType();
[-] 	prepareLlvmDiType ();
[+] 	prepareLlvmDiType();
[-] 	calcLayout ();
[+] 	calcLayout();
----------------------
27/02/2019 18:02:15 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_Closure.cpp
----------------------
[-] Closure::getThisArgValue ()
[+] Closure::getThisArgValue()
[-] 	ASSERT (m_thisArgIdx != -1);
[+] 	ASSERT(m_thisArgIdx != -1);
[-] 	sl::BoxIterator <Value> it = m_argValueList.getHead ();
[+] 	sl::BoxIterator<Value> it = m_argValueList.getHead();
[-] 	m_thisArgValue = it.p ();
[+] 	m_thisArgValue = it.p();
[-] Closure::setThisArgIdx (size_t thisArgIdx)
[+] Closure::setThisArgIdx(size_t thisArgIdx)
[-] 	ASSERT (m_thisArgIdx == -1 && !m_thisArgValue); // only once
[+] 	ASSERT(m_thisArgIdx == -1 && !m_thisArgValue); // only once
[-] 	ASSERT (thisArgIdx < m_argValueList.getCount ());
[+] 	ASSERT(thisArgIdx < m_argValueList.getCount());
[-] Closure::insertThisArgValue (const Value& value)
[+] Closure::insertThisArgValue(const Value& value)
[-] 	ASSERT (m_thisArgIdx == -1 && !m_thisArgValue); // only once
[+] 	ASSERT(m_thisArgIdx == -1 && !m_thisArgValue); // only once
[-] 	sl::BoxIterator <Value> it = m_argValueList.insertHead (value);
[+] 	sl::BoxIterator<Value> it = m_argValueList.insertHead(value);
[-] 	m_thisArgValue = it.p ();
[+] 	m_thisArgValue = it.p();
[-] Closure::append (const Value& argValue)
[+] Closure::append(const Value& argValue)
[-] 	sl::BoxIterator <Value> internalArg = m_argValueList.getHead ();
[+] 	sl::BoxIterator<Value> internalArg = m_argValueList.getHead();
[-] 	while (internalArg && !internalArg->isEmpty ())
[+] 	while (internalArg && !internalArg->isEmpty())
[-] 		m_argValueList.insertTail (argValue);
[+] 		m_argValueList.insertTail(argValue);
[-] 	return m_argValueList.getCount ();
[+] 	return m_argValueList.getCount();
[-] Closure::append (const sl::ConstBoxList <Value>& argValueList)
[+] Closure::append(const sl::ConstBoxList<Value>& argValueList)
[-] 	ASSERT (!argValueList.isEmpty ());
[+] 	ASSERT(!argValueList.isEmpty());
[-] 	sl::BoxIterator <Value> internalArg = m_argValueList.getHead ();
[+] 	sl::BoxIterator<Value> internalArg = m_argValueList.getHead();
[-] 	sl::ConstBoxIterator <Value> externalArg = argValueList.getHead ();
[+] 	sl::ConstBoxIterator<Value> externalArg = argValueList.getHead();
[-] 		while (internalArg && !internalArg->isEmpty ())
[+] 		while (internalArg && !internalArg->isEmpty())
[-] 			return m_argValueList.getCount ();
[+] 			return m_argValueList.getCount();
[-] 		m_argValueList.insertTail (*externalArg);
[+] 		m_argValueList.insertTail(*externalArg);
[-] 	return m_argValueList.getCount ();
[+] 	return m_argValueList.getCount();
[-] Closure::apply (sl::BoxList <Value>* argValueList)
[+] Closure::apply(sl::BoxList<Value>* argValueList)
[-] 	if (m_argValueList.isEmpty ())
[+] 	if (m_argValueList.isEmpty())
[-] 	sl::ConstBoxIterator <Value> closureArg = m_argValueList.getHead ();
[+] 	sl::ConstBoxIterator<Value> closureArg = m_argValueList.getHead();
[-] 	sl::BoxIterator <Value> targetArg = argValueList->getHead ();
[+] 	sl::BoxIterator<Value> targetArg = argValueList->getHead();
[-] 		if (!closureArg->isEmpty ())
[+] 		if (!closureArg->isEmpty())
[-] 			argValueList->insertBefore (*closureArg, targetArg);
[+] 			argValueList->insertBefore(*closureArg, targetArg);
[-] 			err::setFormatStringError ("closure call misses argument #%d", i + 1);
[+] 			err::setFormatStringError("closure call misses argument #%d", i + 1);
[-] Closure::getClosureType (Type* type)
[+] Closure::getClosureType(Type* type)
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		return getFunctionClosureType ((FunctionPtrType*) type);
[+] 		return getFunctionClosureType((FunctionPtrType*)type);
[-] 		return getPropertyClosureType ((PropertyPtrType*) type);
[+] 		return getPropertyClosureType((PropertyPtrType*)type);
[-] Closure::getFunctionClosureType (Function* function)
[+] Closure::getFunctionClosureType(Function* function)
[-] 	if (!function->isOverloaded ())
[+] 	if (!function->isOverloaded())
[-] 		return getFunctionClosureType (function->getType ()->getFunctionPtrType (TypeKind_FunctionRef, FunctionPtrTypeKind_Thin));
[+] 		return getFunctionClosureType(function->getType()->getFunctionPtrType(TypeKind_FunctionRef, FunctionPtrTypeKind_Thin));
[-] 	err::setFormatStringError ("function overload closures are not implemented yet");
[+] 	err::setFormatStringError("function overload closures are not implemented yet");
[-] Closure::getArgTypeArray (
[+] Closure::getArgTypeArray(
[-] 	sl::Array <FunctionArg*>* argArray
[+] 	sl::Array<FunctionArg*>* argArray
[-] 	size_t closureArgCount = m_argValueList.getCount ();
[+] 	size_t closureArgCount = m_argValueList.getCount();
[-] 	size_t argCount = argArray->getCount ();
[+] 	size_t argCount = argArray->getCount();
[-] 		err::setFormatStringError ("closure with %d arguments for function with %d arguments", closureArgCount, argCount);
[+] 		err::setFormatStringError("closure with %d arguments for function with %d arguments", closureArgCount, argCount);
[-] 	sl::BoxIterator <Value> closureArg = m_argValueList.getHead ();
[+] 	sl::BoxIterator<Value> closureArg = m_argValueList.getHead();
[-] 		if (closureArg->isEmpty ())
[+] 		if (closureArg->isEmpty())
[-] 		ASSERT (i < argCount);
[+] 		ASSERT(i < argCount);
[-] 		result = module->m_operatorMgr.checkCastKind (closureArg->getType (), (*argArray) [i]->getType ());
[+] 		result = module->m_operatorMgr.checkCastKind(closureArg->getType(), (*argArray) [i]->getType());
[-] 		argArray->remove (i);
[+] 		argArray->remove(i);
[-] Closure::getFunctionClosureType (FunctionPtrType* ptrType)
[+] Closure::getFunctionClosureType(FunctionPtrType* ptrType)
[-] 	Module* module = ptrType->getModule ();
[+] 	Module* module = ptrType->getModule();
[-] 	FunctionType* type = ptrType->getTargetType ();
[+] 	FunctionType* type = ptrType->getTargetType();
[-] 	if (type->getFlags () & FunctionTypeFlag_VarArg)
[+] 	if (type->getFlags() & FunctionTypeFlag_VarArg)
[-] 		err::setFormatStringError ("function closures cannot be applied to vararg functions");
[+] 		err::setFormatStringError("function closures cannot be applied to vararg functions");
[-] 	sl::Array <FunctionArg*> argArray = type->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = type->getArgArray();
[-] 	result = getArgTypeArray (module, &argArray);
[+] 	result = getArgTypeArray(module, &argArray);
[-] 	FunctionType* closureType = module->m_typeMgr.getFunctionType (
[+] 	FunctionType* closureType = module->m_typeMgr.getFunctionType(
[-] 		type->getCallConv (),
[+] 		type->getCallConv(),
[-] 		type->getReturnType (),
[+] 		type->getReturnType(),
[-] 	return closureType->getFunctionPtrType (
[+] 	return closureType->getFunctionPtrType(
[-] 		ptrType->getTypeKind (),
[+] 		ptrType->getTypeKind(),
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
[-] Closure::getPropertyClosureType (PropertyPtrType* ptrType)
[+] Closure::getPropertyClosureType(PropertyPtrType* ptrType)
[-] 	Module* module = ptrType->getModule ();
[+] 	Module* module = ptrType->getModule();
[-] 	PropertyType* type = ptrType->getTargetType ();
[+] 	PropertyType* type = ptrType->getTargetType();
[-] 	FunctionType* getterType = type->getGetterType ();
[+] 	FunctionType* getterType = type->getGetterType();
[-] 	FunctionTypeOverload* setterType = type->getSetterType ();
[+] 	FunctionTypeOverload* setterType = type->getSetterType();
[-] 	sl::Array <FunctionArg*> argArray = getterType->getArgArray ();
[+] 	sl::Array<FunctionArg*> argArray = getterType->getArgArray();
[-] 	result = getArgTypeArray (module, &argArray);
[+] 	result = getArgTypeArray(module, &argArray);
[-] 	FunctionType* closureGetterType = module->m_typeMgr.getFunctionType (
[+] 	FunctionType* closureGetterType = module->m_typeMgr.getFunctionType(
[-] 		getterType->getCallConv (),
[+] 		getterType->getCallConv(),
[-] 		getterType->getReturnType (),
[+] 		getterType->getReturnType(),
[-] 	size_t setterCount = setterType->getOverloadCount ();
[+] 	size_t setterCount = setterType->getOverloadCount();
[-] 		FunctionType* overloadType = setterType->getOverload (i);
[+] 		FunctionType* overloadType = setterType->getOverload(i);
[-] 		ASSERT (!overloadType->getArgArray ().isEmpty ());
[+] 		ASSERT(!overloadType->getArgArray().isEmpty());
[-] 		argArray.append (overloadType->getArgArray ().getBack ());
[+] 		argArray.append(overloadType->getArgArray().getBack());
[-] 		FunctionType* closureOverloadType = module->m_typeMgr.getFunctionType (
[+] 		FunctionType* closureOverloadType = module->m_typeMgr.getFunctionType(
[-] 			overloadType->getCallConv (),
[+] 			overloadType->getCallConv(),
[-] 			overloadType->getReturnType (),
[+] 			overloadType->getReturnType(),
[-] 		argArray.pop ();
[+] 		argArray.pop();
[-] 		result = closureSetterType.addOverload (closureOverloadType) != -1;
[+] 		result = closureSetterType.addOverload(closureOverloadType) != -1;
[-] 	PropertyType* closureType = module->m_typeMgr.getPropertyType (
[+] 	PropertyType* closureType = module->m_typeMgr.getPropertyType(
[-] 		type->getFlags ()
[+] 		type->getFlags()
[-] 	return closureType->getPropertyPtrType (
[+] 	return closureType->getPropertyPtrType(
[-] 		ptrType->getTypeKind (),
[+] 		ptrType->getTypeKind(),
[-] 		ptrType->getPtrTypeKind (),
[+] 		ptrType->getPtrTypeKind(),
[-] 		ptrType->getFlags ()
[+] 		ptrType->getFlags()
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_ConstMgr.cpp
----------------------
[-] ConstMgr::ConstMgr ()
[+] ConstMgr::ConstMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] ConstMgr::clear ()
[+] ConstMgr::clear()
[-] 	m_valueList.clear ();
[+] 	m_valueList.clear();
[-] 	m_constList.clear ();
[+] 	m_constList.clear();
[-] 	m_constDataPtrValidatorList.clear ();
[+] 	m_constDataPtrValidatorList.clear();
[-] ConstMgr::createConst (
[+] ConstMgr::createConst(
[-] 	Const* cnst = AXL_MEM_NEW (Const);
[+] 	Const* cnst = AXL_MEM_NEW(Const);
[-] 	m_constList.insertTail (cnst);
[+] 	m_constList.insertTail(cnst);
[-] ConstMgr::saveLiteral (const sl::StringRef& string)
[+] ConstMgr::saveLiteral(const sl::StringRef& string)
[-] 	value.setCharArray (string, m_module);
[+] 	value.setCharArray(string, m_module);
[-] 	return saveValue (value);
[+] 	return saveValue(value);
[-] ConstMgr::createConstDataPtrValidator (
[+] ConstMgr::createConstDataPtrValidator(
[-] 	ConstDataPtrValidatorEntry* entry = AXL_MEM_NEW (ConstDataPtrValidatorEntry);
[+] 	ConstDataPtrValidatorEntry* entry = AXL_MEM_NEW(ConstDataPtrValidatorEntry);
[-] 	entry->m_box.m_p = (void*) p;
[+] 	entry->m_box.m_p = (void*)p;
[-] 	entry->m_validator.m_rangeEnd = (char*) p + type->getSize ();
[+] 	entry->m_validator.m_rangeEnd = (char*)p + type->getSize();
[-] 	m_constDataPtrValidatorList.insertTail (entry);
[+] 	m_constDataPtrValidatorList.insertTail(entry);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_LeanDataPtrValidator.cpp
----------------------
[-] LeanDataPtrValidator::getValidatorValue ()
[+] LeanDataPtrValidator::getValidatorValue()
[-] 	createValidator ();
[+] 	createValidator();
[-] 	ASSERT (m_validatorValue);
[+] 	ASSERT(m_validatorValue);
[-] LeanDataPtrValidator::createValidator ()
[+] LeanDataPtrValidator::createValidator()
[-] 	ASSERT (m_originValue);
[+] 	ASSERT(m_originValue);
[-] 	if (m_originValue.getType ()->getTypeKindFlags () & TypeKindFlag_ClassPtr)
[+] 	if (m_originValue.getType()->getTypeKindFlags() & TypeKindFlag_ClassPtr)
[-] 		createClassFieldValidator ();
[+] 		createClassFieldValidator();
[-] 	ASSERT (m_originValue.getType ()->getTypeKindFlags () & TypeKindFlag_DataPtr);
[+] 	ASSERT(m_originValue.getType()->getTypeKindFlags() & TypeKindFlag_DataPtr);
[-] 	Module* module = m_originValue.getType ()->getModule ();
[+] 	Module* module = m_originValue.getType()->getModule();
[-] 	DataPtrType* originType = (DataPtrType*) m_originValue.getType ();
[+] 	DataPtrType* originType = (DataPtrType*)m_originValue.getType();
[-] 	if (m_originValue.getValueKind () == ValueKind_Variable)
[+] 	if (m_originValue.getValueKind() == ValueKind_Variable)
[-] 		Variable* variable = m_originValue.getVariable ();
[+] 		Variable* variable = m_originValue.getVariable();
[-] 		LeanDataPtrValidator* originValidator = variable->getLeanDataPtrValidator ();
[+] 		LeanDataPtrValidator* originValidator = variable->getLeanDataPtrValidator();
[-] 			StorageKind storageKind = variable->getStorageKind ();
[+] 			StorageKind storageKind = variable->getStorageKind();
[-] 			switch (storageKind)
[+] 			switch(storageKind)
[-] 				module->m_variableMgr.createStaticDataPtrValidatorVariable (variable);
[+] 				module->m_variableMgr.createStaticDataPtrValidatorVariable(variable);
[-] 				module->m_variableMgr.liftStackVariable (variable);
[+] 				module->m_variableMgr.liftStackVariable(variable);
[-] 				ASSERT (false); // heap variables should already have validator value set
[+] 				ASSERT(false); // heap variables should already have validator value set
[-] 		ASSERT (originValidatorValue);
[+] 		ASSERT(originValidatorValue);
[-] 		if (originType->getTargetType ()->getStdType () == StdType_DataPtrValidator)
[+] 		if (originType->getTargetType()->getStdType() == StdType_DataPtrValidator)
[-] 		else if (originType->getPtrTypeKind () == DataPtrTypeKind_Lean)
[+] 		else if (originType->getPtrTypeKind() == DataPtrTypeKind_Lean)
[-] 			originValidatorValue = m_originValue.getLeanDataPtrValidator ()->getValidatorValue ();
[+] 			originValidatorValue = m_originValue.getLeanDataPtrValidator()->getValidatorValue();
[-] 			ASSERT (originType->getPtrTypeKind () == DataPtrTypeKind_Normal);
[+] 			ASSERT(originType->getPtrTypeKind() == DataPtrTypeKind_Normal);
[-] 			module->m_llvmIrBuilder.createExtractValue (
[+] 			module->m_llvmIrBuilder.createExtractValue(
[-] 				module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr),
[+] 				module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr),
[-] 	if (!m_rangeBeginValue || m_rangeBeginValue.getLlvmValue () == m_originValue.getLlvmValue ())
[+] 	if (!m_rangeBeginValue || m_rangeBeginValue.getLlvmValue() == m_originValue.getLlvmValue())
[-] 		module->m_llvmIrBuilder.createGep2 (originValidatorValue, 1, NULL, &boxValue);
[+] 		module->m_llvmIrBuilder.createGep2(originValidatorValue, 1, NULL, &boxValue);
[-] 		module->m_llvmIrBuilder.createLoad (boxValue, module->m_typeMgr.getStdType (StdType_BoxPtr), &boxValue);
[+] 		module->m_llvmIrBuilder.createLoad(boxValue, module->m_typeMgr.getStdType(StdType_BoxPtr), &boxValue);
[-] 		createValidator (boxValue);
[+] 		createValidator(boxValue);
[-] LeanDataPtrValidator::createValidator (const Value& boxValue)
[+] LeanDataPtrValidator::createValidator(const Value& boxValue)
[-] 	ASSERT (m_originValue && m_rangeBeginValue && m_rangeLength);
[+] 	ASSERT(m_originValue && m_rangeBeginValue && m_rangeLength);
[-] 	Module* module = m_originValue.getType ()->getModule ();
[+] 	Module* module = m_originValue.getType()->getModule();
[-] 	Function* createDataPtrValidator = module->m_functionMgr.getStdFunction (StdFunc_CreateDataPtrValidator);
[+] 	Function* createDataPtrValidator = module->m_functionMgr.getStdFunction(StdFunc_CreateDataPtrValidator);
[-] 	Value argValueArray [3];
[+] 	Value argValueArray[3];
[-] 	argValueArray [0] = boxValue;
[+] 	argValueArray[0] = boxValue;
[-] 	module->m_llvmIrBuilder.createBitCast (m_rangeBeginValue, module->m_typeMgr.getStdType (StdType_BytePtr), &argValueArray [1]);
[+] 	module->m_llvmIrBuilder.createBitCast(m_rangeBeginValue, module->m_typeMgr.getStdType(StdType_BytePtr), &argValueArray[1]);
[-] 	argValueArray [2].setConstSizeT (m_rangeLength, module);
[+] 	argValueArray[2].setConstSizeT(m_rangeLength, module);
[-] 	module->m_llvmIrBuilder.createCall (
[+] 	module->m_llvmIrBuilder.createCall(
[-] 		createDataPtrValidator->getType (),
[+] 		createDataPtrValidator->getType(),
[-] 	module->m_gcShadowStackMgr.markGcRoot (
[+] 	module->m_gcShadowStackMgr.markGcRoot(
[-] 		module->m_typeMgr.getStdType (StdType_DataPtrValidatorPtr)
[+] 		module->m_typeMgr.getStdType(StdType_DataPtrValidatorPtr)
[-] LeanDataPtrValidator::createClassFieldValidator ()
[+] LeanDataPtrValidator::createClassFieldValidator()
[-] 	ASSERT (m_originValue);
[+] 	ASSERT(m_originValue);
[-] 	Module* module = m_originValue.getType ()->getModule ();
[+] 	Module* module = m_originValue.getType()->getModule();
[-] 	if (m_originValue.getValueKind () == ValueKind_Variable)
[+] 	if (m_originValue.getValueKind() == ValueKind_Variable)
[-] 		module->m_llvmIrBuilder.createBitCast (m_originValue, module->m_typeMgr.getStdType (StdType_BoxPtr), &tmpValue);
[+] 		module->m_llvmIrBuilder.createBitCast(m_originValue, module->m_typeMgr.getStdType(StdType_BoxPtr), &tmpValue);
[-] 		module->m_llvmIrBuilder.createGep (tmpValue, -1, module->m_typeMgr.getStdType (StdType_BoxPtr), &boxValue);
[+] 		module->m_llvmIrBuilder.createGep(tmpValue, -1, module->m_typeMgr.getStdType(StdType_BoxPtr), &boxValue);
[-] 		module->m_llvmIrBuilder.createBitCast (m_originValue, module->m_typeMgr.getStdType (StdType_IfaceHdrPtr), &tmpValue);
[+] 		module->m_llvmIrBuilder.createBitCast(m_originValue, module->m_typeMgr.getStdType(StdType_IfaceHdrPtr), &tmpValue);
[-] 		module->m_llvmIrBuilder.createGep2 (tmpValue, 1, NULL, &tmpValue);
[+] 		module->m_llvmIrBuilder.createGep2(tmpValue, 1, NULL, &tmpValue);
[-] 		module->m_llvmIrBuilder.createLoad (tmpValue, module->m_typeMgr.getStdType (StdType_BoxPtr), &boxValue);
[+] 		module->m_llvmIrBuilder.createLoad(tmpValue, module->m_typeMgr.getStdType(StdType_BoxPtr), &boxValue);
[-] 	createValidator (boxValue);
[+] 	createValidator(boxValue);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_Value.cpp
----------------------
[-] 	get (
[+] 	get(
[-] 		llvm::Type* llvmType = type->getLlvmType ();
[+] 		llvm::Type* llvmType = type->getLlvmType();
[-] 		return getImpl (llvm::StringRef ((char*) p, type->getSize ()), llvmType);
[+] 		return getImpl(llvm::StringRef((char*)p, type->getSize()), llvmType);
[-] 	get (
[+] 	get(
[-] 		llvm::Type* llvmType = type->getLlvmType ();
[+] 		llvm::Type* llvmType = type->getLlvmType();
[-] 		char buffer [256];
[+] 		char buffer[256];
[-] 		sl::Array <llvm::Constant*> llvmMemberArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 		sl::Array<llvm::Constant*> llvmMemberArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		sl::Array <StructField*> fieldArray = type->getMemberFieldArray ();
[+] 		sl::Array<StructField*> fieldArray = type->getMemberFieldArray();
[-] 		size_t count = fieldArray.getCount ();
[+] 		size_t count = fieldArray.getCount();
[-] 			StructField* field = fieldArray [i];
[+] 			StructField* field = fieldArray[i];
[-] 			jnc::ct::Value memberConst ((char*) p + field->getOffset (), field->getType ());
[+] 			jnc::ct::Value memberConst((char*)p + field->getOffset(), field->getType());
[-] 			llvmMemberArray.append ((llvm::Constant*) memberConst.getLlvmValue ());
[+] 			llvmMemberArray.append((llvm::Constant*)memberConst.getLlvmValue());
[-] 		return llvm::ConstantStruct::get (
[+] 		return llvm::ConstantStruct::get(
[-] 			(llvm::StructType*) llvmType,
[+] 			(llvm::StructType*)llvmType,
[-] 			llvm::ArrayRef <llvm::Constant*> (llvmMemberArray, llvmMemberArray.getCount ())
[+] 			llvm::ArrayRef<llvm::Constant*> (llvmMemberArray, llvmMemberArray.getCount())
[-] getValueKindString (ValueKind valueKind)
[+] getValueKindString(ValueKind valueKind)
[-] 	static const char* stringTable [ValueKind__Count] =
[+] 	static const char* stringTable[ValueKind__Count] =
[-] 	return (size_t) valueKind < ValueKind__Count ?
[+] 	return (size_t)valueKind < ValueKind__Count ?
[-] 		stringTable [valueKind] :
[+] 		stringTable[valueKind] :
[-] Value::init ()
[+] Value::init()
[-] Value::clear ()
[+] Value::clear()
[-] Value::getLlvmValue () const
[+] Value::getLlvmValue() const
[-] 	ASSERT (m_valueKind == ValueKind_Const);
[+] 	ASSERT(m_valueKind == ValueKind_Const);
[-] 	m_llvmValue = getLlvmConst (m_type, getConstData ());
[+] 	m_llvmValue = getLlvmConst(m_type, getConstData());
[-] getLlvmPtrConst (
[+] getLlvmPtrConst(
[-] 	int64_t integer = *(int64_t*) p;
[+] 	int64_t integer = *(int64_t*)p;
[-] 	llvm::Constant* llvmConst = llvm::ConstantInt::get (
[+] 	llvm::Constant* llvmConst = llvm::ConstantInt::get(
[-] 		type->getModule ()->m_typeMgr.getPrimitiveType (TypeKind_IntPtr_u)->getLlvmType (),
[+] 		type->getModule()->m_typeMgr.getPrimitiveType(TypeKind_IntPtr_u)->getLlvmType(),
[-] 		llvm::APInt (sizeof (void*) * 8, integer, false)
[+] 		llvm::APInt(sizeof(void*)* 8, integer, false)
[-] 	return llvm::ConstantExpr::getIntToPtr (llvmConst, type->getLlvmType ());
[+] 	return llvm::ConstantExpr::getIntToPtr(llvmConst, type->getLlvmType());
[-] Value::getLlvmConst (
[+] Value::getLlvmConst(
[-] 	if (type->getTypeKind () == TypeKind_Enum)
[+] 	if (type->getTypeKind() == TypeKind_Enum)
[-] 		type = ((EnumType*) type)->getBaseType ();
[+] 		type = ((EnumType*)type)->getBaseType();
[-] 	Module* module = type->getModule ();
[+] 	Module* module = type->getModule();
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		integer = *(int8_t*) p != 0;
[+] 		integer = *(int8_t*)p != 0;
[-] 		llvmConst = llvm::ConstantInt::get (
[+] 		llvmConst = llvm::ConstantInt::get(
[-] 			type->getLlvmType (),
[+] 			type->getLlvmType(),
[-] 			llvm::APInt (1, integer)
[+] 			llvm::APInt(1, integer)
[-] 		integer = *(int8_t*) p;
[+] 		integer = *(int8_t*)p;
[-] 		llvmConst = llvm::ConstantInt::get (
[+] 		llvmConst = llvm::ConstantInt::get(
[-] 			type->getLlvmType (),
[+] 			type->getLlvmType(),
[-] 			llvm::APInt (8, integer, !(type->getTypeKindFlags () & TypeKindFlag_Unsigned))
[+] 			llvm::APInt(8, integer, !(type->getTypeKindFlags() & TypeKindFlag_Unsigned))
[-] 		integer = *(int16_t*) p;
[+] 		integer = *(int16_t*)p;
[-] 		llvmConst = llvm::ConstantInt::get (
[+] 		llvmConst = llvm::ConstantInt::get(
[-] 			type->getLlvmType (),
[+] 			type->getLlvmType(),
[-] 			llvm::APInt (16, integer, !(type->getTypeKindFlags () & TypeKindFlag_Unsigned))
[+] 			llvm::APInt(16, integer, !(type->getTypeKindFlags() & TypeKindFlag_Unsigned))
[-] 		integer = *(int32_t*) p;
[+] 		integer = *(int32_t*)p;
[-] 		llvmConst = llvm::ConstantInt::get (
[+] 		llvmConst = llvm::ConstantInt::get(
[-] 			type->getLlvmType (),
[+] 			type->getLlvmType(),
[-] 			llvm::APInt (32, integer, !(type->getTypeKindFlags () & TypeKindFlag_Unsigned))
[+] 			llvm::APInt(32, integer, !(type->getTypeKindFlags() & TypeKindFlag_Unsigned))
[-] 		integer = *(int64_t*) p;
[+] 		integer = *(int64_t*)p;
[-] 		llvmConst = llvm::ConstantInt::get (
[+] 		llvmConst = llvm::ConstantInt::get(
[-] 			type->getLlvmType (),
[+] 			type->getLlvmType(),
[-] 			llvm::APInt (64, integer, !(type->getTypeKindFlags () & TypeKindFlag_Unsigned))
[+] 			llvm::APInt(64, integer, !(type->getTypeKindFlags() & TypeKindFlag_Unsigned))
[-] 		doubleValue = *(float*) p;
[+] 		doubleValue = *(float*)p;
[-] 		llvmConst = llvm::ConstantFP::get (type->getLlvmType (), doubleValue);
[+] 		llvmConst = llvm::ConstantFP::get(type->getLlvmType(), doubleValue);
[-] 		doubleValue = *(double*) p;
[+] 		doubleValue = *(double*)p;
[-] 		llvmConst = llvm::ConstantFP::get (type->getLlvmType (), doubleValue);
[+] 		llvmConst = llvm::ConstantFP::get(type->getLlvmType(), doubleValue);
[-] 		llvmConst = LlvmPodStruct::get ((StructType*) module->m_typeMgr.getStdType (StdType_VariantStruct), p);
[+] 		llvmConst = LlvmPodStruct::get((StructType*)module->m_typeMgr.getStdType(StdType_VariantStruct), p);
[-] 		llvmConst = LlvmPodArray::get ((ArrayType*) type, p);
[+] 		llvmConst = LlvmPodArray::get((ArrayType*)type, p);
[-] 		llvmConst = LlvmPodStruct::get ((StructType*) type, p);
[+] 		llvmConst = LlvmPodStruct::get((StructType*)type, p);
[-] 		if (((DataPtrType*) type)->getPtrTypeKind () == DataPtrTypeKind_Normal)
[+] 		if (((DataPtrType*)type)->getPtrTypeKind() == DataPtrTypeKind_Normal)
[-] 			llvmConst = LlvmPodStruct::get ((StructType*) module->m_typeMgr.getStdType (StdType_DataPtrStruct), p);
[+] 			llvmConst = LlvmPodStruct::get((StructType*)module->m_typeMgr.getStdType(StdType_DataPtrStruct), p);
[-] 			llvmConst = getLlvmPtrConst (type, p);
[+] 			llvmConst = getLlvmPtrConst(type, p);
[-] 		llvmConst = getLlvmPtrConst (type, p);
[+] 		llvmConst = getLlvmPtrConst(type, p);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Value::createClosure ()
[+] Value::createClosure()
[-] 	m_closure = AXL_REF_NEW (Closure);
[+] 	m_closure = AXL_REF_NEW(Closure);
[-] Value::setClosure (Closure* closure)
[+] Value::setClosure(Closure* closure)
[-] Value::getClosureAwareType () const
[+] Value::getClosureAwareType() const
[-] 	return m_closure ? m_closure->getClosureType (m_type) : m_type;
[+] 	return m_closure ? m_closure->getClosureType(m_type) : m_type;
[-] Value::setDynamicFieldInfo (
[+] Value::setDynamicFieldInfo(
[-] 	m_dynamicFieldInfo = AXL_REF_NEW (DynamicFieldValueInfo);
[+] 	m_dynamicFieldInfo = AXL_REF_NEW(DynamicFieldValueInfo);
[-] Value::setVoid (Module* module)
[+] Value::setVoid(Module* module)
[-] 	clear ();
[+] 	clear();
[-] 	m_type = module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 	m_type = module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] Value::setNull (Module* module)
[+] Value::setNull(Module* module)
[-] 	clear ();
[+] 	clear();
[-] 	m_type = module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 	m_type = module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] Value::setType (Type* type)
[+] Value::setType(Type* type)
[-] 	clear ();
[+] 	clear();
[-] Value::setNamespace (GlobalNamespace* nspace)
[+] Value::setNamespace(GlobalNamespace* nspace)
[-] 	clear ();
[+] 	clear();
[-] 	Module* module = nspace->getModule ();
[+] 	Module* module = nspace->getModule();
[-] 	m_type = module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 	m_type = module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] Value::setNamespace (NamedType* type)
[+] Value::setNamespace(NamedType* type)
[-] 	clear ();
[+] 	clear();
[-] 	Module* module = type->getModule ();
[+] 	Module* module = type->getModule();
[-] 	m_type = module->m_typeMgr.getPrimitiveType (TypeKind_Void);
[+] 	m_type = module->m_typeMgr.getPrimitiveType(TypeKind_Void);
[-] Value::setVariable (Variable* variable)
[+] Value::setVariable(Variable* variable)
[-] 	clear ();
[+] 	clear();
[-] 	m_llvmValue = variable->getLlvmValue ();
[+] 	m_llvmValue = variable->getLlvmValue();
[-] 	m_type = getDirectRefType (
[+] 	m_type = getDirectRefType(
[-] 		variable->getType (),
[+] 		variable->getType(),
[-] 		variable->getPtrTypeFlags () | PtrTypeFlag_Safe
[+] 		variable->getPtrTypeFlags() | PtrTypeFlag_Safe
[-] Value::setFunction (Function* function)
[+] Value::setFunction(Function* function)
[-] 	clear ();
[+] 	clear();
[-] 	m_type = function->getType ()->getFunctionPtrType (
[+] 	m_type = function->getType()->getFunctionPtrType(
[-] 	if (!function->isVirtual ())
[+] 	if (!function->isVirtual())
[-] 		m_llvmValue = function->getLlvmFunction ();
[+] 		m_llvmValue = function->getLlvmFunction();
[-] Value::setFunctionTypeOverload (FunctionTypeOverload* functionTypeOverload)
[+] Value::setFunctionTypeOverload(FunctionTypeOverload* functionTypeOverload)
[-] 	clear ();
[+] 	clear();
[-] 	m_valueKind = functionTypeOverload->isOverloaded () ? ValueKind_FunctionTypeOverload : ValueKind_Type;
[+] 	m_valueKind = functionTypeOverload->isOverloaded() ? ValueKind_FunctionTypeOverload : ValueKind_Type;
[-] 	m_type = functionTypeOverload->getOverload (0);
[+] 	m_type = functionTypeOverload->getOverload(0);
[-] Value::setProperty (Property* prop)
[+] Value::setProperty(Property* prop)
[-] 	clear ();
[+] 	clear();
[-] 	m_type = prop->getType ()->getPropertyPtrType (
[+] 	m_type = prop->getType()->getPropertyPtrType(
[-] Value::setEnumConst (EnumConst* enumConst)
[+] Value::setEnumConst(EnumConst* enumConst)
[-] 	enumType = enumConst->getParentEnumType ();
[+] 	enumType = enumConst->getParentEnumType();
[-] 	enumValue = enumConst->getValue ();
[+] 	enumValue = enumConst->getValue();
[-] 	if (enumType->getBaseType ()->getTypeKindFlags () & TypeKindFlag_BigEndian)
[+] 	if (enumType->getBaseType()->getTypeKindFlags() & TypeKindFlag_BigEndian)
[-] 		enumValue = sl::swapByteOrder64 (enumValue);
[+] 		enumValue = sl::swapByteOrder64(enumValue);
[-] 		size_t size = enumType->getSize ();
[+] 		size_t size = enumType->getSize();
[-] 	createConst (&enumValue, enumType);
[+] 	createConst(&enumValue, enumType);
[-] Value::setField (
[+] Value::setField(
[-] 	clear ();
[+] 	clear();
[-] 	m_constData.setCount (sizeof (size_t));
[+] 	m_constData.setCount(sizeof(size_t));
[-] 	*(size_t*) m_constData.p () = baseOffset + field->getOffset ();
[+] 	*(size_t*)m_constData.p() = baseOffset + field->getOffset();
[-] Value::setField (
[+] Value::setField(
[-] 	setField (field, field->getType (), baseOffset);
[+] 	setField(field, field->getType(), baseOffset);
[-] Value::setLlvmValue (
[+] Value::setLlvmValue(
[-] 	clear ();
[+] 	clear();
[-] Value::getLeanDataPtrValidator () const
[+] Value::getLeanDataPtrValidator() const
[-] 	ASSERT (m_valueKind == ValueKind_Variable);
[+] 	ASSERT(m_valueKind == ValueKind_Variable);
[-] 	m_leanDataPtrValidator = m_variable->getLeanDataPtrValidator ();
[+] 	m_leanDataPtrValidator = m_variable->getLeanDataPtrValidator();
[-] Value::setLeanDataPtrValidator (LeanDataPtrValidator* validator)
[+] Value::setLeanDataPtrValidator(LeanDataPtrValidator* validator)
[-] 	ASSERT (isDataPtrType (m_type, DataPtrTypeKind_Lean));
[+] 	ASSERT(isDataPtrType(m_type, DataPtrTypeKind_Lean));
[-] Value::setLeanDataPtrValidator (const Value& originValue)
[+] Value::setLeanDataPtrValidator(const Value& originValue)
[-] 	ASSERT (isDataPtrType (m_type, DataPtrTypeKind_Lean));
[+] 	ASSERT(isDataPtrType(m_type, DataPtrTypeKind_Lean));
[-] 		m_leanDataPtrValidator = originValue.m_variable->getLeanDataPtrValidator ();
[+] 		m_leanDataPtrValidator = originValue.m_variable->getLeanDataPtrValidator();
[-] 		m_leanDataPtrValidator = AXL_REF_NEW (LeanDataPtrValidator);
[+] 		m_leanDataPtrValidator = AXL_REF_NEW(LeanDataPtrValidator);
[-] Value::setLeanDataPtrValidator (
[+] Value::setLeanDataPtrValidator(
[-] 	ASSERT (isDataPtrType (m_type, DataPtrTypeKind_Lean));
[+] 	ASSERT(isDataPtrType(m_type, DataPtrTypeKind_Lean));
[-] 	ref::Ptr <LeanDataPtrValidator> validator = AXL_REF_NEW (LeanDataPtrValidator);
[+] 	ref::Ptr<LeanDataPtrValidator> validator = AXL_REF_NEW(LeanDataPtrValidator);
[-] Value::createConst (
[+] Value::createConst(
[-] 	clear ();
[+] 	clear();
[-] 	size_t size = type->getSize ();
[+] 	size_t size = type->getSize();
[-] 	size_t allocSize = AXL_MAX (size, sizeof (int64_t)); // ensure int64 for GetLlvmConst ()
[+] 	size_t allocSize = AXL_MAX(size, sizeof(int64_t)); // ensure int64 for GetLlvmConst ()
[-] 	bool result = m_constData.setCount (allocSize);
[+] 	bool result = m_constData.setCount(allocSize);
[-] 		memcpy (m_constData, p, size);
[+] 		memcpy(m_constData, p, size);
[-] 		memset (m_constData, 0, size);
[+] 		memset(m_constData, 0, size);
[-] Value::setCharArray (
[+] Value::setCharArray(
[-] 	Type* type = module->m_typeMgr.getArrayType (
[+] 	Type* type = module->m_typeMgr.getArrayType(
[-] 		module->m_typeMgr.getPrimitiveType (TypeKind_Char),
[+] 		module->m_typeMgr.getPrimitiveType(TypeKind_Char),
[-] 	createConst (p, type);
[+] 	createConst(p, type);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_Closure.h
----------------------
[-] 	sl::BoxList <Value> m_argValueList;
[+] 	sl::BoxList<Value> m_argValueList;
[-] 	Closure ()
[+] 	Closure()
[-] 	sl::BoxList <Value>*
[+] 	sl::BoxList<Value>*
[-] 	getArgValueList ()
[+] 	getArgValueList()
[-] 	isMemberClosure ()
[+] 	isMemberClosure()
[-] 	getThisArgIdx ()
[+] 	getThisArgIdx()
[-] 	getThisArgValue ();
[+] 	getThisArgValue();
[-] 	setThisArgIdx (size_t thisArgIdx);
[+] 	setThisArgIdx(size_t thisArgIdx);
[-] 	insertThisArgValue (const Value& thisValue);
[+] 	insertThisArgValue(const Value& thisValue);
[-] 	isSimpleClosure ()
[+] 	isSimpleClosure()
[-] 		return isMemberClosure () && m_argValueList.getCount () == 1;
[+] 		return isMemberClosure() && m_argValueList.getCount() == 1;
[-] 	append (const Value& argValue);
[+] 	append(const Value& argValue);
[-] 	append (const sl::ConstBoxList <Value>& argValueList);
[+] 	append(const sl::ConstBoxList<Value>& argValueList);
[-] 	apply (sl::BoxList <Value>* argValueList);
[+] 	apply(sl::BoxList<Value>* argValueList);
[-] 	getClosureType (Type* type);
[+] 	getClosureType(Type* type);
[-] 	getFunctionClosureType (Function* function); // choose the best overload
[+] 	getFunctionClosureType(Function* function); // choose the best overload
[-] 	getFunctionClosureType (FunctionPtrType* ptrType);
[+] 	getFunctionClosureType(FunctionPtrType* ptrType);
[-] 	getPropertyClosureType (PropertyPtrType* ptrType);
[+] 	getPropertyClosureType(PropertyPtrType* ptrType);
[-] 	getArgTypeArray (
[+] 	getArgTypeArray(
[-] 		sl::Array <FunctionArg*>* argArray
[+] 		sl::Array<FunctionArg*>* argArray
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_ConstMgr.h
----------------------
[-] 	Const ()
[+] 	Const()
[-] 	getValue ()
[+] 	getValue()
[-] 	sl::BoxList <Value> m_valueList;
[+] 	sl::BoxList<Value> m_valueList;
[-] 	sl::List <Const> m_constList;
[+] 	sl::List<Const> m_constList;
[-] 	sl::List <ConstDataPtrValidatorEntry> m_constDataPtrValidatorList;
[+] 	sl::List<ConstDataPtrValidatorEntry> m_constDataPtrValidatorList;
[-] 	ConstMgr ();
[+] 	ConstMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	createConst (
[+] 	createConst(
[-] 	saveValue (const Value& value)
[+] 	saveValue(const Value& value)
[-] 		sl::BoxIterator <Value> it = m_valueList.insertTail (value);
[+] 		sl::BoxIterator<Value> it = m_valueList.insertTail(value);
[-] 	saveLiteral (const sl::StringRef& string);
[+] 	saveLiteral(const sl::StringRef& string);
[-] 	createConstDataPtrValidator (
[+] 	createConstDataPtrValidator(
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_LeanDataPtrValidator.h
----------------------
[-] 	LeanDataPtrValidator ()
[+] 	LeanDataPtrValidator()
[-] 	isDynamicRange ()
[+] 	isDynamicRange()
[-] 	hasValidatorValue ()
[+] 	hasValidatorValue()
[-] 	getOriginValue ()
[+] 	getOriginValue()
[-] 	getRangeBeginValue ()
[+] 	getRangeBeginValue()
[-] 	getRangeLength ()
[+] 	getRangeLength()
[-] 		ASSERT (m_rangeLength); // should be checked with isDynamicRange ()
[+] 		ASSERT(m_rangeLength); // should be checked with isDynamicRange ()
[-] 	getValidatorValue ();
[+] 	getValidatorValue();
[-] 	createValidator ();
[+] 	createValidator();
[-] 	createValidator (const Value& boxValue);
[+] 	createValidator(const Value& boxValue);
[-] 	createClassFieldValidator ();
[+] 	createClassFieldValidator();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_Value\jnc_ct_Value.h
----------------------
[-] getValueKindString (ValueKind valueKind);
[+] getValueKindString(ValueKind valueKind);
[-] 	sl::Array <char> m_constData;
[+] 	sl::Array<char> m_constData;
[-] 	ref::Ptr <Closure> m_closure;
[+] 	ref::Ptr<Closure> m_closure;
[-] 	ref::Ptr <DynamicFieldValueInfo> m_dynamicFieldInfo;
[+] 	ref::Ptr<DynamicFieldValueInfo> m_dynamicFieldInfo;
[-] 	mutable ref::Ptr <LeanDataPtrValidator> m_leanDataPtrValidator;
[+] 	mutable ref::Ptr<LeanDataPtrValidator> m_leanDataPtrValidator;
[-] 	Value ()
[+] 	Value()
[-] 		init ();
[+] 		init();
[-] 	Value (
[+] 	Value(
[-] 		init ();
[+] 		init();
[-] 		overrideType (value, type);
[+] 		overrideType(value, type);
[-] 	Value (
[+] 	Value(
[-] 		init ();
[+] 		init();
[-] 		createConst (&value, type);
[+] 		createConst(&value, type);
[-] 	Value (
[+] 	Value(
[-] 		init ();
[+] 		init();
[-] 		createConst (p, type);
[+] 		createConst(p, type);
[-] 	Value (Type* type)
[+] 	Value(Type* type)
[-] 		init ();
[+] 		init();
[-] 		setType (type);
[+] 		setType(type);
[-] 	Value (GlobalNamespace* nspace)
[+] 	Value(GlobalNamespace* nspace)
[-] 		init ();
[+] 		init();
[-] 		setNamespace (nspace);
[+] 		setNamespace(nspace);
[-] 	Value (Variable* variable)
[+] 	Value(Variable* variable)
[-] 		init ();
[+] 		init();
[-] 		setVariable (variable);
[+] 		setVariable(variable);
[-] 	Value (Function* function)
[+] 	Value(Function* function)
[-] 		init ();
[+] 		init();
[-] 		setFunction (function);
[+] 		setFunction(function);
[-] 	Value (FunctionTypeOverload* functionTypeOverload)
[+] 	Value(FunctionTypeOverload* functionTypeOverload)
[-] 		init ();
[+] 		init();
[-] 		setFunctionTypeOverload (functionTypeOverload);
[+] 		setFunctionTypeOverload(functionTypeOverload);
[-] 	Value (Property* prop)
[+] 	Value(Property* prop)
[-] 		init ();
[+] 		init();
[-] 		setProperty (prop);
[+] 		setProperty(prop);
[-] 	Value (
[+] 	Value(
[-] 		init ();
[+] 		init();
[-] 		setLlvmValue (llvmValue, type, valueKind);
[+] 		setLlvmValue(llvmValue, type, valueKind);
[-] 	operator bool () const
[+] 	operator bool() const
[-] 		return !isEmpty ();
[+] 		return !isEmpty();
[-] 	getValueKind () const
[+] 	getValueKind() const
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	getType () const
[+] 	getType() const
[-] 	getNamespace () const
[+] 	getNamespace() const
[-] 		ASSERT (m_valueKind == ValueKind_Namespace);
[+] 		ASSERT(m_valueKind == ValueKind_Namespace);
[-] 	getVariable () const
[+] 	getVariable() const
[-] 		ASSERT (m_valueKind == ValueKind_Variable);
[+] 		ASSERT(m_valueKind == ValueKind_Variable);
[-] 	getFunction () const
[+] 	getFunction() const
[-] 		ASSERT (m_valueKind == ValueKind_Function);
[+] 		ASSERT(m_valueKind == ValueKind_Function);
[-] 	getFunctionTypeOverload () const
[+] 	getFunctionTypeOverload() const
[-] 		ASSERT (m_valueKind == ValueKind_FunctionTypeOverload);
[+] 		ASSERT(m_valueKind == ValueKind_FunctionTypeOverload);
[-] 	getProperty () const
[+] 	getProperty() const
[-] 		ASSERT (m_valueKind == ValueKind_Property);
[+] 		ASSERT(m_valueKind == ValueKind_Property);
[-] 	getField () const
[+] 	getField() const
[-] 		ASSERT (m_valueKind == ValueKind_Field);
[+] 		ASSERT(m_valueKind == ValueKind_Field);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	getConstDataArray () const
[+] 	getConstDataArray() const
[-] 	getConstData () const
[+] 	getConstData() const
[-] 		ASSERT (m_valueKind == ValueKind_Const || m_valueKind == ValueKind_Field);
[+] 		ASSERT(m_valueKind == ValueKind_Const || m_valueKind == ValueKind_Field);
[-] 		return m_constData.cp ();
[+] 		return m_constData.cp();
[-] 	getConstData ()
[+] 	getConstData()
[-] 		ASSERT (m_valueKind == ValueKind_Const);
[+] 		ASSERT(m_valueKind == ValueKind_Const);
[-] 		return m_constData.p ();
[+] 		return m_constData.p();
[-] 	getBool () const
[+] 	getBool() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (bool));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(bool));
[-] 		return *(const bool*) m_constData.cp ();
[+] 		return *(const bool*) m_constData.cp();
[-] 	getInt () const
[+] 	getInt() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (int));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(int));
[-] 		return *(const int*) m_constData.cp ();
[+] 		return *(const int*) m_constData.cp();
[-] 	getIntPtr () const
[+] 	getIntPtr() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (intptr_t));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(intptr_t));
[-] 		return *(const intptr_t*) m_constData.cp ();
[+] 		return *(const intptr_t*) m_constData.cp();
[-] 	getInt32 () const
[+] 	getInt32() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (int32_t));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(int32_t));
[-] 		return *(const int32_t*) m_constData.cp ();
[+] 		return *(const int32_t*) m_constData.cp();
[-] 	getInt64 () const
[+] 	getInt64() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (int64_t));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(int64_t));
[-] 		return *(const int64_t*) m_constData.cp ();
[+] 		return *(const int64_t*) m_constData.cp();
[-] 	getSizeT () const
[+] 	getSizeT() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (size_t));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(size_t));
[-] 		return *(const size_t*) m_constData.cp ();
[+] 		return *(const size_t*) m_constData.cp();
[-] 	getFloat () const
[+] 	getFloat() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (float));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(float));
[-] 		return *(const float*) m_constData.cp ();
[+] 		return *(const float*) m_constData.cp();
[-] 	getDouble () const
[+] 	getDouble() const
[-] 		ASSERT (m_valueKind == ValueKind_Const && m_type->getSize () >= sizeof (double));
[+] 		ASSERT(m_valueKind == ValueKind_Const && m_type->getSize() >= sizeof(double));
[-] 		return *(const double*) m_constData.cp ();
[+] 		return *(const double*) m_constData.cp();
[-] 	getFieldOffset () const
[+] 	getFieldOffset() const
[-] 		ASSERT (m_valueKind == ValueKind_Field && m_constData.getCount () >= sizeof (size_t));
[+] 		ASSERT(m_valueKind == ValueKind_Field && m_constData.getCount() >= sizeof(size_t));
[-] 		return *(const size_t*) m_constData.cp ();
[+] 		return *(const size_t*) m_constData.cp();
[-] 	hasLlvmValue () const
[+] 	hasLlvmValue() const
[-] 	getLlvmValue () const;
[+] 	getLlvmValue() const;
[-] 	getLlvmTypeString () const
[+] 	getLlvmTypeString() const
[-] 		llvm::Value* llvmValue = getLlvmValue ();
[+] 		llvm::Value* llvmValue = getLlvmValue();
[-] 		return llvmValue ? ct::getLlvmTypeString (llvmValue->getType ()) : sl::String ();
[+] 		return llvmValue ? ct::getLlvmTypeString(llvmValue->getType()) : sl::String();
[-] 	getLlvmConst (
[+] 	getLlvmConst(
[-] 	getClosure () const
[+] 	getClosure() const
[-] 	createClosure ();
[+] 	createClosure();
[-] 	setClosure (Closure* closure);
[+] 	setClosure(Closure* closure);
[-] 	clearClosure ()
[+] 	clearClosure()
[-] 	getClosureAwareType () const;
[+] 	getClosureAwareType() const;
[-] 	getDynamicFieldInfo () const
[+] 	getDynamicFieldInfo() const
[-] 	setDynamicFieldInfo (
[+] 	setDynamicFieldInfo(
[-] 	clearDynamicFieldInfo ()
[+] 	clearDynamicFieldInfo()
[-] 	overrideType (Type* type)
[+] 	overrideType(Type* type)
[-] 	overrideType (
[+] 	overrideType(
[-] 		overrideType (type);
[+] 		overrideType(type);
[-] 	clear ();
[+] 	clear();
[-] 	isZero () const
[+] 	isZero() const
[-] 			m_type->getTypeKind () == TypeKind_Int8 &&
[+] 			m_type->getTypeKind() == TypeKind_Int8 &&
[-] 			*(char*) m_constData.cp () == 0;
[+] 			*(char*)m_constData.cp() == 0;
[-] 	setVoid (Module* module);
[+] 	setVoid(Module* module);
[-] 	setNull (Module* module);
[+] 	setNull(Module* module);
[-] 	setNamespace (GlobalNamespace* nspace);
[+] 	setNamespace(GlobalNamespace* nspace);
[-] 	setNamespace (NamedType* type);
[+] 	setNamespace(NamedType* type);
[-] 	setType (Type* type);
[+] 	setType(Type* type);
[-] 	setVariable (Variable* variable);
[+] 	setVariable(Variable* variable);
[-] 	setFunction (Function* function);
[+] 	setFunction(Function* function);
[-] 	setFunctionTypeOverload (FunctionTypeOverload* functionTypeOverload);
[+] 	setFunctionTypeOverload(FunctionTypeOverload* functionTypeOverload);
[-] 	setProperty (Property* prop);
[+] 	setProperty(Property* prop);
[-] 	setEnumConst (EnumConst* enumConst);
[+] 	setEnumConst(EnumConst* enumConst);
[-] 	setField (
[+] 	setField(
[-] 	setField (
[+] 	setField(
[-] 	setLlvmValue (
[+] 	setLlvmValue(
[-] 	getLeanDataPtrValidator () const;
[+] 	getLeanDataPtrValidator() const;
[-] 	setLeanDataPtrValidator (LeanDataPtrValidator* validator);
[+] 	setLeanDataPtrValidator(LeanDataPtrValidator* validator);
[-] 	setLeanDataPtrValidator (const Value& originValue);
[+] 	setLeanDataPtrValidator(const Value& originValue);
[-] 	setLeanDataPtrValidator (
[+] 	setLeanDataPtrValidator(
[-] 	setLeanDataPtr (
[+] 	setLeanDataPtr(
[-] 		setLlvmValue (llvmValue, (Type*) type);
[+] 		setLlvmValue(llvmValue, (Type*)type);
[-] 		setLeanDataPtrValidator (validator);
[+] 		setLeanDataPtrValidator(validator);
[-] 	setLeanDataPtr (
[+] 	setLeanDataPtr(
[-] 		setLlvmValue (llvmValue, (Type*) type);
[+] 		setLlvmValue(llvmValue, (Type*)type);
[-] 		setLeanDataPtrValidator (originValue);
[+] 		setLeanDataPtrValidator(originValue);
[-] 	setLeanDataPtr (
[+] 	setLeanDataPtr(
[-] 		setLlvmValue (llvmValue, (Type*) type);
[+] 		setLlvmValue(llvmValue, (Type*)type);
[-] 		setLeanDataPtrValidator (originValue, rangeBeginValue, rangeLength);
[+] 		setLeanDataPtrValidator(originValue, rangeBeginValue, rangeLength);
[-] 	createConst (
[+] 	createConst(
[-] 	setConstBool (
[+] 	setConstBool(
[-] 		createConst (&value, getSimpleType (TypeKind_Bool, module));
[+] 		createConst(&value, getSimpleType(TypeKind_Bool, module));
[-] 	setConstInt32 (
[+] 	setConstInt32(
[-] 		createConst (&value, type);
[+] 		createConst(&value, type);
[-] 	setConstInt32 (
[+] 	setConstInt32(
[-] 		Type* type = getSimpleType (getInt32TypeKind (value), module);
[+] 		Type* type = getSimpleType(getInt32TypeKind(value), module);
[-] 		setConstInt32 (value, type);
[+] 		setConstInt32(value, type);
[-] 	setConstInt32_u (
[+] 	setConstInt32_u(
[-] 		Type* type = getSimpleType (getInt32TypeKind_u (value), module);
[+] 		Type* type = getSimpleType(getInt32TypeKind_u(value), module);
[-] 		setConstInt32 (value, type);
[+] 		setConstInt32(value, type);
[-] 	setConstInt64 (
[+] 	setConstInt64(
[-] 		createConst (&value, type);
[+] 		createConst(&value, type);
[-] 	setConstInt64 (
[+] 	setConstInt64(
[-] 		Type* type = getSimpleType (getInt64TypeKind (value), module);
[+] 		Type* type = getSimpleType(getInt64TypeKind(value), module);
[-] 		setConstInt64 (value, type);
[+] 		setConstInt64(value, type);
[-] 	setConstInt64_u (
[+] 	setConstInt64_u(
[-] 		Type* type = getSimpleType (getInt64TypeKind_u (value), module);
[+] 		Type* type = getSimpleType(getInt64TypeKind_u(value), module);
[-] 		setConstInt64 (value, type);
[+] 		setConstInt64(value, type);
[-] 	setConstSizeT (
[+] 	setConstSizeT(
[-] 		createConst (&value, type);
[+] 		createConst(&value, type);
[-] 	setConstSizeT (
[+] 	setConstSizeT(
[-] 		createConst (&value, getSimpleType (TypeKind_SizeT, module));
[+] 		createConst(&value, getSimpleType(TypeKind_SizeT, module));
[-] 	setConstFloat (
[+] 	setConstFloat(
[-] 		createConst (&value, getSimpleType (TypeKind_Float, module));
[+] 		createConst(&value, getSimpleType(TypeKind_Float, module));
[-] 	setConstDouble (
[+] 	setConstDouble(
[-] 		createConst (&value, getSimpleType (TypeKind_Double, module));
[+] 		createConst(&value, getSimpleType(TypeKind_Double, module));
[-] 	setEmptyCharArray (Module* module)
[+] 	setEmptyCharArray(Module* module)
[-] 		setCharArray ("", 1, module);
[+] 		setCharArray("", 1, module);
[-] 	setCharArray (
[+] 	setCharArray(
[-] 		if (string.isEmpty ())
[+] 		if (string.isEmpty())
[-] 			setEmptyCharArray (module);
[+] 			setEmptyCharArray(module);
[-] 			setCharArray (string.sz (), string.getLength () + 1, module);
[+] 			setCharArray(string.sz(), string.getLength() + 1, module);
[-] 	setCharArray (
[+] 	setCharArray(
[-] 	init ();
[+] 	init();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_VariableMgr\jnc_ct_Variable.cpp
----------------------
[-] Variable::Variable ()
[+] Variable::Variable()
[-] Variable::getLeanDataPtrValidator ()
[+] Variable::getLeanDataPtrValidator()
[-] 	Value originValue (this);
[+] 	Value originValue(this);
[-] 	m_leanDataPtrValidator = AXL_REF_NEW (LeanDataPtrValidator);
[+] 	m_leanDataPtrValidator = AXL_REF_NEW(LeanDataPtrValidator);
[-] 	m_leanDataPtrValidator->m_rangeLength = m_type->getSize ();
[+] 	m_leanDataPtrValidator->m_rangeLength = m_type->getSize();
[-] Variable::getStaticData ()
[+] Variable::getStaticData()
[-] 	ASSERT (m_storageKind == StorageKind_Static);
[+] 	ASSERT(m_storageKind == StorageKind_Static);
[-] 	llvm::ExecutionEngine* llvmExecutionEngine = m_module->getLlvmExecutionEngine ();
[+] 	llvm::ExecutionEngine* llvmExecutionEngine = m_module->getLlvmExecutionEngine();
[-] 	m_staticData = (m_module->getCompileFlags () & ModuleCompileFlag_McJit) ?
[+] 	m_staticData = (m_module->getCompileFlags() & ModuleCompileFlag_McJit) ?
[-] 		(void*) llvmExecutionEngine->getGlobalValueAddress (m_llvmGlobalVariable->getName ()) :
[+] 		(void*)llvmExecutionEngine->getGlobalValueAddress(m_llvmGlobalVariable->getName()) :
[-] 		(void*) llvmExecutionEngine->getPointerToGlobal (m_llvmGlobalVariable);
[+] 		(void*)llvmExecutionEngine->getPointerToGlobal(m_llvmGlobalVariable);
[-] Variable::getLlvmValue ()
[+] Variable::getLlvmValue()
[-] 	ASSERT (m_storageKind == StorageKind_Tls);
[+] 	ASSERT(m_storageKind == StorageKind_Tls);
[-] 	Function* function = m_module->m_functionMgr.getCurrentFunction ();
[+] 	Function* function = m_module->m_functionMgr.getCurrentFunction();
[-] 	BasicBlock* prologueBlock = function->getPrologueBlock ();
[+] 	BasicBlock* prologueBlock = function->getPrologueBlock();
[-] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock (prologueBlock);
[+] 	BasicBlock* prevBlock = m_module->m_controlFlowMgr.setCurrentBlock(prologueBlock);
[-] 	m_llvmValue = m_module->m_llvmIrBuilder.createAlloca (
[+] 	m_llvmValue = m_module->m_llvmIrBuilder.createAlloca(
[-] 	m_module->m_controlFlowMgr.setCurrentBlock (prevBlock);
[+] 	m_module->m_controlFlowMgr.setCurrentBlock(prevBlock);
[-] 	function->addTlsVariable (this);
[+] 	function->addTlsVariable(this);
[-] Variable::isInitializationNeeded ()
[+] Variable::isInitializationNeeded()
[-] 		!m_constructor.isEmpty () ||
[+] 		!m_constructor.isEmpty() ||
[-] 		!m_initializer.isEmpty () ||
[+] 		!m_initializer.isEmpty() ||
[-] 		m_type->getTypeKind () == TypeKind_Class; // static class variable
[+] 		m_type->getTypeKind() == TypeKind_Class; // static class variable
[-] Variable::generateDocumentation (
[+] Variable::generateDocumentation(
[-] 	DoxyBlock* doxyBlock = getDoxyBlock ();
[+] 	DoxyBlock* doxyBlock = getDoxyBlock();
[-] 	bool isMulticast = isClassType (m_type, ClassTypeKind_Multicast);
[+] 	bool isMulticast = isClassType(m_type, ClassTypeKind_Multicast);
[-] 	itemXml->format ("<memberdef kind='%s' id='%s'", kind, doxyBlock->getRefId ().sz ());
[+] 	itemXml->format("<memberdef kind='%s' id='%s'", kind, doxyBlock->getRefId ().sz ());
[-] 		itemXml->appendFormat (" prot='%s'", getAccessKindString (m_accessKind));
[+] 		itemXml->appendFormat(" prot='%s'", getAccessKindString (m_accessKind));
[-] 		itemXml->append (" static='yes'");
[+] 		itemXml->append(" static='yes'");
[-] 		itemXml->append (" tls='yes'");
[+] 		itemXml->append(" tls='yes'");
[-] 		itemXml->append (" const='yes'");
[+] 		itemXml->append(" const='yes'");
[-] 	itemXml->appendFormat (">\n<name>%s</name>\n", m_name.sz ());
[+] 	itemXml->appendFormat(">\n<name>%s</name>\n", m_name.sz ());
[-] 	itemXml->append (m_type->getDoxyTypeString ());
[+] 	itemXml->append(m_type->getDoxyTypeString());
[-] 	sl::String ptrTypeFlagString = getPtrTypeFlagString (m_ptrTypeFlags & ~PtrTypeFlag_DualEvent);
[+] 	sl::String ptrTypeFlagString = getPtrTypeFlagString(m_ptrTypeFlags & ~PtrTypeFlag_DualEvent);
[-] 	if (!ptrTypeFlagString.isEmpty ())
[+] 	if (!ptrTypeFlagString.isEmpty())
[-] 		itemXml->appendFormat ("<modifiers>%s</modifiers>\n", ptrTypeFlagString.sz ());
[+] 		itemXml->appendFormat("<modifiers>%s</modifiers>\n", ptrTypeFlagString.sz ());
[-] 	if (!m_initializer.isEmpty ())
[+] 	if (!m_initializer.isEmpty())
[-] 		itemXml->appendFormat ("<initializer>= %s</initializer>\n", getInitializerString ().sz ());
[+] 		itemXml->appendFormat("<initializer>= %s</initializer>\n", getInitializerString ().sz ());
[-] 	itemXml->append (doxyBlock->getImportString ());
[+] 	itemXml->append(doxyBlock->getImportString());
[-] 	itemXml->append (doxyBlock->getDescriptionString ());
[+] 	itemXml->append(doxyBlock->getDescriptionString());
[-] 	itemXml->append (getDoxyLocationString ());
[+] 	itemXml->append(getDoxyLocationString());
[-] 	itemXml->append ("</memberdef>\n");
[+] 	itemXml->append("</memberdef>\n");
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_VariableMgr\jnc_ct_VariableMgr.cpp
----------------------
[-] VariableMgr::VariableMgr ()
[+] VariableMgr::VariableMgr()
[-] 	m_module = Module::getCurrentConstructedModule ();
[+] 	m_module = Module::getCurrentConstructedModule();
[-] 	ASSERT (m_module);
[+] 	ASSERT(m_module);
[-] 	memset (m_stdVariableArray, 0, sizeof (m_stdVariableArray));
[+] 	memset(m_stdVariableArray, 0, sizeof(m_stdVariableArray));
[-] VariableMgr::clear ()
[+] VariableMgr::clear()
[-] 	m_variableList.clear ();
[+] 	m_variableList.clear();
[-] 	m_staticVariableArray.clear ();
[+] 	m_staticVariableArray.clear();
[-] 	m_staticGcRootArray.clear ();
[+] 	m_staticGcRootArray.clear();
[-] 	m_globalStaticVariableArray.clear ();
[+] 	m_globalStaticVariableArray.clear();
[-] 	m_liftedStackVariableArray.clear ();
[+] 	m_liftedStackVariableArray.clear();
[-] 	m_argVariableArray.clear ();
[+] 	m_argVariableArray.clear();
[-] 	m_tlsVariableArray.clear ();
[+] 	m_tlsVariableArray.clear();
[-] 	memset (m_stdVariableArray, 0, sizeof (m_stdVariableArray));
[+] 	memset(m_stdVariableArray, 0, sizeof(m_stdVariableArray));
[-] VariableMgr::createStdVariables ()
[+] VariableMgr::createStdVariables()
[-] 	getStdVariable (StdVariable_SjljFrame);
[+] 	getStdVariable(StdVariable_SjljFrame);
[-] 	getStdVariable (StdVariable_GcShadowStackTop);
[+] 	getStdVariable(StdVariable_GcShadowStackTop);
[-] VariableMgr::getStdVariable (StdVariable stdVariable)
[+] VariableMgr::getStdVariable(StdVariable stdVariable)
[-] 	ASSERT ((size_t) stdVariable < StdVariable__Count);
[+] 	ASSERT((size_t)stdVariable < StdVariable__Count);
[-] 	if (m_stdVariableArray [stdVariable])
[+] 	if (m_stdVariableArray[stdVariable])
[-] 		return m_stdVariableArray [stdVariable];
[+] 		return m_stdVariableArray[stdVariable];
[-] 	switch (stdVariable)
[+] 	switch(stdVariable)
[-] 		variable = createVariable (
[+] 		variable = createVariable(
[-] 			m_module->m_typeMgr.getStdType (StdType_SjljFrame)->getDataPtrType_c ()
[+] 			m_module->m_typeMgr.getStdType(StdType_SjljFrame)->getDataPtrType_c()
[-] 		variable = createVariable (
[+] 		variable = createVariable(
[-] 			m_module->m_typeMgr.getStdType (StdType_GcShadowStackFrame)->getDataPtrType_c ()
[+] 			m_module->m_typeMgr.getStdType(StdType_GcShadowStackFrame)->getDataPtrType_c()
[-] 		variable = createVariable (
[+] 		variable = createVariable(
[-] 			m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr)->getDataPtrType_c ()
[+] 			m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr)->getDataPtrType_c()
[-] 		variable = createVariable (
[+] 		variable = createVariable(
[-] 			m_module->m_typeMgr.getPrimitiveType (TypeKind_Char)
[+] 			m_module->m_typeMgr.getPrimitiveType(TypeKind_Char)
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	m_stdVariableArray [stdVariable] = variable;
[+] 	m_stdVariableArray[stdVariable] = variable;
[-] VariableMgr::createVariable (
[+] VariableMgr::createVariable(
[-] 	sl::BoxList <Token>* constructor,
[+] 	sl::BoxList<Token>* constructor,
[-] 	sl::BoxList <Token>* initializer
[+] 	sl::BoxList<Token>* initializer
[-] 	Variable* variable = AXL_MEM_NEW (Variable);
[+] 	Variable* variable = AXL_MEM_NEW(Variable);
[-] 	variable->m_scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	variable->m_scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 		sl::takeOver (&variable->m_constructor, constructor);
[+] 		sl::takeOver(&variable->m_constructor, constructor);
[-] 		sl::takeOver (&variable->m_initializer, initializer);
[+] 		sl::takeOver(&variable->m_initializer, initializer);
[-] 	m_variableList.insertTail (variable);
[+] 	m_variableList.insertTail(variable);
[-] 	switch (storageKind)
[+] 	switch(storageKind)
[-] 		m_staticVariableArray.append (variable);
[+] 		m_staticVariableArray.append(variable);
[-] 		if (!m_module->m_namespaceMgr.getCurrentScope ())
[+] 		if (!m_module->m_namespaceMgr.getCurrentScope())
[-] 			m_globalStaticVariableArray.append (variable);
[+] 			m_globalStaticVariableArray.append(variable);
[-] 		variable->m_llvmGlobalVariable = createLlvmGlobalVariable (type, qualifiedName);
[+] 		variable->m_llvmGlobalVariable = createLlvmGlobalVariable(type, qualifiedName);
[-] 		if (type->getFlags () & TypeFlag_GcRoot)
[+] 		if (type->getFlags() & TypeFlag_GcRoot)
[-] 			m_staticGcRootArray.append (variable);
[+] 			m_staticGcRootArray.append(variable);
[-] 		m_tlsVariableArray.append (variable);
[+] 		m_tlsVariableArray.append(variable);
[-] 		m_module->m_llvmIrBuilder.createAlloca (type, qualifiedName, NULL, &ptrValue);
[+] 		m_module->m_llvmIrBuilder.createAlloca(type, qualifiedName, NULL, &ptrValue);
[-] 		variable->m_llvmValue = ptrValue.getLlvmValue ();
[+] 		variable->m_llvmValue = ptrValue.getLlvmValue();
[-] 		m_module->m_llvmIrBuilder.saveInsertPoint (&variable->m_liftInsertPoint);
[+] 		m_module->m_llvmIrBuilder.saveInsertPoint(&variable->m_liftInsertPoint);
[-] 		result = allocateHeapVariable (variable);
[+] 		result = allocateHeapVariable(variable);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Import)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Import)
[-] 		((ImportType*) type)->addFixup (&variable->m_type);
[+] 		((ImportType*)type)->addFixup(&variable->m_type);
[-] VariableMgr::createSimpleStaticVariable (
[+] VariableMgr::createSimpleStaticVariable(
[-] 	ASSERT (type->getTypeKind () != TypeKind_Class);
[+] 	ASSERT(type->getTypeKind() != TypeKind_Class);
[-] 	Variable* variable = AXL_MEM_NEW (Variable);
[+] 	Variable* variable = AXL_MEM_NEW(Variable);
[-] 	variable->m_scope = m_module->m_namespaceMgr.getCurrentScope ();
[+] 	variable->m_scope = m_module->m_namespaceMgr.getCurrentScope();
[-] 	variable->m_llvmGlobalVariable = createLlvmGlobalVariable (type, qualifiedName, value);
[+] 	variable->m_llvmGlobalVariable = createLlvmGlobalVariable(type, qualifiedName, value);
[-] 	if (type->getFlags () & TypeFlag_GcRoot)
[+] 	if (type->getFlags() & TypeFlag_GcRoot)
[-] 		m_staticGcRootArray.append (variable);
[+] 		m_staticGcRootArray.append(variable);
[-] 	m_variableList.insertTail (variable);
[+] 	m_variableList.insertTail(variable);
[-] VariableMgr::initializeVariable (Variable* variable)
[+] VariableMgr::initializeVariable(Variable* variable)
[-] 	if (variable->m_type->getFlags () & TypeFlag_Dynamic)
[+] 	if (variable->m_type->getFlags() & TypeFlag_Dynamic)
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			variable->m_qualifiedName.sz (),
[+] 			variable->m_qualifiedName.sz(),
[-] 			variable->m_type->getTypeString ().sz ()
[+] 			variable->m_type->getTypeString().sz()
[-] 		variable->pushSrcPosError ();
[+] 		variable->pushSrcPosError();
[-] 	switch (variable->m_storageKind)
[+] 	switch(variable->m_storageKind)
[-] 		if (variable->m_type->getTypeKind () == TypeKind_Class)
[+] 		if (variable->m_type->getTypeKind() == TypeKind_Class)
[-] 			primeStaticClassVariable (variable);
[+] 			primeStaticClassVariable(variable);
[-] 		if (variable->m_type->getFlags () & TypeFlag_GcRoot)
[+] 		if (variable->m_type->getFlags() & TypeFlag_GcRoot)
[-] 			m_module->m_operatorMgr.zeroInitialize (variable);
[+] 			m_module->m_operatorMgr.zeroInitialize(variable);
[-] 			m_module->m_gcShadowStackMgr.markGcRoot (variable, variable->m_type);
[+] 			m_module->m_gcShadowStackMgr.markGcRoot(variable, variable->m_type);
[-] 		else if ((variable->m_type->getTypeKindFlags () & TypeKindFlag_Aggregate) || variable->m_initializer.isEmpty ())
[+] 		else if ((variable->m_type->getTypeKindFlags() & TypeKindFlag_Aggregate) || variable->m_initializer.isEmpty())
[-] 			m_module->m_operatorMgr.zeroInitialize (variable);
[+] 			m_module->m_operatorMgr.zeroInitialize(variable);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 		m_module->m_unitMgr.setCurrentUnit (variable->m_parentUnit);
[+] 		m_module->m_unitMgr.setCurrentUnit(variable->m_parentUnit);
[-] 	return m_module->m_operatorMgr.parseInitializer (
[+] 	return m_module->m_operatorMgr.parseInitializer(
[-] VariableMgr::finalizeDisposableVariable (Variable* variable)
[+] VariableMgr::finalizeDisposableVariable(Variable* variable)
[-] 	ASSERT (variable->m_scope && (variable->m_scope->getFlags () & ScopeFlag_Disposable));
[+] 	ASSERT(variable->m_scope && (variable->m_scope->getFlags() & ScopeFlag_Disposable));
[-] 	Type* ptrType = variable->m_type->getTypeKind () == TypeKind_Class ?
[+] 	Type* ptrType = variable->m_type->getTypeKind() == TypeKind_Class ?
[-] 		(Type*) ((ClassType*) variable->m_type)->getClassPtrType () :
[+] 		(Type*)((ClassType*)variable->m_type)->getClassPtrType() :
[-] 		(variable->m_type->getTypeKindFlags () & TypeKindFlag_Ptr) ?
[+] 		(variable->m_type->getTypeKindFlags() & TypeKindFlag_Ptr) ?
[-] 			variable->m_type->getDataPtrType_c () :
[+] 			variable->m_type->getDataPtrType_c() :
[-] 			variable->m_type->getDataPtrType ();
[+] 			variable->m_type->getDataPtrType();
[-] 	Variable* ptrVariable = createSimpleStackVariable ("disposable_variable_ptr", ptrType);
[+] 	Variable* ptrVariable = createSimpleStackVariable("disposable_variable_ptr", ptrType);
[-] 		m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, variable, &ptrValue) &&
[+] 		m_module->m_operatorMgr.unaryOperator(UnOpKind_Addr, variable, &ptrValue) &&
[-] 		m_module->m_operatorMgr.storeDataRef (ptrVariable, ptrValue);
[+] 		m_module->m_operatorMgr.storeDataRef(ptrVariable, ptrValue);
[-] 	size_t count = variable->m_scope->addDisposableVariable (ptrVariable);
[+] 	size_t count = variable->m_scope->addDisposableVariable(ptrVariable);
[-] 	Variable* disposeLevelVariable = variable->m_scope->getDisposeLevelVariable ();
[+] 	Variable* disposeLevelVariable = variable->m_scope->getDisposeLevelVariable();
[-] 	m_module->m_llvmIrBuilder.createStore (
[+] 	m_module->m_llvmIrBuilder.createStore(
[-] 		Value (&count, disposeLevelVariable->m_type),
[+] 		Value(&count, disposeLevelVariable->m_type),
[-] VariableMgr::createLlvmGlobalVariable (
[+] VariableMgr::createLlvmGlobalVariable(
[-] 		(llvm::Constant*) initValue.getLlvmValue () :
[+] 		(llvm::Constant*)initValue.getLlvmValue() :
[-] 		(llvm::Constant*) type->getZeroValue ().getLlvmValue ();
[+] 		(llvm::Constant*)type->getZeroValue().getLlvmValue();
[-] 	if (m_module->getCompileFlags () & ModuleCompileFlag_McJit)
[+] 	if (m_module->getCompileFlags() & ModuleCompileFlag_McJit)
[-] 	return new llvm::GlobalVariable (
[+] 	return new llvm::GlobalVariable(
[-] 		*m_module->getLlvmModule (),
[+] 		*m_module->getLlvmModule(),
[-] 		type->getLlvmType (),
[+] 		type->getLlvmType(),
[-] VariableMgr::primeStaticClassVariable (Variable* variable)
[+] VariableMgr::primeStaticClassVariable(Variable* variable)
[-] 	ASSERT (variable->m_storageKind == StorageKind_Static && variable->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(variable->m_storageKind == StorageKind_Static && variable->m_type->getTypeKind() == TypeKind_Class);
[-] 	Function* primeStaticClass = m_module->m_functionMgr.getStdFunction (StdFunc_PrimeStaticClass);
[+] 	Function* primeStaticClass = m_module->m_functionMgr.getStdFunction(StdFunc_PrimeStaticClass);
[-] 	Value argValueArray [2];
[+] 	Value argValueArray[2];
[-] 	m_module->m_llvmIrBuilder.createBitCast (
[+] 	m_module->m_llvmIrBuilder.createBitCast(
[-] 		m_module->m_typeMgr.getStdType (StdType_BoxPtr),
[+] 		m_module->m_typeMgr.getStdType(StdType_BoxPtr),
[-] 		&argValueArray [0]
[+] 		&argValueArray[0]
[-] 	argValueArray [1].createConst (
[+] 	argValueArray[1].createConst(
[-] 		m_module->m_typeMgr.getStdType (StdType_BytePtr)
[+] 		m_module->m_typeMgr.getStdType(StdType_BytePtr)
[-] 	m_module->m_llvmIrBuilder.createCall (
[+] 	m_module->m_llvmIrBuilder.createCall(
[-] 		primeStaticClass->getType (),
[+] 		primeStaticClass->getType(),
[-] 	m_module->m_llvmIrBuilder.createGep2 (variable->m_llvmValue, 1, NULL, &ifaceValue);
[+] 	m_module->m_llvmIrBuilder.createGep2(variable->m_llvmValue, 1, NULL, &ifaceValue);
[-] 	variable->m_llvmValue = ifaceValue.getLlvmValue ();
[+] 	variable->m_llvmValue = ifaceValue.getLlvmValue();
[-] 	Function* destructor = ((ClassType*) variable->m_type)->getDestructor ();
[+] 	Function* destructor = ((ClassType*)variable->m_type)->getDestructor();
[-] 		Function* addDestructor = m_module->m_functionMgr.getStdFunction (StdFunc_AddStaticClassDestructor);
[+] 		Function* addDestructor = m_module->m_functionMgr.getStdFunction(StdFunc_AddStaticClassDestructor);
[-] 		Value argValueArray [2];
[+] 		Value argValueArray[2];
[-] 		m_module->m_llvmIrBuilder.createBitCast (destructor, m_module->m_typeMgr.getStdType (StdType_BytePtr), &argValueArray [0]);
[+] 		m_module->m_llvmIrBuilder.createBitCast(destructor, m_module->m_typeMgr.getStdType(StdType_BytePtr), &argValueArray[0]);
[-] 		m_module->m_llvmIrBuilder.createBitCast (variable, m_module->m_typeMgr.getStdType (StdType_AbstractClassPtr), &argValueArray [1]);
[+] 		m_module->m_llvmIrBuilder.createBitCast(variable, m_module->m_typeMgr.getStdType(StdType_AbstractClassPtr), &argValueArray[1]);
[-] 		m_module->m_llvmIrBuilder.createCall (addDestructor, addDestructor->getType (), argValueArray, countof (argValueArray), NULL);
[+] 		m_module->m_llvmIrBuilder.createCall(addDestructor, addDestructor->getType(), argValueArray, countof(argValueArray), NULL);
[-] VariableMgr::createOnceFlagVariable (StorageKind storageKind)
[+] VariableMgr::createOnceFlagVariable(StorageKind storageKind)
[-] 	return createVariable (
[+] 	return createVariable(
[-] 		m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32),
[+] 		m_module->m_typeMgr.getPrimitiveType(TypeKind_Int32),
[-] VariableMgr::createStaticDataPtrValidatorVariable (Variable* variable)
[+] VariableMgr::createStaticDataPtrValidatorVariable(Variable* variable)
[-] 	ASSERT (variable->m_storageKind == StorageKind_Static);
[+] 	ASSERT(variable->m_storageKind == StorageKind_Static);
[-] 	StructType* boxType = (StructType*) m_module->m_typeMgr.getStdType (StdType_StaticDataBox);
[+] 	StructType* boxType = (StructType*)m_module->m_typeMgr.getStdType(StdType_StaticDataBox);
[-] 	m_module->m_llvmIrBuilder.createBitCast (
[+] 	m_module->m_llvmIrBuilder.createBitCast(
[-] 		m_module->m_typeMgr.getStdType (StdType_BytePtr),
[+] 		m_module->m_typeMgr.getStdType(StdType_BytePtr),
[-] 	m_module->m_llvmIrBuilder.createGep (
[+] 	m_module->m_llvmIrBuilder.createGep(
[-] 		variable->m_type->getSize (),
[+] 		variable->m_type->getSize(),
[-] 		m_module->m_typeMgr.getStdType (StdType_BytePtr),
[+] 		m_module->m_typeMgr.getStdType(StdType_BytePtr),
[-] 	ASSERT (llvm::isa <llvm::Constant> (variablePtrValue.getLlvmValue ()));
[+] 	ASSERT(llvm::isa<llvm::Constant> (variablePtrValue.getLlvmValue()));
[-] 	ASSERT (llvm::isa <llvm::Constant> (variableEndPtrValue.getLlvmValue ()));
[+] 	ASSERT(llvm::isa<llvm::Constant> (variableEndPtrValue.getLlvmValue()));
[-] 	llvm::Constant* llvmMemberArray [4]; // this buffer is used twice
[+] 	llvm::Constant* llvmMemberArray[4]; // this buffer is used twice
[-] 	llvmMemberArray [0] = Value::getLlvmConst (m_module->m_typeMgr.getStdType (StdType_BytePtr), &variable->m_type),
[+] 	llvmMemberArray[0] = Value::getLlvmConst(m_module->m_typeMgr.getStdType(StdType_BytePtr), &variable->m_type),
[-] 	llvmMemberArray [1] = Value::getLlvmConst (m_module->m_typeMgr.getPrimitiveType (TypeKind_IntPtr_u), &flags),
[+] 	llvmMemberArray[1] = Value::getLlvmConst(m_module->m_typeMgr.getPrimitiveType(TypeKind_IntPtr_u), &flags),
[-] 	llvmMemberArray [2] = (llvm::Constant*) variablePtrValue.getLlvmValue ();
[+] 	llvmMemberArray[2] = (llvm::Constant*)variablePtrValue.getLlvmValue();
[-] 	llvm::Constant* llvmBoxConst = llvm::ConstantStruct::get (
[+] 	llvm::Constant* llvmBoxConst = llvm::ConstantStruct::get(
[-] 		(llvm::StructType*) boxType->getLlvmType (),
[+] 		(llvm::StructType*)boxType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Constant*> (llvmMemberArray, 3)
[+] 		llvm::ArrayRef<llvm::Constant*> (llvmMemberArray, 3)
[-] 	llvm::GlobalVariable* llvmBoxVariable = new llvm::GlobalVariable (
[+] 	llvm::GlobalVariable* llvmBoxVariable = new llvm::GlobalVariable(
[-] 		*m_module->getLlvmModule (),
[+] 		*m_module->getLlvmModule(),
[-] 		boxType->getLlvmType (),
[+] 		boxType->getLlvmType(),
[-] 		boxTag.sz ()
[+] 		boxTag.sz()
[-] 	StructType* validatorType = (StructType*) m_module->m_typeMgr.getStdType (StdType_DataPtrValidator);
[+] 	StructType* validatorType = (StructType*)m_module->m_typeMgr.getStdType(StdType_DataPtrValidator);
[-] 	m_module->m_llvmIrBuilder.createBitCast (
[+] 	m_module->m_llvmIrBuilder.createBitCast(
[-] 		m_module->m_typeMgr.getStdType (StdType_BoxPtr),
[+] 		m_module->m_typeMgr.getStdType(StdType_BoxPtr),
[-] 	ASSERT (llvm::isa <llvm::Constant> (boxPtrValue.getLlvmValue ()));
[+] 	ASSERT(llvm::isa<llvm::Constant> (boxPtrValue.getLlvmValue()));
[-] 	llvmMemberArray [0] = (llvm::Constant*) boxPtrValue.getLlvmValue ();
[+] 	llvmMemberArray[0] = (llvm::Constant*)boxPtrValue.getLlvmValue();
[-] 	llvmMemberArray [1] = (llvm::Constant*) boxPtrValue.getLlvmValue ();
[+] 	llvmMemberArray[1] = (llvm::Constant*)boxPtrValue.getLlvmValue();
[-] 	llvmMemberArray [2] = (llvm::Constant*) variablePtrValue.getLlvmValue ();
[+] 	llvmMemberArray[2] = (llvm::Constant*)variablePtrValue.getLlvmValue();
[-] 	llvmMemberArray [3] = (llvm::Constant*) variableEndPtrValue.getLlvmValue ();
[+] 	llvmMemberArray[3] = (llvm::Constant*)variableEndPtrValue.getLlvmValue();
[-] 	llvm::Constant* llvmValidatorConst = llvm::ConstantStruct::get (
[+] 	llvm::Constant* llvmValidatorConst = llvm::ConstantStruct::get(
[-] 		(llvm::StructType*) validatorType->getLlvmType (),
[+] 		(llvm::StructType*)validatorType->getLlvmType(),
[-] 		llvm::ArrayRef <llvm::Constant*> (llvmMemberArray, 4)
[+] 		llvm::ArrayRef<llvm::Constant*> (llvmMemberArray, 4)
[-] 	llvm::GlobalVariable* llvmValidatorVariable = new llvm::GlobalVariable (
[+] 	llvm::GlobalVariable* llvmValidatorVariable = new llvm::GlobalVariable(
[-] 		*m_module->getLlvmModule (),
[+] 		*m_module->getLlvmModule(),
[-] 		validatorType->getLlvmType (),
[+] 		validatorType->getLlvmType(),
[-] 		validatorTag.sz ()
[+] 		validatorTag.sz()
[-] 	Variable* validatorVariable = AXL_MEM_NEW (Variable);
[+] 	Variable* validatorVariable = AXL_MEM_NEW(Variable);
[-] 	m_variableList.insertTail (validatorVariable);
[+] 	m_variableList.insertTail(validatorVariable);
[-] 	LeanDataPtrValidator* validator = variable->getLeanDataPtrValidator ();
[+] 	LeanDataPtrValidator* validator = variable->getLeanDataPtrValidator();
[-] VariableMgr::allocateHeapVariable (Variable* variable)
[+] VariableMgr::allocateHeapVariable(Variable* variable)
[-] 	bool result = m_module->m_operatorMgr.gcHeapAllocate (variable->m_type, &ptrValue);
[+] 	bool result = m_module->m_operatorMgr.gcHeapAllocate(variable->m_type, &ptrValue);
[-] 	if (variable->m_type->getTypeKind () == TypeKind_Class)
[+] 	if (variable->m_type->getTypeKind() == TypeKind_Class)
[-] 		variable->m_llvmValue = ptrValue.getLlvmValue ();
[+] 		variable->m_llvmValue = ptrValue.getLlvmValue();
[-] 		m_module->m_llvmIrBuilder.createExtractValue (ptrValue, 0, NULL, &variableValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(ptrValue, 0, NULL, &variableValue);
[-] 		m_module->m_llvmIrBuilder.createExtractValue (ptrValue, 1, NULL, &validatorValue);
[+] 		m_module->m_llvmIrBuilder.createExtractValue(ptrValue, 1, NULL, &validatorValue);
[-] 		m_module->m_llvmIrBuilder.createBitCast (variableValue, variable->m_type->getDataPtrType_c (), &variableValue);
[+] 		m_module->m_llvmIrBuilder.createBitCast(variableValue, variable->m_type->getDataPtrType_c(), &variableValue);
[-] 		variable->m_llvmValue = variableValue.getLlvmValue ();
[+] 		variable->m_llvmValue = variableValue.getLlvmValue();
[-] 		LeanDataPtrValidator* validator = variable->getLeanDataPtrValidator ();
[+] 		LeanDataPtrValidator* validator = variable->getLeanDataPtrValidator();
[-] VariableMgr::liftStackVariable (Variable* variable)
[+] VariableMgr::liftStackVariable(Variable* variable)
[-] 	ASSERT (variable->m_storageKind == StorageKind_Stack);
[+] 	ASSERT(variable->m_storageKind == StorageKind_Stack);
[-] 	ASSERT (llvm::isa <llvm::AllocaInst> (variable->m_llvmValue));
[+] 	ASSERT(llvm::isa<llvm::AllocaInst> (variable->m_llvmValue));
[-] 	ASSERT (variable->m_liftInsertPoint);
[+] 	ASSERT(variable->m_liftInsertPoint);
[-] 	variable->m_llvmPreLiftValue = (llvm::AllocaInst*) variable->m_llvmValue;
[+] 	variable->m_llvmPreLiftValue = (llvm::AllocaInst*)variable->m_llvmValue;
[-] 	bool isInsertPointChanged = m_module->m_llvmIrBuilder.restoreInsertPoint (
[+] 	bool isInsertPointChanged = m_module->m_llvmIrBuilder.restoreInsertPoint(
[-] 	bool result = allocateHeapVariable (variable);
[+] 	bool result = allocateHeapVariable(variable);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 		m_module->m_llvmIrBuilder.restoreInsertPoint (prevInsertPoint);
[+] 		m_module->m_llvmIrBuilder.restoreInsertPoint(prevInsertPoint);
[-] 	m_liftedStackVariableArray.append (variable);
[+] 	m_liftedStackVariableArray.append(variable);
[-] VariableMgr::finalizeFunction ()
[+] VariableMgr::finalizeFunction()
[-] 	size_t count = m_liftedStackVariableArray.getCount ();
[+] 	size_t count = m_liftedStackVariableArray.getCount();
[-] 		Variable* variable = m_liftedStackVariableArray [i];
[+] 		Variable* variable = m_liftedStackVariableArray[i];
[-] 		ASSERT (variable->m_llvmPreLiftValue);
[+] 		ASSERT(variable->m_llvmPreLiftValue);
[-] 		variable->m_llvmPreLiftValue->replaceAllUsesWith (variable->m_llvmValue);
[+] 		variable->m_llvmPreLiftValue->replaceAllUsesWith(variable->m_llvmValue);
[-] 		variable->m_llvmPreLiftValue->eraseFromParent ();
[+] 		variable->m_llvmPreLiftValue->eraseFromParent();
[-] 	m_liftedStackVariableArray.clear ();
[+] 	m_liftedStackVariableArray.clear();
[-] 	m_argVariableArray.clear ();
[+] 	m_argVariableArray.clear();
[-] VariableMgr::createArgVariable (
[+] VariableMgr::createArgVariable(
[-] 	Variable* variable = createSimpleStackVariable (
[+] 	Variable* variable = createSimpleStackVariable(
[-] 		arg->getName (),
[+] 		arg->getName(),
[-] 		arg->getType (),
[+] 		arg->getType(),
[-] 		arg->getPtrTypeFlags ()
[+] 		arg->getPtrTypeFlags()
[-] 	variable->m_parentUnit = arg->getParentUnit ();
[+] 	variable->m_parentUnit = arg->getParentUnit();
[-] 	variable->m_pos = *arg->getPos ();
[+] 	variable->m_pos = *arg->getPos();
[-] 	if ((m_module->getCompileFlags () & ModuleCompileFlag_DebugInfo) &&
[+] 	if ((m_module->getCompileFlags() & ModuleCompileFlag_DebugInfo) &&
[-] 		(variable->getFlags () & ModuleItemFlag_User))
[+] 		(variable->getFlags() & ModuleItemFlag_User))
[-] 		variable->m_llvmDiDescriptor = m_module->m_llvmDiBuilder.createParameterVariable (variable, argIdx);
[+] 		variable->m_llvmDiDescriptor = m_module->m_llvmDiBuilder.createParameterVariable(variable, argIdx);
[-] 		m_module->m_llvmDiBuilder.createDeclare (variable);
[+] 		m_module->m_llvmDiBuilder.createDeclare(variable);
[-] 	if (variable->m_type->getFlags () & TypeFlag_GcRoot)
[+] 	if (variable->m_type->getFlags() & TypeFlag_GcRoot)
[-] 		m_module->m_gcShadowStackMgr.markGcRoot (variable, variable->m_type);
[+] 		m_module->m_gcShadowStackMgr.markGcRoot(variable, variable->m_type);
[-] 	m_argVariableArray.append (variable);
[+] 	m_argVariableArray.append(variable);
[-] VariableMgr::createAsyncArgVariable (
[+] VariableMgr::createAsyncArgVariable(
[-] 	ASSERT (value.getLlvmValue ());
[+] 	ASSERT(value.getLlvmValue());
[-] 	Variable* variable = createVariable (StorageKind_Member, name, name, type);
[+] 	Variable* variable = createVariable(StorageKind_Member, name, name, type);
[-] 	variable->m_llvmValue = value.getLlvmValue ();
[+] 	variable->m_llvmValue = value.getLlvmValue();
[-] VariableMgr::createTlsStructType ()
[+] VariableMgr::createTlsStructType()
[-] 	StructType* type = m_module->m_typeMgr.createStructType ("Tls", "jnc.Tls");
[+] 	StructType* type = m_module->m_typeMgr.createStructType("Tls", "jnc.Tls");
[-] 	size_t count = m_tlsVariableArray.getCount ();
[+] 	size_t count = m_tlsVariableArray.getCount();
[-] 		Variable* variable = m_tlsVariableArray [i];
[+] 		Variable* variable = m_tlsVariableArray[i];
[-] 		if (variable->m_type->getTypeKindFlags () & TypeKindFlag_Aggregate)
[+] 		if (variable->m_type->getTypeKindFlags() & TypeKindFlag_Aggregate)
[-] 			err::setFormatStringError ("'threadlocal' variables cannot have aggregate type '%s'",  variable->m_type->getTypeString ().sz ());
[+] 			err::setFormatStringError("'threadlocal' variables cannot have aggregate type '%s'",  variable->m_type->getTypeString ().sz ());
[-] 		variable->m_tlsField = type->createField (variable->m_type);
[+] 		variable->m_tlsField = type->createField(variable->m_type);
[-] 	result = type->ensureLayout ();
[+] 	result = type->ensureLayout();
[-] VariableMgr::allocateInitializeGlobalVariables ()
[+] VariableMgr::allocateInitializeGlobalVariables()
[-] 	size_t count = m_globalStaticVariableArray.getCount ();
[+] 	size_t count = m_globalStaticVariableArray.getCount();
[-] 		Variable* variable = m_globalStaticVariableArray [i];
[+] 		Variable* variable = m_globalStaticVariableArray[i];
[-] 		ASSERT (!variable->m_llvmValue);
[+] 		ASSERT(!variable->m_llvmValue);
[-] 		variable->m_llvmGlobalVariable = createLlvmGlobalVariable (variable->m_type, variable->m_qualifiedName);
[+] 		variable->m_llvmGlobalVariable = createLlvmGlobalVariable(variable->m_type, variable->m_qualifiedName);
[-] 		if (variable->m_type->getFlags () & TypeFlag_GcRoot)
[+] 		if (variable->m_type->getFlags() & TypeFlag_GcRoot)
[-] 			m_staticGcRootArray.append (variable);
[+] 			m_staticGcRootArray.append(variable);
[-] 		result = initializeVariable (variable);
[+] 		result = initializeVariable(variable);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_VariableMgr\jnc_ct_Variable.h
----------------------
[-] 	sl::BoxList <Token> m_constructor;
[+] 	sl::BoxList<Token> m_constructor;
[-] 	ref::Ptr <LeanDataPtrValidator> m_leanDataPtrValidator;
[+] 	ref::Ptr<LeanDataPtrValidator> m_leanDataPtrValidator;
[-] 	Variable ();
[+] 	Variable();
[-] 	getType ()
[+] 	getType()
[-] 	getPtrTypeFlags ()
[+] 	getPtrTypeFlags()
[-] 	sl::ConstBoxList <Token>
[+] 	sl::ConstBoxList<Token>
[-] 	getConstructor ()
[+] 	getConstructor()
[-] 	getScope ()
[+] 	getScope()
[-] 	getTlsField ()
[+] 	getTlsField()
[-] 		ASSERT (m_storageKind == StorageKind_Tls);
[+] 		ASSERT(m_storageKind == StorageKind_Tls);
[-] 	getStaticData ();
[+] 	getStaticData();
[-] 	getLeanDataPtrValidator ();
[+] 	getLeanDataPtrValidator();
[-] 	getLlvmGlobalVariable ()
[+] 	getLlvmGlobalVariable()
[-] 	getLlvmValue ();
[+] 	getLlvmValue();
[-] 	getLlvmDiDescriptor ()
[+] 	getLlvmDiDescriptor()
[-] 	isInitializationNeeded ();
[+] 	isInitializationNeeded();
[-] 	generateDocumentation (
[+] 	generateDocumentation(
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ct\jnc_ct_VariableMgr\jnc_ct_VariableMgr.h
----------------------
[-] 	sl::List <Variable> m_variableList;
[+] 	sl::List<Variable> m_variableList;
[-] 	sl::Array <Variable*> m_staticVariableArray;
[+] 	sl::Array<Variable*> m_staticVariableArray;
[-] 	sl::Array <Variable*> m_staticGcRootArray;
[+] 	sl::Array<Variable*> m_staticGcRootArray;
[-] 	sl::Array <Variable*> m_globalStaticVariableArray;
[+] 	sl::Array<Variable*> m_globalStaticVariableArray;
[-] 	sl::Array <Variable*> m_liftedStackVariableArray;
[+] 	sl::Array<Variable*> m_liftedStackVariableArray;
[-] 	sl::Array <Variable*> m_argVariableArray;
[+] 	sl::Array<Variable*> m_argVariableArray;
[-] 	sl::Array <Variable*> m_tlsVariableArray;
[+] 	sl::Array<Variable*> m_tlsVariableArray;
[-] 	Variable* m_stdVariableArray [StdVariable__Count];
[+] 	Variable* m_stdVariableArray[StdVariable__Count];
[-] 	VariableMgr ();
[+] 	VariableMgr();
[-] 	getModule ()
[+] 	getModule()
[-] 	clear ();
[+] 	clear();
[-] 	createStdVariables ();
[+] 	createStdVariables();
[-] 	finalizeFunction ();
[+] 	finalizeFunction();
[-] 	getStdVariable (StdVariable variable);
[+] 	getStdVariable(StdVariable variable);
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getStaticVariableArray ()
[+] 	getStaticVariableArray()
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getStaticGcRootArray ()
[+] 	getStaticGcRootArray()
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getGlobalStaticVariableArray ()
[+] 	getGlobalStaticVariableArray()
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getArgVariableArray ()
[+] 	getArgVariableArray()
[-] 	sl::Array <Variable*>
[+] 	sl::Array<Variable*>
[-] 	getTlsVariableArray ()
[+] 	getTlsVariableArray()
[-] 	getTlsStructType ()
[+] 	getTlsStructType()
[-] 		ASSERT (m_tlsStructType);
[+] 		ASSERT(m_tlsStructType);
[-] 	getCurrentLiftedStackVariable ()
[+] 	getCurrentLiftedStackVariable()
[-] 	createVariable (
[+] 	createVariable(
[-] 		sl::BoxList <Token>* constructor = NULL,
[+] 		sl::BoxList<Token>* constructor = NULL,
[-] 		sl::BoxList <Token>* initializer = NULL
[+] 		sl::BoxList<Token>* initializer = NULL
[-] 	createSimpleStackVariable (
[+] 	createSimpleStackVariable(
[-] 		return createVariable (StorageKind_Stack, name, name, type, ptrTypeFlags);
[+] 		return createVariable(StorageKind_Stack, name, name, type, ptrTypeFlags);
[-] 	createSimpleStaticVariable (
[+] 	createSimpleStaticVariable(
[-] 		const Value& value = Value (),
[+] 		const Value& value = Value(),
[-] 	createOnceFlagVariable (StorageKind storageKind = StorageKind_Static);
[+] 	createOnceFlagVariable(StorageKind storageKind = StorageKind_Static);
[-] 	createStaticDataPtrValidatorVariable (Variable* variable);
[+] 	createStaticDataPtrValidatorVariable(Variable* variable);
[-] 	createArgVariable (
[+] 	createArgVariable(
[-] 	createAsyncArgVariable (
[+] 	createAsyncArgVariable(
[-] 	createTlsStructType ();
[+] 	createTlsStructType();
[-] 	allocateInitializeGlobalVariables ();
[+] 	allocateInitializeGlobalVariables();
[-] 	initializeVariable (Variable* variable);
[+] 	initializeVariable(Variable* variable);
[-] 	liftStackVariable (Variable* variable);
[+] 	liftStackVariable(Variable* variable);
[-] 	finalizeDisposableVariable (Variable* variable);
[+] 	finalizeDisposableVariable(Variable* variable);
[-] 	createLlvmGlobalVariable (
[+] 	createLlvmGlobalVariable(
[-] 		const Value& initValue = Value ()
[+] 		const Value& initValue = Value()
[-] 	primeStaticClassVariable (Variable* variable);
[+] 	primeStaticClassVariable(Variable* variable);
[-] 	allocateHeapVariable (Variable* variable);
[+] 	allocateHeapVariable(Variable* variable);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_dll\dllmain.c
----------------------
[-] DllMain (
[+] DllMain(
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_File.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (File)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(File)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <File>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<File>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <File>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<File>)
[-] 	JNC_MAP_CONST_PROPERTY ("m_size", &File::getSize)
[+] 	JNC_MAP_CONST_PROPERTY("m_size", &File::getSize)
[-] 	JNC_MAP_PROPERTY ("m_position", &File::getPosition, &File::setPosition)
[+] 	JNC_MAP_PROPERTY("m_position", &File::getPosition, &File::setPosition)
[-] 	JNC_MAP_FUNCTION ("open",  &File::open)
[+] 	JNC_MAP_FUNCTION("open",  &File::open)
[-] 	JNC_MAP_FUNCTION ("close", &File::close)
[+] 	JNC_MAP_FUNCTION("close", &File::close)
[-] 	JNC_MAP_FUNCTION ("setSize", &File::setSize)
[+] 	JNC_MAP_FUNCTION("setSize", &File::setSize)
[-] 	JNC_MAP_FUNCTION ("read",  &File::read)
[+] 	JNC_MAP_FUNCTION("read",  &File::read)
[-] 	JNC_MAP_FUNCTION ("write", &File::write)
[+] 	JNC_MAP_FUNCTION("write", &File::write)
[-] 	JNC_MAP_FUNCTION ("flush", &File::flush)
[+] 	JNC_MAP_FUNCTION("flush", &File::flush)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] File::File ()
[+] File::File()
[-] 	m_runtime = getCurrentThreadRuntime ();
[+] 	m_runtime = getCurrentThreadRuntime();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_FileStream.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (FileStream)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(FileStream)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <FileStream>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<FileStream>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <FileStream>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<FileStream>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &FileStream::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &FileStream::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &FileStream::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &FileStream::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &FileStream::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &FileStream::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &FileStream::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &FileStream::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &FileStream::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &FileStream::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",         &FileStream::open)
[+] 	JNC_MAP_FUNCTION("open",         &FileStream::open)
[-] 	JNC_MAP_FUNCTION ("close",        &FileStream::close)
[+] 	JNC_MAP_FUNCTION("close",        &FileStream::close)
[-] 	JNC_MAP_FUNCTION ("clear",        &FileStream::clear)
[+] 	JNC_MAP_FUNCTION("clear",        &FileStream::clear)
[-] 	JNC_MAP_FUNCTION ("read",         &FileStream::read)
[+] 	JNC_MAP_FUNCTION("read",         &FileStream::read)
[-] 	JNC_MAP_FUNCTION ("write",        &FileStream::write)
[+] 	JNC_MAP_FUNCTION("write",        &FileStream::write)
[-] 	JNC_MAP_FUNCTION ("wait",         &FileStream::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &FileStream::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &FileStream::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &FileStream::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &FileStream::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &FileStream::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] FileStream::FileStream ()
[+] FileStream::FileStream()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] FileStream::open (
[+] FileStream::open(
[-] 	close ();
[+] 	close();
[-] 	result = m_file.open ((const char*) namePtr.m_p, openFlags | axl::io::FileFlag_Asynchronous);
[+] 	result = m_file.open((const char*) namePtr.m_p, openFlags | axl::io::FileFlag_Asynchronous);
[-] 	dword_t type = ::GetFileType (m_file.m_file);
[+] 	dword_t type = ::GetFileType(m_file.m_file);
[-] 	switch (type)
[+] 	switch(type)
[-] 		result = ::SetNamedPipeHandleState (m_file.m_file, &pipeMode, NULL, NULL) != 0;
[+] 		result = ::SetNamedPipeHandleState(m_file.m_file, &pipeMode, NULL, NULL) != 0;
[-] 			err::setLastSystemError ();
[+] 			err::setLastSystemError();
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] FileStream::close ()
[+] FileStream::close()
[-] 	if (!m_file.isOpen ())
[+] 	if (!m_file.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 		AXL_MEM_DELETE (m_overlappedIo);
[+] 		AXL_MEM_DELETE(m_overlappedIo);
[-] FileStream::setOptions (uint_t options)
[+] FileStream::setOptions(uint_t options)
[-] 		bool result = ::SetNamedPipeHandleState (m_file.m_file, &pipeMode, NULL, NULL) != 0;
[+] 		bool result = ::SetNamedPipeHandleState(m_file.m_file, &pipeMode, NULL, NULL) != 0;
[-] 			err::setLastSystemError ();
[+] 			err::setLastSystemError();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] FileStream::clear ()
[+] FileStream::clear()
[-] 	bool result = m_file.setSize (0);
[+] 	bool result = m_file.setSize(0);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] FileStream::read (
[+] FileStream::read(
[-] 		err::setError (err::SystemErrorCode_AccessDenied);
[+] 		err::setError(err::SystemErrorCode_AccessDenied);
[-] 	return bufferedRead (ptr, size);
[+] 	return bufferedRead(ptr, size);
[-] FileStream::write (
[+] FileStream::write(
[-] 		err::setError (err::SystemErrorCode_AccessDenied);
[+] 		err::setError(err::SystemErrorCode_AccessDenied);
[-] 	return bufferedWrite (ptr, size);
[+] 	return bufferedWrite(ptr, size);
[-] FileStream::ioThreadFunc ()
[+] FileStream::ioThreadFunc()
[-] 	ASSERT (m_file.isOpen () && m_overlappedIo);
[+] 	ASSERT(m_file.isOpen() && m_overlappedIo);
[-] 	HANDLE waitTable [3] =
[+] 	HANDLE waitTable[3] =
[-] 	bool isDiskFile = ::GetFileType (m_file.m_file) == FILE_TYPE_DISK; // need to advance read/write offsets
[+] 	bool isDiskFile = ::GetFileType(m_file.m_file) == FILE_TYPE_DISK; // need to advance read/write offsets
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		DWORD waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			result = read->m_overlapped.m_completionEvent.wait (0);
[+] 			result = read->m_overlapped.m_completionEvent.wait(0);
[-] 			result = m_file.m_file.getOverlappedResult (&read->m_overlapped, &actualSize);
[+] 			result = m_file.m_file.getOverlappedResult(&read->m_overlapped, &actualSize);
[-] 				err::Error error = err::getLastError ();
[+] 				err::Error error = err::getLastError();
[-] 					setEvents (FileStreamEvent_Eof);
[+] 					setEvents(FileStreamEvent_Eof);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				setEvents (FileStreamEvent_Eof);
[+] 				setEvents(FileStreamEvent_Eof);
[-] 			m_overlappedIo->m_activeOverlappedReadList.remove (read);
[+] 			m_overlappedIo->m_activeOverlappedReadList.remove(read);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			addToReadBuffer (read->m_buffer, actualSize);
[+] 			addToReadBuffer(read->m_buffer, actualSize);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			read->m_overlapped.m_completionEvent.reset ();
[+] 			read->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedReadPool.put (read);
[+] 			m_overlappedIo->m_overlappedReadPool.put(read);
[-] 		if (isWritingFile && m_overlappedIo->m_writeOverlapped.m_completionEvent.wait (0))
[+] 		if (isWritingFile && m_overlappedIo->m_writeOverlapped.m_completionEvent.wait(0))
[-] 			ASSERT (isWritingFile);
[+] 			ASSERT(isWritingFile);
[-] 			result = m_file.m_file.getOverlappedResult (&m_overlappedIo->m_writeOverlapped, &actualSize);
[+] 			result = m_file.m_file.getOverlappedResult(&m_overlappedIo->m_writeOverlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			if (actualSize < m_overlappedIo->m_writeBlock.getCount ()) // shouldn't happen, actually (unless with a non-standard driver)
[+] 			if (actualSize < m_overlappedIo->m_writeBlock.getCount()) // shouldn't happen, actually (unless with a non-standard driver)
[-] 				m_overlappedIo->m_writeBlock.remove (0, actualSize);
[+] 				m_overlappedIo->m_writeBlock.remove(0, actualSize);
[-] 				m_overlappedIo->m_writeBlock.clear ();
[+] 				m_overlappedIo->m_writeBlock.clear();
[-] 			m_overlappedIo->m_writeOverlapped.m_completionEvent.reset ();
[+] 			m_overlappedIo->m_writeOverlapped.m_completionEvent.reset();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		getNextWriteBlock (&m_overlappedIo->m_writeBlock);
[+] 		getNextWriteBlock(&m_overlappedIo->m_writeBlock);
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		bool isReadBufferFull = m_readBuffer.isFull ();
[+] 		bool isReadBufferFull = m_readBuffer.isFull();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		if (!isWritingFile && !m_overlappedIo->m_writeBlock.isEmpty ())
[+] 		if (!isWritingFile && !m_overlappedIo->m_writeBlock.isEmpty())
[-] 				m_overlappedIo->m_writeOverlapped.Offset = (uint32_t) writeOffset;
[+] 				m_overlappedIo->m_writeOverlapped.Offset = (uint32_t)writeOffset;
[-] 				m_overlappedIo->m_writeOverlapped.OffsetHigh = (uint32_t) (writeOffset >> 32);
[+] 				m_overlappedIo->m_writeOverlapped.OffsetHigh = (uint32_t)(writeOffset >> 32);
[-] 			result = m_file.m_file.overlappedWrite (
[+] 			result = m_file.m_file.overlappedWrite(
[-] 				m_overlappedIo->m_writeBlock.getCount (),
[+] 				m_overlappedIo->m_writeBlock.getCount(),
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount ();
[+] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount();
[-] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get ();
[+] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get();
[-] 					read->m_overlapped.Offset = (uint32_t) m_overlappedIo->m_readOffset;
[+] 					read->m_overlapped.Offset = (uint32_t)m_overlappedIo->m_readOffset;
[-] 					read->m_overlapped.OffsetHigh = (uint32_t) (m_overlappedIo->m_readOffset >> 32);
[+] 					read->m_overlapped.OffsetHigh = (uint32_t)(m_overlappedIo->m_readOffset >> 32);
[-] 					read->m_buffer.setCount (readBlockSize) &&
[+] 					read->m_buffer.setCount(readBlockSize) &&
[-] 					m_file.m_file.overlappedRead (read->m_buffer, readBlockSize, &read->m_overlapped);
[+] 					m_file.m_file.overlappedRead(read->m_buffer, readBlockSize, &read->m_overlapped);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedReadList.insertTail (read);
[+] 				m_overlappedIo->m_activeOverlappedReadList.insertTail(read);
[-] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			waitTable [2] = read->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[2] = read->m_overlapped.m_completionEvent.m_event;
[-] FileStream::ioThreadFunc ()
[+] FileStream::ioThreadFunc()
[-] 	ASSERT (m_file.isOpen ());
[+] 	ASSERT(m_file.isOpen());
[-] 	int selectFd = AXL_MAX (m_file.m_file, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_file.m_file, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	sl::Array <char> writeBlock;
[+] 	sl::Array<char> writeBlock;
[-] 	readBlock.setCount (Def_ReadBlockSize);
[+] 	readBlock.setCount(Def_ReadBlockSize);
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_file.m_file, &readSet);
[+] 			FD_SET(m_file.m_file, &readSet);
[-] 			FD_SET (m_file.m_file, &writeSet);
[+] 			FD_SET(m_file.m_file, &writeSet);
[-] 		result = ::select (selectFd, &readSet, &writeSet, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, &writeSet, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_file.m_file, &readSet))
[+] 		if (FD_ISSET(m_file.m_file, &readSet))
[-] 		if (FD_ISSET (m_file.m_file, &writeSet))
[+] 		if (FD_ISSET(m_file.m_file, &writeSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 		while (canReadFile && !m_readBuffer.isFull ())
[+] 		while (canReadFile && !m_readBuffer.isFull())
[-] 			ssize_t actualSize = ::read (m_file.m_file, readBlock, readBlock.getCount ());
[+] 			ssize_t actualSize = ::read(m_file.m_file, readBlock, readBlock.getCount());
[-] 					setIoErrorEvent_l (err::Errno (errno));
[+] 					setIoErrorEvent_l(err::Errno(errno));
[-] 				setEvents_l (FileStreamEvent_Eof);
[+] 				setEvents_l(FileStreamEvent_Eof);
[-] 				addToReadBuffer (readBlock, actualSize);
[+] 				addToReadBuffer(readBlock, actualSize);
[-] 			getNextWriteBlock (&writeBlock);
[+] 			getNextWriteBlock(&writeBlock);
[-] 			if (writeBlock.isEmpty ())
[+] 			if (writeBlock.isEmpty())
[-] 			size_t blockSize = writeBlock.getCount ();
[+] 			size_t blockSize = writeBlock.getCount();
[-] 			ssize_t actualSize = ::write (m_file.m_file, writeBlock, blockSize);
[+] 			ssize_t actualSize = ::write(m_file.m_file, writeBlock, blockSize);
[-] 					setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 					setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 			else if ((size_t) actualSize < blockSize)
[+] 			else if ((size_t)actualSize < blockSize)
[-] 				writeBlock.remove (0, actualSize);
[+] 				writeBlock.remove(0, actualSize);
[-] 				writeBlock.clear ();
[+] 				writeBlock.clear();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_IoLib.cpp
----------------------
[-] DataPtr getSymbolicLinkTarget (DataPtr namePtr)
[+] DataPtr getSymbolicLinkTarget(DataPtr namePtr)
[-] 	bool result = axl::io::getSymbolicLinkTarget (&linkTarget, (const char*) namePtr.m_p);
[+] 	bool result = axl::io::getSymbolicLinkTarget(&linkTarget, (const char*) namePtr.m_p);
[-] 	return strDup (linkTarget);
[+] 	return strDup(linkTarget);
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (IoLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(IoLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (IoLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(IoLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (File)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(File)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (MappedFile)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(MappedFile)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (FileStream)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(FileStream)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Serial)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Serial)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Socket)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Socket)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (SocketAddressResolver)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(SocketAddressResolver)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (NamedPipe)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(NamedPipe)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Mailslot)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Mailslot)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (IoLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(IoLib)
[-] 	JNC_MAP_TYPE (File)
[+] 	JNC_MAP_TYPE(File)
[-] 	JNC_MAP_TYPE (FileStream)
[+] 	JNC_MAP_TYPE(FileStream)
[-] 	JNC_MAP_TYPE (MappedFile)
[+] 	JNC_MAP_TYPE(MappedFile)
[-] 	JNC_MAP_TYPE (Serial)
[+] 	JNC_MAP_TYPE(Serial)
[-] 	JNC_MAP_TYPE (Socket)
[+] 	JNC_MAP_TYPE(Socket)
[-] 	JNC_MAP_TYPE (Address_ip4)
[+] 	JNC_MAP_TYPE(Address_ip4)
[-] 	JNC_MAP_TYPE (Address_ip6)
[+] 	JNC_MAP_TYPE(Address_ip6)
[-] 	JNC_MAP_TYPE (SocketAddress_ip4)
[+] 	JNC_MAP_TYPE(SocketAddress_ip4)
[-] 	JNC_MAP_TYPE (SocketAddress_ip6)
[+] 	JNC_MAP_TYPE(SocketAddress_ip6)
[-] 	JNC_MAP_TYPE (SocketAddress)
[+] 	JNC_MAP_TYPE(SocketAddress)
[-] 	JNC_MAP_TYPE (SocketAddressResolver)
[+] 	JNC_MAP_TYPE(SocketAddressResolver)
[-] 	JNC_MAP_TYPE (NamedPipe)
[+] 	JNC_MAP_TYPE(NamedPipe)
[-] 	JNC_MAP_TYPE (Mailslot)
[+] 	JNC_MAP_TYPE(Mailslot)
[-] 	JNC_MAP_FUNCTION ("io.createNetworkAdapterDescList", createNetworkAdapterDescList)
[+] 	JNC_MAP_FUNCTION("io.createNetworkAdapterDescList", createNetworkAdapterDescList)
[-] 	JNC_MAP_FUNCTION ("io.createSerialPortDescList",     createSerialPortDescList)
[+] 	JNC_MAP_FUNCTION("io.createSerialPortDescList",     createSerialPortDescList)
[-] 	JNC_MAP_FUNCTION ("io.getSymbolicLinkTarget",        getSymbolicLinkTarget)
[+] 	JNC_MAP_FUNCTION("io.getSymbolicLinkTarget",        getSymbolicLinkTarget)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] jncDynamicExtensionLibMain (jnc_DynamicExtensionLibHost* host)
[+] jncDynamicExtensionLibMain(jnc_DynamicExtensionLibHost* host)
[-] 	WSAStartup (0x0202, &WsaData);
[+] 	WSAStartup(0x0202, &WsaData);
[-] 	g::getModule ()->setTag ("jnc_io_base");
[+] 	g::getModule()->setTag("jnc_io_base");
[-] 	err::getErrorMgr ()->setForwardRouter (host->m_errorRouter);
[+] 	err::getErrorMgr()->setForwardRouter(host->m_errorRouter);
[-] 	return jnc::io::IoLib_getLib ();
[+] 	return jnc::io::IoLib_getLib();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Mailslot.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Mailslot)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Mailslot)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Mailslot>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Mailslot>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Mailslot>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Mailslot>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &Mailslot::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &Mailslot::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &Mailslot::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &Mailslot::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &Mailslot::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &Mailslot::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &Mailslot::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &Mailslot::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",         &Mailslot::open)
[+] 	JNC_MAP_FUNCTION("open",         &Mailslot::open)
[-] 	JNC_MAP_FUNCTION ("close",        &Mailslot::close)
[+] 	JNC_MAP_FUNCTION("close",        &Mailslot::close)
[-] 	JNC_MAP_FUNCTION ("read",         &Mailslot::read)
[+] 	JNC_MAP_FUNCTION("read",         &Mailslot::read)
[-] 	JNC_MAP_FUNCTION ("wait",         &Mailslot::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &Mailslot::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &Mailslot::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &Mailslot::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &Mailslot::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &Mailslot::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Mailslot::Mailslot ()
[+] Mailslot::Mailslot()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] Mailslot::open (DataPtr namePtr)
[+] Mailslot::open(DataPtr namePtr)
[-] 	close ();
[+] 	close();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w deviceName (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w deviceName(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	sl::StringRef name ((const char*) namePtr.m_p);
[+] 	sl::StringRef name((const char*) namePtr.m_p);
[-] 	if (name.isPrefix ("\\\\.\\mailslot\\"))
[+] 	if (name.isPrefix("\\\\.\\mailslot\\"))
[-] 		deviceName += name.getSubString (deviceName.getLength ());
[+] 		deviceName += name.getSubString(deviceName.getLength());
[-] 	HANDLE h = ::CreateMailslotW (deviceName, 0, -1, NULL);
[+] 	HANDLE h = ::CreateMailslotW(deviceName, 0, -1, NULL);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 	m_file.m_file.attach (h);
[+] 	m_file.m_file.attach(h);
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] Mailslot::close ()
[+] Mailslot::close()
[-] 	if (!m_file.isOpen ())
[+] 	if (!m_file.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 		AXL_MEM_DELETE (m_overlappedIo);
[+] 		AXL_MEM_DELETE(m_overlappedIo);
[-] Mailslot::ioThreadFunc ()
[+] Mailslot::ioThreadFunc()
[-] 	ASSERT (m_file.isOpen () && m_overlappedIo);
[+] 	ASSERT(m_file.isOpen() && m_overlappedIo);
[-] 	HANDLE waitTable [2] =
[+] 	HANDLE waitTable[2] =
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		DWORD waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			result = read->m_overlapped.m_completionEvent.wait (0);
[+] 			result = read->m_overlapped.m_completionEvent.wait(0);
[-] 			result = m_file.m_file.getOverlappedResult (&read->m_overlapped, &actualSize);
[+] 			result = m_file.m_file.getOverlappedResult(&read->m_overlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			m_overlappedIo->m_activeOverlappedReadList.remove (read);
[+] 			m_overlappedIo->m_activeOverlappedReadList.remove(read);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			addToReadBuffer (read->m_buffer, actualSize);
[+] 			addToReadBuffer(read->m_buffer, actualSize);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			read->m_overlapped.m_completionEvent.reset ();
[+] 			read->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedReadPool.put (read);
[+] 			m_overlappedIo->m_overlappedReadPool.put(read);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		bool isReadBufferFull = m_readBuffer.isFull ();
[+] 		bool isReadBufferFull = m_readBuffer.isFull();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount ();
[+] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount();
[-] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get ();
[+] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get();
[-] 					read->m_buffer.setCount (readBlockSize) &&
[+] 					read->m_buffer.setCount(readBlockSize) &&
[-] 					m_file.m_file.overlappedRead (read->m_buffer, readBlockSize, &read->m_overlapped);
[+] 					m_file.m_file.overlappedRead(read->m_buffer, readBlockSize, &read->m_overlapped);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedReadList.insertTail (read);
[+] 				m_overlappedIo->m_activeOverlappedReadList.insertTail(read);
[-] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			waitTable [1] = read->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[1] = read->m_overlapped.m_completionEvent.m_event;
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_MappedFile.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MappedFile)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MappedFile)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <MappedFile>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<MappedFile>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <MappedFile>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<MappedFile>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_dynamicViewLimit", &MappedFile::setDynamicViewLimit)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_dynamicViewLimit", &MappedFile::setDynamicViewLimit)
[-] 	JNC_MAP_CONST_PROPERTY ("m_size", &MappedFile::getSize)
[+] 	JNC_MAP_CONST_PROPERTY("m_size", &MappedFile::getSize)
[-] 	JNC_MAP_FUNCTION ("setSize",  &MappedFile::setSize)
[+] 	JNC_MAP_FUNCTION("setSize",  &MappedFile::setSize)
[-] 	JNC_MAP_FUNCTION ("open",  &MappedFile::open)
[+] 	JNC_MAP_FUNCTION("open",  &MappedFile::open)
[-] 	JNC_MAP_FUNCTION ("close", &MappedFile::close)
[+] 	JNC_MAP_FUNCTION("close", &MappedFile::close)
[-] 	JNC_MAP_FUNCTION ("view",  &MappedFile::view)
[+] 	JNC_MAP_FUNCTION("view",  &MappedFile::view)
[-] 	JNC_MAP_FUNCTION ("unmapAllViews",  &MappedFile::unmapAllViews)
[+] 	JNC_MAP_FUNCTION("unmapAllViews",  &MappedFile::unmapAllViews)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] MappedFile::MappedFile ()
[+] MappedFile::MappedFile()
[-] 	m_runtime = getCurrentThreadRuntime ();
[+] 	m_runtime = getCurrentThreadRuntime();
[-] MappedFile::view (
[+] MappedFile::view(
[-] 	void* p = self->m_file.view (offset, size, isPermanent);
[+] 	void* p = self->m_file.view(offset, size, isPermanent);
[-] 	GcHeap* gcHeap = self->m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = self->m_runtime->getGcHeap();
[-] 	ptr.m_validator = gcHeap->createDataPtrValidator (self->m_box, p, size);
[+] 	ptr.m_validator = gcHeap->createDataPtrValidator(self->m_box, p, size);
[-] MappedFile::setDynamicViewLimit (size_t limit)
[+] MappedFile::setDynamicViewLimit(size_t limit)
[-] 	bool result = m_file.setup (limit, axl::io::MappedFile::DefaultsKind_ReadAheadSize);
[+] 	bool result = m_file.setup(limit, axl::io::MappedFile::DefaultsKind_ReadAheadSize);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_NamedPipe.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (NamedPipe)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(NamedPipe)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <NamedPipe>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<NamedPipe>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <NamedPipe>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<NamedPipe>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_backLogLimit",    &NamedPipe::setBackLogLimit)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_backLogLimit",    &NamedPipe::setBackLogLimit)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &NamedPipe::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &NamedPipe::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &NamedPipe::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &NamedPipe::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &NamedPipe::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &NamedPipe::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &NamedPipe::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &NamedPipe::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &NamedPipe::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &NamedPipe::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",         &NamedPipe::open)
[+] 	JNC_MAP_FUNCTION("open",         &NamedPipe::open)
[-] 	JNC_MAP_FUNCTION ("close",        &NamedPipe::close)
[+] 	JNC_MAP_FUNCTION("close",        &NamedPipe::close)
[-] 	JNC_MAP_FUNCTION ("accept",       &NamedPipe::accept)
[+] 	JNC_MAP_FUNCTION("accept",       &NamedPipe::accept)
[-] 	JNC_MAP_FUNCTION ("wait",         &NamedPipe::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &NamedPipe::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &NamedPipe::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &NamedPipe::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &NamedPipe::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &NamedPipe::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] NamedPipe::NamedPipe ()
[+] NamedPipe::NamedPipe()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] NamedPipe::open (DataPtr namePtr)
[+] NamedPipe::open(DataPtr namePtr)
[-] 	close ();
[+] 	close();
[-] 	sl::StringRef name ((const char*) namePtr.m_p);
[+] 	sl::StringRef name((const char*) namePtr.m_p);
[-] 	if (name.isPrefix ("\\\\.\\pipe\\"))
[+] 	if (name.isPrefix("\\\\.\\pipe\\"))
[-] 		m_pipeName += name.getSubString (m_pipeName.getLength ());
[+] 		m_pipeName += name.getSubString(m_pipeName.getLength());
[-] 	sl::List <OverlappedConnect> pipeList;
[+] 	sl::List<OverlappedConnect> pipeList;
[-] 		result = pipe.create (
[+] 		result = pipe.create(
[-] 		OverlappedConnect* connect = AXL_MEM_NEW (OverlappedConnect);
[+] 		OverlappedConnect* connect = AXL_MEM_NEW(OverlappedConnect);
[-] 		sl::takeOver (&connect->m_pipe, &pipe);
[+] 		sl::takeOver(&connect->m_pipe, &pipe);
[-] 		pipeList.insertTail (connect);
[+] 		pipeList.insertTail(connect);
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	sl::takeOver (&m_overlappedIo->m_pipeList, &pipeList);
[+] 	sl::takeOver(&m_overlappedIo->m_pipeList, &pipeList);
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] NamedPipe::close ()
[+] NamedPipe::close()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 	m_pipeName.clear ();
[+] 	m_pipeName.clear();
[-] 	sl::Iterator <IncomingConnection> it = m_pendingIncomingConnectionList.getHead ();
[+] 	sl::Iterator<IncomingConnection> it = m_pendingIncomingConnectionList.getHead();
[-] 		it->m_pipe.close ();
[+] 		it->m_pipe.close();
[-] 	m_incomingConnectionPool.put (&m_pendingIncomingConnectionList);
[+] 	m_incomingConnectionPool.put(&m_pendingIncomingConnectionList);
[-] 	ASSERT (m_overlappedIo);
[+] 	ASSERT(m_overlappedIo);
[-] 	AXL_MEM_DELETE (m_overlappedIo);
[+] 	AXL_MEM_DELETE(m_overlappedIo);
[-] NamedPipe::setOptions (uint_t options)
[+] NamedPipe::setOptions(uint_t options)
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] NamedPipe::accept ()
[+] NamedPipe::accept()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_pendingIncomingConnectionList.isEmpty ())
[+] 	if (m_pendingIncomingConnectionList.isEmpty())
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	IncomingConnection* connection = m_pendingIncomingConnectionList.removeHead ();
[+] 	IncomingConnection* connection = m_pendingIncomingConnectionList.removeHead();
[-] 	HANDLE h = connection->m_pipe.detach ();
[+] 	HANDLE h = connection->m_pipe.detach();
[-] 	m_incomingConnectionPool.put (connection);
[+] 	m_incomingConnectionPool.put(connection);
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	FileStream* fileStream = jnc::createClass <FileStream> (m_runtime);
[+] 	FileStream* fileStream = jnc::createClass<FileStream> (m_runtime);
[-] 	fileStream->m_file.m_file.attach (h);
[+] 	fileStream->m_file.m_file.attach(h);
[-] 	fileStream->setReadParallelism (m_readParallelism);
[+] 	fileStream->setReadParallelism(m_readParallelism);
[-] 	fileStream->setReadBlockSize (m_readBlockSize);
[+] 	fileStream->setReadBlockSize(m_readBlockSize);
[-] 	fileStream->setReadBufferSize (m_readBufferSize);
[+] 	fileStream->setReadBufferSize(m_readBufferSize);
[-] 	fileStream->setWriteBufferSize (m_writeBufferSize);
[+] 	fileStream->setWriteBufferSize(m_writeBufferSize);
[-] 	fileStream->setOptions (m_options);
[+] 	fileStream->setOptions(m_options);
[-] 	fileStream->m_overlappedIo = AXL_MEM_NEW (FileStream::OverlappedIo);
[+] 	fileStream->m_overlappedIo = AXL_MEM_NEW(FileStream::OverlappedIo);
[-] 	fileStream->m_ioThread.start ();
[+] 	fileStream->m_ioThread.start();
[-] NamedPipe::ioThreadFunc ()
[+] NamedPipe::ioThreadFunc()
[-] 	ASSERT (m_overlappedIo);
[+] 	ASSERT(m_overlappedIo);
[-] 	HANDLE waitTable [2] =
[+] 	HANDLE waitTable[2] =
[-] 	while (!m_overlappedIo->m_pipeList.isEmpty ())
[+] 	while (!m_overlappedIo->m_pipeList.isEmpty())
[-] 		OverlappedConnect* connect = m_overlappedIo->m_pipeList.removeHead ();
[+] 		OverlappedConnect* connect = m_overlappedIo->m_pipeList.removeHead();
[-] 		result = connect->m_pipe.overlappedConnect (&connect->m_overlapped);
[+] 		result = connect->m_pipe.overlappedConnect(&connect->m_overlapped);
[-] 			setIoErrorEvent ();
[+] 			setIoErrorEvent();
[-] 		m_overlappedIo->m_activeOverlappedConnectList.insertTail (connect);
[+] 		m_overlappedIo->m_activeOverlappedConnectList.insertTail(connect);
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		DWORD waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedConnectList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedConnectList.isEmpty())
[-] 			OverlappedConnect* connect = *m_overlappedIo->m_activeOverlappedConnectList.getHead ();
[+] 			OverlappedConnect* connect = *m_overlappedIo->m_activeOverlappedConnectList.getHead();
[-] 			result = connect->m_overlapped.m_completionEvent.wait (0);
[+] 			result = connect->m_overlapped.m_completionEvent.wait(0);
[-] 			result = connect->m_pipe.getOverlappedResult (&connect->m_overlapped, &actualSize);
[+] 			result = connect->m_pipe.getOverlappedResult(&connect->m_overlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			m_overlappedIo->m_activeOverlappedConnectList.remove (connect);
[+] 			m_overlappedIo->m_activeOverlappedConnectList.remove(connect);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			IncomingConnection* connection = m_incomingConnectionPool.get ();
[+] 			IncomingConnection* connection = m_incomingConnectionPool.get();
[-] 			sl::takeOver (&connection->m_pipe, &connect->m_pipe);
[+] 			sl::takeOver(&connection->m_pipe, &connect->m_pipe);
[-] 			m_pendingIncomingConnectionList.insertTail (connection);
[+] 			m_pendingIncomingConnectionList.insertTail(connection);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			connect->m_overlapped.m_completionEvent.reset ();
[+] 			connect->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedConnectPool.put (connect);
[+] 			m_overlappedIo->m_overlappedConnectPool.put(connect);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		if (!m_pendingIncomingConnectionList.isEmpty ())
[+] 		if (!m_pendingIncomingConnectionList.isEmpty())
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_pendingIncomingConnectionList.getCount () +
[+] 			m_pendingIncomingConnectionList.getCount() +
[-] 			m_overlappedIo->m_activeOverlappedConnectList.getCount ();
[+] 			m_overlappedIo->m_activeOverlappedConnectList.getCount();
[-] 				result = pipe.create (
[+] 				result = pipe.create(
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				OverlappedConnect* connect = m_overlappedIo->m_overlappedConnectPool.get ();
[+] 				OverlappedConnect* connect = m_overlappedIo->m_overlappedConnectPool.get();
[-] 				sl::takeOver (&connect->m_pipe, &pipe);
[+] 				sl::takeOver(&connect->m_pipe, &pipe);
[-] 				result = connect->m_pipe.overlappedConnect (&connect->m_overlapped);
[+] 				result = connect->m_pipe.overlappedConnect(&connect->m_overlapped);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedConnectList.insertTail (connect);
[+] 				m_overlappedIo->m_activeOverlappedConnectList.insertTail(connect);
[-] 		if (m_overlappedIo->m_activeOverlappedConnectList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedConnectList.isEmpty())
[-] 			OverlappedConnect* connect = *m_overlappedIo->m_activeOverlappedConnectList.getHead ();
[+] 			OverlappedConnect* connect = *m_overlappedIo->m_activeOverlappedConnectList.getHead();
[-] 			waitTable [1] = connect->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[1] = connect->m_overlapped.m_completionEvent.m_event;
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_NetworkAdapter.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] createNetworkAdapterAddress (
[+] createNetworkAdapterAddress(
[-] 	DataPtr addressPtr = createData <NetworkAdapterAddress> (runtime);
[+] 	DataPtr addressPtr = createData<NetworkAdapterAddress> (runtime);
[-] 	NetworkAdapterAddress* address = (NetworkAdapterAddress*) addressPtr.m_p;
[+] 	NetworkAdapterAddress* address = (NetworkAdapterAddress*)addressPtr.m_p;
[-] createNetworkAdapterDesc (
[+] createNetworkAdapterDesc(
[-] 	DataPtr adapterPtr = createData <NetworkAdapterDesc> (runtime);
[+] 	DataPtr adapterPtr = createData<NetworkAdapterDesc> (runtime);
[-] 	NetworkAdapterDesc* adapter = (NetworkAdapterDesc*) adapterPtr.m_p;
[+] 	NetworkAdapterDesc* adapter = (NetworkAdapterDesc*)adapterPtr.m_p;
[-] 	adapter->m_type = srcAdapter->getType ();
[+] 	adapter->m_type = srcAdapter->getType();
[-] 	adapter->m_flags = srcAdapter->getFlags ();
[+] 	adapter->m_flags = srcAdapter->getFlags();
[-] 	adapter->m_namePtr = strDup (srcAdapter->getName ());
[+] 	adapter->m_namePtr = strDup(srcAdapter->getName());
[-] 	adapter->m_descriptionPtr = strDup (srcAdapter->getDescription ());
[+] 	adapter->m_descriptionPtr = strDup(srcAdapter->getDescription());
[-] 	memcpy (adapter->m_mac, srcAdapter->getMac (), 6);
[+] 	memcpy(adapter->m_mac, srcAdapter->getMac(), 6);
[-] 	sl::ConstList <axl::io::NetworkAdapterAddress> addressList = srcAdapter->getAddressList ();
[+] 	sl::ConstList<axl::io::NetworkAdapterAddress> addressList = srcAdapter->getAddressList();
[-] 	if (addressList.isEmpty ())
[+] 	if (addressList.isEmpty())
[-] 	sl::ConstIterator <axl::io::NetworkAdapterAddress> it = addressList.getHead ();
[+] 	sl::ConstIterator<axl::io::NetworkAdapterAddress> it = addressList.getHead();
[-] 	DataPtr addressPtr = createNetworkAdapterAddress (runtime, *it, NULL);
[+] 	DataPtr addressPtr = createNetworkAdapterAddress(runtime, *it, NULL);
[-] 	adapter->m_addressCount = addressList.getCount ();
[+] 	adapter->m_addressCount = addressList.getCount();
[-] 		addressPtr = createNetworkAdapterAddress (runtime, *it, (NetworkAdapterAddress*) addressPtr.m_p);
[+] 		addressPtr = createNetworkAdapterAddress(runtime, *it, (NetworkAdapterAddress*)addressPtr.m_p);
[-] createNetworkAdapterDescList (
[+] createNetworkAdapterDescList(
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	sl::List <axl::io::NetworkAdapterDesc> adapterList;
[+] 	sl::List<axl::io::NetworkAdapterDesc> adapterList;
[-] 	size_t adapterCount = axl::io::createNetworkAdapterDescList (&adapterList);
[+] 	size_t adapterCount = axl::io::createNetworkAdapterDescList(&adapterList);
[-] 	if (adapterList.isEmpty ())
[+] 	if (adapterList.isEmpty())
[-] 			*(size_t*) adapterCountPtr.m_p = 0;
[+] 			*(size_t*)adapterCountPtr.m_p = 0;
[-] 			*(size_t*) addressCountPtr.m_p = 0;
[+] 			*(size_t*)addressCountPtr.m_p = 0;
[-] 	ScopedNoCollectRegion noCollectRegion (runtime, false);
[+] 	ScopedNoCollectRegion noCollectRegion(runtime, false);
[-] 	sl::Iterator <axl::io::NetworkAdapterDesc> it = adapterList.getHead ();
[+] 	sl::Iterator<axl::io::NetworkAdapterDesc> it = adapterList.getHead();
[-] 	DataPtr adapterPtr = createNetworkAdapterDesc (runtime, *it, NULL);
[+] 	DataPtr adapterPtr = createNetworkAdapterDesc(runtime, *it, NULL);
[-] 	NetworkAdapterDesc* adapter = (NetworkAdapterDesc*) adapterPtr.m_p;
[+] 	NetworkAdapterDesc* adapter = (NetworkAdapterDesc*)adapterPtr.m_p;
[-] 		adapterPtr = createNetworkAdapterDesc (runtime, *it, adapter);
[+] 		adapterPtr = createNetworkAdapterDesc(runtime, *it, adapter);
[-] 		adapter = (NetworkAdapterDesc*) adapterPtr.m_p;
[+] 		adapter = (NetworkAdapterDesc*)adapterPtr.m_p;
[-] 		*(size_t*) adapterCountPtr.m_p = adapterCount;
[+] 		*(size_t*)adapterCountPtr.m_p = adapterCount;
[-] 		*(size_t*) addressCountPtr.m_p = addressCount;
[+] 		*(size_t*)addressCountPtr.m_p = addressCount;
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Serial.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Serial)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Serial)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Serial>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Serial>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Serial>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Serial>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_baudRate",    &Serial::setBaudRate)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_baudRate",    &Serial::setBaudRate)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_flowControl", &Serial::setFlowControl)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_flowControl", &Serial::setFlowControl)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_dataBits",    &Serial::setDataBits)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_dataBits",    &Serial::setDataBits)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_stopBits",    &Serial::setStopBits)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_stopBits",    &Serial::setStopBits)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_parity",      &Serial::setParity)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_parity",      &Serial::setParity)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_dtr",         &Serial::setDtr)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_dtr",         &Serial::setDtr)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_rts",         &Serial::setRts)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_rts",         &Serial::setRts)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readInterval",    &Serial::setReadInterval)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readInterval",    &Serial::setReadInterval)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &Serial::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &Serial::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &Serial::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &Serial::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &Serial::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &Serial::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &Serial::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &Serial::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &Serial::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &Serial::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",            &Serial::open)
[+] 	JNC_MAP_FUNCTION("open",            &Serial::open)
[-] 	JNC_MAP_FUNCTION ("close",           &Serial::close)
[+] 	JNC_MAP_FUNCTION("close",           &Serial::close)
[-] 	JNC_MAP_FUNCTION ("clearLineErrors", &Serial::clearLineErrors)
[+] 	JNC_MAP_FUNCTION("clearLineErrors", &Serial::clearLineErrors)
[-] 	JNC_MAP_FUNCTION ("read",            &Serial::read)
[+] 	JNC_MAP_FUNCTION("read",            &Serial::read)
[-] 	JNC_MAP_FUNCTION ("write",           &Serial::write)
[+] 	JNC_MAP_FUNCTION("write",           &Serial::write)
[-] 	JNC_MAP_FUNCTION ("setupDevice",     &Serial::setupDevice)
[+] 	JNC_MAP_FUNCTION("setupDevice",     &Serial::setupDevice)
[-] 	JNC_MAP_FUNCTION ("wait",            &Serial::wait)
[+] 	JNC_MAP_FUNCTION("wait",            &Serial::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",      &Serial::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",      &Serial::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait",    &Serial::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait",    &Serial::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SerialPortDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SerialPortDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Serial::Serial ()
[+] Serial::Serial()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] Serial::setReadWaitFirstChar ()
[+] Serial::setReadWaitFirstChar()
[-] 	return m_serial.m_serial.setTimeouts (&timeouts);  // still no problem -- read will just return 0 bytes
[+] 	return m_serial.m_serial.setTimeouts(&timeouts);  // still no problem -- read will just return 0 bytes
[-] Serial::open (DataPtr namePtr)
[+] Serial::open(DataPtr namePtr)
[-] 	close ();
[+] 	close();
[-] 	axl::io::SerialSettings serialSettings (
[+] 	axl::io::SerialSettings serialSettings(
[-] 		m_serial.open ((const char*) namePtr.m_p, axl::io::FileFlag_Asynchronous) &&
[+] 		m_serial.open((const char*) namePtr.m_p, axl::io::FileFlag_Asynchronous) &&
[-] 		m_serial.setSettings (&serialSettings);
[+] 		m_serial.setSettings(&serialSettings);
[-] 		result = setReadWaitFirstChar ();
[+] 		result = setReadWaitFirstChar();
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] Serial::close ()
[+] Serial::close()
[-] 	if (!m_serial.isOpen ())
[+] 	if (!m_serial.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_serial.close ();
[+] 	m_serial.close();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 		AXL_MEM_DELETE (m_overlappedIo);
[+] 		AXL_MEM_DELETE(m_overlappedIo);
[-] Serial::setReadInterval (uint_t interval)
[+] Serial::setReadInterval(uint_t interval)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_ReadInterval);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_ReadInterval);
[-] Serial::setOptions (uint_t options)
[+] Serial::setOptions(uint_t options)
[-] 			result = setReadWaitFirstChar ();
[+] 			result = setReadWaitFirstChar();
[-] 			result = m_serial.setSettings (&settings, axl::io::SerialSettingId_ReadInterval);
[+] 			result = m_serial.setSettings(&settings, axl::io::SerialSettingId_ReadInterval);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Serial::setBaudRate (uint_t baudRate)
[+] Serial::setBaudRate(uint_t baudRate)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_BaudRate);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_BaudRate);
[-] Serial::setFlowControl (axl::io::SerialFlowControl flowControl)
[+] Serial::setFlowControl(axl::io::SerialFlowControl flowControl)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_FlowControl);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_FlowControl);
[-] Serial::setDataBits (uint_t dataBits)
[+] Serial::setDataBits(uint_t dataBits)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_DataBits);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_DataBits);
[-] Serial::setStopBits (axl::io::SerialStopBits stopBits)
[+] Serial::setStopBits(axl::io::SerialStopBits stopBits)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_StopBits);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_StopBits);
[-] Serial::setParity (axl::io::SerialParity parity)
[+] Serial::setParity(axl::io::SerialParity parity)
[-] 	bool result = m_serial.setSettings (&settings, axl::io::SerialSettingId_Parity);
[+] 	bool result = m_serial.setSettings(&settings, axl::io::SerialSettingId_Parity);
[-] Serial::setDtr (bool dtr)
[+] Serial::setDtr(bool dtr)
[-] 	bool result = m_serial.setDtr (dtr);
[+] 	bool result = m_serial.setDtr(dtr);
[-] Serial::setRts (bool rts)
[+] Serial::setRts(bool rts)
[-] 	bool result = m_serial.setRts (rts);
[+] 	bool result = m_serial.setRts(rts);
[-] Serial::setupDevice (
[+] Serial::setupDevice(
[-] 	bool result = m_serial.setSettings (&settings, mask);
[+] 	bool result = m_serial.setSettings(&settings, mask);
[-] Serial::clearLineErrors ()
[+] Serial::clearLineErrors()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Serial::ioThreadFunc ()
[+] Serial::ioThreadFunc()
[-] 	ASSERT (m_serial.isOpen () && m_overlappedIo);
[+] 	ASSERT(m_serial.isOpen() && m_overlappedIo);
[-] 	HANDLE waitTable [4] =
[+] 	HANDLE waitTable[4] =
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		DWORD waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			result = read->m_overlapped.m_completionEvent.wait (0);
[+] 			result = read->m_overlapped.m_completionEvent.wait(0);
[-] 			result = m_serial.m_serial.getOverlappedResult (&read->m_overlapped, &actualSize);
[+] 			result = m_serial.m_serial.getOverlappedResult(&read->m_overlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			m_overlappedIo->m_activeOverlappedReadList.remove (read);
[+] 			m_overlappedIo->m_activeOverlappedReadList.remove(read);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			addToReadBuffer (read->m_buffer, actualSize);
[+] 			addToReadBuffer(read->m_buffer, actualSize);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			read->m_overlapped.m_completionEvent.reset ();
[+] 			read->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedReadPool.put (read);
[+] 			m_overlappedIo->m_overlappedReadPool.put(read);
[-] 		if (isWritingSerial && m_overlappedIo->m_writeOverlapped.m_completionEvent.wait (0))
[+] 		if (isWritingSerial && m_overlappedIo->m_writeOverlapped.m_completionEvent.wait(0))
[-] 			result = m_serial.m_serial.getOverlappedResult (&m_overlappedIo->m_writeOverlapped, &actualSize);
[+] 			result = m_serial.m_serial.getOverlappedResult(&m_overlappedIo->m_writeOverlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			if (actualSize < m_overlappedIo->m_writeBlock.getCount ()) // shouldn't happen, actually (unless with a non-standard driver)
[+] 			if (actualSize < m_overlappedIo->m_writeBlock.getCount()) // shouldn't happen, actually (unless with a non-standard driver)
[-] 				m_overlappedIo->m_writeBlock.remove (0, actualSize);
[+] 				m_overlappedIo->m_writeBlock.remove(0, actualSize);
[-] 				m_overlappedIo->m_writeBlock.clear ();
[+] 				m_overlappedIo->m_writeBlock.clear();
[-] 			m_overlappedIo->m_writeOverlapped.m_completionEvent.reset ();
[+] 			m_overlappedIo->m_writeOverlapped.m_completionEvent.reset();
[-] 		if (m_overlappedIo->m_serialWaitOverlapped.m_completionEvent.wait (0))
[+] 		if (m_overlappedIo->m_serialWaitOverlapped.m_completionEvent.wait(0))
[-] 			m_overlappedIo->m_serialWaitOverlapped.m_completionEvent.reset ();
[+] 			m_overlappedIo->m_serialWaitOverlapped.m_completionEvent.reset();
[-] 		m_serial.m_serial.clearError (&errors, NULL);
[+] 		m_serial.m_serial.clearError(&errors, NULL);
[-] 		uint_t statusLines = m_serial.getStatusLines ();
[+] 		uint_t statusLines = m_serial.getStatusLines();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		getNextWriteBlock (&m_overlappedIo->m_writeBlock);
[+] 		getNextWriteBlock(&m_overlappedIo->m_writeBlock);
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		bool isReadBufferFull = m_readBuffer.isFull ();
[+] 		bool isReadBufferFull = m_readBuffer.isFull();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			result = m_serial.m_serial.setWaitMask (serialEventMask); // if wait is in progress, it will be completed now
[+] 			result = m_serial.m_serial.setWaitMask(serialEventMask); // if wait is in progress, it will be completed now
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			result = m_serial.m_serial.overlappedWait (
[+] 			result = m_serial.m_serial.overlappedWait(
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 		if (!isWritingSerial && !m_overlappedIo->m_writeBlock.isEmpty ())
[+] 		if (!isWritingSerial && !m_overlappedIo->m_writeBlock.isEmpty())
[-] 			result = m_serial.m_serial.overlappedWrite (
[+] 			result = m_serial.m_serial.overlappedWrite(
[-] 				m_overlappedIo->m_writeBlock.getCount (),
[+] 				m_overlappedIo->m_writeBlock.getCount(),
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 				size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount ();
[+] 				size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount();
[-] 			else if (m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 			else if (m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 				result = m_serial.m_serial.clearError (NULL, &stat);
[+] 				result = m_serial.m_serial.clearError(NULL, &stat);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get ();
[+] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get();
[-] 					read->m_buffer.setCount (readBlockSize) &&
[+] 					read->m_buffer.setCount(readBlockSize) &&
[-] 					m_serial.m_serial.overlappedRead (read->m_buffer, readBlockSize, &read->m_overlapped);
[+] 					m_serial.m_serial.overlappedRead(read->m_buffer, readBlockSize, &read->m_overlapped);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedReadList.insertTail (read);
[+] 				m_overlappedIo->m_activeOverlappedReadList.insertTail(read);
[-] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			waitTable [3] = read->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[3] = read->m_overlapped.m_completionEvent.m_event;
[-] Serial::ioThreadFunc ()
[+] Serial::ioThreadFunc()
[-] 	ASSERT (m_serial.isOpen ());
[+] 	ASSERT(m_serial.isOpen());
[-] 	int selectFd = AXL_MAX (m_serial.m_serial, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_serial.m_serial, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	sl::Array <char> writeBlock;
[+] 	sl::Array<char> writeBlock;
[-] 	readBlock.setCount (Def_ReadBlockSize);
[+] 	readBlock.setCount(Def_ReadBlockSize);
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_serial.m_serial, &readSet);
[+] 			FD_SET(m_serial.m_serial, &readSet);
[-] 			FD_SET (m_serial.m_serial, &writeSet);
[+] 			FD_SET(m_serial.m_serial, &writeSet);
[-] 		result = ::select (selectFd, &readSet, &writeSet, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, &writeSet, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_serial.m_serial, &readSet))
[+] 		if (FD_ISSET(m_serial.m_serial, &readSet))
[-] 		if (FD_ISSET (m_serial.m_serial, &writeSet))
[+] 		if (FD_ISSET(m_serial.m_serial, &writeSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 		while (canReadSerial && !m_readBuffer.isFull ())
[+] 		while (canReadSerial && !m_readBuffer.isFull())
[-] 			ssize_t actualSize = ::read (m_serial.m_serial, readBlock, readBlock.getCount ());
[+] 			ssize_t actualSize = ::read(m_serial.m_serial, readBlock, readBlock.getCount());
[-] 					setIoErrorEvent_l (err::Errno (errno));
[+] 					setIoErrorEvent_l(err::Errno(errno));
[-] 				setIoErrorEvent_l (err::Errno (EPIPE));
[+] 				setIoErrorEvent_l(err::Errno(EPIPE));
[-] 				addToReadBuffer (readBlock, actualSize);
[+] 				addToReadBuffer(readBlock, actualSize);
[-] 			getNextWriteBlock (&writeBlock);
[+] 			getNextWriteBlock(&writeBlock);
[-] 			if (writeBlock.isEmpty ())
[+] 			if (writeBlock.isEmpty())
[-] 			size_t blockSize = writeBlock.getCount ();
[+] 			size_t blockSize = writeBlock.getCount();
[-] 			ssize_t actualSize = ::write (m_serial.m_serial, writeBlock, blockSize);
[+] 			ssize_t actualSize = ::write(m_serial.m_serial, writeBlock, blockSize);
[-] 					setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 					setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 			else if ((size_t) actualSize < blockSize)
[+] 			else if ((size_t)actualSize < blockSize)
[-] 				writeBlock.remove (0, actualSize);
[+] 				writeBlock.remove(0, actualSize);
[-] 				writeBlock.clear ();
[+] 				writeBlock.clear();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] createSerialPortDesc (
[+] createSerialPortDesc(
[-] 	DataPtr portPtr = createData <SerialPortDesc> (runtime);
[+] 	DataPtr portPtr = createData<SerialPortDesc> (runtime);
[-] 	SerialPortDesc* port = (SerialPortDesc*) portPtr.m_p;
[+] 	SerialPortDesc* port = (SerialPortDesc*)portPtr.m_p;
[-] 	port->m_deviceNamePtr = strDup (portDesc->getDeviceName ());
[+] 	port->m_deviceNamePtr = strDup(portDesc->getDeviceName());
[-] 	port->m_descriptionPtr = strDup (portDesc->getDescription ());
[+] 	port->m_descriptionPtr = strDup(portDesc->getDescription());
[-] createSerialPortDescList (DataPtr countPtr)
[+] createSerialPortDescList(DataPtr countPtr)
[-] 	sl::List <axl::io::SerialPortDesc> portList;
[+] 	sl::List<axl::io::SerialPortDesc> portList;
[-] 	axl::io::createSerialPortDescList (&portList);
[+] 	axl::io::createSerialPortDescList(&portList);
[-] 	if (portList.isEmpty ())
[+] 	if (portList.isEmpty())
[-] 			*(size_t*) countPtr.m_p = 0;
[+] 			*(size_t*)countPtr.m_p = 0;
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	ScopedNoCollectRegion noCollectRegion (runtime, false);
[+] 	ScopedNoCollectRegion noCollectRegion(runtime, false);
[-] 	sl::Iterator <axl::io::SerialPortDesc> it = portList.getHead ();
[+] 	sl::Iterator<axl::io::SerialPortDesc> it = portList.getHead();
[-] 	DataPtr portPtr = createSerialPortDesc (runtime, *it);
[+] 	DataPtr portPtr = createSerialPortDesc(runtime, *it);
[-] 	SerialPortDesc* prevPort = (SerialPortDesc*) portPtr.m_p;
[+] 	SerialPortDesc* prevPort = (SerialPortDesc*)portPtr.m_p;
[-] 		portPtr = createSerialPortDesc (runtime, *it);
[+] 		portPtr = createSerialPortDesc(runtime, *it);
[-] 		prevPort = (SerialPortDesc*) portPtr.m_p;
[+] 		prevPort = (SerialPortDesc*)portPtr.m_p;
[-] 		*(size_t*) countPtr.m_p = count;
[+] 		*(size_t*)countPtr.m_p = count;
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Socket.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Socket)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Socket)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Socket>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Socket>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Socket>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Socket>)
[-] 	JNC_MAP_CONST_PROPERTY ("m_address",     &Socket::getAddress)
[+] 	JNC_MAP_CONST_PROPERTY("m_address",     &Socket::getAddress)
[-] 	JNC_MAP_CONST_PROPERTY ("m_peerAddress", &Socket::getPeerAddress)
[+] 	JNC_MAP_CONST_PROPERTY("m_peerAddress", &Socket::getPeerAddress)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &Socket::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &Socket::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &Socket::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &Socket::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &Socket::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &Socket::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &Socket::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &Socket::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &Socket::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &Socket::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",          &Socket::open_0)
[+] 	JNC_MAP_FUNCTION("open",          &Socket::open_0)
[-] 	JNC_MAP_OVERLOAD (&Socket::open_1)
[+] 	JNC_MAP_OVERLOAD(&Socket::open_1)
[-] 	JNC_MAP_FUNCTION ("close",         &Socket::close)
[+] 	JNC_MAP_FUNCTION("close",         &Socket::close)
[-] 	JNC_MAP_FUNCTION ("connect",       &Socket::connect)
[+] 	JNC_MAP_FUNCTION("connect",       &Socket::connect)
[-] 	JNC_MAP_FUNCTION ("listen",        &Socket::listen)
[+] 	JNC_MAP_FUNCTION("listen",        &Socket::listen)
[-] 	JNC_MAP_FUNCTION ("accept",        &Socket::accept)
[+] 	JNC_MAP_FUNCTION("accept",        &Socket::accept)
[-] 	JNC_MAP_FUNCTION ("read",          &Socket::read)
[+] 	JNC_MAP_FUNCTION("read",          &Socket::read)
[-] 	JNC_MAP_FUNCTION ("write",         &Socket::write)
[+] 	JNC_MAP_FUNCTION("write",         &Socket::write)
[-] 	JNC_MAP_FUNCTION ("readDatagram",  &Socket::readDatagram)
[+] 	JNC_MAP_FUNCTION("readDatagram",  &Socket::readDatagram)
[-] 	JNC_MAP_FUNCTION ("writeDatagram", &Socket::writeDatagram)
[+] 	JNC_MAP_FUNCTION("writeDatagram", &Socket::writeDatagram)
[-] 	JNC_MAP_FUNCTION ("wait",          &Socket::wait)
[+] 	JNC_MAP_FUNCTION("wait",          &Socket::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",    &Socket::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",    &Socket::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait",  &Socket::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait",  &Socket::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Socket::Socket ()
[+] Socket::Socket()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] Socket::openImpl (
[+] Socket::openImpl(
[-] 	close ();
[+] 	close();
[-] 	bool result = SocketBase::open (family, protocol, address);
[+] 	bool result = SocketBase::open(family, protocol, address);
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] Socket::close ()
[+] Socket::close()
[-] 	if (!m_socket.isOpen ())
[+] 	if (!m_socket.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	SocketBase::close ();
[+] 	SocketBase::close();
[-] 	sl::Iterator <IncomingConnection> it = m_pendingIncomingConnectionList.getHead ();
[+] 	sl::Iterator<IncomingConnection> it = m_pendingIncomingConnectionList.getHead();
[-] 		it->m_socket.close ();
[+] 		it->m_socket.close();
[-] 	m_incomingConnectionPool.put (&m_pendingIncomingConnectionList);
[+] 	m_incomingConnectionPool.put(&m_pendingIncomingConnectionList);
[-] 		AXL_MEM_DELETE (m_overlappedIo);
[+] 		AXL_MEM_DELETE(m_overlappedIo);
[-] Socket::connect (DataPtr addressPtr)
[+] Socket::connect(DataPtr addressPtr)
[-] 	SocketAddress* address = (SocketAddress*) addressPtr.m_p;
[+] 	SocketAddress* address = (SocketAddress*)addressPtr.m_p;
[-] 	bool result = m_socket.connect (address->getSockAddr ());
[+] 	bool result = m_socket.connect(address->getSockAddr());
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Socket::listen (size_t backLogLimit)
[+] Socket::listen(size_t backLogLimit)
[-] 	bool result = m_socket.listen (backLogLimit);
[+] 	bool result = m_socket.listen(backLogLimit);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Socket::accept (DataPtr addressPtr)
[+] Socket::accept(DataPtr addressPtr)
[-] 	SocketAddress* address = ((SocketAddress*) addressPtr.m_p);
[+] 	SocketAddress* address = ((SocketAddress*)addressPtr.m_p);
[-] 	Socket* connectionSocket = createClass <Socket> (m_runtime);
[+] 	Socket* connectionSocket = createClass<Socket> (m_runtime);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_pendingIncomingConnectionList.isEmpty ())
[+] 	if (m_pendingIncomingConnectionList.isEmpty())
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	IncomingConnection* incomingConnection = m_pendingIncomingConnectionList.removeHead ();
[+] 	IncomingConnection* incomingConnection = m_pendingIncomingConnectionList.removeHead();
[-] 	sl::takeOver (&connectionSocket->m_socket.m_socket, &incomingConnection->m_socket.m_socket);
[+] 	sl::takeOver(&connectionSocket->m_socket.m_socket, &incomingConnection->m_socket.m_socket);
[-] 	connectionSocket->setOptions (m_options);
[+] 	connectionSocket->setOptions(m_options);
[-] 	connectionSocket->AsyncIoDevice::open ();
[+] 	connectionSocket->AsyncIoDevice::open();
[-] 	connectionSocket->m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	connectionSocket->m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 		address->setSockAddr (incomingConnection->m_sockAddr);
[+] 		address->setSockAddr(incomingConnection->m_sockAddr);
[-] 	m_incomingConnectionPool.put (incomingConnection);
[+] 	m_incomingConnectionPool.put(incomingConnection);
[-] 	if (m_pendingIncomingConnectionList.isEmpty ())
[+] 	if (m_pendingIncomingConnectionList.isEmpty())
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	bool result = connectionSocket->m_socket.setBlockingMode (false); // not guaranteed to be propagated across accept calls
[+] 	bool result = connectionSocket->m_socket.setBlockingMode(false); // not guaranteed to be propagated across accept calls
[-] 	connectionSocket->wakeIoThread ();
[+] 	connectionSocket->wakeIoThread();
[-] 	connectionSocket->m_ioThread.start ();
[+] 	connectionSocket->m_ioThread.start();
[-] Socket::readDatagram (
[+] Socket::readDatagram(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 		result = bufferedRead (dataPtr, dataSize);
[+] 		result = bufferedRead(dataPtr, dataSize);
[-] 		char buffer [256];
[+] 		char buffer[256];
[-] 		sl::Array <char> params (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 		sl::Array<char> params(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		result = bufferedRead (dataPtr, dataSize, &params);
[+] 		result = bufferedRead(dataPtr, dataSize, &params);
[-] 		ASSERT (params.getCount () == sizeof (axl::io::SockAddr));
[+] 		ASSERT(params.getCount() == sizeof(axl::io::SockAddr));
[-] 		((SocketAddress*) addressPtr.m_p)->setSockAddr (*(axl::io::SockAddr*) params.p ());
[+] 		((SocketAddress*)addressPtr.m_p)->setSockAddr(*(axl::io::SockAddr*)params.p());
[-] Socket::writeDatagram (
[+] Socket::writeDatagram(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	SocketAddress* address = (SocketAddress*) addressPtr.m_p;
[+] 	SocketAddress* address = (SocketAddress*)addressPtr.m_p;
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidParameter));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidParameter));
[-] 	axl::io::SockAddr sockAddr = address->getSockAddr ();
[+] 	axl::io::SockAddr sockAddr = address->getSockAddr();
[-] 	return bufferedWrite (dataPtr, dataSize, &sockAddr, sizeof (sockAddr));
[+] 	return bufferedWrite(dataPtr, dataSize, &sockAddr, sizeof(sockAddr));
[-] Socket::ioThreadFunc ()
[+] Socket::ioThreadFunc()
[-] 	ASSERT (m_socket.isOpen ());
[+] 	ASSERT(m_socket.isOpen());
[-] 	sleepIoThread ();
[+] 	sleepIoThread();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		sendRecvLoop (0, true);
[+] 		sendRecvLoop(0, true);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		bool result = tcpConnect (SocketEvent_Connected);
[+] 		bool result = tcpConnect(SocketEvent_Connected);
[-] 			sendRecvLoop (SocketEvent_Connected, false);
[+] 			sendRecvLoop(SocketEvent_Connected, false);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		acceptLoop ();
[+] 		acceptLoop();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		sendRecvLoop (SocketEvent_Connected, false);
[+] 		sendRecvLoop(SocketEvent_Connected, false);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		ASSERT (false); // shouldn't normally happen
[+] 		ASSERT(false); // shouldn't normally happen
[-] Socket::acceptLoop ()
[+] Socket::acceptLoop()
[-] 	bool result = m_socket.m_socket.wsaEventSelect (socketEvent.m_event, FD_ACCEPT);
[+] 	bool result = m_socket.m_socket.wsaEventSelect(socketEvent.m_event, FD_ACCEPT);
[-] 	HANDLE waitTable [] =
[+] 	HANDLE waitTable[] =
[-] 		DWORD waitResult = ::WaitForMultipleObjects (countof (waitTable), waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(countof(waitTable), waitTable, false, INFINITE);
[-] 		switch (waitResult)
[+] 		switch(waitResult)
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			result = m_socket.m_socket.wsaEnumEvents (&networkEvents);
[+] 			result = m_socket.m_socket.wsaEnumEvents(&networkEvents);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 				int error = networkEvents.iErrorCode [FD_ACCEPT_BIT];
[+] 				int error = networkEvents.iErrorCode[FD_ACCEPT_BIT];
[-] 					setIoErrorEvent (error);
[+] 					setIoErrorEvent(error);
[-] 				bool result = m_socket.accept (&socket, &sockAddr);
[+] 				bool result = m_socket.accept(&socket, &sockAddr);
[-] 				m_lock.lock ();
[+] 				m_lock.lock();
[-] 				IncomingConnection* incomingConnection = m_incomingConnectionPool.get ();
[+] 				IncomingConnection* incomingConnection = m_incomingConnectionPool.get();
[-] 				sl::takeOver (&incomingConnection->m_socket.m_socket, &socket.m_socket);
[+] 				sl::takeOver(&incomingConnection->m_socket.m_socket, &socket.m_socket);
[-] 				m_pendingIncomingConnectionList.insertTail (incomingConnection);
[+] 				m_pendingIncomingConnectionList.insertTail(incomingConnection);
[-] 				setEvents_l (SocketEvent_IncomingConnection);
[+] 				setEvents_l(SocketEvent_IncomingConnection);
[-] Socket::sendRecvLoop (
[+] Socket::sendRecvLoop(
[-] 	ASSERT (m_socket.isOpen () && m_overlappedIo);
[+] 	ASSERT(m_socket.isOpen() && m_overlappedIo);
[-] 	HANDLE waitTable [3] =
[+] 	HANDLE waitTable[3] =
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		dword_t waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		dword_t waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedRecvList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedRecvList.isEmpty())
[-] 			OverlappedRecv* recv = *m_overlappedIo->m_activeOverlappedRecvList.getHead ();
[+] 			OverlappedRecv* recv = *m_overlappedIo->m_activeOverlappedRecvList.getHead();
[-] 			result = recv->m_overlapped.m_completionEvent.wait (0);
[+] 			result = recv->m_overlapped.m_completionEvent.wait(0);
[-] 			result = m_socket.m_socket.wsaGetOverlappedResult (&recv->m_overlapped, &actualSize);
[+] 			result = m_socket.m_socket.wsaGetOverlappedResult(&recv->m_overlapped, &actualSize);
[-] 				err::Error error = err::getLastError ();
[+] 				err::Error error = err::getLastError();
[-] 				ASSERT (error->m_guid == err::g_systemErrorGuid);
[+] 				ASSERT(error->m_guid == err::g_systemErrorGuid);
[-] 					setEvents (SocketEvent_Disconnected | SocketEvent_Reset);
[+] 					setEvents(SocketEvent_Disconnected | SocketEvent_Reset);
[-] 					setIoErrorEvent (error);
[+] 					setIoErrorEvent(error);
[-] 			m_overlappedIo->m_activeOverlappedRecvList.remove (recv);
[+] 			m_overlappedIo->m_activeOverlappedRecvList.remove(recv);
[-] 				setEvents (SocketEvent_Disconnected);
[+] 				setEvents(SocketEvent_Disconnected);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				addToReadBuffer (recv->m_buffer, actualSize, &recv->m_sockAddr, sizeof (recv->m_sockAddr));
[+] 				addToReadBuffer(recv->m_buffer, actualSize, &recv->m_sockAddr, sizeof(recv->m_sockAddr));
[-] 				addToReadBuffer (recv->m_buffer, actualSize);
[+] 				addToReadBuffer(recv->m_buffer, actualSize);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			recv->m_overlapped.m_completionEvent.reset ();
[+] 			recv->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedRecvPool.put (recv);
[+] 			m_overlappedIo->m_overlappedRecvPool.put(recv);
[-] 		if (isSendingSocket && m_overlappedIo->m_sendOverlapped.m_completionEvent.wait (0))
[+] 		if (isSendingSocket && m_overlappedIo->m_sendOverlapped.m_completionEvent.wait(0))
[-] 			result = m_socket.m_socket.wsaGetOverlappedResult (&m_overlappedIo->m_sendOverlapped, &actualSize);
[+] 			result = m_socket.m_socket.wsaGetOverlappedResult(&m_overlappedIo->m_sendOverlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			if (actualSize < m_overlappedIo->m_sendBlock.getCount () && !isDatagram) // shouldn't happen, actually (unless with a non-standard WSP)
[+] 			if (actualSize < m_overlappedIo->m_sendBlock.getCount() && !isDatagram) // shouldn't happen, actually (unless with a non-standard WSP)
[-] 				m_overlappedIo->m_sendBlock.remove (0, actualSize);
[+] 				m_overlappedIo->m_sendBlock.remove(0, actualSize);
[-] 				m_overlappedIo->m_sendBlock.clear ();
[+] 				m_overlappedIo->m_sendBlock.clear();
[-] 			m_overlappedIo->m_sendOverlapped.m_completionEvent.reset ();
[+] 			m_overlappedIo->m_sendOverlapped.m_completionEvent.reset();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			getNextWriteBlock (&m_overlappedIo->m_sendBlock, &m_overlappedIo->m_sendToParams) :
[+] 			getNextWriteBlock(&m_overlappedIo->m_sendBlock, &m_overlappedIo->m_sendToParams) :
[-] 			getNextWriteBlock (&m_overlappedIo->m_sendBlock);
[+] 			getNextWriteBlock(&m_overlappedIo->m_sendBlock);
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		bool isReadBufferFull = m_readBuffer.isFull ();
[+] 		bool isReadBufferFull = m_readBuffer.isFull();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		if (!isSendingSocket && !m_overlappedIo->m_sendBlock.isEmpty ())
[+] 		if (!isSendingSocket && !m_overlappedIo->m_sendBlock.isEmpty())
[-] 				m_socket.m_socket.wsaSendTo (
[+] 				m_socket.m_socket.wsaSendTo(
[-] 					m_overlappedIo->m_sendBlock.getCount (),
[+] 					m_overlappedIo->m_sendBlock.getCount(),
[-] 					&((axl::io::SockAddr*) m_overlappedIo->m_sendToParams.p ())->m_addr,
[+] 					&((axl::io::SockAddr*)m_overlappedIo->m_sendToParams.p())->m_addr,
[-] 				m_socket.m_socket.wsaSend (
[+] 				m_socket.m_socket.wsaSend(
[-] 					m_overlappedIo->m_sendBlock.getCount (),
[+] 					m_overlappedIo->m_sendBlock.getCount(),
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedRecvList.getCount ();
[+] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedRecvList.getCount();
[-] 				OverlappedRecv* recv = m_overlappedIo->m_overlappedRecvPool.get ();
[+] 				OverlappedRecv* recv = m_overlappedIo->m_overlappedRecvPool.get();
[-] 					recv->m_sockAddrSize = sizeof (recv->m_sockAddr);
[+] 					recv->m_sockAddrSize = sizeof(recv->m_sockAddr);
[-] 						recv->m_buffer.setCount (readBlockSize) &&
[+] 						recv->m_buffer.setCount(readBlockSize) &&
[-] 						m_socket.m_socket.wsaRecvFrom (
[+] 						m_socket.m_socket.wsaRecvFrom(
[-] 						recv->m_buffer.setCount (readBlockSize) &&
[+] 						recv->m_buffer.setCount(readBlockSize) &&
[-] 						m_socket.m_socket.wsaRecv (
[+] 						m_socket.m_socket.wsaRecv(
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedRecvList.insertTail (recv);
[+] 				m_overlappedIo->m_activeOverlappedRecvList.insertTail(recv);
[-] 		if (m_overlappedIo->m_activeOverlappedRecvList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedRecvList.isEmpty())
[-] 			OverlappedRecv* recv = *m_overlappedIo->m_activeOverlappedRecvList.getHead ();
[+] 			OverlappedRecv* recv = *m_overlappedIo->m_activeOverlappedRecvList.getHead();
[-] 			waitTable [2] = recv->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[2] = recv->m_overlapped.m_completionEvent.m_event;
[-] Socket::acceptLoop ()
[+] Socket::acceptLoop()
[-] 	int selectFd = AXL_MAX (m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_socket.m_socket, &readSet);
[+] 			FD_SET(m_socket.m_socket, &readSet);
[-] 		result = ::select (selectFd, &readSet, NULL, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, NULL, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_socket.m_socket, &readSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &readSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			socklen_t sockAddrSize = sizeof (sockAddr);
[+] 			socklen_t sockAddrSize = sizeof(sockAddr);
[-] 			int socket = ::accept (m_socket.m_socket, &sockAddr.m_addr, &sockAddrSize);
[+] 			int socket = ::accept(m_socket.m_socket, &sockAddr.m_addr, &sockAddrSize);
[-] 					setIoErrorEvent_l (err::Errno (errno));
[+] 					setIoErrorEvent_l(err::Errno(errno));
[-] 				IncomingConnection* incomingConnection = m_incomingConnectionPool.get ();
[+] 				IncomingConnection* incomingConnection = m_incomingConnectionPool.get();
[-] 				incomingConnection->m_socket.m_socket.attach (socket);
[+] 				incomingConnection->m_socket.m_socket.attach(socket);
[-] 				m_pendingIncomingConnectionList.insertTail (incomingConnection);
[+] 				m_pendingIncomingConnectionList.insertTail(incomingConnection);
[-] 		if (!m_pendingIncomingConnectionList.isEmpty ())
[+] 		if (!m_pendingIncomingConnectionList.isEmpty())
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] Socket::sendRecvLoop (
[+] Socket::sendRecvLoop(
[-] 	int selectFd = AXL_MAX (m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	sl::Array <char> writeBlock;
[+] 	sl::Array<char> writeBlock;
[-] 	readBlock.setCount (Def_ReadBlockSize);
[+] 	readBlock.setCount(Def_ReadBlockSize);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> writeParams (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> writeParams(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	writeParams.setCount (sizeof (SocketAddress));
[+] 	writeParams.setCount(sizeof(SocketAddress));
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_socket.m_socket, &readSet);
[+] 			FD_SET(m_socket.m_socket, &readSet);
[-] 			FD_SET (m_socket.m_socket, &writeSet);
[+] 			FD_SET(m_socket.m_socket, &writeSet);
[-] 		result = ::select (selectFd, &readSet, &writeSet, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, &writeSet, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_socket.m_socket, &readSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &readSet))
[-] 		if (FD_ISSET (m_socket.m_socket, &writeSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &writeSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 			while (canReadSocket && !m_readBuffer.isFull ())
[+] 			while (canReadSocket && !m_readBuffer.isFull())
[-] 				socklen_t sockAddrSize = sizeof (sockAddr);
[+] 				socklen_t sockAddrSize = sizeof(sockAddr);
[-] 				ssize_t actualSize = ::recvfrom (
[+] 				ssize_t actualSize = ::recvfrom(
[-] 					readBlock.getCount (),
[+] 					readBlock.getCount(),
[-] 						setIoErrorEvent_l (err::Errno (errno));
[+] 						setIoErrorEvent_l(err::Errno(errno));
[-] 					addToReadBuffer (readBlock, actualSize, &sockAddr, sizeof (sockAddr));
[+] 					addToReadBuffer(readBlock, actualSize, &sockAddr, sizeof(sockAddr));
[-] 				getNextWriteBlock (&writeBlock, &writeParams);
[+] 				getNextWriteBlock(&writeBlock, &writeParams);
[-] 				if (writeBlock.isEmpty ())
[+] 				if (writeBlock.isEmpty())
[-] 				axl::io::SockAddr* sockAddr = ((axl::io::SockAddr*) writeParams.p ());
[+] 				axl::io::SockAddr* sockAddr = ((axl::io::SockAddr*)writeParams.p());
[-] 				socklen_t sockAddrSize = axl::io::getSockAddrSize (&sockAddr->m_addr);
[+] 				socklen_t sockAddrSize = axl::io::getSockAddrSize(&sockAddr->m_addr);
[-] 				size_t blockSize = writeBlock.getCount ();
[+] 				size_t blockSize = writeBlock.getCount();
[-] 				ssize_t actualSize = ::sendto (
[+] 				ssize_t actualSize = ::sendto(
[-] 						setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 						setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 					writeBlock.clear ();
[+] 					writeBlock.clear();
[-] 			while (canReadSocket && !m_readBuffer.isFull ())
[+] 			while (canReadSocket && !m_readBuffer.isFull())
[-] 				ssize_t actualSize = ::recv (m_socket.m_socket, readBlock, readBlock.getCount (), 0);
[+] 				ssize_t actualSize = ::recv(m_socket.m_socket, readBlock, readBlock.getCount(), 0);
[-] 						setIoErrorEvent_l (err::Errno (errno));
[+] 						setIoErrorEvent_l(err::Errno(errno));
[-] 					setEvents_l (m_socket.getError () ?
[+] 					setEvents_l(m_socket.getError() ?
[-] 					addToReadBuffer (readBlock, actualSize);
[+] 					addToReadBuffer(readBlock, actualSize);
[-] 				getNextWriteBlock (&writeBlock);
[+] 				getNextWriteBlock(&writeBlock);
[-] 				if (writeBlock.isEmpty ())
[+] 				if (writeBlock.isEmpty())
[-] 				size_t blockSize = writeBlock.getCount ();
[+] 				size_t blockSize = writeBlock.getCount();
[-] 				ssize_t actualSize = ::send (m_socket.m_socket, writeBlock, blockSize, 0);
[+] 				ssize_t actualSize = ::send(m_socket.m_socket, writeBlock, blockSize, 0);
[-] 						setIoErrorEvent_l (err::Errno (errno));
[+] 						setIoErrorEvent_l(err::Errno(errno));
[-] 				else if ((size_t) actualSize < blockSize)
[+] 				else if ((size_t)actualSize < blockSize)
[-] 					writeBlock.remove (0, actualSize);
[+] 					writeBlock.remove(0, actualSize);
[-] 					writeBlock.clear ();
[+] 					writeBlock.clear();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_SocketAddressResolver.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SocketAddressResolver)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SocketAddressResolver)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <SocketAddressResolver>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<SocketAddressResolver>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <SocketAddressResolver>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<SocketAddressResolver>)
[-] 	JNC_MAP_FUNCTION ("resolve",   &SocketAddressResolver::resolve)
[+] 	JNC_MAP_FUNCTION("resolve",   &SocketAddressResolver::resolve)
[-] 	JNC_MAP_FUNCTION ("cancel",    &SocketAddressResolver::cancel)
[+] 	JNC_MAP_FUNCTION("cancel",    &SocketAddressResolver::cancel)
[-] 	JNC_MAP_FUNCTION ("cancelAll", &SocketAddressResolver::cancelAll)
[+] 	JNC_MAP_FUNCTION("cancelAll", &SocketAddressResolver::cancelAll)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] SocketAddressResolver::SocketAddressResolver ()
[+] SocketAddressResolver::SocketAddressResolver()
[-] 	m_runtime = getCurrentThreadRuntime ();
[+] 	m_runtime = getCurrentThreadRuntime();
[-] 	ASSERT (m_runtime);
[+] 	ASSERT(m_runtime);
[-] SocketAddressResolver::~SocketAddressResolver ()
[+] SocketAddressResolver::~SocketAddressResolver()
[-] 	cancelAll ();
[+] 	cancelAll();
[-] 	stopIoThread ();
[+] 	stopIoThread();
[-] SocketAddressResolver::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] SocketAddressResolver::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::Iterator <Req> it = m_pendingReqList.getHead ();
[+] 	sl::Iterator<Req> it = m_pendingReqList.getHead();
[-] 			gcHeap->markClass (it->m_completionFuncPtr.m_closure->m_box);
[+] 			gcHeap->markClass(it->m_completionFuncPtr.m_closure->m_box);
[-] 	it = m_activeReqList.getHead ();
[+] 	it = m_activeReqList.getHead();
[-] 			gcHeap->markClass (it->m_completionFuncPtr.m_closure->m_box);
[+] 			gcHeap->markClass(it->m_completionFuncPtr.m_closure->m_box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SocketAddressResolver::stopIoThread ()
[+] SocketAddressResolver::stopIoThread()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] SocketAddressResolver::wakeIoThread ()
[+] SocketAddressResolver::wakeIoThread()
[-] 	m_ioThreadEvent.signal ();
[+] 	m_ioThreadEvent.signal();
[-] 	m_selfPipe.write (" ", 1);
[+] 	m_selfPipe.write(" ", 1);
[-] SocketAddressResolver::resolve (
[+] SocketAddressResolver::resolve(
[-] 	bool result = sockAddr.parse (name);
[+] 	bool result = sockAddr.parse(name);
[-] 		callCompletionFunc (completionFuncPtr, &sockAddr, 1);
[+] 		callCompletionFunc(completionFuncPtr, &sockAddr, 1);
[-] 	const char* p = strchr (name, ':');
[+] 	const char* p = strchr(name, ':');
[-] 		port = (ushort_t) strtol (p + 1, &end, 10);
[+] 		port = (ushort_t)strtol(p + 1, &end, 10);
[-] 			callCompletionFunc (completionFuncPtr, "invalid port string");
[+] 			callCompletionFunc(completionFuncPtr, "invalid port string");
[-] 		nameString.copy (name, p - name);
[+] 		nameString.copy(name, p - name);
[-] 	Req* req = AXL_MEM_NEW (Req);
[+] 	Req* req = AXL_MEM_NEW(Req);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	uintptr_t id = m_reqMap.add (req);
[+] 	uintptr_t id = m_reqMap.add(req);
[-] 	m_pendingReqList.insertTail (req);
[+] 	m_pendingReqList.insertTail(req);
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 		m_selfPipe.create ();
[+] 		m_selfPipe.create();
[-] 		m_ioThread.start ();
[+] 		m_ioThread.start();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SocketAddressResolver::cancel (uintptr_t id)
[+] SocketAddressResolver::cancel(uintptr_t id)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	Req* req = m_reqMap.findValue (id, NULL);
[+] 	Req* req = m_reqMap.findValue(id, NULL);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	ASSERT (req->m_id == id);
[+] 	ASSERT(req->m_id == id);
[-] 	m_reqMap.eraseKey (req->m_id);
[+] 	m_reqMap.eraseKey(req->m_id);
[-] 	m_activeReqList.insertTail (req);
[+] 	m_activeReqList.insertTail(req);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	callCompletionFunc (req->m_completionFuncPtr, err::SystemErrorCode_Cancelled);
[+] 	callCompletionFunc(req->m_completionFuncPtr, err::SystemErrorCode_Cancelled);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_activeReqList.erase (req);
[+] 	m_activeReqList.erase(req);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SocketAddressResolver::cancelAll ()
[+] SocketAddressResolver::cancelAll()
[-] 	err::Error error (err::SystemErrorCode_Cancelled);
[+] 	err::Error error(err::SystemErrorCode_Cancelled);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	while (!m_activeReqList.isEmpty ())
[+] 	while (!m_activeReqList.isEmpty())
[-] 		Req* req = m_pendingReqList.removeTail ();
[+] 		Req* req = m_pendingReqList.removeTail();
[-] 		m_reqMap.eraseKey (req->m_id);
[+] 		m_reqMap.eraseKey(req->m_id);
[-] 		m_activeReqList.insertTail (req);
[+] 		m_activeReqList.insertTail(req);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		callCompletionFunc (req->m_completionFuncPtr, error);
[+] 		callCompletionFunc(req->m_completionFuncPtr, error);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		m_activeReqList.erase (req);
[+] 		m_activeReqList.erase(req);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SocketAddressResolver::ioThreadFunc ()
[+] SocketAddressResolver::ioThreadFunc()
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		while (!m_pendingReqList.isEmpty ())
[+] 		while (!m_pendingReqList.isEmpty())
[-] 			Req* req = m_pendingReqList.removeHead ();
[+] 			Req* req = m_pendingReqList.removeHead();
[-] 			m_reqMap.eraseKey (req->m_id);
[+] 			m_reqMap.eraseKey(req->m_id);
[-] 			m_activeReqList.insertTail (req);
[+] 			m_activeReqList.insertTail(req);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			processReq (req);
[+] 			processReq(req);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			m_activeReqList.erase (req);
[+] 			m_activeReqList.erase(req);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_ioThreadEvent.wait ();
[+] 		m_ioThreadEvent.wait();
[-] 		char buffer [256];
[+] 		char buffer[256];
[-] 		m_selfPipe.read (buffer, sizeof (buffer));
[+] 		m_selfPipe.read(buffer, sizeof(buffer));
[-] 	cancelAll ();
[+] 	cancelAll();
[-] SocketAddressResolver::callCompletionFunc (
[+] SocketAddressResolver::callCompletionFunc(
[-] 	JNC_BEGIN_CALL_SITE (m_runtime);
[+] 	JNC_BEGIN_CALL_SITE(m_runtime);
[-] 		Type* addressType = SocketAddress::getType (m_runtime->getModule ());
[+] 		Type* addressType = SocketAddress::getType(m_runtime->getModule());
[-] 		addressTablePtr = m_runtime->getGcHeap ()->allocateArray (addressType, addressCount);
[+] 		addressTablePtr = m_runtime->getGcHeap()->allocateArray(addressType, addressCount);
[-] 		SocketAddress* dst = (SocketAddress*) addressTablePtr.m_p;
[+] 		SocketAddress* dst = (SocketAddress*)addressTablePtr.m_p;
[-] 			dst->setSockAddr (*src);
[+] 			dst->setSockAddr(*src);
[-] 	DataPtr errorPtr = error ? memDup (error, error->m_size) : g_nullPtr;
[+] 	DataPtr errorPtr = error ? memDup(error, error->m_size) : g_nullPtr;
[-] 	callVoidFunctionPtr (completionFuncPtr, addressTablePtr, addressCount, errorPtr);
[+] 	callVoidFunctionPtr(completionFuncPtr, addressTablePtr, addressCount, errorPtr);
[-] 	JNC_END_CALL_SITE ();
[+] 	JNC_END_CALL_SITE();
[-] SocketAddressResolver::processReq (Req* req)
[+] SocketAddressResolver::processReq(Req* req)
[-] 	sl::Array <axl::io::SockAddr> addrArray;
[+] 	sl::Array<axl::io::SockAddr> addrArray;
[-] 	bool result = axl::io::resolveHostName (&addrArray, req->m_name, req->m_addrFamily);
[+] 	bool result = axl::io::resolveHostName(&addrArray, req->m_name, req->m_addrFamily);
[-] 		callCompletionFunc (req->m_completionFuncPtr, err::getLastError ());
[+] 		callCompletionFunc(req->m_completionFuncPtr, err::getLastError());
[-] 	uint_t port = sl::swapByteOrder16 (req->m_port);
[+] 	uint_t port = sl::swapByteOrder16(req->m_port);
[-] 	size_t count = addrArray.getCount ();
[+] 	size_t count = addrArray.getCount();
[-] 		addrArray [i].m_addr_ip4.sin_port = port;
[+] 		addrArray[i].m_addr_ip4.sin_port = port;
[-] 	callCompletionFunc (req->m_completionFuncPtr, addrArray, count);
[+] 	callCompletionFunc(req->m_completionFuncPtr, addrArray, count);
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_File.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (File)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(File)
[-] 	File ();
[+] 	File();
[-] 	setDynamicViewLimit (size_t limit);
[+] 	setDynamicViewLimit(size_t limit);
[-] 	getSize ()
[+] 	getSize()
[-] 		return m_file.getSize ();
[+] 		return m_file.getSize();
[-] 	setSize (uint64_t size)
[+] 	setSize(uint64_t size)
[-] 		return m_file.setSize (size);
[+] 		return m_file.setSize(size);
[-] 	getPosition ()
[+] 	getPosition()
[-] 		return m_file.getPosition ();
[+] 		return m_file.getPosition();
[-] 	setPosition (uint64_t offset)
[+] 	setPosition(uint64_t offset)
[-] 		return m_file.setPosition (offset);
[+] 		return m_file.setPosition(offset);
[-] 	open (
[+] 	open(
[-] 		return m_file.open ((const char*) namePtr.m_p, flags);
[+] 		return m_file.open((const char*) namePtr.m_p, flags);
[-] 	close ()
[+] 	close()
[-] 		m_file.close ();
[+] 		m_file.close();
[-] 	read (
[+] 	read(
[-] 		return m_file.read (ptr.m_p, size);
[+] 		return m_file.read(ptr.m_p, size);
[-] 	write (
[+] 	write(
[-] 		return m_file.write (ptr.m_p, size);
[+] 		return m_file.write(ptr.m_p, size);
[-] 	flush ()
[+] 	flush()
[-] 		return m_file.flush ();
[+] 		return m_file.flush();
----------------------
27/02/2019 18:02:16 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_FileStream.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (FileStream)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(FileStream)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (FileStream)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(FileStream)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, FileStream, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, FileStream, m_ioThread)->ioThreadFunc();
[-] 		mem::Pool <OverlappedRead> m_overlappedReadPool;
[+] 		mem::Pool<OverlappedRead> m_overlappedReadPool;
[-] 		sl::List <OverlappedRead> m_activeOverlappedReadList;
[+] 		sl::List<OverlappedRead> m_activeOverlappedReadList;
[-] 		sl::Array <char> m_writeBlock;
[+] 		sl::Array<char> m_writeBlock;
[-] 		OverlappedIo ()
[+] 		OverlappedIo()
[-] 	FileStream ();
[+] 	FileStream();
[-] 	~FileStream ()
[+] 	~FileStream()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	open (
[+] 	open(
[-] 	close ();
[+] 	close();
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t options);
[+] 	setOptions(uint_t options);
[-] 	clear ();
[+] 	clear();
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_IoLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Mailslot.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Mailslot)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Mailslot)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Mailslot, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, Mailslot, m_ioThread)->ioThreadFunc();
[-] 		mem::Pool <OverlappedRead> m_overlappedReadPool;
[+] 		mem::Pool<OverlappedRead> m_overlappedReadPool;
[-] 		sl::List <OverlappedRead> m_activeOverlappedReadList;
[+] 		sl::List<OverlappedRead> m_activeOverlappedReadList;
[-] 	Mailslot ();
[+] 	Mailslot();
[-] 	~Mailslot ()
[+] 	~Mailslot()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	open (DataPtr namePtr);
[+] 	open(DataPtr namePtr);
[-] 	close ();
[+] 	close();
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setOptions (uint_t options)
[+] 	setOptions(uint_t options)
[-] 		AsyncIoDevice::setSetting (&m_options, options);
[+] 		AsyncIoDevice::setSetting(&m_options, options);
[-] 	read (
[+] 	read(
[-] 		return bufferedRead (ptr, size);
[+] 		return bufferedRead(ptr, size);
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_MappedFile.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (MappedFile)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(MappedFile)
[-] 	MappedFile ();
[+] 	MappedFile();
[-] 	setDynamicViewLimit (size_t limit);
[+] 	setDynamicViewLimit(size_t limit);
[-] 	getSize ()
[+] 	getSize()
[-] 		return m_file.getSize ();
[+] 		return m_file.getSize();
[-] 	setSize (uint64_t size)
[+] 	setSize(uint64_t size)
[-] 		return m_file.setSize (size);
[+] 		return m_file.setSize(size);
[-] 	open (
[+] 	open(
[-] 		return m_file.open ((const char*) namePtr.m_p, flags);
[+] 		return m_file.open((const char*) namePtr.m_p, flags);
[-] 	close ()
[+] 	close()
[-] 		m_file.close ();
[+] 		m_file.close();
[-] 	view (
[+] 	view(
[-] 	unmapAllViews ()
[+] 	unmapAllViews()
[-] 		m_file.unmapAllViews ();
[+] 		m_file.unmapAllViews();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_NamedPipe.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (NamedPipe)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(NamedPipe)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, NamedPipe, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, NamedPipe, m_ioThread)->ioThreadFunc();
[-] 		mem::Pool <OverlappedConnect> m_overlappedConnectPool;
[+] 		mem::Pool<OverlappedConnect> m_overlappedConnectPool;
[-] 		sl::List <OverlappedConnect> m_pipeList;
[+] 		sl::List<OverlappedConnect> m_pipeList;
[-] 		sl::List <OverlappedConnect> m_activeOverlappedConnectList;
[+] 		sl::List<OverlappedConnect> m_activeOverlappedConnectList;
[-] 	mem::Pool <IncomingConnection> m_incomingConnectionPool;
[+] 	mem::Pool<IncomingConnection> m_incomingConnectionPool;
[-] 	sl::List <IncomingConnection> m_pendingIncomingConnectionList;
[+] 	sl::List<IncomingConnection> m_pendingIncomingConnectionList;
[-] 	NamedPipe ();
[+] 	NamedPipe();
[-] 	~NamedPipe ()
[+] 	~NamedPipe()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	open (DataPtr namePtr);
[+] 	open(DataPtr namePtr);
[-] 	close ();
[+] 	close();
[-] 	setBackLogLimit (uint_t limit)
[+] 	setBackLogLimit(uint_t limit)
[-] 		AsyncIoDevice::setSetting (&m_backLogLimit, limit ? limit : Def_BackLogLimit);
[+] 		AsyncIoDevice::setSetting(&m_backLogLimit, limit ? limit : Def_BackLogLimit);
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t options);
[+] 	setOptions(uint_t options);
[-] 	accept ();
[+] 	accept();
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_NetworkAdapter.h
----------------------
[-] JNC_DECLARE_TYPE (NetworkAdapterAddress)
[+] JNC_DECLARE_TYPE(NetworkAdapterAddress)
[-] JNC_DECLARE_TYPE (NetworkAdapterDesc)
[+] JNC_DECLARE_TYPE(NetworkAdapterDesc)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (NetworkAdapterAddress)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(NetworkAdapterAddress)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (NetworkAdapterDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(NetworkAdapterDesc)
[-] 	uint8_t m_mac [6];
[+] 	uint8_t m_mac[6];
[-] createNetworkAdapterDescList (
[+] createNetworkAdapterDescList(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Serial.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Serial)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Serial)
[-] JNC_DECLARE_TYPE (SerialPortDesc)
[+] JNC_DECLARE_TYPE(SerialPortDesc)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Serial, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, Serial, m_ioThread)->ioThreadFunc();
[-] 		mem::Pool <OverlappedRead> m_overlappedReadPool;
[+] 		mem::Pool<OverlappedRead> m_overlappedReadPool;
[-] 		sl::List <OverlappedRead> m_activeOverlappedReadList;
[+] 		sl::List<OverlappedRead> m_activeOverlappedReadList;
[-] 		sl::Array <char> m_writeBlock;
[+] 		sl::Array<char> m_writeBlock;
[-] 		OverlappedIo ()
[+] 		OverlappedIo()
[-] 	Serial ();
[+] 	Serial();
[-] 	~Serial ()
[+] 	~Serial()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	open (DataPtr namePtr);
[+] 	open(DataPtr namePtr);
[-] 	close ();
[+] 	close();
[-] 	setReadInterval (uint_t interval);
[+] 	setReadInterval(uint_t interval);
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t options);
[+] 	setOptions(uint_t options);
[-] 	setBaudRate (uint_t baudRate);
[+] 	setBaudRate(uint_t baudRate);
[-] 	setFlowControl (axl::io::SerialFlowControl flowControl);
[+] 	setFlowControl(axl::io::SerialFlowControl flowControl);
[-] 	setDataBits (uint_t dataBits);
[+] 	setDataBits(uint_t dataBits);
[-] 	setStopBits (axl::io::SerialStopBits stopBits);
[+] 	setStopBits(axl::io::SerialStopBits stopBits);
[-] 	setParity (axl::io::SerialParity parity);
[+] 	setParity(axl::io::SerialParity parity);
[-] 	getStatusLines ()
[+] 	getStatusLines()
[-] 		return m_serial.getStatusLines ();
[+] 		return m_serial.getStatusLines();
[-] 	setDtr (bool dtr);
[+] 	setDtr(bool dtr);
[-] 	setRts (bool rts);
[+] 	setRts(bool rts);
[-] 	setupDevice (
[+] 	setupDevice(
[-] 	clearLineErrors ();
[+] 	clearLineErrors();
[-] 	read (
[+] 	read(
[-] 		return bufferedRead (ptr, size);
[+] 		return bufferedRead(ptr, size);
[-] 	write (
[+] 	write(
[-] 		return bufferedWrite (ptr, size);
[+] 		return bufferedWrite(ptr, size);
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	setReadWaitFirstChar ();
[+] 	setReadWaitFirstChar();
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (SerialPortDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(SerialPortDesc)
[-] createSerialPortDescList (DataPtr countPtr);
[+] createSerialPortDescList(DataPtr countPtr);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_Socket.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Socket)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Socket)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (Socket)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(Socket)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Socket, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, Socket, m_ioThread)->ioThreadFunc();
[-] 		OverlappedRecv ()
[+] 		OverlappedRecv()
[-] 		mem::Pool <OverlappedRecv> m_overlappedRecvPool;
[+] 		mem::Pool<OverlappedRecv> m_overlappedRecvPool;
[-] 		sl::List <OverlappedRecv> m_activeOverlappedRecvList;
[+] 		sl::List<OverlappedRecv> m_activeOverlappedRecvList;
[-] 		sl::Array <char> m_sendBlock;
[+] 		sl::Array<char> m_sendBlock;
[-] 		sl::Array <char> m_sendToParams;
[+] 		sl::Array<char> m_sendToParams;
[-] 	mem::Pool <IncomingConnection> m_incomingConnectionPool;
[+] 	mem::Pool<IncomingConnection> m_incomingConnectionPool;
[-] 	sl::List <IncomingConnection> m_pendingIncomingConnectionList;
[+] 	sl::List<IncomingConnection> m_pendingIncomingConnectionList;
[-] 	Socket ();
[+] 	Socket();
[-] 	~Socket ()
[+] 	~Socket()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	getAddress (Socket* self)
[+] 	getAddress(Socket* self)
[-] 		return self->SocketBase::getAddress ();
[+] 		return self->SocketBase::getAddress();
[-] 	getPeerAddress (Socket* self)
[+] 	getPeerAddress(Socket* self)
[-] 		return self->SocketBase::getPeerAddress ();
[+] 		return self->SocketBase::getPeerAddress();
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t options)
[+] 	setOptions(uint_t options)
[-] 		return SocketBase::setOptions (options);
[+] 		return SocketBase::setOptions(options);
[-] 	open_0 (
[+] 	open_0(
[-] 		return openImpl (family, protocol, NULL);
[+] 		return openImpl(family, protocol, NULL);
[-] 	open_1 (
[+] 	open_1(
[-] 		return openImpl (address ? address->m_family : AddressFamily_Ip4, protocol, address);
[+] 		return openImpl(address ? address->m_family : AddressFamily_Ip4, protocol, address);
[-] 	close ();
[+] 	close();
[-] 	connect (DataPtr addressPtr);
[+] 	connect(DataPtr addressPtr);
[-] 	listen (size_t backLogLimit);
[+] 	listen(size_t backLogLimit);
[-] 	accept (DataPtr addressPtr);
[+] 	accept(DataPtr addressPtr);
[-] 	read (
[+] 	read(
[-] 		return bufferedRead (ptr, size);
[+] 		return bufferedRead(ptr, size);
[-] 	write (
[+] 	write(
[-] 		return bufferedWrite (ptr, size);
[+] 		return bufferedWrite(ptr, size);
[-] 	readDatagram (
[+] 	readDatagram(
[-] 	writeDatagram (
[+] 	writeDatagram(
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	openImpl (
[+] 	openImpl(
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	acceptLoop ();
[+] 	acceptLoop();
[-] 	sendRecvLoop (
[+] 	sendRecvLoop(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc_io_SocketAddressResolver.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (SocketAddressResolver)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(SocketAddressResolver)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, SocketAddressResolver, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, SocketAddressResolver, m_ioThread)->ioThreadFunc();
[-] 	sl::List <Req> m_pendingReqList;
[+] 	sl::List<Req> m_pendingReqList;
[-] 	sl::List <Req> m_activeReqList;
[+] 	sl::List<Req> m_activeReqList;
[-] 	sl::HandleTable <Req*> m_reqMap;
[+] 	sl::HandleTable<Req*> m_reqMap;
[-] 	SocketAddressResolver ();
[+] 	SocketAddressResolver();
[-] 	~SocketAddressResolver ();
[+] 	~SocketAddressResolver();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	resolve (
[+] 	resolve(
[-] 	cancel (uintptr_t id);
[+] 	cancel(uintptr_t id);
[-] 	cancelAll ();
[+] 	cancelAll();
[-] 	callCompletionFunc (
[+] 	callCompletionFunc(
[-] 	callCompletionFunc (
[+] 	callCompletionFunc(
[-] 		callCompletionFunc (completionFuncPtr, NULL, 0, error);
[+] 		callCompletionFunc(completionFuncPtr, NULL, 0, error);
[-] 	processReq (Req* req);
[+] 	processReq(Req* req);
[-] 	stopIoThread ();
[+] 	stopIoThread();
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\pch.h
----------------------
[-] #	pragma comment (lib, "setupapi.lib")
[+] #	pragma comment(lib, "setupapi.lib")
[-] #	pragma comment (lib, "iphlpapi.lib")
[+] #	pragma comment(lib, "iphlpapi.lib")
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_AsyncIoDevice.cpp
----------------------
[-] AsyncIoDevice::AsyncIoDevice ()
[+] AsyncIoDevice::AsyncIoDevice()
[-] 	m_runtime = getCurrentThreadRuntime ();
[+] 	m_runtime = getCurrentThreadRuntime();
[-] 	ASSERT (m_runtime);
[+] 	ASSERT(m_runtime);
[-] AsyncIoDevice::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] AsyncIoDevice::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::Iterator <AsyncWait> it = m_asyncWaitList.getHead ();
[+] 	sl::Iterator<AsyncWait> it = m_asyncWaitList.getHead();
[-] 			gcHeap->markClass (it->m_handlerPtr.m_closure->m_box);
[+] 			gcHeap->markClass(it->m_handlerPtr.m_closure->m_box);
[-] 	it = m_pendingAsyncWaitList.getHead ();
[+] 	it = m_pendingAsyncWaitList.getHead();
[-] 			gcHeap->markClass (it->m_handlerPtr.m_closure->m_box);
[+] 			gcHeap->markClass(it->m_handlerPtr.m_closure->m_box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::open ()
[+] AsyncIoDevice::open()
[-] 	m_readBuffer.clear ();
[+] 	m_readBuffer.clear();
[-] 	m_readOverflowBuffer.clear ();
[+] 	m_readOverflowBuffer.clear();
[-] 	m_writeBuffer.clear ();
[+] 	m_writeBuffer.clear();
[-] 	m_ioThreadEvent.reset ();
[+] 	m_ioThreadEvent.reset();
[-] 	m_ioThreadSelfPipe.create ();
[+] 	m_ioThreadSelfPipe.create();
[-] AsyncIoDevice::close ()
[+] AsyncIoDevice::close()
[-] 	cancelAllWaits ();
[+] 	cancelAllWaits();
[-] 	m_freeReadWriteMetaList.insertListTail (&m_readMetaList);
[+] 	m_freeReadWriteMetaList.insertListTail(&m_readMetaList);
[-] 	m_freeReadWriteMetaList.insertListTail (&m_writeMetaList);
[+] 	m_freeReadWriteMetaList.insertListTail(&m_writeMetaList);
[-] 	m_ioThreadSelfPipe.close ();
[+] 	m_ioThreadSelfPipe.close();
[-] AsyncIoDevice::setReadBufferSize (
[+] AsyncIoDevice::setReadBufferSize(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_readBuffer.getBufferSize () == size)
[+] 	if (m_readBuffer.getBufferSize() == size)
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_readMetaList.clear ();
[+] 	m_readMetaList.clear();
[-] 	m_readBuffer.clear ();
[+] 	m_readBuffer.clear();
[-] 	m_readOverflowBuffer.clear ();
[+] 	m_readOverflowBuffer.clear();
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	bool result = m_readBuffer.setBufferSize (size);
[+] 	bool result = m_readBuffer.setBufferSize(size);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::setWriteBufferSize (
[+] AsyncIoDevice::setWriteBufferSize(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_writeBuffer.getBufferSize () == size)
[+] 	if (m_writeBuffer.getBufferSize() == size)
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_writeMetaList.clear ();
[+] 	m_writeMetaList.clear();
[-] 	m_writeBuffer.clear ();
[+] 	m_writeBuffer.clear();
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	bool result = m_writeBuffer.setBufferSize (size);
[+] 	bool result = m_writeBuffer.setBufferSize(size);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::blockingWait (
[+] AsyncIoDevice::blockingWait(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_syncWaitList.insertTail (&wait);
[+] 	m_syncWaitList.insertTail(&wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	event.wait (timeout);
[+] 	event.wait(timeout);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_syncWaitList.remove (&wait);
[+] 	m_syncWaitList.remove(&wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::wait (
[+] AsyncIoDevice::wait(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 		return (handle_t) (intptr_t) -1;
[+] 		return (handle_t)(intptr_t) -1;
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		callVoidFunctionPtr (handlerPtr, triggeredEvents);
[+] 		callVoidFunctionPtr(handlerPtr, triggeredEvents);
[-] 	AsyncWait* wait = AXL_MEM_NEW (AsyncWait);
[+] 	AsyncWait* wait = AXL_MEM_NEW(AsyncWait);
[-] 	m_asyncWaitList.insertTail (wait);
[+] 	m_asyncWaitList.insertTail(wait);
[-] 	handle_t handle = (handle_t) m_asyncWaitMap.add (wait);
[+] 	handle_t handle = (handle_t)m_asyncWaitMap.add(wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::cancelWait (handle_t handle)
[+] AsyncIoDevice::cancelWait(handle_t handle)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::HandleTableIterator <AsyncWait*> it = m_asyncWaitMap.find ((uintptr_t) handle);
[+] 	sl::HandleTableIterator<AsyncWait*> it = m_asyncWaitMap.find((uintptr_t)handle);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidParameter));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidParameter));
[-] 	m_asyncWaitList.erase (it->m_value);
[+] 	m_asyncWaitList.erase(it->m_value);
[-] 	m_asyncWaitMap.erase (it);
[+] 	m_asyncWaitMap.erase(it);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::wakeIoThread ()
[+] AsyncIoDevice::wakeIoThread()
[-] 	m_ioThreadEvent.signal ();
[+] 	m_ioThreadEvent.signal();
[-] 	m_ioThreadSelfPipe.write (" ", 1);
[+] 	m_ioThreadSelfPipe.write(" ", 1);
[-] AsyncIoDevice::sleepIoThread ()
[+] AsyncIoDevice::sleepIoThread()
[-] 	m_ioThreadEvent.wait ();
[+] 	m_ioThreadEvent.wait();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 	m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] AsyncIoDevice::cancelAllWaits ()
[+] AsyncIoDevice::cancelAllWaits()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::List <AsyncWait> asyncWaitList; // will be cleared upon exiting the scope
[+] 	sl::List<AsyncWait> asyncWaitList; // will be cleared upon exiting the scope
[-] 	sl::takeOver (&asyncWaitList, &m_asyncWaitList);
[+] 	sl::takeOver(&asyncWaitList, &m_asyncWaitList);
[-] 	m_asyncWaitMap.clear ();
[+] 	m_asyncWaitMap.clear();
[-] 	sl::Iterator <SyncWait> it = m_syncWaitList.getHead ();
[+] 	sl::Iterator<SyncWait> it = m_syncWaitList.getHead();
[-] 		it->m_event->signal ();
[+] 		it->m_event->signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::processWaitLists_l ()
[+] AsyncIoDevice::processWaitLists_l()
[-] 	sl::Iterator <AsyncWait> asyncIt = m_asyncWaitList.getHead ();
[+] 	sl::Iterator<AsyncWait> asyncIt = m_asyncWaitList.getHead();
[-] 			sl::Iterator <AsyncWait> nextIt = asyncIt.getNext ();
[+] 			sl::Iterator<AsyncWait> nextIt = asyncIt.getNext();
[-] 			m_asyncWaitList.remove (wait);
[+] 			m_asyncWaitList.remove(wait);
[-] 			m_pendingAsyncWaitList.insertTail (wait);
[+] 			m_pendingAsyncWaitList.insertTail(wait);
[-] 			m_asyncWaitMap.eraseKey ((uintptr_t) wait->m_handle);
[+] 			m_asyncWaitMap.eraseKey((uintptr_t)wait->m_handle);
[-] 	sl::Iterator <SyncWait> syncIt = m_syncWaitList.getHead ();
[+] 	sl::Iterator<SyncWait> syncIt = m_syncWaitList.getHead();
[-] 			syncIt->m_event->signal ();
[+] 			syncIt->m_event->signal();
[-] 	size_t count = m_pendingAsyncWaitList.getCount ();
[+] 	size_t count = m_pendingAsyncWaitList.getCount();
[-] 	while (!m_pendingAsyncWaitList.isEmpty ())
[+] 	while (!m_pendingAsyncWaitList.isEmpty())
[-] 		AsyncWait* wait = *m_pendingAsyncWaitList.getHead ();
[+] 		AsyncWait* wait = *m_pendingAsyncWaitList.getHead();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		callVoidFunctionPtr (m_runtime, wait->m_handlerPtr, wait->m_mask);
[+] 		callVoidFunctionPtr(m_runtime, wait->m_handlerPtr, wait->m_mask);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		m_pendingAsyncWaitList.erase (wait);
[+] 		m_pendingAsyncWaitList.erase(wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::setEvents_l (uint_t events)
[+] AsyncIoDevice::setEvents_l(uint_t events)
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	processWaitLists_l ();
[+] 	processWaitLists_l();
[-] AsyncIoDevice::setErrorEvent (
[+] AsyncIoDevice::setErrorEvent(
[-] 	JNC_BEGIN_CALL_SITE (m_runtime)
[+] 	JNC_BEGIN_CALL_SITE(m_runtime)
[-] 	DataPtr errorPtr = memDup (error, error->m_size);
[+] 	DataPtr errorPtr = memDup(error, error->m_size);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		processWaitLists_l ();
[+] 		processWaitLists_l();
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] AsyncIoDevice::getMetaListDataSize (const sl::ConstList <ReadWriteMeta>& metaList)
[+] AsyncIoDevice::getMetaListDataSize(const sl::ConstList<ReadWriteMeta>& metaList)
[-] 	sl::ConstIterator <ReadWriteMeta> it = metaList.getHead ();
[+] 	sl::ConstIterator<ReadWriteMeta> it = metaList.getHead();
[-] AsyncIoDevice::isReadBufferValid ()
[+] AsyncIoDevice::isReadBufferValid()
[-] 		m_readBuffer.isValid () &&
[+] 		m_readBuffer.isValid() &&
[-] 		(m_readBuffer.isFull () || m_readOverflowBuffer.isEmpty ()) &&
[+] 		(m_readBuffer.isFull() || m_readOverflowBuffer.isEmpty()) &&
[-] 		(m_readMetaList.isEmpty () ||
[+] 		(m_readMetaList.isEmpty() ||
[-] 		m_readBuffer.getDataSize () + m_readOverflowBuffer.getCount () == getMetaListDataSize (m_readMetaList));
[+] 		m_readBuffer.getDataSize() + m_readOverflowBuffer.getCount() == getMetaListDataSize(m_readMetaList));
[-] AsyncIoDevice::isWriteBufferValid ()
[+] AsyncIoDevice::isWriteBufferValid()
[-] 		m_writeBuffer.isValid () &&
[+] 		m_writeBuffer.isValid() &&
[-] 		(m_writeMetaList.isEmpty () ||
[+] 		(m_writeMetaList.isEmpty() ||
[-] 		m_writeBuffer.getDataSize () == getMetaListDataSize (m_writeMetaList));
[+] 		m_writeBuffer.getDataSize() == getMetaListDataSize(m_writeMetaList));
[-] AsyncIoDevice::bufferedRead (
[+] AsyncIoDevice::bufferedRead(
[-] 	sl::Array <char>* params
[+] 	sl::Array<char>* params
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	char* p = (char*) ptr.m_p;
[+] 	char* p = (char*)ptr.m_p;
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_readMetaList.isEmpty ())
[+] 	if (m_readMetaList.isEmpty())
[-] 			params->clear ();
[+] 			params->clear();
[-] 		ReadWriteMeta* meta = *m_readMetaList.getHead ();
[+] 		ReadWriteMeta* meta = *m_readMetaList.getHead();
[-] 			params->copy ((char*) (meta + 1), meta->m_paramSize);
[+] 			params->copy((char*)(meta + 1), meta->m_paramSize);
[-] 			m_readMetaList.remove (meta);
[+] 			m_readMetaList.remove(meta);
[-] 			m_freeReadWriteMetaList.insertHead (meta);
[+] 			m_freeReadWriteMetaList.insertHead(meta);
[-] 			m_readMetaList.remove (meta);
[+] 			m_readMetaList.remove(meta);
[-] 			m_freeReadWriteMetaList.insertHead (meta);
[+] 			m_freeReadWriteMetaList.insertHead(meta);
[-] 	result = m_readBuffer.read (p, size);
[+] 	result = m_readBuffer.read(p, size);
[-] 		if (!m_readOverflowBuffer.isEmpty ())
[+] 		if (!m_readOverflowBuffer.isEmpty())
[-] 			size_t overflowSize = m_readOverflowBuffer.getCount ();
[+] 			size_t overflowSize = m_readOverflowBuffer.getCount();
[-] 			if (!m_readBuffer.isEmpty ()) // refill the main buffer first
[+] 			if (!m_readBuffer.isEmpty()) // refill the main buffer first
[-] 				size_t movedSize = m_readBuffer.write (m_readOverflowBuffer, overflowSize);
[+] 				size_t movedSize = m_readBuffer.write(m_readOverflowBuffer, overflowSize);
[-] 				m_readOverflowBuffer.remove (0, movedSize);
[+] 				m_readOverflowBuffer.remove(0, movedSize);
[-] 				size_t extraSize = AXL_MIN (overflowSize, size);
[+] 				size_t extraSize = AXL_MIN(overflowSize, size);
[-] 				memcpy (p, m_readOverflowBuffer, extraSize);
[+] 				memcpy(p, m_readOverflowBuffer, extraSize);
[-] 				size_t movedSize = m_readBuffer.write (m_readOverflowBuffer + extraSize, overflowSize - extraSize);
[+] 				size_t movedSize = m_readBuffer.write(m_readOverflowBuffer + extraSize, overflowSize - extraSize);
[-] 				m_readOverflowBuffer.remove (0, extraSize + movedSize);
[+] 				m_readOverflowBuffer.remove(0, extraSize + movedSize);
[-] 		if (!m_readBuffer.isFull ())
[+] 		if (!m_readBuffer.isFull())
[-] 		if (m_readBuffer.isEmpty ())
[+] 		if (m_readBuffer.isEmpty())
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	ASSERT (isReadBufferValid ());
[+] 	ASSERT(isReadBufferValid());
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::bufferedWrite (
[+] AsyncIoDevice::bufferedWrite(
[-] 	ASSERT ((m_options & AsyncIoOption_KeepWriteBlockSize) || paramSize == 0);
[+] 	ASSERT((m_options & AsyncIoOption_KeepWriteBlockSize) || paramSize == 0);
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	size_t result = m_writeBuffer.write (dataPtr.m_p, dataSize);
[+] 	size_t result = m_writeBuffer.write(dataPtr.m_p, dataSize);
[-] 			ReadWriteMeta* meta = createReadWriteMeta (result, params, paramSize);
[+] 			ReadWriteMeta* meta = createReadWriteMeta(result, params, paramSize);
[-] 			m_writeMetaList.insertTail (meta);
[+] 			m_writeMetaList.insertTail(meta);
[-] 		if (m_writeBuffer.isFull ())
[+] 		if (m_writeBuffer.isFull())
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	ASSERT (isWriteBufferValid ());
[+] 	ASSERT(isWriteBufferValid());
[-] 	isWriteBufferValid ();
[+] 	isWriteBufferValid();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] AsyncIoDevice::addToReadBuffer (
[+] AsyncIoDevice::addToReadBuffer(
[-] 	ASSERT ((m_options & AsyncIoOption_KeepReadBlockSize) || paramSize == 0);
[+] 	ASSERT((m_options & AsyncIoOption_KeepReadBlockSize) || paramSize == 0);
[-] 	size_t addedSize = m_readBuffer.write (p, dataSize);
[+] 	size_t addedSize = m_readBuffer.write(p, dataSize);
[-] 		m_readOverflowBuffer.append ((char*) p + addedSize, overflowSize);
[+] 		m_readOverflowBuffer.append((char*)p + addedSize, overflowSize);
[-] 		ReadWriteMeta* meta = createReadWriteMeta (dataSize, params, paramSize);
[+] 		ReadWriteMeta* meta = createReadWriteMeta(dataSize, params, paramSize);
[-] 		m_readMetaList.insertTail (meta);
[+] 		m_readMetaList.insertTail(meta);
[-] 	ASSERT (isReadBufferValid ());
[+] 	ASSERT(isReadBufferValid());
[-] AsyncIoDevice::createReadWriteMeta (
[+] AsyncIoDevice::createReadWriteMeta(
[-] 	ReadWriteMeta* meta = !m_freeReadWriteMetaList.isEmpty () &&
[+] 	ReadWriteMeta* meta = !m_freeReadWriteMetaList.isEmpty() &&
[-] 		m_freeReadWriteMetaList.getHead ()->m_paramSize >= paramSize ?
[+] 		m_freeReadWriteMetaList.getHead()->m_paramSize >= paramSize ?
[-] 		m_freeReadWriteMetaList.removeHead () :
[+] 		m_freeReadWriteMetaList.removeHead() :
[-] 		AXL_MEM_NEW_EXTRA (ReadWriteMeta, paramSize);
[+] 		AXL_MEM_NEW_EXTRA(ReadWriteMeta, paramSize);
[-] 	memcpy (meta + 1, params, paramSize);
[+] 	memcpy(meta + 1, params, paramSize);
[-] AsyncIoDevice::getNextWriteBlock (
[+] AsyncIoDevice::getNextWriteBlock(
[-] 	sl::Array <char>* data,
[+] 	sl::Array<char>* data,
[-] 	sl::Array <char>* params
[+] 	sl::Array<char>* params
[-] 	if (!data->isEmpty ())
[+] 	if (!data->isEmpty())
[-] 	if (m_writeMetaList.isEmpty ())
[+] 	if (m_writeMetaList.isEmpty())
[-] 		m_writeBuffer.readAll (data);
[+] 		m_writeBuffer.readAll(data);
[-] 			params->clear ();
[+] 			params->clear();
[-] 		ReadWriteMeta* meta = m_writeMetaList.removeHead ();
[+] 		ReadWriteMeta* meta = m_writeMetaList.removeHead();
[-] 		ASSERT (meta->m_dataSize <= m_writeBuffer.getDataSize ());
[+] 		ASSERT(meta->m_dataSize <= m_writeBuffer.getDataSize());
[-] 		data->setCount (meta->m_dataSize);
[+] 		data->setCount(meta->m_dataSize);
[-] 		m_writeBuffer.read (*data, meta->m_dataSize);
[+] 		m_writeBuffer.read(*data, meta->m_dataSize);
[-] 			params->copy ((char*) (meta + 1), meta->m_paramSize);
[+] 			params->copy((char*)(meta + 1), meta->m_paramSize);
[-] 		m_freeReadWriteMetaList.insertHead (meta);
[+] 		m_freeReadWriteMetaList.insertHead(meta);
[-] 	ASSERT (isWriteBufferValid ());
[+] 	ASSERT(isWriteBufferValid());
[-] AsyncIoDevice::updateReadWriteBufferEvents ()
[+] AsyncIoDevice::updateReadWriteBufferEvents()
[-] 	if (!m_readBuffer.isEmpty ())
[+] 	if (!m_readBuffer.isEmpty())
[-] 	if (m_readBuffer.isFull ())
[+] 	if (m_readBuffer.isFull())
[-] 	if (!m_writeBuffer.isFull ())
[+] 	if (!m_writeBuffer.isFull())
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_SocketAddress.cpp
----------------------
[-] SocketAddress::parse (
[+] SocketAddress::parse(
[-] 	bool result = sockAddr.parse ((const char*) stringPtr.m_p);
[+] 	bool result = sockAddr.parse((const char*) stringPtr.m_p);
[-] 	((SocketAddress*) selfPtr.m_p)->setSockAddr (sockAddr);
[+] 	((SocketAddress*)selfPtr.m_p)->setSockAddr(sockAddr);
[-] SocketAddress::getSockAddr () const
[+] SocketAddress::getSockAddr() const
[-] 	ASSERT (sizeof (SocketAddress) == sizeof (sockAddr));
[+] 	ASSERT(sizeof(SocketAddress) == sizeof(sockAddr));
[-] 	memcpy (&sockAddr, this, sizeof (sockAddr));
[+] 	memcpy(&sockAddr, this, sizeof(sockAddr));
[-] SocketAddress::setSockAddr (const axl::io::SockAddr& sockAddr)
[+] SocketAddress::setSockAddr(const axl::io::SockAddr& sockAddr)
[-] 	ASSERT (sizeof (SocketAddress) == sizeof (sockAddr));
[+] 	ASSERT(sizeof(SocketAddress) == sizeof(sockAddr));
[-] 	memcpy (this, &sockAddr, sizeof (SocketAddress));
[+] 	memcpy(this, &sockAddr, sizeof(SocketAddress));
[-] SocketAddress::fromSockAddr (const axl::io::SockAddr& sockAddr)
[+] SocketAddress::fromSockAddr(const axl::io::SockAddr& sockAddr)
[-] 	socketAddress.setSockAddr (sockAddr);
[+] 	socketAddress.setSockAddr(sockAddr);
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Address_ip4)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Address_ip4)
[-] 	JNC_MAP_FUNCTION ("parse",     &Address_ip4::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &Address_ip4::parse)
[-] 	JNC_MAP_FUNCTION ("getString", &Address_ip4::getString)
[+] 	JNC_MAP_FUNCTION("getString", &Address_ip4::getString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Address_ip6)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Address_ip6)
[-] 	JNC_MAP_FUNCTION ("parse",     &Address_ip6::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &Address_ip6::parse)
[-] 	JNC_MAP_FUNCTION ("getString", &Address_ip6::getString)
[+] 	JNC_MAP_FUNCTION("getString", &Address_ip6::getString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SocketAddress_ip4)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SocketAddress_ip4)
[-] 	JNC_MAP_FUNCTION ("isEqual",   &SocketAddress_ip4::isEqual)
[+] 	JNC_MAP_FUNCTION("isEqual",   &SocketAddress_ip4::isEqual)
[-] 	JNC_MAP_FUNCTION ("isMatch",   &SocketAddress_ip4::isMatch)
[+] 	JNC_MAP_FUNCTION("isMatch",   &SocketAddress_ip4::isMatch)
[-] 	JNC_MAP_FUNCTION ("parse",     &SocketAddress_ip4::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &SocketAddress_ip4::parse)
[-] 	JNC_MAP_FUNCTION ("getString", &SocketAddress_ip4::getString)
[+] 	JNC_MAP_FUNCTION("getString", &SocketAddress_ip4::getString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SocketAddress_ip6)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SocketAddress_ip6)
[-] 	JNC_MAP_FUNCTION ("isEqual",   &SocketAddress_ip6::isEqual)
[+] 	JNC_MAP_FUNCTION("isEqual",   &SocketAddress_ip6::isEqual)
[-] 	JNC_MAP_FUNCTION ("isMatch",   &SocketAddress_ip6::isMatch)
[+] 	JNC_MAP_FUNCTION("isMatch",   &SocketAddress_ip6::isMatch)
[-] 	JNC_MAP_FUNCTION ("parse",     &SocketAddress_ip6::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &SocketAddress_ip6::parse)
[-] 	JNC_MAP_FUNCTION ("getString", &SocketAddress_ip6::getString)
[+] 	JNC_MAP_FUNCTION("getString", &SocketAddress_ip6::getString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SocketAddress)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SocketAddress)
[-] 	JNC_MAP_FUNCTION ("isEqual",   &SocketAddress::isEqual)
[+] 	JNC_MAP_FUNCTION("isEqual",   &SocketAddress::isEqual)
[-] 	JNC_MAP_FUNCTION ("isMatch",   &SocketAddress::isMatch)
[+] 	JNC_MAP_FUNCTION("isMatch",   &SocketAddress::isMatch)
[-] 	JNC_MAP_FUNCTION ("parse",     &SocketAddress::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &SocketAddress::parse)
[-] 	JNC_MAP_FUNCTION ("getString", &SocketAddress::getString)
[+] 	JNC_MAP_FUNCTION("getString", &SocketAddress::getString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_SocketBase.cpp
----------------------
[-] SocketBase::getAddress ()
[+] SocketBase::getAddress()
[-] 	m_socket.getAddress (&sockAddr);
[+] 	m_socket.getAddress(&sockAddr);
[-] 	return SocketAddress::fromSockAddr (sockAddr);
[+] 	return SocketAddress::fromSockAddr(sockAddr);
[-] SocketBase::getPeerAddress ()
[+] SocketBase::getPeerAddress()
[-] 	m_socket.getPeerAddress (&sockAddr);
[+] 	m_socket.getPeerAddress(&sockAddr);
[-] 	return SocketAddress::fromSockAddr (sockAddr);
[+] 	return SocketAddress::fromSockAddr(sockAddr);
[-] SocketBase::setOptions (uint_t options)
[+] SocketBase::setOptions(uint_t options)
[-] 		result = m_socket.setOption (IPPROTO_TCP, TCP_NODELAY, &value, sizeof (value));
[+] 		result = m_socket.setOption(IPPROTO_TCP, TCP_NODELAY, &value, sizeof(value));
[-] 		result = m_socket.setOption (SOL_SOCKET, SO_LINGER, &value, sizeof (value));
[+] 		result = m_socket.setOption(SOL_SOCKET, SO_LINGER, &value, sizeof(value));
[-] 		result = m_socket.setOption (SOL_SOCKET, SO_BROADCAST, &value, sizeof (value));
[+] 		result = m_socket.setOption(SOL_SOCKET, SO_BROADCAST, &value, sizeof(value));
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SocketBase::open (
[+] SocketBase::open(
[-] 	close ();
[+] 	close();
[-] 	result = m_socket.m_socket.wsaOpen (family_s, socketKind, protocol, WSA_FLAG_OVERLAPPED);
[+] 	result = m_socket.m_socket.wsaOpen(family_s, socketKind, protocol, WSA_FLAG_OVERLAPPED);
[-] 	result = m_socket.m_socket.open (family_s, socketKind, protocol);
[+] 	result = m_socket.m_socket.open(family_s, socketKind, protocol);
[-] 	result = m_socket.setBlockingMode (false);
[+] 	result = m_socket.setBlockingMode(false);
[-] 	switch (protocol)
[+] 	switch(protocol)
[-] 			m_socket.setOption (IPPROTO_TCP, TCP_NODELAY, &tcpNoDelayValue, sizeof (tcpNoDelayValue)) &&
[+] 			m_socket.setOption(IPPROTO_TCP, TCP_NODELAY, &tcpNoDelayValue, sizeof(tcpNoDelayValue)) &&
[-] 			m_socket.setOption (SOL_SOCKET, SO_KEEPALIVE, &tcpKeepAlive, sizeof (tcpKeepAlive)) &&
[+] 			m_socket.setOption(SOL_SOCKET, SO_KEEPALIVE, &tcpKeepAlive, sizeof(tcpKeepAlive)) &&
[-] 			m_socket.setOption (SOL_SOCKET, SO_LINGER, &lingerValue, sizeof (lingerValue));
[+] 			m_socket.setOption(SOL_SOCKET, SO_LINGER, &lingerValue, sizeof(lingerValue));
[-] 		result = m_socket.setOption (SOL_SOCKET, SO_BROADCAST, &udpBroadcastValue, sizeof (udpBroadcastValue));
[+] 		result = m_socket.setOption(SOL_SOCKET, SO_BROADCAST, &udpBroadcastValue, sizeof(udpBroadcastValue));
[-] 			m_socket.setOption (IPPROTO_IPV6, IPV6_HDRINCL, &rawHdrInclValue, sizeof (rawHdrInclValue)) :
[+] 			m_socket.setOption(IPPROTO_IPV6, IPV6_HDRINCL, &rawHdrInclValue, sizeof(rawHdrInclValue)) :
[-] 			m_socket.setOption (IPPROTO_IP, IP_HDRINCL, &rawHdrInclValue, sizeof (rawHdrInclValue));
[+] 			m_socket.setOption(IPPROTO_IP, IP_HDRINCL, &rawHdrInclValue, sizeof(rawHdrInclValue));
[-] 			m_socket.setOption (SOL_SOCKET, SO_REUSEADDR, &reuseAddrValue, sizeof (reuseAddrValue)) &&
[+] 			m_socket.setOption(SOL_SOCKET, SO_REUSEADDR, &reuseAddrValue, sizeof(reuseAddrValue)) &&
[-] 			m_socket.bind (address->getSockAddr ());
[+] 			m_socket.bind(address->getSockAddr());
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] SocketBase::close ()
[+] SocketBase::close()
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] SocketBase::tcpConnect (uint_t connectCompletedEvent)
[+] SocketBase::tcpConnect(uint_t connectCompletedEvent)
[-] 	bool result = m_socket.m_socket.wsaEventSelect (socketEvent.m_event, FD_CONNECT);
[+] 	bool result = m_socket.m_socket.wsaEventSelect(socketEvent.m_event, FD_CONNECT);
[-] 		setIoErrorEvent (err::getLastError ());
[+] 		setIoErrorEvent(err::getLastError());
[-] 	HANDLE waitTable [] =
[+] 	HANDLE waitTable[] =
[-] 		DWORD waitResult = ::WaitForMultipleObjects (countof (waitTable), waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(countof(waitTable), waitTable, false, INFINITE);
[-] 		switch (waitResult)
[+] 		switch(waitResult)
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			result = m_socket.m_socket.wsaEnumEvents (&networkEvents);
[+] 			result = m_socket.m_socket.wsaEnumEvents(&networkEvents);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 				int error = networkEvents.iErrorCode [FD_CONNECT_BIT];
[+] 				int error = networkEvents.iErrorCode[FD_CONNECT_BIT];
[-] 					setIoErrorEvent (error);
[+] 					setIoErrorEvent(error);
[-] 					setEvents (connectCompletedEvent);
[+] 					setEvents(connectCompletedEvent);
[-] SocketBase::tcpConnect (uint_t connectCompletedEvent)
[+] SocketBase::tcpConnect(uint_t connectCompletedEvent)
[-] 	int selectFd = AXL_MAX (m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 		FD_SET (m_socket.m_socket, &writeSet);
[+] 		FD_SET(m_socket.m_socket, &writeSet);
[-] 		result = ::select (selectFd, &readSet, &writeSet, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, &writeSet, NULL, NULL);
[-] 			setIoErrorEvent (err::Error (errno));
[+] 			setIoErrorEvent(err::Error(errno));
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		if (FD_ISSET (m_socket.m_socket, &writeSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &writeSet))
[-] 			int error = m_socket.getError ();
[+] 			int error = m_socket.getError();
[-] 				setIoErrorEvent (err::Errno (error));
[+] 				setIoErrorEvent(err::Errno(error));
[-] 				setEvents (connectCompletedEvent);
[+] 				setEvents(connectCompletedEvent);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_AsyncIoDevice.h
----------------------
[-] 	sl::AuxList <SyncWait> m_syncWaitList;
[+] 	sl::AuxList<SyncWait> m_syncWaitList;
[-] 	sl::List <AsyncWait> m_asyncWaitList;
[+] 	sl::List<AsyncWait> m_asyncWaitList;
[-] 	sl::List <AsyncWait> m_pendingAsyncWaitList;
[+] 	sl::List<AsyncWait> m_pendingAsyncWaitList;
[-] 	sl::HandleTable <AsyncWait*> m_asyncWaitMap;
[+] 	sl::HandleTable<AsyncWait*> m_asyncWaitMap;
[-] 	sl::Array <char> m_readOverflowBuffer;
[+] 	sl::Array<char> m_readOverflowBuffer;
[-] 	sl::List <ReadWriteMeta> m_readMetaList;
[+] 	sl::List<ReadWriteMeta> m_readMetaList;
[-] 	sl::List <ReadWriteMeta> m_writeMetaList;
[+] 	sl::List<ReadWriteMeta> m_writeMetaList;
[-] 	sl::List <ReadWriteMeta> m_freeReadWriteMetaList;
[+] 	sl::List<ReadWriteMeta> m_freeReadWriteMetaList;
[-] 	AsyncIoDevice ();
[+] 	AsyncIoDevice();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	wait (
[+] 	wait(
[-] 	cancelWait (handle_t handle);
[+] 	cancelWait(handle_t handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 	open ();
[+] 	open();
[-] 	close ();
[+] 	close();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	sleepIoThread ();
[+] 	sleepIoThread();
[-] 	setSetting (
[+] 	setSetting(
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	setReadBufferSize (
[+] 	setReadBufferSize(
[-] 	setWriteBufferSize (
[+] 	setWriteBufferSize(
[-] 	cancelAllWaits ();
[+] 	cancelAllWaits();
[-] 	processWaitLists_l ();
[+] 	processWaitLists_l();
[-] 	setEvents_l (uint_t events);
[+] 	setEvents_l(uint_t events);
[-] 	setEvents (uint_t events)
[+] 	setEvents(uint_t events)
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		setEvents_l (events);
[+] 		setEvents_l(events);
[-] 	setErrorEvent_l (
[+] 	setErrorEvent_l(
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		setErrorEvent (event, error);
[+] 		setErrorEvent(event, error);
[-] 	setIoErrorEvent_l (const err::Error& error)
[+] 	setIoErrorEvent_l(const err::Error& error)
[-] 		setErrorEvent_l (AsyncIoEvent_IoError, error);
[+] 		setErrorEvent_l(AsyncIoEvent_IoError, error);
[-] 	setIoErrorEvent_l ()
[+] 	setIoErrorEvent_l()
[-] 		setErrorEvent_l (AsyncIoEvent_IoError, err::getLastError ());
[+] 		setErrorEvent_l(AsyncIoEvent_IoError, err::getLastError());
[-] 	setErrorEvent (
[+] 	setErrorEvent(
[-] 	setIoErrorEvent (const err::Error& error)
[+] 	setIoErrorEvent(const err::Error& error)
[-] 		setErrorEvent (AsyncIoEvent_IoError, error);
[+] 		setErrorEvent(AsyncIoEvent_IoError, error);
[-] 	setIoErrorEvent ()
[+] 	setIoErrorEvent()
[-] 		setErrorEvent (AsyncIoEvent_IoError, err::getLastError ());
[+] 		setErrorEvent(AsyncIoEvent_IoError, err::getLastError());
[-] 	getMetaListDataSize (const sl::ConstList <ReadWriteMeta>& metaList);
[+] 	getMetaListDataSize(const sl::ConstList<ReadWriteMeta>& metaList);
[-] 	isReadBufferValid ();
[+] 	isReadBufferValid();
[-] 	isWriteBufferValid ();
[+] 	isWriteBufferValid();
[-] 	bufferedRead (
[+] 	bufferedRead(
[-] 		sl::Array <char>* params = NULL
[+] 		sl::Array<char>* params = NULL
[-] 	bufferedWrite (
[+] 	bufferedWrite(
[-] 	addToReadBuffer (
[+] 	addToReadBuffer(
[-] 	getNextWriteBlock (
[+] 	getNextWriteBlock(
[-] 		sl::Array <char>* data,
[+] 		sl::Array<char>* data,
[-] 		sl::Array <char>* params = NULL
[+] 		sl::Array<char>* params = NULL
[-] 	updateReadWriteBufferEvents ();
[+] 	updateReadWriteBufferEvents();
[-] 	createReadWriteMeta (
[+] 	createReadWriteMeta(
[-] 	sl::Array <char> m_buffer;
[+] 	sl::Array<char> m_buffer;
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_SocketAddress.h
----------------------
[-] JNC_DECLARE_TYPE (Address_ip4)
[+] JNC_DECLARE_TYPE(Address_ip4)
[-] JNC_DECLARE_TYPE (Address_ip6)
[+] JNC_DECLARE_TYPE(Address_ip6)
[-] JNC_DECLARE_TYPE (SocketAddress_ip4)
[+] JNC_DECLARE_TYPE(SocketAddress_ip4)
[-] JNC_DECLARE_TYPE (SocketAddress_ip6)
[+] JNC_DECLARE_TYPE(SocketAddress_ip6)
[-] JNC_DECLARE_TYPE (SocketAddress)
[+] JNC_DECLARE_TYPE(SocketAddress)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (Address_ip4)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(Address_ip4)
[-] 	parse (
[+] 	parse(
[-] 		return axl::io::parseAddr_ip4 (
[+] 		return axl::io::parseAddr_ip4(
[-] 			(in_addr*) selfPtr.m_p,
[+] 			(in_addr*)selfPtr.m_p,
[-] 	getString (DataPtr selfPtr)
[+] 	getString(DataPtr selfPtr)
[-] 		sl::String string = axl::io::getAddrString_ip4 ((const in_addr*) selfPtr.m_p);
[+] 		sl::String string = axl::io::getAddrString_ip4((const in_addr*) selfPtr.m_p);
[-] 		return strDup (string, string.getLength ());
[+] 		return strDup(string, string.getLength());
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (Address_ip6)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(Address_ip6)
[-] 	parse (
[+] 	parse(
[-] 		return axl::io::parseAddr_ip6 (
[+] 		return axl::io::parseAddr_ip6(
[-] 			(in6_addr*) selfPtr.m_p,
[+] 			(in6_addr*)selfPtr.m_p,
[-] 	getString (DataPtr selfPtr)
[+] 	getString(DataPtr selfPtr)
[-] 		sl::String string = axl::io::getAddrString_ip6 ((const in6_addr*) selfPtr.m_p);
[+] 		sl::String string = axl::io::getAddrString_ip6((const in6_addr*) selfPtr.m_p);
[-] 		return strDup (string, string.getLength ());
[+] 		return strDup(string, string.getLength());
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (SocketAddress_ip4)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(SocketAddress_ip4)
[-] 	isEqual (
[+] 	isEqual(
[-] 		return axl::io::isSockAddrEqual_ip4 (
[+] 		return axl::io::isSockAddrEqual_ip4(
[-] 	isMatch (
[+] 	isMatch(
[-] 		return axl::io::isSockAddrMatch_ip4 (
[+] 		return axl::io::isSockAddrMatch_ip4(
[-] 	parse (
[+] 	parse(
[-] 		return axl::io::parseSockAddr_ip4 (
[+] 		return axl::io::parseSockAddr_ip4(
[-] 			(sockaddr_in*) selfPtr.m_p,
[+] 			(sockaddr_in*)selfPtr.m_p,
[-] 	getString (DataPtr selfPtr)
[+] 	getString(DataPtr selfPtr)
[-] 		sl::String string = axl::io::getSockAddrString_ip4 ((const sockaddr_in*) selfPtr.m_p);
[+] 		sl::String string = axl::io::getSockAddrString_ip4((const sockaddr_in*) selfPtr.m_p);
[-] 		return strDup (string, string.getLength ());
[+] 		return strDup(string, string.getLength());
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (SocketAddress_ip6)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(SocketAddress_ip6)
[-] 	isEqual (
[+] 	isEqual(
[-] 		return axl::io::isSockAddrEqual_ip6 (
[+] 		return axl::io::isSockAddrEqual_ip6(
[-] 	isMatch (
[+] 	isMatch(
[-] 		return axl::io::isSockAddrMatch_ip6 (
[+] 		return axl::io::isSockAddrMatch_ip6(
[-] 	parse (
[+] 	parse(
[-] 		return axl::io::parseSockAddr_ip6 (
[+] 		return axl::io::parseSockAddr_ip6(
[-] 			(sockaddr_in6*) selfPtr.m_p,
[+] 			(sockaddr_in6*)selfPtr.m_p,
[-] 	getString (DataPtr selfPtr)
[+] 	getString(DataPtr selfPtr)
[-] 		sl::String string = axl::io::getSockAddrString_ip6 ((const sockaddr_in6*) selfPtr.m_p);
[+] 		sl::String string = axl::io::getSockAddrString_ip6((const sockaddr_in6*) selfPtr.m_p);
[-] 		return strDup (string, string.getLength ());
[+] 		return strDup(string, string.getLength());
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (SocketAddress)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(SocketAddress)
[-] 	isEqual (
[+] 	isEqual(
[-] 		return ((SocketAddress*) selfPtr.m_p)->getSockAddr ().isEqual ((const sockaddr*) addressPtr.m_p);
[+] 		return ((SocketAddress*)selfPtr.m_p)->getSockAddr().isEqual((const sockaddr*) addressPtr.m_p);
[-] 	isMatch (
[+] 	isMatch(
[-] 		return ((SocketAddress*) selfPtr.m_p)->getSockAddr ().isMatch ((const sockaddr*) addressPtr.m_p);
[+] 		return ((SocketAddress*)selfPtr.m_p)->getSockAddr().isMatch((const sockaddr*) addressPtr.m_p);
[-] 	parse (
[+] 	parse(
[-] 	getString (DataPtr selfPtr)
[+] 	getString(DataPtr selfPtr)
[-] 		sl::String string = ((SocketAddress*) selfPtr.m_p)->getSockAddr ().getString ();
[+] 		sl::String string = ((SocketAddress*)selfPtr.m_p)->getSockAddr().getString();
[-] 		return strDup (string, string.getLength ());
[+] 		return strDup(string, string.getLength());
[-] 	getSockAddr () const;
[+] 	getSockAddr() const;
[-] 	setSockAddr (const axl::io::SockAddr& sockAddr);
[+] 	setSockAddr(const axl::io::SockAddr& sockAddr);
[-] 	fromSockAddr (const axl::io::SockAddr& sockAddr);
[+] 	fromSockAddr(const axl::io::SockAddr& sockAddr);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_cmn\jnc_io_SocketBase.h
----------------------
[-] 	getAddress ();
[+] 	getAddress();
[-] 	getPeerAddress ();
[+] 	getPeerAddress();
[-] 	setOptions (uint_t options);
[+] 	setOptions(uint_t options);
[-] 	open (
[+] 	open(
[-] 	close ();
[+] 	close();
[-] 	tcpConnect (uint_t connectCompletedEvent);
[+] 	tcpConnect(uint_t connectCompletedEvent);
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_devmon\jnc_io_DeviceMonitor.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (DeviceMonitor)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(DeviceMonitor)
[-] 	JNC_MAP_CONSTRUCTOR (&sl::construct <DeviceMonitor>)
[+] 	JNC_MAP_CONSTRUCTOR(&sl::construct<DeviceMonitor>)
[-] 	JNC_MAP_DESTRUCTOR (&sl::destruct <DeviceMonitor>)
[+] 	JNC_MAP_DESTRUCTOR(&sl::destruct<DeviceMonitor>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &DeviceMonitor::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &DeviceMonitor::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &DeviceMonitor::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &DeviceMonitor::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &DeviceMonitor::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &DeviceMonitor::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_pendingNotifySizeLimit", &DeviceMonitor::setPendingNotifySizeLimit)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_pendingNotifySizeLimit", &DeviceMonitor::setPendingNotifySizeLimit)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_isEnabled",       &DeviceMonitor::setEnabled)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_isEnabled",       &DeviceMonitor::setEnabled)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_fileNameFilter",  &DeviceMonitor::setFileNameFilter)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_fileNameFilter",  &DeviceMonitor::setFileNameFilter)
[-] 	JNC_MAP_FUNCTION ("open",              &DeviceMonitor::open)
[+] 	JNC_MAP_FUNCTION("open",              &DeviceMonitor::open)
[-] 	JNC_MAP_FUNCTION ("close",             &DeviceMonitor::close)
[+] 	JNC_MAP_FUNCTION("close",             &DeviceMonitor::close)
[-] 	JNC_MAP_FUNCTION ("connect",           &DeviceMonitor::connect)
[+] 	JNC_MAP_FUNCTION("connect",           &DeviceMonitor::connect)
[-] 	JNC_MAP_FUNCTION ("setIoctlDescTable", &DeviceMonitor::setIoctlDescTable)
[+] 	JNC_MAP_FUNCTION("setIoctlDescTable", &DeviceMonitor::setIoctlDescTable)
[-] 	JNC_MAP_FUNCTION ("read",              &DeviceMonitor::read)
[+] 	JNC_MAP_FUNCTION("read",              &DeviceMonitor::read)
[-] 	JNC_MAP_FUNCTION ("wait",              &DeviceMonitor::wait)
[+] 	JNC_MAP_FUNCTION("wait",              &DeviceMonitor::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",        &DeviceMonitor::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",        &DeviceMonitor::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait",      &DeviceMonitor::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait",      &DeviceMonitor::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] DeviceMonitor::DeviceMonitor ()
[+] DeviceMonitor::DeviceMonitor()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] DeviceMonitor::setPendingNotifySizeLimit (size_t limit)
[+] DeviceMonitor::setPendingNotifySizeLimit(size_t limit)
[-] 	bool result = m_monitor.setPendingNotifySizeLimit (limit);
[+] 	bool result = m_monitor.setPendingNotifySizeLimit(limit);
[-] DeviceMonitor::setFileNameFilter (DataPtr filterPtr)
[+] DeviceMonitor::setFileNameFilter(DataPtr filterPtr)
[-] 		setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	bool result = m_monitor.setFileNameFilter (filter);
[+] 	bool result = m_monitor.setFileNameFilter(filter);
[-] 	m_fileNameFilterPtr = strDup (filter);
[+] 	m_fileNameFilterPtr = strDup(filter);
[-] DeviceMonitor::setEnabled (bool isEnabled)
[+] DeviceMonitor::setEnabled(bool isEnabled)
[-] 		setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	bool result = isEnabled ? m_monitor.enable () : m_monitor.disable ();
[+] 	bool result = isEnabled ? m_monitor.enable() : m_monitor.disable();
[-] DeviceMonitor::open ()
[+] DeviceMonitor::open()
[-] 	close ();
[+] 	close();
[-] 	bool result = m_monitor.open ();
[+] 	bool result = m_monitor.open();
[-] 	ASSERT (!m_overlappedIo);
[+] 	ASSERT(!m_overlappedIo);
[-] 	m_overlappedIo = AXL_MEM_NEW (OverlappedIo);
[+] 	m_overlappedIo = AXL_MEM_NEW(OverlappedIo);
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] DeviceMonitor::close ()
[+] DeviceMonitor::close()
[-] 	if (!m_monitor.isOpen ())
[+] 	if (!m_monitor.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_monitor.close ();
[+] 	m_monitor.close();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] 		AXL_MEM_DELETE (m_overlappedIo);
[+] 		AXL_MEM_DELETE(m_overlappedIo);
[-] DeviceMonitor::connect (DataPtr deviceNamePtr)
[+] DeviceMonitor::connect(DataPtr deviceNamePtr)
[-] 		m_monitor.connect ((const char*) deviceNamePtr.m_p) &&
[+] 		m_monitor.connect((const char*) deviceNamePtr.m_p) &&
[-] 		m_monitor.setPendingNotifySizeLimit (m_pendingNotifySizeLimit);
[+] 		m_monitor.setPendingNotifySizeLimit(m_pendingNotifySizeLimit);
[-] 	m_monitor.getTargetDeviceInfo (&deviceInfo);
[+] 	m_monitor.getTargetDeviceInfo(&deviceInfo);
[-] 	m_deviceNamePtr = strDup (deviceInfo.m_deviceName);
[+] 	m_deviceNamePtr = strDup(deviceInfo.m_deviceName);
[-] 	m_monitor.getTargetHookInfo (&hookInfo);
[+] 	m_monitor.getTargetHookInfo(&hookInfo);
[-] 	m_deviceNamePtr = strDup (hookInfo.m_fileName);
[+] 	m_deviceNamePtr = strDup(hookInfo.m_fileName);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] DeviceMonitor::setIoctlDescTable (
[+] DeviceMonitor::setIoctlDescTable(
[-] 	bool result = m_monitor.setIoctlDescTable (ioctlDesc, count);
[+] 	bool result = m_monitor.setIoctlDescTable(ioctlDesc, count);
[-] DeviceMonitor::connectLoop ()
[+] DeviceMonitor::connectLoop()
[-] 		sleepIoThread ();
[+] 		sleepIoThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] DeviceMonitor::ioThreadFunc ()
[+] DeviceMonitor::ioThreadFunc()
[-] 	ASSERT (m_monitor.isOpen () && m_overlappedIo);
[+] 	ASSERT(m_monitor.isOpen() && m_overlappedIo);
[-] 	bool result = connectLoop ();
[+] 	bool result = connectLoop();
[-] 	HANDLE waitTable [2] =
[+] 	HANDLE waitTable[2] =
[-] 	m_ioThreadEvent.signal (); // do initial update of active events
[+] 	m_ioThreadEvent.signal(); // do initial update of active events
[-] 		DWORD waitResult = ::WaitForMultipleObjects (waitCount, waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(waitCount, waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		while (!m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			result = read->m_overlapped.m_completionEvent.wait (0);
[+] 			result = read->m_overlapped.m_completionEvent.wait(0);
[-] 			result = m_monitor.getOverlappedResult (&read->m_overlapped, &actualSize);
[+] 			result = m_monitor.getOverlappedResult(&read->m_overlapped, &actualSize);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 			read->m_overlapped.m_completionEvent.reset ();
[+] 			read->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_activeOverlappedReadList.remove (read);
[+] 			m_overlappedIo->m_activeOverlappedReadList.remove(read);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 			addToReadBuffer (read->m_buffer, actualSize);
[+] 			addToReadBuffer(read->m_buffer, actualSize);
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			read->m_overlapped.m_completionEvent.reset ();
[+] 			read->m_overlapped.m_completionEvent.reset();
[-] 			m_overlappedIo->m_overlappedReadPool.put (read);
[+] 			m_overlappedIo->m_overlappedReadPool.put(read);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		bool isReadBufferFull = m_readBuffer.isFull ();
[+] 		bool isReadBufferFull = m_readBuffer.isFull();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount ();
[+] 		size_t activeReadCount = m_overlappedIo->m_activeOverlappedReadList.getCount();
[-] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get ();
[+] 				OverlappedRead* read = m_overlappedIo->m_overlappedReadPool.get();
[-] 					read->m_buffer.setCount (readBlockSize) &&
[+] 					read->m_buffer.setCount(readBlockSize) &&
[-] 					m_monitor.overlappedRead (read->m_buffer, readBlockSize, &read->m_overlapped);
[+] 					m_monitor.overlappedRead(read->m_buffer, readBlockSize, &read->m_overlapped);
[-] 					setIoErrorEvent ();
[+] 					setIoErrorEvent();
[-] 				m_overlappedIo->m_activeOverlappedReadList.insertTail (read);
[+] 				m_overlappedIo->m_activeOverlappedReadList.insertTail(read);
[-] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty ())
[+] 		if (m_overlappedIo->m_activeOverlappedReadList.isEmpty())
[-] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead ();
[+] 			OverlappedRead* read = *m_overlappedIo->m_activeOverlappedReadList.getHead();
[-] 			waitTable [1] = read->m_overlapped.m_completionEvent.m_event;
[+] 			waitTable[1] = read->m_overlapped.m_completionEvent.m_event;
[-] DeviceMonitor::ioThreadFunc ()
[+] DeviceMonitor::ioThreadFunc()
[-] 	ASSERT (m_monitor.isOpen ());
[+] 	ASSERT(m_monitor.isOpen());
[-] 	int result = connectLoop ();
[+] 	int result = connectLoop();
[-] 	int selectFd = AXL_MAX (m_monitor.m_device, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_monitor.m_device, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	readBlock.setCount (Def_ReadBlockSize);
[+] 	readBlock.setCount(Def_ReadBlockSize);
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_monitor.m_device, &readSet);
[+] 			FD_SET(m_monitor.m_device, &readSet);
[-] 		result = ::select (selectFd, &readSet, NULL, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, NULL, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_monitor.m_device, &readSet))
[+] 		if (FD_ISSET(m_monitor.m_device, &readSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 		while (canReadMonitor && !m_readBuffer.isFull ())
[+] 		while (canReadMonitor && !m_readBuffer.isFull())
[-] 			ssize_t actualSize = ::read (m_monitor.m_device, readBlock, readBlock.getCount ());
[+] 			ssize_t actualSize = ::read(m_monitor.m_device, readBlock, readBlock.getCount());
[-] 					setIoErrorEvent_l (err::Errno (errno));
[+] 					setIoErrorEvent_l(err::Errno(errno));
[-] 				addToReadBuffer (readBlock, actualSize);
[+] 				addToReadBuffer(readBlock, actualSize);
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_devmon\jnc_io_DevMonLib.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (DevMonLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(DevMonLib)
[-] 	JNC_LIB_IMPORT ("io_DeviceMonitor.jnc")
[+] 	JNC_LIB_IMPORT("io_DeviceMonitor.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (DevMonLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(DevMonLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (jnc::io::DeviceMonitor)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(jnc::io::DeviceMonitor)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (DevMonLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(DevMonLib)
[-] 	JNC_MAP_TYPE (jnc::io::DeviceMonitor)
[+] 	JNC_MAP_TYPE(jnc::io::DeviceMonitor)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] jncDynamicExtensionLibMain (jnc::DynamicExtensionLibHost* host)
[+] jncDynamicExtensionLibMain(jnc::DynamicExtensionLibHost* host)
[-] 	g::getModule ()->setTag ("jnc_io_devmon");
[+] 	g::getModule()->setTag("jnc_io_devmon");
[-] 	err::getErrorMgr ()->setForwardRouter (host->m_errorRouter);
[+] 	err::getErrorMgr()->setForwardRouter(host->m_errorRouter);
[-] 	return jnc::io::DevMonLib_getLib ();
[+] 	return jnc::io::DevMonLib_getLib();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_devmon\jnc_io_DeviceMonitor.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (DeviceMonitor)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(DeviceMonitor)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, DeviceMonitor, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, DeviceMonitor, m_ioThread)->ioThreadFunc();
[-] 		mem::Pool <OverlappedRead> m_overlappedReadPool;
[+] 		mem::Pool<OverlappedRead> m_overlappedReadPool;
[-] 		sl::List <OverlappedRead> m_activeOverlappedReadList;
[+] 		sl::List<OverlappedRead> m_activeOverlappedReadList;
[-] 	DeviceMonitor ();
[+] 	DeviceMonitor();
[-] 	~DeviceMonitor ()
[+] 	~DeviceMonitor()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setPendingNotifySizeLimit (size_t limit);
[+] 	setPendingNotifySizeLimit(size_t limit);
[-] 	setFileNameFilter (DataPtr filterPtr);
[+] 	setFileNameFilter(DataPtr filterPtr);
[-] 	setEnabled (bool isEnabled);
[+] 	setEnabled(bool isEnabled);
[-] 	open ();
[+] 	open();
[-] 	close ();
[+] 	close();
[-] 	connect (DataPtr deviceNamePtr);
[+] 	connect(DataPtr deviceNamePtr);
[-] 	setIoctlDescTable (
[+] 	setIoctlDescTable(
[-] 	read (
[+] 	read(
[-] 		return bufferedRead (ptr, size);
[+] 		return bufferedRead(ptr, size);
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	connectLoop ();
[+] 	connectLoop();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_devmon\jnc_io_DevMonLib.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_pcap\jnc_io_Pcap.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Pcap)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Pcap)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Pcap>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Pcap>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Pcap>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Pcap>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &Pcap::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &Pcap::setReadBufferSize)
[-] 	JNC_MAP_FUNCTION ("openDevice",   &Pcap::openDevice)
[+] 	JNC_MAP_FUNCTION("openDevice",   &Pcap::openDevice)
[-] 	JNC_MAP_FUNCTION ("openFile",     &Pcap::openFile)
[+] 	JNC_MAP_FUNCTION("openFile",     &Pcap::openFile)
[-] 	JNC_MAP_FUNCTION ("close",        &Pcap::close)
[+] 	JNC_MAP_FUNCTION("close",        &Pcap::close)
[-] 	JNC_MAP_FUNCTION ("setFilter",    &Pcap::setFilter)
[+] 	JNC_MAP_FUNCTION("setFilter",    &Pcap::setFilter)
[-] 	JNC_MAP_FUNCTION ("write",        &Pcap::write)
[+] 	JNC_MAP_FUNCTION("write",        &Pcap::write)
[-] 	JNC_MAP_FUNCTION ("read",         &Pcap::read)
[+] 	JNC_MAP_FUNCTION("read",         &Pcap::read)
[-] 	JNC_MAP_FUNCTION ("wait",         &Pcap::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &Pcap::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &Pcap::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &Pcap::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &Pcap::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &Pcap::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (PcapAddress)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(PcapAddress)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (PcapDeviceDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(PcapDeviceDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Pcap::Pcap ()
[+] Pcap::Pcap()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] Pcap::openDevice (
[+] Pcap::openDevice(
[-] 	close ();
[+] 	close();
[-] 		m_pcap.openDevice (deviceName, snapshotSize, isPromiscious, readTimeout) &&
[+] 		m_pcap.openDevice(deviceName, snapshotSize, isPromiscious, readTimeout) &&
[-] 		m_pcap.setFilter (filter);
[+] 		m_pcap.setFilter(filter);
[-] 	m_filterPtr = strDup (filter);
[+] 	m_filterPtr = strDup(filter);
[-] 	return finishOpen ();
[+] 	return finishOpen();
[-] Pcap::openFile (
[+] Pcap::openFile(
[-] 	close ();
[+] 	close();
[-] 		m_pcap.openFile (fileName) &&
[+] 		m_pcap.openFile(fileName) &&
[-] 		m_pcap.setFilter (filter);
[+] 		m_pcap.setFilter(filter);
[-] 	m_filterPtr = strDup (filter);
[+] 	m_filterPtr = strDup(filter);
[-] 	return finishOpen ();
[+] 	return finishOpen();
[-] Pcap::finishOpen ()
[+] Pcap::finishOpen()
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] Pcap::close ()
[+] Pcap::close()
[-] 	if (!m_pcap.isOpen ())
[+] 	if (!m_pcap.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_pcap.close ();
[+] 	m_pcap.close();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] Pcap::setFilter (DataPtr filterPtr)
[+] Pcap::setFilter(DataPtr filterPtr)
[-] 	bool result = m_pcap.setFilter (filter);
[+] 	bool result = m_pcap.setFilter(filter);
[-] 	m_filterPtr = strDup (filter);
[+] 	m_filterPtr = strDup(filter);
[-] Pcap::read (
[+] Pcap::read(
[-] 		result = bufferedRead (dataPtr, size);
[+] 		result = bufferedRead(dataPtr, size);
[-] 		char buffer [256];
[+] 		char buffer[256];
[-] 		sl::Array <char> params (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 		sl::Array<char> params(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		result = bufferedRead (dataPtr, size, &params);
[+] 		result = bufferedRead(dataPtr, size, &params);
[-] 		ASSERT (params.getCount () == sizeof (uint64_t));
[+] 		ASSERT(params.getCount() == sizeof(uint64_t));
[-] 		*(uint64_t*) timestampPtr.m_p = *(uint64_t*) params.p ();
[+] 		*(uint64_t*)timestampPtr.m_p = *(uint64_t*)params.p();
[-] Pcap::write (
[+] Pcap::write(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	return m_pcap.write (ptr.m_p, size);
[+] 	return m_pcap.write(ptr.m_p, size);
[-] Pcap::ioThreadFunc ()
[+] Pcap::ioThreadFunc()
[-] 	ASSERT (m_pcap.isOpen ());
[+] 	ASSERT(m_pcap.isOpen());
[-] 	sl::Array <char> readBuffer;
[+] 	sl::Array<char> readBuffer;
[-] 	readBuffer.setCount (m_snapshotSize);
[+] 	readBuffer.setCount(m_snapshotSize);
[-] 		size_t readResult = m_pcap.read (readBuffer, m_snapshotSize, &timestamp);
[+] 		size_t readResult = m_pcap.read(readBuffer, m_snapshotSize, &timestamp);
[-] 			setIoErrorEvent ();
[+] 			setIoErrorEvent();
[-] 			setEvents (PcapEvent_Eof);
[+] 			setEvents(PcapEvent_Eof);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		while (m_readBuffer.isFull ())
[+] 		while (m_readBuffer.isFull())
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			sleepIoThread ();
[+] 			sleepIoThread();
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 		addToReadBuffer (readBuffer, readResult, &timestamp, sizeof (timestamp));
[+] 		addToReadBuffer(readBuffer, readResult, &timestamp, sizeof(timestamp));
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] getIpFromSockAddr (const sockaddr* sockAddr)
[+] getIpFromSockAddr(const sockaddr* sockAddr)
[-] setupPcapAddress (
[+] setupPcapAddress(
[-] 	GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = runtime->getGcHeap();
[-] 	Type* addressType = PcapAddress_getType (runtime->getModule ());
[+] 	Type* addressType = PcapAddress_getType(runtime->getModule());
[-] 	address->m_address = getIpFromSockAddr (ifaceAddr->addr);
[+] 	address->m_address = getIpFromSockAddr(ifaceAddr->addr);
[-] 	address->m_mask = getIpFromSockAddr (ifaceAddr->netmask);
[+] 	address->m_mask = getIpFromSockAddr(ifaceAddr->netmask);
[-] 	address->m_broadcast = getIpFromSockAddr (ifaceAddr->broadaddr);
[+] 	address->m_broadcast = getIpFromSockAddr(ifaceAddr->broadaddr);
[-] 		DataPtr addressPtr = gcHeap->allocateData (addressType);
[+] 		DataPtr addressPtr = gcHeap->allocateData(addressType);
[-] 		address = (PcapAddress*) addressPtr.m_p;
[+] 		address = (PcapAddress*)addressPtr.m_p;
[-] 		address->m_address = getIpFromSockAddr (ifaceAddr->addr);
[+] 		address->m_address = getIpFromSockAddr(ifaceAddr->addr);
[-] 		address->m_mask = getIpFromSockAddr (ifaceAddr->netmask);
[+] 		address->m_mask = getIpFromSockAddr(ifaceAddr->netmask);
[-] 		address->m_broadcast = getIpFromSockAddr (ifaceAddr->broadaddr);
[+] 		address->m_broadcast = getIpFromSockAddr(ifaceAddr->broadaddr);
[-] createPcapDeviceDescList (DataPtr countPtr)
[+] createPcapDeviceDescList(DataPtr countPtr)
[-] 		*(size_t*) countPtr.m_p = 0;
[+] 		*(size_t*)countPtr.m_p = 0;
[-] 	char errorBuffer [PCAP_ERRBUF_SIZE] = { 0 };
[+] 	char errorBuffer[PCAP_ERRBUF_SIZE] = { 0 };
[-] 	int result = pcap_findalldevs (&ifaceList, errorBuffer);
[+] 	int result = pcap_findalldevs(&ifaceList, errorBuffer);
[-] 		err::setError (errorBuffer);
[+] 		err::setError(errorBuffer);
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	ScopedNoCollectRegion noCollectRegion (runtime, false);
[+] 	ScopedNoCollectRegion noCollectRegion(runtime, false);
[-] 	GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = runtime->getGcHeap();
[-] 	Type* deviceType = PcapDeviceDesc_getType (runtime->getModule ());
[+] 	Type* deviceType = PcapDeviceDesc_getType(runtime->getModule());
[-] 	DataPtr devicePtr = gcHeap->allocateData (deviceType);
[+] 	DataPtr devicePtr = gcHeap->allocateData(deviceType);
[-] 	PcapDeviceDesc* device = (PcapDeviceDesc*) devicePtr.m_p;
[+] 	PcapDeviceDesc* device = (PcapDeviceDesc*)devicePtr.m_p;
[-] 	device->m_namePtr = strDup (iface->name);
[+] 	device->m_namePtr = strDup(iface->name);
[-] 	device->m_descriptionPtr = strDup (iface->description);
[+] 	device->m_descriptionPtr = strDup(iface->description);
[-] 	setupPcapAddress (runtime, &device->m_address, iface->addresses);
[+] 	setupPcapAddress(runtime, &device->m_address, iface->addresses);
[-] 		devicePtr = gcHeap->allocateData (deviceType);
[+] 		devicePtr = gcHeap->allocateData(deviceType);
[-] 		device = (PcapDeviceDesc*) devicePtr.m_p;
[+] 		device = (PcapDeviceDesc*)devicePtr.m_p;
[-] 		device->m_namePtr = strDup (iface->name);
[+] 		device->m_namePtr = strDup(iface->name);
[-] 		device->m_descriptionPtr = strDup (iface->description);
[+] 		device->m_descriptionPtr = strDup(iface->description);
[-] 		setupPcapAddress (runtime, &device->m_address, iface->addresses);
[+] 		setupPcapAddress(runtime, &device->m_address, iface->addresses);
[-] 	pcap_freealldevs (ifaceList);
[+] 	pcap_freealldevs(ifaceList);
[-] 		*(size_t*) countPtr.m_p = count;
[+] 		*(size_t*)countPtr.m_p = count;
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_pcap\jnc_io_PcapLib.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (PcapLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(PcapLib)
[-] 	JNC_LIB_IMPORT ("io_Pcap.jnc")
[+] 	JNC_LIB_IMPORT("io_Pcap.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (PcapLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(PcapLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Pcap)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Pcap)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (PcapLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(PcapLib)
[-] 	JNC_MAP_TYPE (Pcap)
[+] 	JNC_MAP_TYPE(Pcap)
[-] 	JNC_MAP_FUNCTION ("io.createPcapDeviceDescList", &createPcapDeviceDescList)
[+] 	JNC_MAP_FUNCTION("io.createPcapDeviceDescList", &createPcapDeviceDescList)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] jncDynamicExtensionLibMain (jnc_DynamicExtensionLibHost* host)
[+] jncDynamicExtensionLibMain(jnc_DynamicExtensionLibHost* host)
[-] 	g::getModule ()->setTag ("jnc_io_pcap");
[+] 	g::getModule()->setTag("jnc_io_pcap");
[-] 	err::getErrorMgr ()->setForwardRouter (host->m_errorRouter);
[+] 	err::getErrorMgr()->setForwardRouter(host->m_errorRouter);
[-] 	return jnc::io::PcapLib_getLib ();
[+] 	return jnc::io::PcapLib_getLib();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_pcap\jnc_io_Pcap.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Pcap)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Pcap)
[-] JNC_DECLARE_TYPE (PcapAddress)
[+] JNC_DECLARE_TYPE(PcapAddress)
[-] JNC_DECLARE_TYPE (PcapDeviceDesc)
[+] JNC_DECLARE_TYPE(PcapDeviceDesc)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Pcap, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, Pcap, m_ioThread)->ioThreadFunc();
[-] 	Pcap ();
[+] 	Pcap();
[-] 	~Pcap ()
[+] 	~Pcap()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	openDevice (
[+] 	openDevice(
[-] 	openFile (
[+] 	openFile(
[-] 	close ();
[+] 	close();
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setFilter (DataPtr filter);
[+] 	setFilter(DataPtr filter);
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	finishOpen ();
[+] 	finishOpen();
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] createPcapDeviceDescList (DataPtr countPtr);
[+] createPcapDeviceDescList(DataPtr countPtr);
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_pcap\jnc_io_PcapLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\jnc_io_Ssh.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (SshChannel)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(SshChannel)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <SshChannel>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<SshChannel>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <SshChannel>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<SshChannel>)
[-] 	JNC_MAP_CONST_PROPERTY ("m_address",     &SshChannel::getAddress)
[+] 	JNC_MAP_CONST_PROPERTY("m_address",     &SshChannel::getAddress)
[-] 	JNC_MAP_CONST_PROPERTY ("m_peerAddress", &SshChannel::getPeerAddress)
[+] 	JNC_MAP_CONST_PROPERTY("m_peerAddress", &SshChannel::getPeerAddress)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &SshChannel::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &SshChannel::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &SshChannel::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &SshChannel::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &SshChannel::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &SshChannel::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &SshChannel::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &SshChannel::setOptions)
[-] 	JNC_MAP_FUNCTION ("open",         &SshChannel::open_0)
[+] 	JNC_MAP_FUNCTION("open",         &SshChannel::open_0)
[-] 	JNC_MAP_OVERLOAD (&SshChannel::open_1)
[+] 	JNC_MAP_OVERLOAD(&SshChannel::open_1)
[-] 	JNC_MAP_FUNCTION ("close",        &SshChannel::close)
[+] 	JNC_MAP_FUNCTION("close",        &SshChannel::close)
[-] 	JNC_MAP_FUNCTION ("connect",      &SshChannel::connect_0)
[+] 	JNC_MAP_FUNCTION("connect",      &SshChannel::connect_0)
[-] 	JNC_MAP_OVERLOAD (&SshChannel::connect_1)
[+] 	JNC_MAP_OVERLOAD(&SshChannel::connect_1)
[-] 	JNC_MAP_FUNCTION ("authenticate", &SshChannel::authenticate)
[+] 	JNC_MAP_FUNCTION("authenticate", &SshChannel::authenticate)
[-] 	JNC_MAP_FUNCTION ("resizePty",    &SshChannel::resizePty)
[+] 	JNC_MAP_FUNCTION("resizePty",    &SshChannel::resizePty)
[-] 	JNC_MAP_FUNCTION ("read",         &SshChannel::read)
[+] 	JNC_MAP_FUNCTION("read",         &SshChannel::read)
[-] 	JNC_MAP_FUNCTION ("write",        &SshChannel::write)
[+] 	JNC_MAP_FUNCTION("write",        &SshChannel::write)
[-] 	JNC_MAP_FUNCTION ("wait",         &SshChannel::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &SshChannel::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &SshChannel::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &SshChannel::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &SshChannel::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &SshChannel::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] SshChannel::SshChannel ()
[+] SshChannel::SshChannel()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] SshChannel::open_0 (uint16_t family)
[+] SshChannel::open_0(uint16_t family)
[-] 	close ();
[+] 	close();
[-] 	bool result = SocketBase::open (family, IPPROTO_TCP, NULL);
[+] 	bool result = SocketBase::open(family, IPPROTO_TCP, NULL);
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] SshChannel::open_1 (DataPtr addressPtr)
[+] SshChannel::open_1(DataPtr addressPtr)
[-] 	close ();
[+] 	close();
[-] 	SocketAddress* address = (SocketAddress*) addressPtr.m_p;
[+] 	SocketAddress* address = (SocketAddress*)addressPtr.m_p;
[-] 	bool result = SocketBase::open (address ? address->m_family : AF_INET, IPPROTO_TCP, address);
[+] 	bool result = SocketBase::open(address ? address->m_family : AF_INET, IPPROTO_TCP, address);
[-] 	m_ioThread.start ();
[+] 	m_ioThread.start();
[-] SshChannel::close ()
[+] SshChannel::close()
[-] 	if (!m_socket.isOpen ())
[+] 	if (!m_socket.isOpen())
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 		AXL_MEM_DELETE (m_connectParams);
[+] 		AXL_MEM_DELETE(m_connectParams);
[-] 	SocketBase::close ();
[+] 	SocketBase::close();
[-] SshChannel::connect_0 (
[+] SshChannel::connect_0(
[-] 	return connectImpl (
[+] 	return connectImpl(
[-] SshChannel::connect_1 (DataPtr paramPtr)
[+] SshChannel::connect_1(DataPtr paramPtr)
[-] 	SshConnectParams* params = (SshConnectParams*) paramPtr.m_p;
[+] 	SshConnectParams* params = (SshConnectParams*)paramPtr.m_p;
[-] 	return connectImpl (
[+] 	return connectImpl(
[-] SshChannel::connectImpl (
[+] SshChannel::connectImpl(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	ASSERT (!m_connectParams);
[+] 	ASSERT(!m_connectParams);
[-] 	m_connectParams = AXL_MEM_NEW (ConnectParams);
[+] 	m_connectParams = AXL_MEM_NEW(ConnectParams);
[-] 		m_connectParams->m_privateKey.copy ((char*) privateKey, privateKeySize);
[+] 		m_connectParams->m_privateKey.copy((char*)privateKey, privateKeySize);
[-] 		m_connectParams->m_channelExtra.copy ((char*) channelExtra, channelExtraSize);
[+] 		m_connectParams->m_channelExtra.copy((char*)channelExtra, channelExtraSize);
[-] 		m_connectParams->m_processExtra.copy ((char*) processExtra, processExtraSize);
[+] 		m_connectParams->m_processExtra.copy((char*)processExtra, processExtraSize);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	result = m_socket.connect (m_remoteAddress.getSockAddr ());
[+] 	result = m_socket.connect(m_remoteAddress.getSockAddr());
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] SshChannel::authenticate (
[+] SshChannel::authenticate(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	ASSERT (m_connectParams);
[+] 	ASSERT(m_connectParams);
[-] 		m_connectParams->m_privateKey.copy ((char*) privateKeyPtr.m_p, privateKeySize);
[+] 		m_connectParams->m_privateKey.copy((char*)privateKeyPtr.m_p, privateKeySize);
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SshChannel::resizePty (
[+] SshChannel::resizePty(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] SshChannel::ioThreadFunc ()
[+] SshChannel::ioThreadFunc()
[-] 	ASSERT (m_socket.isOpen ());
[+] 	ASSERT(m_socket.isOpen());
[-] 	sleepIoThread ();
[+] 	sleepIoThread();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	bool result = tcpConnect (SshEvent_TcpConnectCompleted) && sshConnect ();
[+] 	bool result = tcpConnect(SshEvent_TcpConnectCompleted) && sshConnect();
[-] 		wakeIoThread ();
[+] 		wakeIoThread();
[-] 		sshReadWriteLoop ();
[+] 		sshReadWriteLoop();
[-] 	m_sshChannel.close ();
[+] 	m_sshChannel.close();
[-] 	m_sshSession.close ();
[+] 	m_sshSession.close();
[-] SshChannel::getLastSshError ()
[+] SshChannel::getLastSshError()
[-] 	::libssh2_session_last_error (m_sshSession, &errorString, &length, false);
[+] 	::libssh2_session_last_error(m_sshSession, &errorString, &length, false);
[-] 	return err::Error (sl::StringRef (errorString, length));
[+] 	return err::Error(sl::StringRef(errorString, length));
[-] SshChannel::sshAsyncLoop (int result)
[+] SshChannel::sshAsyncLoop(int result)
[-] 		setError (getLastSshError ());
[+] 		setError(getLastSshError());
[-] 		setError (err::Error (err::SystemErrorCode_Cancelled));
[+] 		setError(err::Error(err::SystemErrorCode_Cancelled));
[-] 	sys::sleep (10);
[+] 	sys::sleep(10);
[-] getSshLastError (LIBSSH2_SESSION* sshSession)
[+] getSshLastError(LIBSSH2_SESSION* sshSession)
[-] 	::libssh2_session_last_error (sshSession, &string, &length, false);
[+] 	::libssh2_session_last_error(sshSession, &string, &length, false);
[-] 	return err::Error (sl::StringRef (string, length));
[+] 	return err::Error(sl::StringRef(string, length));
[-] SshChannel::sshConnect ()
[+] SshChannel::sshConnect()
[-] 	LIBSSH2_SESSION* sshSession = ::libssh2_session_init ();
[+] 	LIBSSH2_SESSION* sshSession = ::libssh2_session_init();
[-] 	m_sshSession.attach (sshSession);
[+] 	m_sshSession.attach(sshSession);
[-] 	::libssh2_session_set_blocking (m_sshSession, false);
[+] 	::libssh2_session_set_blocking(m_sshSession, false);
[-] 		result = ::libssh2_session_handshake (m_sshSession, m_socket.m_socket);
[+] 		result = ::libssh2_session_handshake(m_sshSession, m_socket.m_socket);
[-] 		result = sshAsyncLoop (result);
[+] 		result = sshAsyncLoop(result);
[-] 		setIoErrorEvent (getSshLastError (m_sshSession));
[+] 		setIoErrorEvent(getSshLastError(m_sshSession));
[-] 	setEvents (SshEvent_SshHandshakeCompleted);
[+] 	setEvents(SshEvent_SshHandshakeCompleted);
[-] 			result = m_connectParams->m_privateKey.isEmpty () ?
[+] 			result = m_connectParams->m_privateKey.isEmpty() ?
[-] 				::libssh2_userauth_password (
[+] 				::libssh2_userauth_password(
[-] 				::libssh2_userauth_publickey_frommemory (
[+] 				::libssh2_userauth_publickey_frommemory(
[-] 					m_connectParams->m_userName.cp (),
[+] 					m_connectParams->m_userName.cp(),
[-] 					m_connectParams->m_userName.getLength (),
[+] 					m_connectParams->m_userName.getLength(),
[-] 					m_connectParams->m_privateKey.cp (),
[+] 					m_connectParams->m_privateKey.cp(),
[-] 					m_connectParams->m_privateKey.getCount (),
[+] 					m_connectParams->m_privateKey.getCount(),
[-] 					m_connectParams->m_password.sz ()
[+] 					m_connectParams->m_password.sz()
[-] 			result = sshAsyncLoop (result);
[+] 			result = sshAsyncLoop(result);
[-] 			setIoErrorEvent (getSshLastError (m_sshSession));
[+] 			setIoErrorEvent(getSshLastError(m_sshSession));
[-] 		setErrorEvent (SshEvent_SshAuthenticateError, getSshLastError (m_sshSession));
[+] 		setErrorEvent(SshEvent_SshAuthenticateError, getSshLastError(m_sshSession));
[-] 		sleepIoThread ();
[+] 		sleepIoThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_socket.close ();
[+] 			m_socket.close();
[-] 			result = m_socket.open (AF_INET, SOCK_STREAM, IPPROTO_TCP);
[+] 			result = m_socket.open(AF_INET, SOCK_STREAM, IPPROTO_TCP);
[-] 				setIoErrorEvent (err::getLastError ());
[+] 				setIoErrorEvent(err::getLastError());
[-] 				result = m_socket.bind (m_localAddress.getSockAddr ());
[+] 				result = m_socket.bind(m_localAddress.getSockAddr());
[-] 					setIoErrorEvent (err::getLastError ());
[+] 					setIoErrorEvent(err::getLastError());
[-] 			result = m_socket.connect (m_remoteAddress.getSockAddr ());
[+] 			result = m_socket.connect(m_remoteAddress.getSockAddr());
[-] 				setIoErrorEvent (err::getLastError ());
[+] 				setIoErrorEvent(err::getLastError());
[-] 			result = tcpConnect (SshEvent_TcpConnectCompleted);
[+] 			result = tcpConnect(SshEvent_TcpConnectCompleted);
[-] 			sshSession = ::libssh2_session_init ();
[+] 			sshSession = ::libssh2_session_init();
[-] 			m_sshSession.attach (sshSession);
[+] 			m_sshSession.attach(sshSession);
[-] 			::libssh2_session_set_blocking (m_sshSession, false);
[+] 			::libssh2_session_set_blocking(m_sshSession, false);
[-] 				result = ::libssh2_session_handshake (m_sshSession, m_socket.m_socket);
[+] 				result = ::libssh2_session_handshake(m_sshSession, m_socket.m_socket);
[-] 				result = sshAsyncLoop (result);
[+] 				result = sshAsyncLoop(result);
[-] 				setIoErrorEvent (getSshLastError (m_sshSession));
[+] 				setIoErrorEvent(getSshLastError(m_sshSession));
[-] 			setEvents (SshEvent_SshHandshakeCompleted);
[+] 			setEvents(SshEvent_SshHandshakeCompleted);
[-] 	setEvents (SshEvent_SshAuthenticateCompleted);
[+] 	setEvents(SshEvent_SshAuthenticateCompleted);
[-] 		channel = ::libssh2_channel_open_ex (
[+] 		channel = ::libssh2_channel_open_ex(
[-] 			m_connectParams->m_channelType.getLength (),
[+] 			m_connectParams->m_channelType.getLength(),
[-] 			m_connectParams->m_channelExtra.getCount ()
[+] 			m_connectParams->m_channelExtra.getCount()
[-] 		result = channel ? 0 : sshAsyncLoop (::libssh2_session_last_errno (m_sshSession));
[+] 		result = channel ? 0 : sshAsyncLoop(::libssh2_session_last_errno(m_sshSession));
[-] 		setIoErrorEvent (getSshLastError (m_sshSession));
[+] 		setIoErrorEvent(getSshLastError(m_sshSession));
[-] 	m_sshChannel.attach (channel);
[+] 	m_sshChannel.attach(channel);
[-] 	::libssh2_channel_set_blocking (m_sshChannel, false);
[+] 	::libssh2_channel_set_blocking(m_sshChannel, false);
[-] 	setEvents (SshEvent_SshChannelOpened);
[+] 	setEvents(SshEvent_SshChannelOpened);
[-] 	if (!m_connectParams->m_ptyType.isEmpty ())
[+] 	if (!m_connectParams->m_ptyType.isEmpty())
[-] 			result = ::libssh2_channel_request_pty_ex (
[+] 			result = ::libssh2_channel_request_pty_ex(
[-] 				m_connectParams->m_ptyType.getLength (),
[+] 				m_connectParams->m_ptyType.getLength(),
[-] 			result = sshAsyncLoop (result);
[+] 			result = sshAsyncLoop(result);
[-] 			setIoErrorEvent (getSshLastError (m_sshSession));
[+] 			setIoErrorEvent(getSshLastError(m_sshSession));
[-] 	setEvents (SshEvent_SshPtyRequestCompleted);
[+] 	setEvents(SshEvent_SshPtyRequestCompleted);
[-] 	if (!m_connectParams->m_processType.isEmpty ())
[+] 	if (!m_connectParams->m_processType.isEmpty())
[-] 			result = ::libssh2_channel_process_startup (
[+] 			result = ::libssh2_channel_process_startup(
[-] 				m_connectParams->m_processType.getLength (),
[+] 				m_connectParams->m_processType.getLength(),
[-] 				m_connectParams->m_processExtra.getCount ()
[+] 				m_connectParams->m_processExtra.getCount()
[-] 			result = sshAsyncLoop (result);
[+] 			result = sshAsyncLoop(result);
[-] 			setIoErrorEvent (getSshLastError (m_sshSession));
[+] 			setIoErrorEvent(getSshLastError(m_sshSession));
[-] 	setEvents (SshEvent_SshConnectCompleted);
[+] 	setEvents(SshEvent_SshConnectCompleted);
[-] 	AXL_MEM_DELETE (m_connectParams);
[+] 	AXL_MEM_DELETE(m_connectParams);
[-] SshChannel::sshReadWriteLoop ()
[+] SshChannel::sshReadWriteLoop()
[-] 	HANDLE waitTable [] =
[+] 	HANDLE waitTable[] =
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	sl::Array <char> writeBlock;
[+] 	sl::Array<char> writeBlock;
[-] 			result = m_socket.m_socket.wsaEventSelect (socketEvent.m_event, socketEventMask);
[+] 			result = m_socket.m_socket.wsaEventSelect(socketEvent.m_event, socketEventMask);
[-] 				setIoErrorEvent (err::getLastError ());
[+] 				setIoErrorEvent(err::getLastError());
[-] 		DWORD waitResult = ::WaitForMultipleObjects (countof (waitTable), waitTable, false, INFINITE);
[+] 		DWORD waitResult = ::WaitForMultipleObjects(countof(waitTable), waitTable, false, INFINITE);
[-] 			setIoErrorEvent (err::getLastSystemErrorCode ());
[+] 			setIoErrorEvent(err::getLastSystemErrorCode());
[-] 		if (socketEvent.wait (0))
[+] 		if (socketEvent.wait(0))
[-] 			result = m_socket.m_socket.wsaEnumEvents (&networkEvents);
[+] 			result = m_socket.m_socket.wsaEnumEvents(&networkEvents);
[-] 				setIoErrorEvent ();
[+] 				setIoErrorEvent();
[-] 				int error = networkEvents.iErrorCode [FD_READ_BIT];
[+] 				int error = networkEvents.iErrorCode[FD_READ_BIT];
[-] 					setIoErrorEvent (error);
[+] 					setIoErrorEvent(error);
[-] 				int error = networkEvents.iErrorCode [FD_WRITE_BIT];
[+] 				int error = networkEvents.iErrorCode[FD_WRITE_BIT];
[-] 					setIoErrorEvent (error);
[+] 					setIoErrorEvent(error);
[-] 			socketEvent.reset ();
[+] 			socketEvent.reset();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 		while (canReadSocket && !m_readBuffer.isFull ())
[+] 		while (canReadSocket && !m_readBuffer.isFull())
[-] 			ssize_t actualSize = ::libssh2_channel_read (m_sshChannel, readBlock, readBlock.getCount ());
[+] 			ssize_t actualSize = ::libssh2_channel_read(m_sshChannel, readBlock, readBlock.getCount());
[-] 				setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 				setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 				setEvents_l (SshEvent_TcpDisconnected);
[+] 				setEvents_l(SshEvent_TcpDisconnected);
[-] 				addToReadBuffer (readBlock, actualSize);
[+] 				addToReadBuffer(readBlock, actualSize);
[-] 			getNextWriteBlock (&writeBlock);
[+] 			getNextWriteBlock(&writeBlock);
[-] 			if (writeBlock.isEmpty ())
[+] 			if (writeBlock.isEmpty())
[-] 			size_t blockSize = writeBlock.getCount ();
[+] 			size_t blockSize = writeBlock.getCount();
[-] 			ssize_t actualSize = ::libssh2_channel_write (m_sshChannel, writeBlock, blockSize);
[+] 			ssize_t actualSize = ::libssh2_channel_write(m_sshChannel, writeBlock, blockSize);
[-] 				setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 				setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 			else if ((size_t) actualSize < blockSize)
[+] 			else if ((size_t)actualSize < blockSize)
[-] 				writeBlock.remove (0, actualSize);
[+] 				writeBlock.remove(0, actualSize);
[-] 				writeBlock.clear ();
[+] 				writeBlock.clear();
[-] 			ssize_t sshResult = ::libssh2_channel_request_pty_size (m_sshChannel, m_ptyWidth, m_ptyHeight);
[+] 			ssize_t sshResult = ::libssh2_channel_request_pty_size(m_sshChannel, m_ptyWidth, m_ptyHeight);
[-] 				setIoErrorEvent_l (err::Errno ((int) sshResult));
[+] 				setIoErrorEvent_l(err::Errno((int)sshResult));
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] SshChannel::sshReadWriteLoop ()
[+] SshChannel::sshReadWriteLoop()
[-] 	int selectFd = AXL_MAX (m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[+] 	int selectFd = AXL_MAX(m_socket.m_socket, m_ioThreadSelfPipe.m_readFile) + 1;
[-] 	sl::Array <char> readBlock;
[+] 	sl::Array<char> readBlock;
[-] 	sl::Array <char> writeBlock;
[+] 	sl::Array<char> writeBlock;
[-] 	readBlock.setCount (Def_ReadBlockSize);
[+] 	readBlock.setCount(Def_ReadBlockSize);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> writeParams (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> writeParams(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	writeParams.setCount (sizeof (SocketAddress));
[+] 	writeParams.setCount(sizeof(SocketAddress));
[-] 		FD_SET (m_ioThreadSelfPipe.m_readFile, &readSet);
[+] 		FD_SET(m_ioThreadSelfPipe.m_readFile, &readSet);
[-] 			FD_SET (m_socket.m_socket, &readSet);
[+] 			FD_SET(m_socket.m_socket, &readSet);
[-] 			FD_SET (m_socket.m_socket, &writeSet);
[+] 			FD_SET(m_socket.m_socket, &writeSet);
[-] 		result = ::select (selectFd, &readSet, &writeSet, NULL, NULL);
[+] 		result = ::select(selectFd, &readSet, &writeSet, NULL, NULL);
[-] 		if (FD_ISSET (m_ioThreadSelfPipe.m_readFile, &readSet))
[+] 		if (FD_ISSET(m_ioThreadSelfPipe.m_readFile, &readSet))
[-] 			char buffer [256];
[+] 			char buffer[256];
[-] 			m_ioThreadSelfPipe.read (buffer, sizeof (buffer));
[+] 			m_ioThreadSelfPipe.read(buffer, sizeof(buffer));
[-] 		if (FD_ISSET (m_socket.m_socket, &readSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &readSet))
[-] 		if (FD_ISSET (m_socket.m_socket, &writeSet))
[+] 		if (FD_ISSET(m_socket.m_socket, &writeSet))
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		readBlock.setCount (m_readBlockSize); // update read block size
[+] 		readBlock.setCount(m_readBlockSize); // update read block size
[-] 		while (canReadSocket && !m_readBuffer.isFull ())
[+] 		while (canReadSocket && !m_readBuffer.isFull())
[-] 			ssize_t actualSize = ::libssh2_channel_read (m_sshChannel, readBlock, readBlock.getCount ());
[+] 			ssize_t actualSize = ::libssh2_channel_read(m_sshChannel, readBlock, readBlock.getCount());
[-] 				setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 				setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 				setEvents_l (SshEvent_TcpDisconnected);
[+] 				setEvents_l(SshEvent_TcpDisconnected);
[-] 				addToReadBuffer (readBlock, actualSize);
[+] 				addToReadBuffer(readBlock, actualSize);
[-] 			getNextWriteBlock (&writeBlock);
[+] 			getNextWriteBlock(&writeBlock);
[-] 			if (writeBlock.isEmpty ())
[+] 			if (writeBlock.isEmpty())
[-] 			size_t blockSize = writeBlock.getCount ();
[+] 			size_t blockSize = writeBlock.getCount();
[-] 			ssize_t actualSize = ::libssh2_channel_write (m_sshChannel, writeBlock, blockSize);
[+] 			ssize_t actualSize = ::libssh2_channel_write(m_sshChannel, writeBlock, blockSize);
[-] 				setIoErrorEvent_l (err::Errno ((int) actualSize));
[+] 				setIoErrorEvent_l(err::Errno((int)actualSize));
[-] 			else if ((size_t) actualSize < blockSize)
[+] 			else if ((size_t)actualSize < blockSize)
[-] 				writeBlock.remove (0, actualSize);
[+] 				writeBlock.remove(0, actualSize);
[-] 				writeBlock.clear ();
[+] 				writeBlock.clear();
[-] 			ssize_t sshResult = ::libssh2_channel_request_pty_size (m_sshChannel, m_ptyWidth, m_ptyHeight);
[+] 			ssize_t sshResult = ::libssh2_channel_request_pty_size(m_sshChannel, m_ptyWidth, m_ptyHeight);
[-] 				setIoErrorEvent_l (err::Errno ((int) sshResult));
[+] 				setIoErrorEvent_l(err::Errno((int)sshResult));
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\jnc_io_SshLib.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (SshLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(SshLib)
[-] 	JNC_LIB_IMPORT ("io_Ssh.jnc")
[+] 	JNC_LIB_IMPORT("io_Ssh.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (SshLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(SshLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (SshChannel)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(SshChannel)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (SshLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(SshLib)
[-] 	JNC_MAP_TYPE (SshChannel)
[+] 	JNC_MAP_TYPE(SshChannel)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] jncDynamicExtensionLibMain (jnc_DynamicExtensionLibHost* host)
[+] jncDynamicExtensionLibMain(jnc_DynamicExtensionLibHost* host)
[-] 	WSAStartup (0x0202, &WsaData);
[+] 	WSAStartup(0x0202, &WsaData);
[-] 	g::getModule ()->setTag ("jnc_io_ssh");
[+] 	g::getModule()->setTag("jnc_io_ssh");
[-] 	err::getErrorMgr ()->setForwardRouter (host->m_errorRouter);
[+] 	err::getErrorMgr()->setForwardRouter(host->m_errorRouter);
[-] 	return jnc::io::SshLib_getLib ();
[+] 	return jnc::io::SshLib_getLib();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\jnc_io_Ssh.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (SshChannel)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(SshChannel)
[-] 			libssh2_session_free (session);
[+] 			libssh2_session_free(session);
[-] 			libssh2_channel_free (channel);
[+] 			libssh2_channel_free(channel);
[-] typedef sl::Handle <LIBSSH2_SESSION*, FreeLibSsh2Session> SshSessionHandle;
[+] typedef sl::Handle<LIBSSH2_SESSION*, FreeLibSsh2Session> SshSessionHandle;
[-] typedef sl::Handle <LIBSSH2_CHANNEL*, FreeLibSsh2Channel> SshChannelHandle;
[+] typedef sl::Handle<LIBSSH2_CHANNEL*, FreeLibSsh2Channel> SshChannelHandle;
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, SshChannel, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, SshChannel, m_ioThread)->ioThreadFunc();
[-] 		sl::Array <char> m_privateKey;
[+] 		sl::Array<char> m_privateKey;
[-] 		sl::Array <char> m_channelExtra;
[+] 		sl::Array<char> m_channelExtra;
[-] 		sl::Array <char> m_processExtra;
[+] 		sl::Array<char> m_processExtra;
[-] 	SshChannel ();
[+] 	SshChannel();
[-] 	~SshChannel ()
[+] 	~SshChannel()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	getAddress (SshChannel* self)
[+] 	getAddress(SshChannel* self)
[-] 		return self->SocketBase::getAddress ();
[+] 		return self->SocketBase::getAddress();
[-] 	getPeerAddress (SshChannel* self)
[+] 	getPeerAddress(SshChannel* self)
[-] 		return self->SocketBase::getPeerAddress ();
[+] 		return self->SocketBase::getPeerAddress();
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t flags)
[+] 	setOptions(uint_t flags)
[-] 		return SocketBase::setOptions (flags);
[+] 		return SocketBase::setOptions(flags);
[-] 	open_0 (uint16_t family);
[+] 	open_0(uint16_t family);
[-] 	open_1 (DataPtr addressPtr);
[+] 	open_1(DataPtr addressPtr);
[-] 	close ();
[+] 	close();
[-] 	connect_0 (
[+] 	connect_0(
[-] 	connect_1 (DataPtr paramPtr);
[+] 	connect_1(DataPtr paramPtr);
[-] 	authenticate (
[+] 	authenticate(
[-] 	resizePty (
[+] 	resizePty(
[-] 	read (
[+] 	read(
[-] 		return bufferedRead (ptr, size);
[+] 		return bufferedRead(ptr, size);
[-] 	write (
[+] 	write(
[-] 		return bufferedWrite (ptr, size);
[+] 		return bufferedWrite(ptr, size);
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	connectImpl (
[+] 	connectImpl(
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	getLastSshError ();
[+] 	getLastSshError();
[-] 	sshAsyncLoop (int result);
[+] 	sshAsyncLoop(int result);
[-] 	sshConnect ();
[+] 	sshConnect();
[-] 	sshReadWriteLoop ();
[+] 	sshReadWriteLoop();
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\jnc_io_SshLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\pch.h
----------------------
[-] #	pragma comment (lib, "ws2_32.lib")
[+] #	pragma comment(lib, "ws2_32.lib")
[-] #	pragma comment (lib, "crypt32.lib")
[+] #	pragma comment(lib, "crypt32.lib")
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbAsyncControlEndpoint.cpp
----------------------
[-] UsbAsyncControlEndpoint::UsbAsyncControlEndpoint (axl::io::UsbDevice* device)
[+] UsbAsyncControlEndpoint::UsbAsyncControlEndpoint(axl::io::UsbDevice* device)
[-] 	m_runtime = getCurrentThreadRuntime ();
[+] 	m_runtime = getCurrentThreadRuntime();
[-] 	ASSERT (m_runtime);
[+] 	ASSERT(m_runtime);
[-] UsbAsyncControlEndpoint::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] UsbAsyncControlEndpoint::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::Iterator <Transfer> it = m_activeTransferList.getHead ();
[+] 	sl::Iterator<Transfer> it = m_activeTransferList.getHead();
[-] 		markTransferGcRoots (gcHeap, *it);
[+] 		markTransferGcRoots(gcHeap, *it);
[-] 	it = m_completedTransferList.getHead ();
[+] 	it = m_completedTransferList.getHead();
[-] 		markTransferGcRoots (gcHeap, *it);
[+] 		markTransferGcRoots(gcHeap, *it);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] UsbAsyncControlEndpoint::markTransferGcRoots (
[+] UsbAsyncControlEndpoint::markTransferGcRoots(
[-] 	gcHeap->markClass (transfer->m_completionFuncPtr.m_closure->m_box);
[+] 	gcHeap->markClass(transfer->m_completionFuncPtr.m_closure->m_box);
[-] 		gcHeap->weakMark (transfer->m_inBufferPtr.m_validator->m_validatorBox);
[+] 		gcHeap->weakMark(transfer->m_inBufferPtr.m_validator->m_validatorBox);
[-] 		gcHeap->markData (transfer->m_inBufferPtr.m_validator->m_targetBox);
[+] 		gcHeap->markData(transfer->m_inBufferPtr.m_validator->m_targetBox);
[-] UsbAsyncControlEndpoint::start ()
[+] UsbAsyncControlEndpoint::start()
[-] 	ASSERT (isIdle ());
[+] 	ASSERT(isIdle());
[-] 	m_idleEvent.signal ();
[+] 	m_idleEvent.signal();
[-] 	return m_completionThread.start ();
[+] 	return m_completionThread.start();
[-] UsbAsyncControlEndpoint::stop ()
[+] UsbAsyncControlEndpoint::stop()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_event.signal ();
[+] 	m_event.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_completionThread.waitAndClose ();
[+] 	m_completionThread.waitAndClose();
[-] UsbAsyncControlEndpoint::transfer (
[+] UsbAsyncControlEndpoint::transfer(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	ASSERT (!m_flags & Flag_Stop);
[+] 	ASSERT(!m_flags & Flag_Stop);
[-] 	Transfer* transfer = m_transferPool.get ();
[+] 	Transfer* transfer = m_transferPool.get();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	result = transfer->m_usbTransfer.create ();
[+] 	result = transfer->m_usbTransfer.create();
[-] 	libusb_control_setup* setup = transfer->m_buffer.createBuffer (sizeof (libusb_control_setup) + size);
[+] 	libusb_control_setup* setup = transfer->m_buffer.createBuffer(sizeof(libusb_control_setup) + size);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		m_transferPool.put (transfer);
[+] 		m_transferPool.put(transfer);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		callCompletionFunc (completionFuncPtr, -1, err::getLastError ());
[+] 		callCompletionFunc(completionFuncPtr, -1, err::getLastError());
[-] 	transfer->m_usbTransfer.fillControlSetup (
[+] 	transfer->m_usbTransfer.fillControlSetup(
[-] 	transfer->m_usbTransfer.fillControlTransfer (
[+] 	transfer->m_usbTransfer.fillControlTransfer(
[-] 		m_device->getOpenHandle (),
[+] 		m_device->getOpenHandle(),
[-] 		memcpy (setup + 1, ptr.m_p, size);
[+] 		memcpy(setup + 1, ptr.m_p, size);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (isIdle ())
[+] 	if (isIdle())
[-] 		m_idleEvent.reset ();
[+] 		m_idleEvent.reset();
[-] 	m_activeTransferList.insertTail (transfer);
[+] 	m_activeTransferList.insertTail(transfer);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	result = transfer->m_usbTransfer.submit ();
[+] 	result = transfer->m_usbTransfer.submit();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_activeTransferList.remove (transfer);
[+] 	m_activeTransferList.remove(transfer);
[-] 	m_transferPool.put (transfer);
[+] 	m_transferPool.put(transfer);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	callCompletionFunc (completionFuncPtr, -1, err::getLastError ());
[+] 	callCompletionFunc(completionFuncPtr, -1, err::getLastError());
[-] UsbAsyncControlEndpoint::cancelTransfers ()
[+] UsbAsyncControlEndpoint::cancelTransfers()
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Transfer*> activeTransferArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Transfer*> activeTransferArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	ASSERT (!m_flags & Flag_Stop);
[+] 	ASSERT(!m_flags & Flag_Stop);
[-] 	m_event.signal ();
[+] 	m_event.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_idleEvent.wait ();
[+] 	m_idleEvent.wait();
[-] UsbAsyncControlEndpoint::completionThreadFunc ()
[+] UsbAsyncControlEndpoint::completionThreadFunc()
[-] 		m_event.wait ();
[+] 		m_event.wait();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			cancelAllActiveTransfers_l ();
[+] 			cancelAllActiveTransfers_l();
[-] 			finalizeTransfers_l ();
[+] 			finalizeTransfers_l();
[-] 	cancelAllActiveTransfers_l ();
[+] 	cancelAllActiveTransfers_l();
[-] UsbAsyncControlEndpoint::cancelAllActiveTransfers_l ()
[+] UsbAsyncControlEndpoint::cancelAllActiveTransfers_l()
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Transfer*> activeTransferArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Transfer*> activeTransferArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	sl::Iterator <Transfer> it = m_activeTransferList.getHead ();
[+] 	sl::Iterator<Transfer> it = m_activeTransferList.getHead();
[-] 		activeTransferArray.append (*it);
[+] 		activeTransferArray.append(*it);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	size_t count = activeTransferArray.getCount ();
[+] 	size_t count = activeTransferArray.getCount();
[-] 		activeTransferArray [i]->m_usbTransfer.cancel (); // may fail if already completed
[+] 		activeTransferArray[i]->m_usbTransfer.cancel(); // may fail if already completed
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	while (!m_activeTransferList.isEmpty ())
[+] 	while (!m_activeTransferList.isEmpty())
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_event.wait ();
[+] 		m_event.wait();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 	finalizeTransfers_l ();
[+] 	finalizeTransfers_l();
[-] UsbAsyncControlEndpoint::finalizeTransfers_l ()
[+] UsbAsyncControlEndpoint::finalizeTransfers_l()
[-] 	sl::List <Transfer> transferList;
[+] 	sl::List<Transfer> transferList;
[-] 	sl::takeOver (&transferList, &m_completedTransferList);
[+] 	sl::takeOver(&transferList, &m_completedTransferList);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	sl::Iterator <Transfer> it = transferList.getHead ();
[+] 	sl::Iterator<Transfer> it = transferList.getHead();
[-] 		switch (it->m_usbTransfer->status)
[+] 		switch(it->m_usbTransfer->status)
[-] 			ASSERT ((size_t) it->m_usbTransfer->actual_length <= it->m_buffer.getSize () - sizeof (libusb_control_setup));
[+] 			ASSERT((size_t)it->m_usbTransfer->actual_length <= it->m_buffer.getSize() - sizeof(libusb_control_setup));
[-] 				memcpy (it->m_inBufferPtr.m_p, it->m_buffer + 1, it->m_usbTransfer->actual_length);
[+] 				memcpy(it->m_inBufferPtr.m_p, it->m_buffer + 1, it->m_usbTransfer->actual_length);
[-] 			callCompletionFunc (it->m_completionFuncPtr, it->m_usbTransfer->actual_length);
[+] 			callCompletionFunc(it->m_completionFuncPtr, it->m_usbTransfer->actual_length);
[-] 			callCompletionFunc (it->m_completionFuncPtr, -1, err::SystemErrorCode_Cancelled);
[+] 			callCompletionFunc(it->m_completionFuncPtr, -1, err::SystemErrorCode_Cancelled);
[-] 			callCompletionFunc (it->m_completionFuncPtr, -1, axl::io::UsbError (LIBUSB_ERROR_IO));
[+] 			callCompletionFunc(it->m_completionFuncPtr, -1, axl::io::UsbError(LIBUSB_ERROR_IO));
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_transferPool.put (&transferList);
[+] 	m_transferPool.put(&transferList);
[-] 	if (isIdle ())
[+] 	if (isIdle())
[-] 		m_idleEvent.signal ();
[+] 		m_idleEvent.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] UsbAsyncControlEndpoint::callCompletionFunc (
[+] UsbAsyncControlEndpoint::callCompletionFunc(
[-] 	JNC_BEGIN_CALL_SITE (m_runtime)
[+] 	JNC_BEGIN_CALL_SITE(m_runtime)
[-] 		errorPtr = jnc::memDup (error, error->m_size);
[+] 		errorPtr = jnc::memDup(error, error->m_size);
[-] 	jnc::callVoidFunctionPtr (completionFuncPtr, resultSize, errorPtr);
[+] 	jnc::callVoidFunctionPtr(completionFuncPtr, resultSize, errorPtr);
[-] 	JNC_CALL_SITE_CATCH ()
[+] 	JNC_CALL_SITE_CATCH()
[-] 	AXL_TRACE ("USB completion func failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 	AXL_TRACE("USB completion func failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] UsbAsyncControlEndpoint::onTransferCompleted (libusb_transfer* usbTransfer)
[+] UsbAsyncControlEndpoint::onTransferCompleted(libusb_transfer* usbTransfer)
[-] 	Transfer* transfer = (Transfer*) usbTransfer->user_data;
[+] 	Transfer* transfer = (Transfer*)usbTransfer->user_data;
[-] 	ASSERT (transfer->m_usbTransfer == usbTransfer);
[+] 	ASSERT(transfer->m_usbTransfer == usbTransfer);
[-] 	self->m_lock.lock ();
[+] 	self->m_lock.lock();
[-] 	self->m_activeTransferList.remove (transfer);
[+] 	self->m_activeTransferList.remove(transfer);
[-] 	self->m_completedTransferList.insertTail (transfer);
[+] 	self->m_completedTransferList.insertTail(transfer);
[-] 	self->m_event.signal ();
[+] 	self->m_event.signal();
[-] 	self->m_lock.unlock ();
[+] 	self->m_lock.unlock();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbDesc.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbEndpointDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbEndpointDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbInterfaceDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbInterfaceDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbConfigurationDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbConfigurationDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbDeviceDesc)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbDeviceDesc)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] getUsbClassString (uint8_t cls)
[+] getUsbClassString(uint8_t cls)
[-] 	return jnc::strDup (axl::io::getUsbClassCodeString ((libusb_class_code) cls));
[+] 	return jnc::strDup(axl::io::getUsbClassCodeString((libusb_class_code)cls));
[-] getUsbSpeedString (libusb_speed speed)
[+] getUsbSpeedString(libusb_speed speed)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	const char* string = (uint_t) speed < countof (stringTable) ?
[+] 	const char* string = (uint_t)speed < countof(stringTable) ?
[-] 		stringTable [(uint_t) speed] :
[+] 		stringTable[(uint_t)speed] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] 	return jnc::strDup (string);
[+] 	return jnc::strDup(string);
[-] getUsbTransferTypeString (libusb_transfer_type type)
[+] getUsbTransferTypeString(libusb_transfer_type type)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	const char* string = (uint_t) type < countof (stringTable) ?
[+] 	const char* string = (uint_t)type < countof(stringTable) ?
[-] 		stringTable [(uint_t) type] :
[+] 		stringTable[(uint_t)type] :
[-] 	return jnc::strDup (string);
[+] 	return jnc::strDup(string);
[-] initUsbEndpointDesc (
[+] initUsbEndpointDesc(
[-] UsbInterfaceDesc::findEndpointDesc (uint8_t endpointId)
[+] UsbInterfaceDesc::findEndpointDesc(uint8_t endpointId)
[-] 		UsbEndpointDesc* endpointDesc = &((UsbEndpointDesc*) m_endpointTable.m_p) [i];
[+] 		UsbEndpointDesc* endpointDesc = &((UsbEndpointDesc*)m_endpointTable.m_p) [i];
[-] initUsbInterfaceDesc (
[+] initUsbInterfaceDesc(
[-] 	Type* endpointDescType = UsbEndpointDesc::getType (runtime->getModule ());
[+] 	Type* endpointDescType = UsbEndpointDesc::getType(runtime->getModule());
[-] 	dstDesc->m_endpointTable = runtime->getGcHeap ()->allocateArray (endpointDescType, srcDesc->bNumEndpoints);
[+] 	dstDesc->m_endpointTable = runtime->getGcHeap()->allocateArray(endpointDescType, srcDesc->bNumEndpoints);
[-] 	UsbEndpointDesc* dstEndpointDescTable = (UsbEndpointDesc*) dstDesc->m_endpointTable.m_p;
[+] 	UsbEndpointDesc* dstEndpointDescTable = (UsbEndpointDesc*)dstDesc->m_endpointTable.m_p;
[-] 		initUsbEndpointDesc (&dstEndpointDescTable [i], &srcDesc->endpoint [i]);
[+] 		initUsbEndpointDesc(&dstEndpointDescTable[i], &srcDesc->endpoint[i]);
[-] initUsbInterfaceDesc (
[+] initUsbInterfaceDesc(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	initUsbInterfaceDesc (runtime, dstDesc, &srcDesc->altsetting [0]);
[+] 	initUsbInterfaceDesc(runtime, dstDesc, &srcDesc->altsetting[0]);
[-] 	for (size_t i = 1; i < (size_t) srcDesc->num_altsetting; i++)
[+] 	for (size_t i = 1; i < (size_t)srcDesc->num_altsetting; i++)
[-] 		DataPtr descPtr = createData <UsbInterfaceDesc> (runtime);
[+] 		DataPtr descPtr = createData<UsbInterfaceDesc> (runtime);
[-] 		dstDesc = (UsbInterfaceDesc*) descPtr.m_p;
[+] 		dstDesc = (UsbInterfaceDesc*)descPtr.m_p;
[-] 		initUsbInterfaceDesc (runtime, dstDesc, &srcDesc->altsetting [i]);
[+] 		initUsbInterfaceDesc(runtime, dstDesc, &srcDesc->altsetting[i]);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] UsbConfigurationDesc::findInterfaceDesc (
[+] UsbConfigurationDesc::findInterfaceDesc(
[-] 	UsbInterfaceDesc* ifaceDesc = &((UsbInterfaceDesc*) m_interfaceTable.m_p) [interfaceId];
[+] 	UsbInterfaceDesc* ifaceDesc = &((UsbInterfaceDesc*)m_interfaceTable.m_p) [interfaceId];
[-] 		ifaceDesc = (UsbInterfaceDesc*) ifaceDesc->m_nextAltSettingInterfacePtr.m_p;
[+] 		ifaceDesc = (UsbInterfaceDesc*)ifaceDesc->m_nextAltSettingInterfacePtr.m_p;
[-] initUsbConfigurationDesc (
[+] initUsbConfigurationDesc(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	Type* ifaceDescType = UsbInterfaceDesc::getType (runtime->getModule ());
[+] 	Type* ifaceDescType = UsbInterfaceDesc::getType(runtime->getModule());
[-] 	dstDesc->m_interfaceTable = runtime->getGcHeap ()->allocateArray (ifaceDescType, srcDesc->bNumInterfaces);
[+] 	dstDesc->m_interfaceTable = runtime->getGcHeap()->allocateArray(ifaceDescType, srcDesc->bNumInterfaces);
[-] 	UsbInterfaceDesc* dstInterfaceDescTable = (UsbInterfaceDesc*) dstDesc->m_interfaceTable.m_p;
[+] 	UsbInterfaceDesc* dstInterfaceDescTable = (UsbInterfaceDesc*)dstDesc->m_interfaceTable.m_p;
[-] 		initUsbInterfaceDesc (runtime, &dstInterfaceDescTable [i], &srcDesc->interface [i]);
[+] 		initUsbInterfaceDesc(runtime, &dstInterfaceDescTable[i], &srcDesc->interface[i]);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] createUsbConfigurationDesc (
[+] createUsbConfigurationDesc(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	resultPtr = createData <UsbConfigurationDesc> (runtime);
[+] 	resultPtr = createData<UsbConfigurationDesc> (runtime);
[-] 	UsbConfigurationDesc* dstDesc = (UsbConfigurationDesc*) resultPtr.m_p;
[+] 	UsbConfigurationDesc* dstDesc = (UsbConfigurationDesc*)resultPtr.m_p;
[-] 	initUsbConfigurationDesc (runtime, dstDesc, srcDesc);
[+] 	initUsbConfigurationDesc(runtime, dstDesc, srcDesc);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] createUsbDeviceDesc (
[+] createUsbDeviceDesc(
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	resultPtr = createData <UsbDeviceDesc> (runtime);
[+] 	resultPtr = createData<UsbDeviceDesc> (runtime);
[-] 	UsbDeviceDesc* deviceDesc = (UsbDeviceDesc*) resultPtr.m_p;
[+] 	UsbDeviceDesc* deviceDesc = (UsbDeviceDesc*)resultPtr.m_p;
[-] 	Type* configDescType = UsbConfigurationDesc::getType (runtime->getModule ());
[+] 	Type* configDescType = UsbConfigurationDesc::getType(runtime->getModule());
[-] 	deviceDesc->m_configurationTable = runtime->getGcHeap ()->allocateArray (configDescType, srcDesc->bNumConfigurations);
[+] 	deviceDesc->m_configurationTable = runtime->getGcHeap()->allocateArray(configDescType, srcDesc->bNumConfigurations);
[-] 	UsbConfigurationDesc* dstConfigDescTable = (UsbConfigurationDesc*) deviceDesc->m_configurationTable.m_p;
[+] 	UsbConfigurationDesc* dstConfigDescTable = (UsbConfigurationDesc*)deviceDesc->m_configurationTable.m_p;
[-] 		bool result = srcDevice->getConfigDescriptor (i, &srcConfigDesc);
[+] 		bool result = srcDevice->getConfigDescriptor(i, &srcConfigDesc);
[-] 			initUsbConfigurationDesc (runtime, &dstConfigDescTable [i], srcConfigDesc);
[+] 			initUsbConfigurationDesc(runtime, &dstConfigDescTable[i], srcConfigDesc);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbDevice.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbDevice)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbDevice)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <UsbDevice>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<UsbDevice>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <UsbDevice>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<UsbDevice>)
[-] 	JNC_MAP_FUNCTION ("open",               &UsbDevice::open)
[+] 	JNC_MAP_FUNCTION("open",               &UsbDevice::open)
[-] 	JNC_MAP_FUNCTION ("close",              &UsbDevice::close)
[+] 	JNC_MAP_FUNCTION("close",              &UsbDevice::close)
[-] 	JNC_MAP_FUNCTION ("getStringDesc",      &UsbDevice::getStringDesc)
[+] 	JNC_MAP_FUNCTION("getStringDesc",      &UsbDevice::getStringDesc)
[-] 	JNC_MAP_FUNCTION ("attachKernelDriver", &UsbDevice::attachKernelDriver)
[+] 	JNC_MAP_FUNCTION("attachKernelDriver", &UsbDevice::attachKernelDriver)
[-] 	JNC_MAP_FUNCTION ("detachKernelDriver", &UsbDevice::detachKernelDriver)
[+] 	JNC_MAP_FUNCTION("detachKernelDriver", &UsbDevice::detachKernelDriver)
[-] 	JNC_MAP_FUNCTION ("claimInterface",     &UsbDevice::claimInterface)
[+] 	JNC_MAP_FUNCTION("claimInterface",     &UsbDevice::claimInterface)
[-] 	JNC_MAP_FUNCTION ("controlTransfer",    &UsbDevice::controlTransfer_0)
[+] 	JNC_MAP_FUNCTION("controlTransfer",    &UsbDevice::controlTransfer_0)
[-] 	JNC_MAP_OVERLOAD (&UsbDevice::controlTransfer_1)
[+] 	JNC_MAP_OVERLOAD(&UsbDevice::controlTransfer_1)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_isAutoDetachKernelDriverEnabled", &UsbDevice::setAutoDetachKernelDriverEnabled)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_isAutoDetachKernelDriverEnabled", &UsbDevice::setAutoDetachKernelDriverEnabled)
[-] 	JNC_MAP_CONST_PROPERTY ("m_isKernelDriverActive", &UsbDevice::isKernelDriverActive)
[+] 	JNC_MAP_CONST_PROPERTY("m_isKernelDriverActive", &UsbDevice::isKernelDriverActive)
[-] 	JNC_MAP_CONST_PROPERTY ("m_deviceDesc", &UsbDevice::getDeviceDesc)
[+] 	JNC_MAP_CONST_PROPERTY("m_deviceDesc", &UsbDevice::getDeviceDesc)
[-] 	JNC_MAP_CONST_PROPERTY ("m_activeConfigurationDesc", &UsbDevice::getActiveConfigurationDesc)
[+] 	JNC_MAP_CONST_PROPERTY("m_activeConfigurationDesc", &UsbDevice::getActiveConfigurationDesc)
[-] 	JNC_MAP_CONST_PROPERTY ("m_bus",        &UsbDevice::getBus)
[+] 	JNC_MAP_CONST_PROPERTY("m_bus",        &UsbDevice::getBus)
[-] 	JNC_MAP_CONST_PROPERTY ("m_address",    &UsbDevice::getAddress)
[+] 	JNC_MAP_CONST_PROPERTY("m_address",    &UsbDevice::getAddress)
[-] 	JNC_MAP_CONST_PROPERTY ("m_speed",      &UsbDevice::getSpeed)
[+] 	JNC_MAP_CONST_PROPERTY("m_speed",      &UsbDevice::getSpeed)
[-] 	JNC_MAP_PROPERTY ("m_configurationId",  &UsbDevice::getConfigurationId, &UsbDevice::setConfigurationId)
[+] 	JNC_MAP_PROPERTY("m_configurationId",  &UsbDevice::getConfigurationId, &UsbDevice::setConfigurationId)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] UsbDevice::UsbDevice ()
[+] UsbDevice::UsbDevice()
[-] UsbDevice::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] UsbDevice::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		m_asyncControlEndpoint->markOpaqueGcRoots (gcHeap);
[+] 		m_asyncControlEndpoint->markOpaqueGcRoots(gcHeap);
[-] UsbDevice::close ()
[+] UsbDevice::close()
[-] 		AXL_MEM_DELETE (m_asyncControlEndpoint);
[+] 		AXL_MEM_DELETE(m_asyncControlEndpoint);
[-] 	m_device.close ();
[+] 	m_device.close();
[-] UsbDevice::open ()
[+] UsbDevice::open()
[-] 	bool result = m_device.open ();
[+] 	bool result = m_device.open();
[-] UsbDevice::getDeviceDesc (UsbDevice* self)
[+] UsbDevice::getDeviceDesc(UsbDevice* self)
[-] 	bool result = self->m_device.getDeviceDescriptor (&desc);
[+] 	bool result = self->m_device.getDeviceDescriptor(&desc);
[-] 	return createUsbDeviceDesc (getCurrentThreadRuntime (), &desc, &self->m_device);
[+] 	return createUsbDeviceDesc(getCurrentThreadRuntime(), &desc, &self->m_device);
[-] UsbDevice::getActiveConfigurationDesc (UsbDevice* self)
[+] UsbDevice::getActiveConfigurationDesc(UsbDevice* self)
[-] 	bool result = self->m_device.getActiveConfigDescriptor (&desc);
[+] 	bool result = self->m_device.getActiveConfigDescriptor(&desc);
[-] 	return createUsbConfigurationDesc (getCurrentThreadRuntime (), desc);
[+] 	return createUsbConfigurationDesc(getCurrentThreadRuntime(), desc);
[-] UsbDevice::getStringDesc (
[+] UsbDevice::getStringDesc(
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	sl::String string = self->m_device.getStringDesrciptor (stringId);
[+] 	sl::String string = self->m_device.getStringDesrciptor(stringId);
[-] 	return strDup (string, string.getLength ());
[+] 	return strDup(string, string.getLength());
[-] UsbDevice::claimInterface (
[+] UsbDevice::claimInterface(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	bool result = m_device.claimInterface (interfaceId);
[+] 	bool result = m_device.claimInterface(interfaceId);
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = runtime->getGcHeap();
[-] 	DataPtr configDescPtr = getActiveConfigurationDesc (this);
[+] 	DataPtr configDescPtr = getActiveConfigurationDesc(this);
[-] 	UsbConfigurationDesc* configDesc = (UsbConfigurationDesc*) configDescPtr.m_p;
[+] 	UsbConfigurationDesc* configDesc = (UsbConfigurationDesc*)configDescPtr.m_p;
[-] 	UsbInterfaceDesc* ifaceDesc = configDesc->findInterfaceDesc (interfaceId, altSettingId);
[+] 	UsbInterfaceDesc* ifaceDesc = configDesc->findInterfaceDesc(interfaceId, altSettingId);
[-] 		err::setError (err::SystemErrorCode_ObjectNameNotFound);
[+] 		err::setError(err::SystemErrorCode_ObjectNameNotFound);
[-] 		iface = createClass <UsbInterface> (runtime);
[+] 		iface = createClass<UsbInterface> (runtime);
[-] 		iface->m_interfaceDescPtr.m_validator = runtime->getGcHeap ()->createDataPtrValidator (
[+] 		iface->m_interfaceDescPtr.m_validator = runtime->getGcHeap()->createDataPtrValidator(
[-] 			sizeof (UsbInterfaceDesc)
[+] 			sizeof(UsbInterfaceDesc)
[-] 	gcHeap->leaveNoCollectRegion (false);
[+] 	gcHeap->leaveNoCollectRegion(false);
[-] UsbDevice::controlTransfer_0 (
[+] UsbDevice::controlTransfer_0(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 	return m_device.controlTransfer (requestType, requestCode, value, index, ptr.m_p, size, timeout);
[+] 	return m_device.controlTransfer(requestType, requestCode, value, index, ptr.m_p, size, timeout);
[-] UsbDevice::controlTransfer_1 (
[+] UsbDevice::controlTransfer_1(
[-] 		jnc::setError (err::Error (err::SystemErrorCode_InvalidDeviceState));
[+] 		jnc::setError(err::Error(err::SystemErrorCode_InvalidDeviceState));
[-] 		UsbAsyncControlEndpoint* endpoint = AXL_MEM_NEW_ARGS (UsbAsyncControlEndpoint, (&m_device));
[+] 		UsbAsyncControlEndpoint* endpoint = AXL_MEM_NEW_ARGS(UsbAsyncControlEndpoint, (&m_device));
[-] 		bool result = endpoint->start ();
[+] 		bool result = endpoint->start();
[-] 			AXL_MEM_DELETE (endpoint);
[+] 			AXL_MEM_DELETE(endpoint);
[-] 	return m_asyncControlEndpoint->transfer (
[+] 	return m_asyncControlEndpoint->transfer(
[-] UsbDevice::cancelControlTransfers ()
[+] UsbDevice::cancelControlTransfers()
[-] 		m_asyncControlEndpoint->cancelTransfers ();
[+] 		m_asyncControlEndpoint->cancelTransfers();
[-] createUsbDeviceArray (DataPtr countPtr)
[+] createUsbDeviceArray(DataPtr countPtr)
[-] 	size_t count = deviceList.enumerateDevices ();
[+] 	size_t count = deviceList.enumerateDevices();
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = runtime->getGcHeap();
[-] 	Type* classPtrType = (Type*) UsbDevice::getType (runtime->getModule ())->getClassPtrType ();
[+] 	Type* classPtrType = (Type*)UsbDevice::getType(runtime->getModule())->getClassPtrType();
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	arrayPtr = gcHeap->allocateArray (classPtrType, count);
[+] 	arrayPtr = gcHeap->allocateArray(classPtrType, count);
[-] 		UsbDevice* device = createClass <UsbDevice> (runtime);
[+] 		UsbDevice* device = createClass<UsbDevice> (runtime);
[-] 		device->setDevice (srcDeviceArray [i]);
[+] 		device->setDevice(srcDeviceArray[i]);
[-] 		dstDeviceArray [i] = device;
[+] 		dstDeviceArray[i] = device;
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] 		*(size_t*) countPtr.m_p = count;
[+] 		*(size_t*)countPtr.m_p = count;
[-] openUsbDevice (
[+] openUsbDevice(
[-] 	bool result = srcDevice.open (vendorId, productId);
[+] 	bool result = srcDevice.open(vendorId, productId);
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	device = createClass <UsbDevice> (runtime);
[+] 	device = createClass<UsbDevice> (runtime);
[-] 	device->takeOver (&srcDevice);
[+] 	device->takeOver(&srcDevice);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbEndpoint.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbEndpoint)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbEndpoint)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <UsbEndpoint>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<UsbEndpoint>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <UsbEndpoint>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<UsbEndpoint>)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_transferTimeout", &UsbEndpoint::setTransferTimeout)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_transferTimeout", &UsbEndpoint::setTransferTimeout)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readParallelism", &UsbEndpoint::setReadParallelism)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readParallelism", &UsbEndpoint::setReadParallelism)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBlockSize",   &UsbEndpoint::setReadBlockSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBlockSize",   &UsbEndpoint::setReadBlockSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_readBufferSize",  &UsbEndpoint::setReadBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_readBufferSize",  &UsbEndpoint::setReadBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_writeBufferSize", &UsbEndpoint::setWriteBufferSize)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_writeBufferSize", &UsbEndpoint::setWriteBufferSize)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_options",         &UsbEndpoint::setOptions)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_options",         &UsbEndpoint::setOptions)
[-] 	JNC_MAP_FUNCTION ("close",        &UsbEndpoint::close)
[+] 	JNC_MAP_FUNCTION("close",        &UsbEndpoint::close)
[-] 	JNC_MAP_FUNCTION ("write",        &UsbEndpoint::write)
[+] 	JNC_MAP_FUNCTION("write",        &UsbEndpoint::write)
[-] 	JNC_MAP_FUNCTION ("read",         &UsbEndpoint::read)
[+] 	JNC_MAP_FUNCTION("read",         &UsbEndpoint::read)
[-] 	JNC_MAP_FUNCTION ("wait",         &UsbEndpoint::wait)
[+] 	JNC_MAP_FUNCTION("wait",         &UsbEndpoint::wait)
[-] 	JNC_MAP_FUNCTION ("cancelWait",   &UsbEndpoint::cancelWait)
[+] 	JNC_MAP_FUNCTION("cancelWait",   &UsbEndpoint::cancelWait)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &UsbEndpoint::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &UsbEndpoint::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] UsbEndpoint::UsbEndpoint ()
[+] UsbEndpoint::UsbEndpoint()
[-] 	m_readBuffer.setBufferSize (Def_ReadBufferSize);
[+] 	m_readBuffer.setBufferSize(Def_ReadBufferSize);
[-] 	m_writeBuffer.setBufferSize (Def_WriteBufferSize);
[+] 	m_writeBuffer.setBufferSize(Def_WriteBufferSize);
[-] UsbEndpoint::open ()
[+] UsbEndpoint::open()
[-] 	AsyncIoDevice::open ();
[+] 	AsyncIoDevice::open();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	return m_ioThread.start ();
[+] 	return m_ioThread.start();
[-] UsbEndpoint::close ()
[+] UsbEndpoint::close()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	wakeIoThread ();
[+] 	wakeIoThread();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_ioThread.waitAndClose ();
[+] 	m_ioThread.waitAndClose();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	AsyncIoDevice::close ();
[+] 	AsyncIoDevice::close();
[-] UsbEndpoint::read (
[+] UsbEndpoint::read(
[-] 	if (isOutEndpoint ())
[+] 	if (isOutEndpoint())
[-] 		err::setError ("Cannot read from a USB OUT-endpoint");
[+] 		err::setError("Cannot read from a USB OUT-endpoint");
[-] 	return bufferedRead (ptr, size);
[+] 	return bufferedRead(ptr, size);
[-] UsbEndpoint::write (
[+] UsbEndpoint::write(
[-] 	if (isInEndpoint ())
[+] 	if (isInEndpoint())
[-] 		err::setError ("Cannot write to a USB IN-endpoint");
[+] 		err::setError("Cannot write to a USB IN-endpoint");
[-] 	size_t result = bufferedWrite (ptr, size);
[+] 	size_t result = bufferedWrite(ptr, size);
[-] 	AXL_TODO ("combine into a single atomic operation (need to implement AsyncIoDevice::bufferWriteImpl_l)")
[+] 	AXL_TODO("combine into a single atomic operation (need to implement AsyncIoDevice::bufferWriteImpl_l)")
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (!m_writeBuffer.isEmpty () || !m_activeTransferList.isEmpty ())
[+] 	if (!m_writeBuffer.isEmpty() || !m_activeTransferList.isEmpty())
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] UsbEndpoint::ioThreadFunc ()
[+] UsbEndpoint::ioThreadFunc()
[-] 	if (isInEndpoint ())
[+] 	if (isInEndpoint())
[-] 		readLoop ();
[+] 		readLoop();
[-] 		writeLoop ();
[+] 		writeLoop();
[-] 	cancelAllActiveTransfers ();
[+] 	cancelAllActiveTransfers();
[-] UsbEndpoint::cancelAllActiveTransfers ()
[+] UsbEndpoint::cancelAllActiveTransfers()
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Transfer*> activeTransferArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Transfer*> activeTransferArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::Iterator <Transfer> it = m_activeTransferList.getHead ();
[+] 	sl::Iterator<Transfer> it = m_activeTransferList.getHead();
[-] 		activeTransferArray.append (*it);
[+] 		activeTransferArray.append(*it);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	size_t count = activeTransferArray.getCount ();
[+] 	size_t count = activeTransferArray.getCount();
[-] 		activeTransferArray [i]->m_usbTransfer.cancel (); // may fail if already completed
[+] 		activeTransferArray[i]->m_usbTransfer.cancel(); // may fail if already completed
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	while (!m_activeTransferList.isEmpty ())
[+] 	while (!m_activeTransferList.isEmpty())
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		sleepIoThread ();
[+] 		sleepIoThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 	while (!m_completedTransferList.isEmpty ())
[+] 	while (!m_completedTransferList.isEmpty())
[-] 		Transfer* transfer = m_completedTransferList.removeHead ();
[+] 		Transfer* transfer = m_completedTransferList.removeHead();
[-] 		m_transferPool.put (transfer);
[+] 		m_transferPool.put(transfer);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] UsbEndpoint::readLoop ()
[+] UsbEndpoint::readLoop()
[-] 	ASSERT (isInEndpoint ());
[+] 	ASSERT(isInEndpoint());
[-] 	UsbEndpointDesc* desc = (UsbEndpointDesc*) m_endpointDescPtr.m_p;
[+] 	UsbEndpointDesc* desc = (UsbEndpointDesc*)m_endpointDescPtr.m_p;
[-] 		sleepIoThread ();
[+] 		sleepIoThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		while (!m_completedTransferList.isEmpty ())
[+] 		while (!m_completedTransferList.isEmpty())
[-] 			Transfer* transfer = m_completedTransferList.removeHead ();
[+] 			Transfer* transfer = m_completedTransferList.removeHead();
[-] 				m_transferPool.put (transfer);
[+] 				m_transferPool.put(transfer);
[-] 				setIoErrorEvent_l (axl::io::UsbError (LIBUSB_ERROR_IO));
[+] 				setIoErrorEvent_l(axl::io::UsbError(LIBUSB_ERROR_IO));
[-] 			addToReadBuffer (transfer->m_buffer, transfer->m_usbTransfer->actual_length);
[+] 			addToReadBuffer(transfer->m_buffer, transfer->m_usbTransfer->actual_length);
[-] 			m_transferPool.put (transfer);
[+] 			m_transferPool.put(transfer);
[-] 		size_t activeReadCount = m_activeTransferList.getCount ();
[+] 		size_t activeReadCount = m_activeTransferList.getCount();
[-] 		if (!m_readBuffer.isFull () && activeReadCount < m_readParallelism)
[+] 		if (!m_readBuffer.isFull() && activeReadCount < m_readParallelism)
[-] 			UsbEndpointDesc* endpointDesc = (UsbEndpointDesc*) m_endpointDescPtr.m_p;
[+] 			UsbEndpointDesc* endpointDesc = (UsbEndpointDesc*)m_endpointDescPtr.m_p;
[-] 				Transfer* transfer = m_transferPool.get ();
[+] 				Transfer* transfer = m_transferPool.get();
[-] 				result = transfer->m_buffer.setCount (readBlockSize);
[+] 				result = transfer->m_buffer.setCount(readBlockSize);
[-] 					m_transferPool.put (transfer);
[+] 					m_transferPool.put(transfer);
[-] 					setIoErrorEvent_l ();
[+] 					setIoErrorEvent_l();
[-] 				m_activeTransferList.insertTail (transfer); // put it on active list prior to submission
[+] 				m_activeTransferList.insertTail(transfer); // put it on active list prior to submission
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 				result = submitTransfer (transfer, transfer->m_buffer, transfer->m_buffer.getCount (), timeout);
[+] 				result = submitTransfer(transfer, transfer->m_buffer, transfer->m_buffer.getCount(), timeout);
[-] 				m_lock.lock ();
[+] 				m_lock.lock();
[-] 					m_activeTransferList.remove (transfer);
[+] 					m_activeTransferList.remove(transfer);
[-] 					m_transferPool.put (transfer);
[+] 					m_transferPool.put(transfer);
[-] 					setIoErrorEvent_l ();
[+] 					setIoErrorEvent_l();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] UsbEndpoint::writeLoop ()
[+] UsbEndpoint::writeLoop()
[-] 	ASSERT (isOutEndpoint ());
[+] 	ASSERT(isOutEndpoint());
[-] 		sleepIoThread ();
[+] 		sleepIoThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 		if (!m_completedTransferList.isEmpty ())
[+] 		if (!m_completedTransferList.isEmpty())
[-] 			Transfer* transfer = m_completedTransferList.removeHead ();
[+] 			Transfer* transfer = m_completedTransferList.removeHead();
[-] 				m_transferPool.put (transfer);
[+] 				m_transferPool.put(transfer);
[-] 				setIoErrorEvent_l (axl::io::UsbError (LIBUSB_ERROR_IO));
[+] 				setIoErrorEvent_l(axl::io::UsbError(LIBUSB_ERROR_IO));
[-] 			if ((size_t) transfer->m_usbTransfer->actual_length < m_writeBlock.getCount ()) // shouldn't happen, actually
[+] 			if ((size_t)transfer->m_usbTransfer->actual_length < m_writeBlock.getCount()) // shouldn't happen, actually
[-] 				m_writeBlock.remove (0, transfer->m_usbTransfer->actual_length);
[+] 				m_writeBlock.remove(0, transfer->m_usbTransfer->actual_length);
[-] 				m_writeBlock.clear ();
[+] 				m_writeBlock.clear();
[-] 			m_transferPool.put (transfer);
[+] 			m_transferPool.put(transfer);
[-] 			ASSERT (m_completedTransferList.isEmpty ()); // we never submit more than one
[+] 			ASSERT(m_completedTransferList.isEmpty()); // we never submit more than one
[-] 		getNextWriteBlock (&m_writeBlock);
[+] 		getNextWriteBlock(&m_writeBlock);
[-] 		if (m_activeTransferList.isEmpty () && !m_writeBlock.isEmpty ())
[+] 		if (m_activeTransferList.isEmpty() && !m_writeBlock.isEmpty())
[-] 			Transfer* transfer = m_transferPool.get ();
[+] 			Transfer* transfer = m_transferPool.get();
[-] 			m_activeTransferList.insertTail (transfer); // put it on active list prior to submission
[+] 			m_activeTransferList.insertTail(transfer); // put it on active list prior to submission
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			result = submitTransfer (transfer, m_writeBlock, m_writeBlock.getCount (), timeout);
[+] 			result = submitTransfer(transfer, m_writeBlock, m_writeBlock.getCount(), timeout);
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_activeTransferList.remove (transfer);
[+] 				m_activeTransferList.remove(transfer);
[-] 				m_transferPool.put (transfer);
[+] 				m_transferPool.put(transfer);
[-] 				setIoErrorEvent_l ();
[+] 				setIoErrorEvent_l();
[-] 		updateReadWriteBufferEvents ();
[+] 		updateReadWriteBufferEvents();
[-] 		if (m_writeBuffer.isEmpty () && m_activeTransferList.isEmpty ())
[+] 		if (m_writeBuffer.isEmpty() && m_activeTransferList.isEmpty())
[-] 			processWaitLists_l ();
[+] 			processWaitLists_l();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] UsbEndpoint::submitTransfer (
[+] UsbEndpoint::submitTransfer(
[-] 	UsbEndpointDesc* desc = (UsbEndpointDesc*) m_endpointDescPtr.m_p;
[+] 	UsbEndpointDesc* desc = (UsbEndpointDesc*)m_endpointDescPtr.m_p;
[-] 	bool result = transfer->m_usbTransfer.create ();
[+] 	bool result = transfer->m_usbTransfer.create();
[-] 	axl::io::UsbDevice* device = m_parentInterface->m_parentDevice->getDevice ();
[+] 	axl::io::UsbDevice* device = m_parentInterface->m_parentDevice->getDevice();
[-] 	switch (desc->m_transferType)
[+] 	switch(desc->m_transferType)
[-] 		transfer->m_usbTransfer.fillBulkTransfer (
[+] 		transfer->m_usbTransfer.fillBulkTransfer(
[-] 			device->getOpenHandle (),
[+] 			device->getOpenHandle(),
[-] 		transfer->m_usbTransfer.fillInterruptTransfer (
[+] 		transfer->m_usbTransfer.fillInterruptTransfer(
[-] 			device->getOpenHandle (),
[+] 			device->getOpenHandle(),
[-] 		err::setError (err::SystemErrorCode_NotImplemented);
[+] 		err::setError(err::SystemErrorCode_NotImplemented);
[-] 	return transfer->m_usbTransfer.submit ();
[+] 	return transfer->m_usbTransfer.submit();
[-] UsbEndpoint::onTransferCompleted (libusb_transfer* usbTransfer)
[+] UsbEndpoint::onTransferCompleted(libusb_transfer* usbTransfer)
[-] 	Transfer* transfer = (Transfer*) usbTransfer->user_data;
[+] 	Transfer* transfer = (Transfer*)usbTransfer->user_data;
[-] 	ASSERT (transfer->m_usbTransfer == usbTransfer);
[+] 	ASSERT(transfer->m_usbTransfer == usbTransfer);
[-] 	self->m_lock.lock ();
[+] 	self->m_lock.lock();
[-] 	if (transfer != *self->m_activeTransferList.getHead ())
[+] 	if (transfer != *self->m_activeTransferList.getHead())
[-] 			self->m_activeTransferList.remove (transfer);
[+] 			self->m_activeTransferList.remove(transfer);
[-] 			self->m_completedTransferList.insertTail (transfer);
[+] 			self->m_completedTransferList.insertTail(transfer);
[-] 			transfer = *self->m_activeTransferList.getHead ();
[+] 			transfer = *self->m_activeTransferList.getHead();
[-] 		self->wakeIoThread ();
[+] 		self->wakeIoThread();
[-] 	self->m_lock.unlock ();
[+] 	self->m_lock.unlock();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbInterface.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (UsbInterface)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(UsbInterface)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <UsbInterface>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<UsbInterface>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <UsbInterface>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<UsbInterface>)
[-] 	JNC_MAP_FUNCTION ("release", &UsbInterface::release)
[+] 	JNC_MAP_FUNCTION("release", &UsbInterface::release)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] UsbInterface::UsbInterface ()
[+] UsbInterface::UsbInterface()
[-] UsbInterface::release ()
[+] UsbInterface::release()
[-] 	UsbInterfaceDesc* interfaceDesc = (UsbInterfaceDesc*) m_interfaceDescPtr.m_p;
[+] 	UsbInterfaceDesc* interfaceDesc = (UsbInterfaceDesc*)m_interfaceDescPtr.m_p;
[-] 	bool result = m_parentDevice->m_device.releaseInterface (interfaceDesc->m_interfaceId);
[+] 	bool result = m_parentDevice->m_device.releaseInterface(interfaceDesc->m_interfaceId);
[-] UsbInterface::openEndpoint (uint8_t endpointId)
[+] UsbInterface::openEndpoint(uint8_t endpointId)
[-] 	UsbInterfaceDesc* interfaceDesc = (UsbInterfaceDesc*) m_interfaceDescPtr.m_p;
[+] 	UsbInterfaceDesc* interfaceDesc = (UsbInterfaceDesc*)m_interfaceDescPtr.m_p;
[-] 	UsbEndpointDesc* endpointDesc = interfaceDesc->findEndpointDesc (endpointId);
[+] 	UsbEndpointDesc* endpointDesc = interfaceDesc->findEndpointDesc(endpointId);
[-] 		err::setError (err::SystemErrorCode_ObjectNameNotFound);
[+] 		err::setError(err::SystemErrorCode_ObjectNameNotFound);
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = runtime->getGcHeap();
[-] 	UsbEndpoint* endpoint = createClass <UsbEndpoint> (runtime);
[+] 	UsbEndpoint* endpoint = createClass<UsbEndpoint> (runtime);
[-] 	endpoint->m_endpointDescPtr.m_validator = runtime->getGcHeap ()->createDataPtrValidator (
[+] 	endpoint->m_endpointDescPtr.m_validator = runtime->getGcHeap()->createDataPtrValidator(
[-] 		sizeof (UsbEndpointDesc)
[+] 		sizeof(UsbEndpointDesc)
[-] 	gcHeap->leaveNoCollectRegion (false);
[+] 	gcHeap->leaveNoCollectRegion(false);
[-] 	endpoint->open ();
[+] 	endpoint->open();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbLib.cpp
----------------------
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (UsbLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(UsbLib)
[-] 	JNC_LIB_IMPORT ("io_UsbDevice.jnc")
[+] 	JNC_LIB_IMPORT("io_UsbDevice.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (UsbLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(UsbLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (UsbEndpoint)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(UsbEndpoint)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (UsbInterface)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(UsbInterface)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (UsbDevice)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(UsbDevice)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (UsbLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(UsbLib)
[-] 	JNC_MAP_TYPE (UsbEndpoint)
[+] 	JNC_MAP_TYPE(UsbEndpoint)
[-] 	JNC_MAP_TYPE (UsbInterface)
[+] 	JNC_MAP_TYPE(UsbInterface)
[-] 	JNC_MAP_TYPE (UsbDevice)
[+] 	JNC_MAP_TYPE(UsbDevice)
[-] 	JNC_MAP_FUNCTION ("io.getUsbClassString", &getUsbClassString)
[+] 	JNC_MAP_FUNCTION("io.getUsbClassString", &getUsbClassString)
[-] 	JNC_MAP_FUNCTION ("io.getUsbSpeedString", &getUsbSpeedString)
[+] 	JNC_MAP_FUNCTION("io.getUsbSpeedString", &getUsbSpeedString)
[-] 	JNC_MAP_FUNCTION ("io.getUsbTransferTypeString", &getUsbTransferTypeString)
[+] 	JNC_MAP_FUNCTION("io.getUsbTransferTypeString", &getUsbTransferTypeString)
[-] 	JNC_MAP_FUNCTION ("io.createUsbDeviceArray", &createUsbDeviceArray)
[+] 	JNC_MAP_FUNCTION("io.createUsbDeviceArray", &createUsbDeviceArray)
[-] 	JNC_MAP_FUNCTION ("io.openUsbDevice", &openUsbDevice)
[+] 	JNC_MAP_FUNCTION("io.openUsbDevice", &openUsbDevice)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] jncDynamicExtensionLibMain (jnc_DynamicExtensionLibHost* host)
[+] jncDynamicExtensionLibMain(jnc_DynamicExtensionLibHost* host)
[-] 	g::getModule ()->setTag ("jnc_io_usb");
[+] 	g::getModule()->setTag("jnc_io_usb");
[-] 	err::getErrorMgr ()->setForwardRouter (host->m_errorRouter);
[+] 	err::getErrorMgr()->setForwardRouter(host->m_errorRouter);
[-] 	axl::io::registerUsbErrorProvider ();
[+] 	axl::io::registerUsbErrorProvider();
[-] 	axl::io::getUsbDefaultContext ()->createDefault ();
[+] 	axl::io::getUsbDefaultContext()->createDefault();
[-] 	axl::io::getUsbDefaultContextEventThread ()->start ();
[+] 	axl::io::getUsbDefaultContextEventThread()->start();
[-] 	return jnc::io::UsbLib_getLib ();
[+] 	return jnc::io::UsbLib_getLib();
[-] jncDynamicExtensionLibUnload ()
[+] jncDynamicExtensionLibUnload()
[-] 	axl::io::getUsbDefaultContextEventThread ()->stop ();
[+] 	axl::io::getUsbDefaultContextEventThread()->stop();
[-] 	axl::io::getUsbDefaultContext ()->close ();
[+] 	axl::io::getUsbDefaultContext()->close();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbAsyncControlEndpoint.h
----------------------
[-] 		axl::ref::Buf <libusb_control_setup> m_buffer;
[+] 		axl::ref::Buf<libusb_control_setup> m_buffer;
[-] 	class CompletionThread: public sys::ThreadImpl <CompletionThread>
[+] 	class CompletionThread: public sys::ThreadImpl<CompletionThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, UsbAsyncControlEndpoint, m_completionThread)->completionThreadFunc ();
[+] 			containerof(this, UsbAsyncControlEndpoint, m_completionThread)->completionThreadFunc();
[-] 	mem::Pool <Transfer> m_transferPool;
[+] 	mem::Pool<Transfer> m_transferPool;
[-] 	sl::List <Transfer> m_activeTransferList;
[+] 	sl::List<Transfer> m_activeTransferList;
[-] 	sl::List <Transfer> m_completedTransferList;
[+] 	sl::List<Transfer> m_completedTransferList;
[-] 	UsbAsyncControlEndpoint (axl::io::UsbDevice* device);
[+] 	UsbAsyncControlEndpoint(axl::io::UsbDevice* device);
[-] 	~UsbAsyncControlEndpoint ()
[+] 	~UsbAsyncControlEndpoint()
[-] 		stop ();
[+] 		stop();
[-] 	start ();
[+] 	start();
[-] 	stop ();
[+] 	stop();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	transfer (
[+] 	transfer(
[-] 	cancelTransfers ();
[+] 	cancelTransfers();
[-] 	isIdle ()
[+] 	isIdle()
[-] 		return m_activeTransferList.isEmpty () && m_completedTransferList.isEmpty ();
[+] 		return m_activeTransferList.isEmpty() && m_completedTransferList.isEmpty();
[-] 	markTransferGcRoots (
[+] 	markTransferGcRoots(
[-] 	completionThreadFunc ();
[+] 	completionThreadFunc();
[-] 	cancelAllActiveTransfers_l ();
[+] 	cancelAllActiveTransfers_l();
[-] 	finalizeTransfers_l ();
[+] 	finalizeTransfers_l();
[-] 	callCompletionFunc (
[+] 	callCompletionFunc(
[-] 		const err::ErrorRef& error = err::ErrorRef ()
[+] 		const err::ErrorRef& error = err::ErrorRef()
[-] 	onTransferCompleted (libusb_transfer* transfer);
[+] 	onTransferCompleted(libusb_transfer* transfer);
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbDesc.h
----------------------
[-] JNC_DECLARE_TYPE (UsbEndpointDesc)
[+] JNC_DECLARE_TYPE(UsbEndpointDesc)
[-] JNC_DECLARE_TYPE (UsbInterfaceDesc)
[+] JNC_DECLARE_TYPE(UsbInterfaceDesc)
[-] JNC_DECLARE_TYPE (UsbConfigurationDesc)
[+] JNC_DECLARE_TYPE(UsbConfigurationDesc)
[-] JNC_DECLARE_TYPE (UsbDeviceDesc)
[+] JNC_DECLARE_TYPE(UsbDeviceDesc)
[-] getUsbClassString (uint8_t cls);
[+] getUsbClassString(uint8_t cls);
[-] getUsbSpeedString (libusb_speed speed);
[+] getUsbSpeedString(libusb_speed speed);
[-] getUsbTransferTypeString (libusb_transfer_type type);
[+] getUsbTransferTypeString(libusb_transfer_type type);
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (UsbEndpointDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(UsbEndpointDesc)
[-] initUsbEndpointDesc (
[+] initUsbEndpointDesc(
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (UsbInterfaceDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(UsbInterfaceDesc)
[-] 	findEndpointDesc (uint8_t endpointId);
[+] 	findEndpointDesc(uint8_t endpointId);
[-] initUsbInterfaceDesc (
[+] initUsbInterfaceDesc(
[-] initUsbInterfaceDesc (
[+] initUsbInterfaceDesc(
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (UsbConfigurationDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(UsbConfigurationDesc)
[-] 	findInterfaceDesc (
[+] 	findInterfaceDesc(
[-] initUsbConfigurationDesc (
[+] initUsbConfigurationDesc(
[-] createUsbConfigurationDesc (
[+] createUsbConfigurationDesc(
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (UsbDeviceDesc)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(UsbDeviceDesc)
[-] createUsbDeviceDesc (
[+] createUsbDeviceDesc(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbDevice.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (UsbDevice)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(UsbDevice)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (UsbDevice)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(UsbDevice)
[-] 	UsbDevice ();
[+] 	UsbDevice();
[-] 	~UsbDevice ()
[+] 	~UsbDevice()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	getDevice ()
[+] 	getDevice()
[-] 	setDevice (libusb_device* srcDevice)
[+] 	setDevice(libusb_device* srcDevice)
[-] 		m_device.setDevice (srcDevice);
[+] 		m_device.setDevice(srcDevice);
[-] 	takeOver (axl::io::UsbDevice* srcDevice)
[+] 	takeOver(axl::io::UsbDevice* srcDevice)
[-] 		m_isOpen = srcDevice->isOpen ();
[+] 		m_isOpen = srcDevice->isOpen();
[-] 		sl::takeOver (&m_device, srcDevice);
[+] 		sl::takeOver(&m_device, srcDevice);
[-] 	close ();
[+] 	close();
[-] 	open ();
[+] 	open();
[-] 	getDeviceDesc (UsbDevice* self);
[+] 	getDeviceDesc(UsbDevice* self);
[-] 	getActiveConfigurationDesc (UsbDevice* self);
[+] 	getActiveConfigurationDesc(UsbDevice* self);
[-] 	getConfigurationId ()
[+] 	getConfigurationId()
[-] 		return m_isOpen ? m_device.getConfiguration () : 0;
[+] 		return m_isOpen ? m_device.getConfiguration() : 0;
[-] 	setConfigurationId (uint8_t configurationId)
[+] 	setConfigurationId(uint8_t configurationId)
[-] 		return m_isOpen ? m_device.setConfiguration (configurationId) : false;
[+] 		return m_isOpen ? m_device.setConfiguration(configurationId) : false;
[-] 	getBus ()
[+] 	getBus()
[-] 		return m_device.getBusNumber ();
[+] 		return m_device.getBusNumber();
[-] 	getAddress ()
[+] 	getAddress()
[-] 		return m_device.getDeviceAddress ();
[+] 		return m_device.getDeviceAddress();
[-] 	getSpeed ()
[+] 	getSpeed()
[-] 		return m_device.getDeviceSpeed ();
[+] 		return m_device.getDeviceSpeed();
[-] 	getStringDesc (
[+] 	getStringDesc(
[-] 	setAutoDetachKernelDriverEnabled (bool isEnabled)
[+] 	setAutoDetachKernelDriverEnabled(bool isEnabled)
[-] 		return m_device.setAutoDetachKernelDriver (isEnabled);
[+] 		return m_device.setAutoDetachKernelDriver(isEnabled);
[-] 	isKernelDriverActive (uint_t interfaceId)
[+] 	isKernelDriverActive(uint_t interfaceId)
[-] 		return m_device.isKernelDriverActive (interfaceId);
[+] 		return m_device.isKernelDriverActive(interfaceId);
[-] 	attachKernelDriver (uint_t interfaceId)
[+] 	attachKernelDriver(uint_t interfaceId)
[-] 		return m_device.attachKernelDriver (interfaceId);
[+] 		return m_device.attachKernelDriver(interfaceId);
[-] 	detachKernelDriver (uint_t interfaceId)
[+] 	detachKernelDriver(uint_t interfaceId)
[-] 		return m_device.detachKernelDriver (interfaceId);
[+] 		return m_device.detachKernelDriver(interfaceId);
[-] 	claimInterface (
[+] 	claimInterface(
[-] 	controlTransfer_0 (
[+] 	controlTransfer_0(
[-] 	controlTransfer_1 (
[+] 	controlTransfer_1(
[-] 	cancelControlTransfers ();
[+] 	cancelControlTransfers();
[-] createUsbDeviceArray (DataPtr countPtr);
[+] createUsbDeviceArray(DataPtr countPtr);
[-] openUsbDevice (
[+] openUsbDevice(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbEndpoint.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (UsbEndpoint)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(UsbEndpoint)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (UsbEndpoint)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(UsbEndpoint)
[-] 	class IoThread: public sys::ThreadImpl <IoThread>
[+] 	class IoThread: public sys::ThreadImpl<IoThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, UsbEndpoint, m_ioThread)->ioThreadFunc ();
[+] 			containerof(this, UsbEndpoint, m_ioThread)->ioThreadFunc();
[-] 		sl::Array <char> m_buffer;
[+] 		sl::Array<char> m_buffer;
[-] 	mem::Pool <Transfer> m_transferPool;
[+] 	mem::Pool<Transfer> m_transferPool;
[-] 	sl::List <Transfer> m_activeTransferList;
[+] 	sl::List<Transfer> m_activeTransferList;
[-] 	sl::List <Transfer> m_completedTransferList;
[+] 	sl::List<Transfer> m_completedTransferList;
[-] 	sl::Array <char> m_writeBlock;
[+] 	sl::Array<char> m_writeBlock;
[-] 	UsbEndpoint ();
[+] 	UsbEndpoint();
[-] 	~UsbEndpoint ()
[+] 	~UsbEndpoint()
[-] 		close ();
[+] 		close();
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] 		AsyncIoDevice::markOpaqueGcRoots (gcHeap);
[+] 		AsyncIoDevice::markOpaqueGcRoots(gcHeap);
[-] 	open ();
[+] 	open();
[-] 	close ();
[+] 	close();
[-] 	setTransferTimeout (uint_t timeout)
[+] 	setTransferTimeout(uint_t timeout)
[-] 		AsyncIoDevice::setSetting (&m_transferTimeout, timeout ? timeout : Def_TransferTimeout);
[+] 		AsyncIoDevice::setSetting(&m_transferTimeout, timeout ? timeout : Def_TransferTimeout);
[-] 	setReadParallelism (uint_t count)
[+] 	setReadParallelism(uint_t count)
[-] 		AsyncIoDevice::setSetting (&m_readParallelism, count ? count : Def_ReadParallelism);
[+] 		AsyncIoDevice::setSetting(&m_readParallelism, count ? count : Def_ReadParallelism);
[-] 	setReadBufferSize (size_t size)
[+] 	setReadBufferSize(size_t size)
[-] 		return AsyncIoDevice::setReadBufferSize (&m_readBufferSize, size ? size : Def_ReadBufferSize);
[+] 		return AsyncIoDevice::setReadBufferSize(&m_readBufferSize, size ? size : Def_ReadBufferSize);
[-] 	setReadBlockSize (size_t size)
[+] 	setReadBlockSize(size_t size)
[-] 		AsyncIoDevice::setSetting (&m_readBlockSize, size ? size : Def_ReadBlockSize);
[+] 		AsyncIoDevice::setSetting(&m_readBlockSize, size ? size : Def_ReadBlockSize);
[-] 	setWriteBufferSize (size_t size)
[+] 	setWriteBufferSize(size_t size)
[-] 		return AsyncIoDevice::setWriteBufferSize (&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[+] 		return AsyncIoDevice::setWriteBufferSize(&m_writeBufferSize, size ? size : Def_WriteBufferSize);
[-] 	setOptions (uint_t options)
[+] 	setOptions(uint_t options)
[-] 		AsyncIoDevice::setSetting (&m_options, options);
[+] 		AsyncIoDevice::setSetting(&m_options, options);
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
[-] 	wait (
[+] 	wait(
[-] 		return AsyncIoDevice::wait (eventMask, handlerPtr);
[+] 		return AsyncIoDevice::wait(eventMask, handlerPtr);
[-] 	cancelWait (handle_t handle)
[+] 	cancelWait(handle_t handle)
[-] 		return AsyncIoDevice::cancelWait (handle);
[+] 		return AsyncIoDevice::cancelWait(handle);
[-] 	blockingWait (
[+] 	blockingWait(
[-] 		return AsyncIoDevice::blockingWait (eventMask, timeout);
[+] 		return AsyncIoDevice::blockingWait(eventMask, timeout);
[-] 	isInEndpoint ()
[+] 	isInEndpoint()
[-] 		return (((UsbEndpointDesc*) m_endpointDescPtr.m_p)->m_endpointId & LIBUSB_ENDPOINT_IN) != 0;
[+] 		return (((UsbEndpointDesc*)m_endpointDescPtr.m_p)->m_endpointId & LIBUSB_ENDPOINT_IN) != 0;
[-] 	isOutEndpoint ()
[+] 	isOutEndpoint()
[-] 		return (((UsbEndpointDesc*) m_endpointDescPtr.m_p)->m_endpointId & LIBUSB_ENDPOINT_IN) == 0;
[+] 		return (((UsbEndpointDesc*)m_endpointDescPtr.m_p)->m_endpointId & LIBUSB_ENDPOINT_IN) == 0;
[-] 	ioThreadFunc ();
[+] 	ioThreadFunc();
[-] 	cancelAllActiveTransfers ();
[+] 	cancelAllActiveTransfers();
[-] 	readLoop ();
[+] 	readLoop();
[-] 	writeLoop ();
[+] 	writeLoop();
[-] 	submitTransfer (
[+] 	submitTransfer(
[-] 	onTransferCompleted (libusb_transfer* transfer);
[+] 	onTransferCompleted(libusb_transfer* transfer);
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbInterface.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (UsbInterface)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(UsbInterface)
[-] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS (UsbInterface)
[+] 	JNC_DECLARE_CLASS_TYPE_STATIC_METHODS(UsbInterface)
[-] 	UsbInterface ();
[+] 	UsbInterface();
[-] 	~UsbInterface ()
[+] 	~UsbInterface()
[-] 		release ();
[+] 		release();
[-] 	release ();
[+] 	release();
[-] 	openEndpoint (uint8_t endpointId);
[+] 	openEndpoint(uint8_t endpointId);
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc_io_UsbLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_CoreLib.cpp
----------------------
[-] 	if (module->m_functionMgr.isStdFunctionUsed (stdFuncKind)) \
[+] 	if (module->m_functionMgr.isStdFunctionUsed(stdFuncKind)) \
[-] 		function = module->m_functionMgr.getStdFunction (stdFuncKind); \
[+] 		function = module->m_functionMgr.getStdFunction(stdFuncKind); \
[-] 		ASSERT (function); \
[+] 		ASSERT(function); \
[-] 		JNC_MAP_FUNCTION_IMPL (function, proc); \
[+] 		JNC_MAP_FUNCTION_IMPL(function, proc); \
[-] 	if (module->m_typeMgr.isStdTypeUsed (stdType)) \
[+] 	if (module->m_typeMgr.isStdTypeUsed(stdType)) \
[-] 		JNC_MAP_TYPE (Type); \
[+] 		JNC_MAP_TYPE(Type); \
[-] dynamicSizeOf (DataPtr ptr)
[+] dynamicSizeOf(DataPtr ptr)
[-] 	char* p = (char*) ptr.m_p;
[+] 	char* p = (char*)ptr.m_p;
[-] 	char* end = (char*) ptr.m_validator->m_rangeEnd;
[+] 	char* end = (char*)ptr.m_validator->m_rangeEnd;
[-] dynamicCountOf (
[+] dynamicCountOf(
[-] 	size_t maxSize = dynamicSizeOf (ptr);
[+] 	size_t maxSize = dynamicSizeOf(ptr);
[-] 	size_t typeSize = type->getSize ();
[+] 	size_t typeSize = type->getSize();
[-] dynamicCastDataPtr (
[+] dynamicCastDataPtr(
[-] 	void* p = (box->m_flags & BoxFlag_StaticData) ? ((StaticDataBox*) box)->m_p : box + 1;
[+] 	void* p = (box->m_flags & BoxFlag_StaticData) ? ((StaticDataBox*)box)->m_p : box + 1;
[-] 	while (srcType->getTypeKind () == TypeKind_Array)
[+] 	while (srcType->getTypeKind() == TypeKind_Array)
[-] 		ArrayType* arrayType = (ArrayType*) srcType;
[+] 		ArrayType* arrayType = (ArrayType*)srcType;
[-] 		srcType = arrayType->getElementType ();
[+] 		srcType = arrayType->getElementType();
[-] 		size_t srcTypeSize = srcType->getSize ();
[+] 		size_t srcTypeSize = srcType->getSize();
[-] 		size_t offset = ((char*) ptr.m_p - (char*) p) % srcTypeSize;
[+] 		size_t offset = ((char*)ptr.m_p - (char*)p) % srcTypeSize;
[-] 		p = (char*) ptr.m_p - offset;
[+] 		p = (char*)ptr.m_p - offset;
[-] 	if (srcType->cmp (type) == 0)
[+] 	if (srcType->cmp(type) == 0)
[-] 	AXL_TODO ("find field pointed to by ptr and do cast accordingly")
[+] 	AXL_TODO("find field pointed to by ptr and do cast accordingly")
[-] 	if (srcType->getTypeKind () != TypeKind_Struct)
[+] 	if (srcType->getTypeKind() != TypeKind_Struct)
[-] 	size_t offset = ((StructType*) srcType)->findBaseTypeOffset (type);
[+] 	size_t offset = ((StructType*)srcType)->findBaseTypeOffset(type);
[-] 	ptr.m_p = (char*) p + offset;
[+] 	ptr.m_p = (char*)p + offset;
[-] dynamicCastClassPtr (
[+] dynamicCastClassPtr(
[-] 	ASSERT (iface->m_box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(iface->m_box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ClassType* classType = (ClassType*) iface->m_box->m_type;
[+] 	ClassType* classType = (ClassType*)iface->m_box->m_type;
[-] 	if (classType->cmp (type) == 0)
[+] 	if (classType->cmp(type) == 0)
[-] 	size_t offset = classType->findBaseTypeOffset (type);
[+] 	size_t offset = classType->findBaseTypeOffset(type);
[-] 	IfaceHdr* iface2 = (IfaceHdr*) ((uchar_t*) (iface->m_box + 1) + offset);
[+] 	IfaceHdr* iface2 = (IfaceHdr*)((uchar_t*)(iface->m_box + 1) + offset);
[-] 	ASSERT (iface2->m_box == iface->m_box);
[+] 	ASSERT(iface2->m_box == iface->m_box);
[-] dynamicCastVariant (
[+] dynamicCastVariant(
[-] 	return variant.cast (type, buffer);
[+] 	return variant.cast(type, buffer);
[-] strengthenClassPtr (IfaceHdr* iface)
[+] strengthenClassPtr(IfaceHdr* iface)
[-] 	return jnc_strengthenClassPtr (iface);
[+] 	return jnc_strengthenClassPtr(iface);
[-] primeStaticClass (
[+] primeStaticClass(
[-] 	primeClass (box, type);
[+] 	primeClass(box, type);
[-] tryAllocateClass (ClassType* type)
[+] tryAllocateClass(ClassType* type)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->tryAllocateClass (type);
[+] 	return gcHeap->tryAllocateClass(type);
[-] allocateClass (ClassType* type)
[+] allocateClass(ClassType* type)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->allocateClass (type);
[+] 	return gcHeap->allocateClass(type);
[-] tryAllocateData (Type* type)
[+] tryAllocateData(Type* type)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->tryAllocateData (type);
[+] 	return gcHeap->tryAllocateData(type);
[-] allocateData (Type* type)
[+] allocateData(Type* type)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->allocateData (type);
[+] 	return gcHeap->allocateData(type);
[-] tryAllocateArray (
[+] tryAllocateArray(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->tryAllocateArray (type, elementCount);
[+] 	return gcHeap->tryAllocateArray(type, elementCount);
[-] allocateArray (
[+] allocateArray(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->allocateArray (type, elementCount);
[+] 	return gcHeap->allocateArray(type, elementCount);
[-] createDataPtrValidator (
[+] createDataPtrValidator(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	return gcHeap->createDataPtrValidator (box, rangeBegin, rangeLength);
[+] 	return gcHeap->createDataPtrValidator(box, rangeBegin, rangeLength);
[-] gcSafePoint ()
[+] gcSafePoint()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->safePoint ();
[+] 	gcHeap->safePoint();
[-] setGcShadowStackFrameMap (
[+] setGcShadowStackFrameMap(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->setFrameMap (frame, map, op);
[+] 	gcHeap->setFrameMap(frame, map, op);
[-] addStaticDestructor (StaticDestructFunc* destructFunc)
[+] addStaticDestructor(StaticDestructFunc* destructFunc)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->addStaticDestructor (destructFunc);
[+] 	gcHeap->addStaticDestructor(destructFunc);
[-] addStaticClassDestructor (
[+] addStaticClassDestructor(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->addStaticClassDestructor (destructFunc, iface);
[+] 	gcHeap->addStaticClassDestructor(destructFunc, iface);
[-] getTls ()
[+] getTls()
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
[-] 	ASSERT (tls);
[+] 	ASSERT(tls);
[-] dynamicThrow ()
[+] dynamicThrow()
[-] 	jnc::dynamicThrow ();
[+] 	jnc::dynamicThrow();
[-] 	ASSERT (false);
[+] 	ASSERT(false);
[-] asyncRet (
[+] asyncRet(
[-] 	((Promisifier*) promise)->complete_2 (result, g_nullPtr);
[+] 	((Promisifier*)promise)->complete_2(result, g_nullPtr);
[-] asyncThrow (IfaceHdr* promise)
[+] asyncThrow(IfaceHdr* promise)
[-] 	err::Error error = err::getLastError ();
[+] 	err::Error error = err::getLastError();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr errorPtr = gcHeap->tryAllocateBuffer (error->m_size);
[+] 	DataPtr errorPtr = gcHeap->tryAllocateBuffer(error->m_size);
[-] 		memcpy (errorPtr.m_p, error, error->m_size);
[+] 		memcpy(errorPtr.m_p, error, error->m_size);
[-] 	((Promisifier*) promise)->complete_2 (g_nullVariant, errorPtr);
[+] 	((Promisifier*)promise)->complete_2(g_nullVariant, errorPtr);
[-] variantUnaryOperator (
[+] variantUnaryOperator(
[-] 	variant.unaryOperator ((jnc_UnOpKind) opKind, &result);
[+] 	variant.unaryOperator((jnc_UnOpKind)opKind, &result);
[-] variantBinaryOperator (
[+] variantBinaryOperator(
[-] 	variant1.binaryOperator (&variant2, (jnc_BinOpKind) opKind, &result);
[+] 	variant1.binaryOperator(&variant2, (jnc_BinOpKind)opKind, &result);
[-] variantRelationalOperator (
[+] variantRelationalOperator(
[-] 	variant1.relationalOperator (&variant2, (jnc_BinOpKind) opKind, &result);
[+] 	variant1.relationalOperator(&variant2, (jnc_BinOpKind)opKind, &result);
[-] variantMemberOperator (
[+] variantMemberOperator(
[-] 	variant.getMember (name, &result);
[+] 	variant.getMember(name, &result);
[-] variantIndexOperator (
[+] variantIndexOperator(
[-] 	variant.getElement (index, &result);
[+] 	variant.getElement(index, &result);
[-] variantMemberProperty_get (
[+] variantMemberProperty_get(
[-] 	Variant* variant = (Variant*) variantPtr.m_p;
[+] 	Variant* variant = (Variant*)variantPtr.m_p;
[-] 	variant->getMember (name, &result);
[+] 	variant->getMember(name, &result);
[-] variantMemberProperty_set (
[+] variantMemberProperty_set(
[-] 	Variant* variant = (Variant*) variantPtr.m_p;
[+] 	Variant* variant = (Variant*)variantPtr.m_p;
[-] 	variant->setMember (name, value);
[+] 	variant->setMember(name, value);
[-] variantIndexProperty_get (
[+] variantIndexProperty_get(
[-] 	Variant* variant = (Variant*) variantPtr.m_p;
[+] 	Variant* variant = (Variant*)variantPtr.m_p;
[-] 	variant->getElement (index, &result);
[+] 	variant->getElement(index, &result);
[-] variantIndexProperty_set (
[+] variantIndexProperty_set(
[-] 	Variant* variant = (Variant*) variantPtr.m_p;
[+] 	Variant* variant = (Variant*)variantPtr.m_p;
[-] 	variant->setElement (index, value);
[+] 	variant->setElement(index, value);
[-] assertionFailure (
[+] assertionFailure(
[-] 	string.format ("%s(%d): assertion (%s) failed", fileName, line + 1, condition);
[+] 	string.format("%s(%d): assertion (%s) failed", fileName, line + 1, condition);
[-] 		string.appendFormat ("; %s", message);
[+] 		string.appendFormat("; %s", message);
[-] 	err::setError (string);
[+] 	err::setError(string);
[-] 	dynamicThrow ();
[+] 	dynamicThrow();
[-] tryCheckDataPtrRangeDirect (
[+] tryCheckDataPtrRangeDirect(
[-] 		err::setError ("null data pointer access");
[+] 		err::setError("null data pointer access");
[-] 	void* rangeEnd = (char*) rangeBegin + rangeLength;
[+] 	void* rangeEnd = (char*)rangeBegin + rangeLength;
[-] 		err::setFormatStringError ("data pointer %x out of range [%x:%x]", p, rangeBegin, rangeEnd);
[+] 		err::setFormatStringError("data pointer %x out of range [%x:%x]", p, rangeBegin, rangeEnd);
[-] checkDataPtrRangeDirect (
[+] checkDataPtrRangeDirect(
[-] 	bool result = tryCheckDataPtrRangeDirect (p, rangeBegin, rangeLength);
[+] 	bool result = tryCheckDataPtrRangeDirect(p, rangeBegin, rangeLength);
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] tryCheckDataPtrRangeIndirect (
[+] tryCheckDataPtrRangeIndirect(
[-] 		err::setError ("null data pointer access");
[+] 		err::setError("null data pointer access");
[-] 	void* end = (char*) p + size;
[+] 	void* end = (char*)p + size;
[-] 		err::setFormatStringError ("data pointer %x out of range [%x:%x]", p, validator->m_rangeBegin, validator->m_rangeEnd);
[+] 		err::setFormatStringError("data pointer %x out of range [%x:%x]", p, validator->m_rangeBegin, validator->m_rangeEnd);
[-] checkDataPtrRangeIndirect (
[+] checkDataPtrRangeIndirect(
[-] 	bool result = tryCheckDataPtrRangeIndirect (p, size, validator);
[+] 	bool result = tryCheckDataPtrRangeIndirect(p, size, validator);
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] tryCheckNullPtr (
[+] tryCheckNullPtr(
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		err::setError ("null class pointer access");
[+] 		err::setError("null class pointer access");
[-] 		err::setError ("null function pointer access");
[+] 		err::setError("null function pointer access");
[-] 		err::setError ("null property pointer access");
[+] 		err::setError("null property pointer access");
[-] 		err::setError ("null pointer access");
[+] 		err::setError("null pointer access");
[-] checkNullPtr (
[+] checkNullPtr(
[-] 	bool result = tryCheckNullPtr (p, typeKind);
[+] 	bool result = tryCheckNullPtr(p, typeKind);
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] checkStackOverflow ()
[+] checkStackOverflow()
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	ASSERT (runtime);
[+] 	ASSERT(runtime);
[-] 	runtime->checkStackOverflow ();
[+] 	runtime->checkStackOverflow();
[-] checkDivByZero_i32 (int32_t i)
[+] checkDivByZero_i32(int32_t i)
[-] 		err::setError ("integer division by zero");
[+] 		err::setError("integer division by zero");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] checkDivByZero_i64 (int64_t i)
[+] checkDivByZero_i64(int64_t i)
[-] 		err::setError ("integer division by zero");
[+] 		err::setError("integer division by zero");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] checkDivByZero_f32 (float f)
[+] checkDivByZero_f32(float f)
[-] 		err::setError ("floating point division by zero");
[+] 		err::setError("floating point division by zero");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] checkDivByZero_f64 (double f)
[+] checkDivByZero_f64(double f)
[-] 		err::setError ("floating point division by zero");
[+] 		err::setError("floating point division by zero");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] tryLazyGetDynamicLibFunction (
[+] tryLazyGetDynamicLibFunction(
[-] 	ASSERT (lib->m_box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(lib->m_box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ClassType* type = (ClassType*) lib->m_box->m_type;
[+] 	ClassType* type = (ClassType*)lib->m_box->m_type;
[-] 		err::setFormatStringError ("dynamiclib '%s' is not loaded yet", type->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("dynamiclib '%s' is not loaded yet", type->getQualifiedName ().sz ());
[-] 	size_t librarySize = type->getIfaceStructType ()->getSize ();
[+] 	size_t librarySize = type->getIfaceStructType()->getSize();
[-] 	size_t functionCount = (librarySize - sizeof (DynamicLib)) / sizeof (void*);
[+] 	size_t functionCount = (librarySize - sizeof(DynamicLib)) / sizeof(void*);
[-] 		err::setFormatStringError ("index #%d out of range for dynamiclib '%s'", index, type->getQualifiedName ().sz ());
[+] 		err::setFormatStringError("index #%d out of range for dynamiclib '%s'", index, type->getQualifiedName ().sz ());
[-] 	if (functionTable [index])
[+] 	if (functionTable[index])
[-] 		return functionTable [index];
[+] 		return functionTable[index];
[-] 	void* function = lib->getFunctionImpl (name);
[+] 	void* function = lib->getFunctionImpl(name);
[-] 	functionTable [index] = function;
[+] 	functionTable[index] = function;
[-] lazyGetDynamicLibFunction (
[+] lazyGetDynamicLibFunction(
[-] 	void* p = tryLazyGetDynamicLibFunction (lib, index, name);
[+] 	void* p = tryLazyGetDynamicLibFunction(lib, index, name);
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] getDynamicLayout (DataPtr ptr)
[+] getDynamicLayout(DataPtr ptr)
[-] 		err::setError ("null data pointer access");
[+] 		err::setError("null data pointer access");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	IfaceHdr* iface = gcHeap->getDynamicLayout (ptr.m_validator->m_targetBox);
[+] 	IfaceHdr* iface = gcHeap->getDynamicLayout(ptr.m_validator->m_targetBox);
[-] 	ASSERT (iface->m_box->m_type->getStdType () == StdType_DynamicLayout);
[+] 	ASSERT(iface->m_box->m_type->getStdType() == StdType_DynamicLayout);
[-] 	return (rtl::DynamicLayout*) iface;
[+] 	return (rtl::DynamicLayout*)iface;
[-] getDynamicFieldOffset (
[+] getDynamicFieldOffset(
[-] 	ASSERT	(type->getFlags () & TypeFlag_Dynamic);
[+] 	ASSERT	(type->getFlags() & TypeFlag_Dynamic);
[-] 	if (type->getTypeKind () != TypeKind_Struct)
[+] 	if (type->getTypeKind() != TypeKind_Struct)
[-] 		err::setError ("only dynamic structs are currently supported");
[+] 		err::setError("only dynamic structs are currently supported");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 	StructType* structType = (StructType*) type;
[+] 	StructType* structType = (StructType*)type;
[-] 		offset = field->getOffset ();
[+] 		offset = field->getOffset();
[-] 		prevIndex = field->getPrevDynamicFieldIndex ();
[+] 		prevIndex = field->getPrevDynamicFieldIndex();
[-] 		field = structType->getMemberFieldArray ().getBack ();
[+] 		field = structType->getMemberFieldArray().getBack();
[-] 		if (field->getType ()->getFlags () & TypeFlag_Dynamic)
[+] 		if (field->getType()->getFlags() & TypeFlag_Dynamic)
[-] 			prevIndex = structType->getDynamicFieldArray ().getCount () - 1;
[+] 			prevIndex = structType->getDynamicFieldArray().getCount() - 1;
[-] 			offset = field->getOffset () + field->getType ()->getSize ();
[+] 			offset = field->getOffset() + field->getType()->getSize();
[-] 			prevIndex = field->getPrevDynamicFieldIndex ();
[+] 			prevIndex = field->getPrevDynamicFieldIndex();
[-] 	rtl::DynamicLayout* dynamicLayout = getDynamicLayout (ptr);
[+] 	rtl::DynamicLayout* dynamicLayout = getDynamicLayout(ptr);
[-] 	offset += dynamicLayout->getDynamicFieldEndOffset (ptr, structType, prevIndex);
[+] 	offset += dynamicLayout->getDynamicFieldEndOffset(ptr, structType, prevIndex);
[-] getDynamicField (
[+] getDynamicField(
[-] 	return (char*) ptr.m_p + getDynamicFieldOffset (ptr, type, field);
[+] 	return (char*)ptr.m_p + getDynamicFieldOffset(ptr, type, field);
[-] dynamicTypeSizeOf (
[+] dynamicTypeSizeOf(
[-] 	return getDynamicFieldOffset (ptr, type, NULL);
[+] 	return getDynamicFieldOffset(ptr, type, NULL);
[-] dynamicFieldSizeOf (
[+] dynamicFieldSizeOf(
[-] 	ASSERT (type->getFlags () & TypeFlag_Dynamic);
[+] 	ASSERT(type->getFlags() & TypeFlag_Dynamic);
[-] 	ASSERT (field->getType ()->getFlags () & TypeFlag_Dynamic);
[+] 	ASSERT(field->getType()->getFlags() & TypeFlag_Dynamic);
[-] 	rtl::DynamicLayout* dynamicLayout = getDynamicLayout (ptr);
[+] 	rtl::DynamicLayout* dynamicLayout = getDynamicLayout(ptr);
[-] 	size_t dynamicFieldIndex = field->getPrevDynamicFieldIndex () + 1;
[+] 	size_t dynamicFieldIndex = field->getPrevDynamicFieldIndex() + 1;
[-] 	size_t beginOffset = getDynamicFieldOffset (ptr, type, field);
[+] 	size_t beginOffset = getDynamicFieldOffset(ptr, type, field);
[-] 	size_t endOffset = dynamicLayout->getDynamicFieldEndOffset (ptr, type, dynamicFieldIndex);
[+] 	size_t endOffset = dynamicLayout->getDynamicFieldEndOffset(ptr, type, dynamicFieldIndex);
[-] dynamicFieldCountOf (
[+] dynamicFieldCountOf(
[-] 	ASSERT (field->getType ()->getTypeKind () == TypeKind_Array);
[+] 	ASSERT(field->getType()->getTypeKind() == TypeKind_Array);
[-] 	ArrayType* arrayType = (ArrayType*) field->getType ();
[+] 	ArrayType* arrayType = (ArrayType*)field->getType();
[-] 	size_t size = dynamicFieldSizeOf (ptr, type, field);
[+] 	size_t size = dynamicFieldSizeOf(ptr, type, field);
[-] 	return size / arrayType->getElementType ()->getSize ();
[+] 	return size / arrayType->getElementType()->getSize();
[-] appendFmtLiteral_a (
[+] appendFmtLiteral_a(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 		size_t newMaxLength = sl::getAllocSize (newLength);
[+] 		size_t newMaxLength = sl::getAllocSize(newLength);
[-] 		DataPtr ptr = gcHeap->tryAllocateBuffer (newMaxLength + 1);
[+] 		DataPtr ptr = gcHeap->tryAllocateBuffer(newMaxLength + 1);
[-] 			memcpy (ptr.m_p, fmtLiteral->m_ptr.m_p, fmtLiteral->m_length);
[+] 			memcpy(ptr.m_p, fmtLiteral->m_ptr.m_p, fmtLiteral->m_length);
[-] 	char* dst = (char*) fmtLiteral->m_ptr.m_p;
[+] 	char* dst = (char*)fmtLiteral->m_ptr.m_p;
[-] 	memcpy (dst + fmtLiteral->m_length, p, length);
[+] 	memcpy(dst + fmtLiteral->m_length, p, length);
[-] 	dst [fmtLiteral->m_length] = 0;
[+] 	dst[fmtLiteral->m_length] = 0;
[-] 	validator->m_rangeEnd = (char*) validator->m_rangeBegin + fmtLiteral->m_length;
[+] 	validator->m_rangeEnd = (char*)validator->m_rangeBegin + fmtLiteral->m_length;
[-] prepareFormatString (
[+] prepareFormatString(
[-] 		formatString->copy ('%');
[+] 		formatString->copy('%');
[-] 		formatString->append (defaultType);
[+] 		formatString->append(defaultType);
[-] 	formatString->clear ();
[+] 	formatString->clear();
[-] 	if (fmtSpecifier [0] != '%')
[+] 	if (fmtSpecifier[0] != '%')
[-] 		formatString->copy ('%');
[+] 		formatString->copy('%');
[-] 	formatString->append (fmtSpecifier);
[+] 	formatString->append(fmtSpecifier);
[-] 	size_t length = formatString->getLength ();
[+] 	size_t length = formatString->getLength();
[-] 	if (!isalpha (formatString->sz () [length - 1]))
[+] 	if (!isalpha(formatString->sz() [length - 1]))
[-] 		formatString->append (defaultType);
[+] 		formatString->append(defaultType);
[-] appendFmtLiteralDirect_va (
[+] appendFmtLiteralDirect_va(
[-] 	char buffer2 [256];
[+] 	char buffer2[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer2, sizeof (buffer2));
[+] 	sl::String string(ref::BufKind_Stack, buffer2, sizeof(buffer2));
[-] 	string.format_va (formatString, va);
[+] 	string.format_va(formatString, va);
[-] 	return appendFmtLiteral_a (fmtLiteral, string, string.getLength ());
[+] 	return appendFmtLiteral_a(fmtLiteral, string, string.getLength());
[-] appendFmtLiteralDirect (
[+] appendFmtLiteralDirect(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return appendFmtLiteralDirect_va (fmtLiteral, formatString, va);
[+] 	return appendFmtLiteralDirect_va(fmtLiteral, formatString, va);
[-] appendFmtLiteralImpl (
[+] appendFmtLiteralImpl(
[-] 	AXL_VA_DECL (va, defaultType);
[+] 	AXL_VA_DECL(va, defaultType);
[-] 	char buffer1 [256];
[+] 	char buffer1[256];
[-] 	sl::String formatString (ref::BufKind_Stack, buffer1, sizeof (buffer1));
[+] 	sl::String formatString(ref::BufKind_Stack, buffer1, sizeof(buffer1));
[-] 	prepareFormatString (&formatString, fmtSpecifier, defaultType);
[+] 	prepareFormatString(&formatString, fmtSpecifier, defaultType);
[-] 	return appendFmtLiteralDirect_va (fmtLiteral, formatString, va);
[+] 	return appendFmtLiteralDirect_va(fmtLiteral, formatString, va);
[-] appendFmtLiteralStringImpl (
[+] appendFmtLiteralStringImpl(
[-] 		return appendFmtLiteral_a (fmtLiteral, p, length);
[+] 		return appendFmtLiteral_a(fmtLiteral, p, length);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	if (p [length] != 0) // ensure zero-terminated
[+] 	if (p[length] != 0) // ensure zero-terminated
[-] 		string.copy (p, length);
[+] 		string.copy(p, length);
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "s", p);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "s", p);
[-] appendFmtLiteral_p (
[+] appendFmtLiteral_p(
[-] 	return appendFmtLiteralStringImpl (fmtLiteral, fmtSpecifier, (const char*) ptr.m_p, strLen (ptr));
[+] 	return appendFmtLiteralStringImpl(fmtLiteral, fmtSpecifier, (const char*) ptr.m_p, strLen(ptr));
[-] appendFmtLiteral_i32 (
[+] appendFmtLiteral_i32(
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "d", x);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "d", x);
[-] appendFmtLiteral_ui32 (
[+] appendFmtLiteral_ui32(
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "u", x);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "u", x);
[-] appendFmtLiteral_i64 (
[+] appendFmtLiteral_i64(
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "lld", x);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "lld", x);
[-] appendFmtLiteral_ui64 (
[+] appendFmtLiteral_ui64(
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "llu", x);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "llu", x);
[-] appendFmtLiteral_f (
[+] appendFmtLiteral_f(
[-] 	return appendFmtLiteralImpl (fmtLiteral, fmtSpecifier, "f", x);
[+] 	return appendFmtLiteralImpl(fmtLiteral, fmtSpecifier, "f", x);
[-] appendFmtLiteral_v (
[+] appendFmtLiteral_v(
[-] 	TypeKind typeKind = variant.m_type->getTypeKind ();
[+] 	TypeKind typeKind = variant.m_type->getTypeKind();
[-] 	uint_t typeKindFlags = variant.m_type->getTypeKindFlags ();
[+] 	uint_t typeKindFlags = variant.m_type->getTypeKindFlags();
[-] 		Module* module = variant.m_type->getModule ();
[+] 		Module* module = variant.m_type->getModule();
[-] 		char buffer [sizeof (int64_t)];
[+] 		char buffer[sizeof(int64_t)];
[-] 		if (variant.m_type->getSize () > 4)
[+] 		if (variant.m_type->getSize() > 4)
[-] 			Type* targetType = module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
[+] 			Type* targetType = module->m_typeMgr.getPrimitiveType(TypeKind_Int64);
[-] 			result = variant.cast (targetType, buffer);
[+] 			result = variant.cast(targetType, buffer);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 			int64_t x = *(int64_t*) buffer;
[+] 			int64_t x = *(int64_t*)buffer;
[-] 				appendFmtLiteral_ui64 (fmtLiteral, fmtSpecifier, x) :
[+] 				appendFmtLiteral_ui64(fmtLiteral, fmtSpecifier, x) :
[-] 				appendFmtLiteral_i64 (fmtLiteral, fmtSpecifier, x);
[+] 				appendFmtLiteral_i64(fmtLiteral, fmtSpecifier, x);
[-] 			Type* targetType = module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
[+] 			Type* targetType = module->m_typeMgr.getPrimitiveType(TypeKind_Int32);
[-] 			result = variant.cast (targetType, buffer);
[+] 			result = variant.cast(targetType, buffer);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 			int32_t x = *(int32_t*) buffer;
[+] 			int32_t x = *(int32_t*)buffer;
[-] 				appendFmtLiteral_ui32 (fmtLiteral, fmtSpecifier, x) :
[+] 				appendFmtLiteral_ui32(fmtLiteral, fmtSpecifier, x) :
[-] 				appendFmtLiteral_i32 (fmtLiteral, fmtSpecifier, x);
[+] 				appendFmtLiteral_i32(fmtLiteral, fmtSpecifier, x);
[-] 			appendFmtLiteral_f (fmtLiteral, fmtSpecifier, *(float*) &variant) :
[+] 			appendFmtLiteral_f(fmtLiteral, fmtSpecifier, *(float*) &variant) :
[-] 			appendFmtLiteral_f (fmtLiteral, fmtSpecifier, *(double*) &variant);
[+] 			appendFmtLiteral_f(fmtLiteral, fmtSpecifier, *(double*) &variant);
[-] 		type = ((DataPtrType*) variant.m_type)->getTargetType ();
[+] 		type = ((DataPtrType*)variant.m_type)->getTargetType();
[-] 	if (isCharArrayType (type))
[+] 	if (isCharArrayType(type))
[-] 		ArrayType* arrayType = (ArrayType*) type;
[+] 		ArrayType* arrayType = (ArrayType*)type;
[-] 		size_t count = arrayType->getElementCount ();
[+] 		size_t count = arrayType->getElementCount();
[-] 		const char* c = (char*) p;
[+] 		const char* c = (char*)p;
[-] 		while (count && c [count - 1] == 0)
[+] 		while (count && c[count - 1] == 0)
[-] 		return appendFmtLiteralStringImpl (fmtLiteral, fmtSpecifier, c, count);
[+] 		return appendFmtLiteralStringImpl(fmtLiteral, fmtSpecifier, c, count);
[-] 	else if (type->getTypeKindFlags () & TypeKindFlag_Ptr)
[+] 	else if (type->getTypeKindFlags() & TypeKindFlag_Ptr)
[-] 		if (isCharPtrType (type))
[+] 		if (isCharPtrType(type))
[-] 			DataPtrType* ptrType = (DataPtrType*) type;
[+] 			DataPtrType* ptrType = (DataPtrType*)type;
[-] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind ();
[+] 			DataPtrTypeKind ptrTypeKind = ptrType->getPtrTypeKind();
[-] 				return appendFmtLiteral_p (fmtLiteral, fmtSpecifier, *(DataPtr*) &variant);
[+] 				return appendFmtLiteral_p(fmtLiteral, fmtSpecifier, *(DataPtr*) &variant);
[-] 			size_t length = strlen_s (c);
[+] 			size_t length = strlen_s(c);
[-] 			return appendFmtLiteralStringImpl (fmtLiteral, fmtSpecifier, c, length);
[+] 			return appendFmtLiteralStringImpl(fmtLiteral, fmtSpecifier, c, length);
[-] 			return appendFmtLiteralDirect (fmtLiteral, "%p", variant.m_p);
[+] 			return appendFmtLiteralDirect(fmtLiteral, "%p", variant.m_p);
[-] 		return appendFmtLiteralDirect (fmtLiteral, "(variant:%s)", type->getTypeString ().sz ());
[+] 		return appendFmtLiteralDirect(fmtLiteral, "(variant:%s)", type->getTypeString ().sz ());
[-] multicastDestruct (Multicast* multicast)
[+] multicastDestruct(Multicast* multicast)
[-] 	((MulticastImpl*) multicast)->destruct ();
[+] 	((MulticastImpl*)multicast)->destruct();
[-] multicastClear (Multicast* multicast)
[+] multicastClear(Multicast* multicast)
[-] 	return ((MulticastImpl*) multicast)->clear ();
[+] 	return ((MulticastImpl*)multicast)->clear();
[-] multicastSet (
[+] multicastSet(
[-] 	return ((MulticastImpl*) multicast)->setHandler (ptr);
[+] 	return ((MulticastImpl*)multicast)->setHandler(ptr);
[-] multicastSet_t (
[+] multicastSet_t(
[-] 	return ((MulticastImpl*) multicast)->setHandler_t (p);
[+] 	return ((MulticastImpl*)multicast)->setHandler_t(p);
[-] multicastAdd (
[+] multicastAdd(
[-] 	return ((MulticastImpl*) multicast)->addHandler (ptr);
[+] 	return ((MulticastImpl*)multicast)->addHandler(ptr);
[-] multicastAdd_t (
[+] multicastAdd_t(
[-] 	return ((MulticastImpl*) multicast)->addHandler_t (p);
[+] 	return ((MulticastImpl*)multicast)->addHandler_t(p);
[-] multicastRemove (
[+] multicastRemove(
[-] 	return ((MulticastImpl*) multicast)->removeHandler (handle);
[+] 	return ((MulticastImpl*)multicast)->removeHandler(handle);
[-] multicastRemove_t (
[+] multicastRemove_t(
[-] 	return ((MulticastImpl*) multicast)->removeHandler_t (handle);
[+] 	return ((MulticastImpl*)multicast)->removeHandler_t(handle);
[-] multicastGetSnapshot (Multicast* multicast)
[+] multicastGetSnapshot(Multicast* multicast)
[-] 	return ((MulticastImpl*) multicast)->getSnapshot ();
[+] 	return ((MulticastImpl*)multicast)->getSnapshot();
[-] mapMulticastMethods (
[+] mapMulticastMethods(
[-] 	static void* multicastMethodTable [FunctionPtrTypeKind__Count] [MulticastMethodKind__Count - 1] =
[+] 	static void* multicastMethodTable[FunctionPtrTypeKind__Count] [MulticastMethodKind__Count - 1] =
[-] 			(void*) multicastClear,
[+] 			(void*)multicastClear,
[-] 			(void*) multicastSet,
[+] 			(void*)multicastSet,
[-] 			(void*) multicastAdd,
[+] 			(void*)multicastAdd,
[-] 			(void*) multicastRemove,
[+] 			(void*)multicastRemove,
[-] 			(void*) multicastGetSnapshot,
[+] 			(void*)multicastGetSnapshot,
[-] 			(void*) multicastClear,
[+] 			(void*)multicastClear,
[-] 			(void*) multicastSet,
[+] 			(void*)multicastSet,
[-] 			(void*) multicastAdd,
[+] 			(void*)multicastAdd,
[-] 			(void*) multicastRemove,
[+] 			(void*)multicastRemove,
[-] 			(void*) multicastGetSnapshot,
[+] 			(void*)multicastGetSnapshot,
[-] 			(void*) multicastClear,
[+] 			(void*)multicastClear,
[-] 			(void*) multicastSet_t,
[+] 			(void*)multicastSet_t,
[-] 			(void*) multicastAdd_t,
[+] 			(void*)multicastAdd_t,
[-] 			(void*) multicastRemove_t,
[+] 			(void*)multicastRemove_t,
[-] 			(void*) multicastGetSnapshot,
[+] 			(void*)multicastGetSnapshot,
[-] 	FunctionPtrTypeKind ptrTypeKind = multicastType->getTargetType ()->getPtrTypeKind ();
[+] 	FunctionPtrTypeKind ptrTypeKind = multicastType->getTargetType()->getPtrTypeKind();
[-] 	ASSERT (ptrTypeKind < FunctionPtrTypeKind__Count);
[+] 	ASSERT(ptrTypeKind < FunctionPtrTypeKind__Count);
[-] 	Function* function = multicastType->getDestructor ();
[+] 	Function* function = multicastType->getDestructor();
[-] 	module->mapFunction (function, (void*) multicastDestruct);
[+] 	module->mapFunction(function, (void*)multicastDestruct);
[-] 		function = multicastType->getMethod ((MulticastMethodKind) i);
[+] 		function = multicastType->getMethod((MulticastMethodKind)i);
[-] 		module->mapFunction (function, multicastMethodTable [ptrTypeKind] [i]);
[+] 		module->mapFunction(function, multicastMethodTable[ptrTypeKind] [i]);
[-] mapAllMulticastMethods (Module* module)
[+] mapAllMulticastMethods(Module* module)
[-] 	sl::ConstList <ct::MulticastClassType> mcTypeList = module->m_typeMgr.getMulticastClassTypeList ();
[+] 	sl::ConstList<ct::MulticastClassType> mcTypeList = module->m_typeMgr.getMulticastClassTypeList();
[-] 	sl::ConstIterator <ct::MulticastClassType> mcType = mcTypeList.getHead ();
[+] 	sl::ConstIterator<ct::MulticastClassType> mcType = mcTypeList.getHead();
[-] 		mapMulticastMethods (module, *mcType);
[+] 		mapMulticastMethods(module, *mcType);
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (jnc_CoreLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(jnc_CoreLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (jnc_CoreLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(jnc_CoreLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (RegexState)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(RegexState)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (RegexDfa)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(RegexDfa)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (DynamicLayout)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(DynamicLayout)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (ReactorImpl)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(ReactorImpl)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Promise)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Promise)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (jnc_CoreLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(jnc_CoreLib)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicSizeOf,       dynamicSizeOf)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicSizeOf,       dynamicSizeOf)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicCountOf,      dynamicCountOf)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicCountOf,      dynamicCountOf)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicTypeSizeOf,   dynamicTypeSizeOf)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicTypeSizeOf,   dynamicTypeSizeOf)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicFieldSizeOf,  dynamicFieldSizeOf)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicFieldSizeOf,  dynamicFieldSizeOf)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicFieldCountOf, dynamicFieldCountOf)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicFieldCountOf, dynamicFieldCountOf)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicCastDataPtr,  dynamicCastDataPtr)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicCastDataPtr,  dynamicCastDataPtr)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicCastClassPtr, dynamicCastClassPtr)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicCastClassPtr, dynamicCastClassPtr)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicCastVariant,  dynamicCastVariant)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicCastVariant,  dynamicCastVariant)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_StrengthenClassPtr,  strengthenClassPtr)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_StrengthenClassPtr,  strengthenClassPtr)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_GetDynamicField,     getDynamicField)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_GetDynamicField,     getDynamicField)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_PrimeStaticClass,         primeStaticClass)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_PrimeStaticClass,         primeStaticClass)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryAllocateClass,         tryAllocateClass)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryAllocateClass,         tryAllocateClass)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AllocateClass,            allocateClass)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AllocateClass,            allocateClass)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryAllocateData,          tryAllocateData)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryAllocateData,          tryAllocateData)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AllocateData,             allocateData)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AllocateData,             allocateData)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryAllocateArray,         tryAllocateArray)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryAllocateArray,         tryAllocateArray)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AllocateArray,            allocateArray)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AllocateArray,            allocateArray)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CreateDataPtrValidator,   createDataPtrValidator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CreateDataPtrValidator,   createDataPtrValidator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_GcSafePoint,              gcSafePoint)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_GcSafePoint,              gcSafePoint)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_SetGcShadowStackFrameMap, setGcShadowStackFrameMap)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_SetGcShadowStackFrameMap, setGcShadowStackFrameMap)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AddStaticDestructor,      addStaticDestructor)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AddStaticDestructor,      addStaticDestructor)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AddStaticClassDestructor, addStaticClassDestructor)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AddStaticClassDestructor, addStaticClassDestructor)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_GetTls,                   getTls)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_GetTls,                   getTls)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantUnaryOperator,      variantUnaryOperator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantUnaryOperator,      variantUnaryOperator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantBinaryOperator,     variantBinaryOperator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantBinaryOperator,     variantBinaryOperator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantRelationalOperator, variantRelationalOperator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantRelationalOperator, variantRelationalOperator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantMemberOperator,     variantMemberOperator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantMemberOperator,     variantMemberOperator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantIndexOperator,      variantIndexOperator)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantIndexOperator,      variantIndexOperator)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantMemberProperty_get, variantMemberProperty_get)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantMemberProperty_get, variantMemberProperty_get)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantMemberProperty_set, variantMemberProperty_set)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantMemberProperty_set, variantMemberProperty_set)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantIndexProperty_get,  variantIndexProperty_get)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantIndexProperty_get,  variantIndexProperty_get)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_VariantIndexProperty_set,  variantIndexProperty_set)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_VariantIndexProperty_set,  variantIndexProperty_set)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_SetJmp,       ::setjmp)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_SetJmp,       ::setjmp)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_DynamicThrow, dynamicThrow)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_DynamicThrow, dynamicThrow)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AsyncRet,     asyncRet)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AsyncRet,     asyncRet)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AsyncThrow,   asyncThrow)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AsyncThrow,   asyncThrow)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AssertionFailure,             assertionFailure)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AssertionFailure,             assertionFailure)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryCheckDataPtrRangeDirect,   tryCheckDataPtrRangeDirect)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryCheckDataPtrRangeDirect,   tryCheckDataPtrRangeDirect)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDataPtrRangeDirect,      checkDataPtrRangeDirect)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDataPtrRangeDirect,      checkDataPtrRangeDirect)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryCheckDataPtrRangeIndirect, tryCheckDataPtrRangeIndirect)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryCheckDataPtrRangeIndirect, tryCheckDataPtrRangeIndirect)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDataPtrRangeIndirect,    checkDataPtrRangeIndirect)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDataPtrRangeIndirect,    checkDataPtrRangeIndirect)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryCheckNullPtr,              tryCheckNullPtr)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryCheckNullPtr,              tryCheckNullPtr)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckNullPtr,                 checkNullPtr)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckNullPtr,                 checkNullPtr)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckStackOverflow,           checkStackOverflow)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckStackOverflow,           checkStackOverflow)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDivByZero_i32,           checkDivByZero_i32)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDivByZero_i32,           checkDivByZero_i32)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDivByZero_i64,           checkDivByZero_i64)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDivByZero_i64,           checkDivByZero_i64)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDivByZero_f32,           checkDivByZero_f32)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDivByZero_f32,           checkDivByZero_f32)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_CheckDivByZero_f64,           checkDivByZero_f64)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_CheckDivByZero_f64,           checkDivByZero_f64)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_TryLazyGetDynamicLibFunction, tryLazyGetDynamicLibFunction)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_TryLazyGetDynamicLibFunction, tryLazyGetDynamicLibFunction)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_LazyGetDynamicLibFunction,    lazyGetDynamicLibFunction)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_LazyGetDynamicLibFunction,    lazyGetDynamicLibFunction)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_a,    appendFmtLiteral_a)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_a,    appendFmtLiteral_a)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_p,    appendFmtLiteral_p)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_p,    appendFmtLiteral_p)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_i32,  appendFmtLiteral_i32)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_i32,  appendFmtLiteral_i32)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_ui32, appendFmtLiteral_ui32)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_ui32, appendFmtLiteral_ui32)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_i64,  appendFmtLiteral_i64)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_i64,  appendFmtLiteral_i64)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_ui64, appendFmtLiteral_ui64)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_ui64, appendFmtLiteral_ui64)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_f,    appendFmtLiteral_f)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_f,    appendFmtLiteral_f)
[-] 	JNC_MAP_STD_FUNCTION (ct::StdFunc_AppendFmtLiteral_v,    appendFmtLiteral_v)
[+] 	JNC_MAP_STD_FUNCTION(ct::StdFunc_AppendFmtLiteral_v,    appendFmtLiteral_v)
[-] 	result = mapAllMulticastMethods (module);
[+] 	result = mapAllMulticastMethods(module);
[-] 	JNC_MAP_STD_TYPE (StdType_RegexState,    RegexState)
[+] 	JNC_MAP_STD_TYPE(StdType_RegexState,    RegexState)
[-] 	JNC_MAP_STD_TYPE (StdType_RegexDfa,      RegexDfa)
[+] 	JNC_MAP_STD_TYPE(StdType_RegexDfa,      RegexDfa)
[-] 	JNC_MAP_STD_TYPE (StdType_DynamicLib,    DynamicLib)
[+] 	JNC_MAP_STD_TYPE(StdType_DynamicLib,    DynamicLib)
[-] 	JNC_MAP_STD_TYPE (StdType_DynamicLayout, DynamicLayout)
[+] 	JNC_MAP_STD_TYPE(StdType_DynamicLayout, DynamicLayout)
[-] 	JNC_MAP_STD_TYPE (StdType_ReactorBase,   ReactorImpl)
[+] 	JNC_MAP_STD_TYPE(StdType_ReactorBase,   ReactorImpl)
[-] 	JNC_MAP_STD_TYPE (StdType_Promise,       Promise)
[+] 	JNC_MAP_STD_TYPE(StdType_Promise,       Promise)
[-] 	JNC_MAP_STD_TYPE (StdType_Promisifier,   Promisifier)
[+] 	JNC_MAP_STD_TYPE(StdType_Promisifier,   Promisifier)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_DynamicLayout.cpp
----------------------
[-] dynamicTypeSizeOf (
[+] dynamicTypeSizeOf(
[-] DynamicLayout_getType (jnc_Module* module)
[+] DynamicLayout_getType(jnc_Module* module)
[-] 	return (jnc_ClassType*) module->m_typeMgr.getStdType (StdType_DynamicLayout);
[+] 	return (jnc_ClassType*)module->m_typeMgr.getStdType(StdType_DynamicLayout);
[-] DynamicLayout_getQualifiedName ()
[+] DynamicLayout_getQualifiedName()
[-] DynamicLayout_getOpaqueClassTypeInfo ()
[+] DynamicLayout_getOpaqueClassTypeInfo()
[-] 		sizeof (DynamicLayout), // m_size
[+] 		sizeof(DynamicLayout), // m_size
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (DynamicLayout)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(DynamicLayout)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <DynamicLayout>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<DynamicLayout>)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] DynamicLayout::getType (Module* module)
[+] DynamicLayout::getType(Module* module)
[-] 	return (ClassType*) module->m_typeMgr.getStdType (StdType_DynamicLayout);
[+] 	return (ClassType*)module->m_typeMgr.getStdType(StdType_DynamicLayout);
[-] DynamicLayout::getDynamicFieldSize (
[+] DynamicLayout::getDynamicFieldSize(
[-] 	Type* type = field->getType ();
[+] 	Type* type = field->getType();
[-] 	ASSERT (type->getFlags () & TypeFlag_Dynamic);
[+] 	ASSERT(type->getFlags() & TypeFlag_Dynamic);
[-] 	if (type->getTypeKindFlags () & TypeKindFlag_Derivable)
[+] 	if (type->getTypeKindFlags() & TypeKindFlag_Derivable)
[-] 		ptr.m_p = (char*) ptr.m_p + offset;
[+] 		ptr.m_p = (char*)ptr.m_p + offset;
[-] 		size = dynamicTypeSizeOf (ptr, (DerivableType*) type);
[+] 		size = dynamicTypeSizeOf(ptr, (DerivableType*)type);
[-] 	else if (type->getTypeKind () == TypeKind_Array)
[+] 	else if (type->getTypeKind() == TypeKind_Array)
[-] 		Function* getDynamicSizeFunc = ((ArrayType*) type)->getGetDynamicSizeFunction ();
[+] 		Function* getDynamicSizeFunc = ((ArrayType*)type)->getGetDynamicSizeFunction();
[-] 		ASSERT (getDynamicSizeFunc);
[+] 		ASSERT(getDynamicSizeFunc);
[-] 		GetDynamicSize (DataPtr ptr);
[+] 		GetDynamicSize(DataPtr ptr);
[-] 		GetDynamicSize* getDynamicSize = (GetDynamicSize*) getDynamicSizeFunc->getMachineCode ();
[+] 		GetDynamicSize* getDynamicSize = (GetDynamicSize*)getDynamicSizeFunc->getMachineCode();
[-] 		size = getDynamicSize (ptr);
[+] 		size = getDynamicSize(ptr);
[-] 		err::setFormatStringError ("invalid dynamic type: %s", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("invalid dynamic type: %s", type->getTypeString ().sz ());
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] DynamicLayout::getDynamicFieldEndOffset (
[+] DynamicLayout::getDynamicFieldEndOffset(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::MapIterator <Key, Entry*> it = m_map.visit (key);
[+] 	sl::MapIterator<Key, Entry*> it = m_map.visit(key);
[-] 		entry = AXL_MEM_NEW (Entry);
[+] 		entry = AXL_MEM_NEW(Entry);
[-] 		m_list.insertTail (entry);
[+] 		m_list.insertTail(entry);
[-] 	TypeKind typeKind = type->getTypeKind ();
[+] 	TypeKind typeKind = type->getTypeKind();
[-] 	ASSERT (typeKind == TypeKind_Struct);
[+] 	ASSERT(typeKind == TypeKind_Struct);
[-] 	sl::Array <StructField*> dynamicFieldArray = ((StructType*) type)->getDynamicFieldArray ();
[+] 	sl::Array<StructField*> dynamicFieldArray = ((StructType*)type)->getDynamicFieldArray();
[-] 	size_t count = entry->m_endOffsetArray.getCount ();
[+] 	size_t count = entry->m_endOffsetArray.getCount();
[-] 		offset = entry->m_endOffsetArray [fieldIndex];
[+] 		offset = entry->m_endOffsetArray[fieldIndex];
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	entry->m_endOffsetArray.reserve (dynamicFieldArray.getCount ());
[+] 	entry->m_endOffsetArray.reserve(dynamicFieldArray.getCount());
[-] 	offset = count ? entry->m_endOffsetArray [count - 1] : 0;
[+] 	offset = count ? entry->m_endOffsetArray[count - 1] : 0;
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		StructField* field = dynamicFieldArray [i];
[+] 		StructField* field = dynamicFieldArray[i];
[-] 		offset += field->getOffset ();
[+] 		offset += field->getOffset();
[-] 		size_t size = getDynamicFieldSize (ptr, offset, field);
[+] 		size_t size = getDynamicFieldSize(ptr, offset, field);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		entry->m_endOffsetArray.ensureCount (i + 1);
[+] 		entry->m_endOffsetArray.ensureCount(i + 1);
[-] 		entry->m_endOffsetArray [i] = offset;
[+] 		entry->m_endOffsetArray[i] = offset;
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_DynamicLib.cpp
----------------------
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (DynamicLib)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(DynamicLib)
[-] 	JNC_MAP_FUNCTION ("open", &DynamicLib::open)
[+] 	JNC_MAP_FUNCTION("open", &DynamicLib::open)
[-] 	JNC_MAP_FUNCTION ("close", &DynamicLib::close)
[+] 	JNC_MAP_FUNCTION("close", &DynamicLib::close)
[-] 	JNC_MAP_FUNCTION ("getFunction", &DynamicLib::getFunction)
[+] 	JNC_MAP_FUNCTION("getFunction", &DynamicLib::getFunction)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] DynamicLib::openImpl (const sl::StringRef& fileName)
[+] DynamicLib::openImpl(const sl::StringRef& fileName)
[-] 	bool result = getDynamicLibrary ()->open (fileName);
[+] 	bool result = getDynamicLibrary()->open(fileName);
[-] 		err::pushFormatStringError ("cannot open dynamiclib '%s'", fileName.sz ());
[+] 		err::pushFormatStringError("cannot open dynamiclib '%s'", fileName.sz ());
[-] DynamicLib::getFunctionImpl (const sl::StringRef& name)
[+] DynamicLib::getFunctionImpl(const sl::StringRef& name)
[-] 	ASSERT (sizeof (sys::DynamicLibrary) == sizeof (m_handle));
[+] 	ASSERT(sizeof(sys::DynamicLibrary) == sizeof(m_handle));
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	void* p = getDynamicLibrary ()->getFunction (name);
[+] 	void* p = getDynamicLibrary()->getFunction(name);
[-] 		err::pushFormatStringError ("cannot get dynamiclib function '%s'", name.sz ());
[+] 		err::pushFormatStringError("cannot get dynamiclib function '%s'", name.sz ());
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Multicast.cpp
----------------------
[-] MulticastImpl::destruct ()
[+] MulticastImpl::destruct()
[-] 		AXL_MEM_DELETE ((sl::HandleTable <size_t>*) m_handleTable);
[+] 		AXL_MEM_DELETE((sl::HandleTable<size_t>*) m_handleTable);
[-] MulticastImpl::clear ()
[+] MulticastImpl::clear()
[-] 		((sl::HandleTable <size_t>*) m_handleTable)->clear ();
[+] 		((sl::HandleTable<size_t>*) m_handleTable)->clear();
[-] MulticastImpl::setHandler (FunctionPtr ptr)
[+] MulticastImpl::setHandler(FunctionPtr ptr)
[-] 		return setHandlerImpl (ptr);
[+] 		return setHandlerImpl(ptr);
[-] 	clear ();
[+] 	clear();
[-] MulticastImpl::setHandler_t (void* p)
[+] MulticastImpl::setHandler_t(void* p)
[-] 		return setHandlerImpl (p);
[+] 		return setHandlerImpl(p);
[-] 	clear ();
[+] 	clear();
[-] sl::HandleTable <size_t>*
[+] sl::HandleTable<size_t>*
[-] MulticastImpl::getHandleTable ()
[+] MulticastImpl::getHandleTable()
[-] 		return (sl::HandleTable <size_t>*) m_handleTable;
[+] 		return (sl::HandleTable<size_t>*) m_handleTable;
[-] 	sl::HandleTable <size_t>* handleTable = AXL_MEM_NEW (sl::HandleTable <size_t>);
[+] 	sl::HandleTable<size_t>* handleTable = AXL_MEM_NEW(sl::HandleTable<size_t>);
[-] MulticastImpl::setCount (
[+] MulticastImpl::setCount(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	MulticastClassType* type = (MulticastClassType*) m_ifaceHdr.m_box->m_type;
[+] 	MulticastClassType* type = (MulticastClassType*)m_ifaceHdr.m_box->m_type;
[-] 	ASSERT (isClassType (type, ClassTypeKind_Multicast));
[+] 	ASSERT(isClassType(type, ClassTypeKind_Multicast));
[-] 	FunctionPtrType* targetType = type->getTargetType ();
[+] 	FunctionPtrType* targetType = type->getTargetType();
[-] 	size_t maxCount = sl::getAllocSize (count);
[+] 	size_t maxCount = sl::getAllocSize(count);
[-] 	DataPtr ptr = gcHeap->allocateArray (targetType, maxCount);
[+] 	DataPtr ptr = gcHeap->allocateArray(targetType, maxCount);
[-] 		memcpy (ptr.m_p, m_ptr.m_p, m_count * ptrSize);
[+] 		memcpy(ptr.m_p, m_ptr.m_p, m_count * ptrSize);
[-] MulticastImpl::getSnapshot ()
[+] MulticastImpl::getSnapshot()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	MulticastClassType* type = (MulticastClassType*) m_ifaceHdr.m_box->m_type;
[+] 	MulticastClassType* type = (MulticastClassType*)m_ifaceHdr.m_box->m_type;
[-] 	ASSERT (isClassType (type, ClassTypeKind_Multicast));
[+] 	ASSERT(isClassType(type, ClassTypeKind_Multicast));
[-] 	ScopedNoCollectRegion noCollectRegion (gcHeap, false);
[+] 	ScopedNoCollectRegion noCollectRegion(gcHeap, false);
[-] 	McSnapshotClassType* snapshotType = type->getSnapshotType ();
[+] 	McSnapshotClassType* snapshotType = type->getSnapshotType();
[-] 	FunctionPtrType* targetType = type->getTargetType ();
[+] 	FunctionPtrType* targetType = type->getTargetType();
[-] 	McSnapshot* snapshot = (McSnapshot*) gcHeap->allocateClass (snapshotType);
[+] 	McSnapshot* snapshot = (McSnapshot*)gcHeap->allocateClass(snapshotType);
[-] 	resultPtr.m_p = snapshotType->getMethod (McSnapshotMethodKind_Call)->getMachineCode ();
[+] 	resultPtr.m_p = snapshotType->getMethod(McSnapshotMethodKind_Call)->getMachineCode();
[-] 	resultPtr.m_closure = (IfaceHdr*) snapshot;
[+] 	resultPtr.m_closure = (IfaceHdr*)snapshot;
[-] 	snapshot->m_ptr = gcHeap->allocateArray (targetType, m_count);
[+] 	snapshot->m_ptr = gcHeap->allocateArray(targetType, m_count);
[-] 	if (targetType->getPtrTypeKind () != FunctionPtrTypeKind_Weak)
[+] 	if (targetType->getPtrTypeKind() != FunctionPtrTypeKind_Weak)
[-] 		size_t targetTypeSize = targetType->getSize ();
[+] 		size_t targetTypeSize = targetType->getSize();
[-] 		memcpy (snapshot->m_ptr.m_p, m_ptr.m_p, m_count * targetTypeSize);
[+] 		memcpy(snapshot->m_ptr.m_p, m_ptr.m_p, m_count * targetTypeSize);
[-] 	FunctionPtr* dstPtr = (FunctionPtr*) snapshot->m_ptr.m_p;
[+] 	FunctionPtr* dstPtr = (FunctionPtr*)snapshot->m_ptr.m_p;
[-] 	FunctionPtr* srcPtr = (FunctionPtr*) m_ptr.m_p;
[+] 	FunctionPtr* srcPtr = (FunctionPtr*)m_ptr.m_p;
[-] 		if (strengthenClassPtr (srcPtr->m_closure))
[+] 		if (strengthenClassPtr(srcPtr->m_closure))
[-] 		size_t oldSize = m_count * sizeof (FunctionPtr);
[+] 		size_t oldSize = m_count * sizeof(FunctionPtr);
[-] 		size_t aliveSize = aliveCount * sizeof (FunctionPtr);
[+] 		size_t aliveSize = aliveCount * sizeof(FunctionPtr);
[-] 		memcpy (m_ptr.m_p, snapshot->m_ptr.m_p, aliveSize);
[+] 		memcpy(m_ptr.m_p, snapshot->m_ptr.m_p, aliveSize);
[-] 		memset ((char*) m_ptr.m_p + aliveSize, 0, oldSize - aliveSize);
[+] 		memset((char*)m_ptr.m_p + aliveSize, 0, oldSize - aliveSize);
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Promise.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Promise)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Promise)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Promise>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Promise>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Promise>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Promise>)
[-] 	JNC_MAP_FUNCTION ("asyncWait",    &Promise::asyncWait)
[+] 	JNC_MAP_FUNCTION("asyncWait",    &Promise::asyncWait)
[-] 	JNC_MAP_FUNCTION ("wait",         &Promise::wait_0)
[+] 	JNC_MAP_FUNCTION("wait",         &Promise::wait_0)
[-] 	JNC_MAP_OVERLOAD (&Promise::wait_1)
[+] 	JNC_MAP_OVERLOAD(&Promise::wait_1)
[-] 	JNC_MAP_OVERLOAD (&Promise::wait_2)
[+] 	JNC_MAP_OVERLOAD(&Promise::wait_2)
[-] 	JNC_MAP_FUNCTION ("blockingWait", &Promise::blockingWait)
[+] 	JNC_MAP_FUNCTION("blockingWait", &Promise::blockingWait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Promisifier)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Promisifier)
[-] 	JNC_MAP_FUNCTION ("complete", &Promisifier::complete_0)
[+] 	JNC_MAP_FUNCTION("complete", &Promisifier::complete_0)
[-] 	JNC_MAP_OVERLOAD (&Promisifier::complete_1)
[+] 	JNC_MAP_OVERLOAD(&Promisifier::complete_1)
[-] 	JNC_MAP_OVERLOAD (&Promisifier::complete_2)
[+] 	JNC_MAP_OVERLOAD(&Promisifier::complete_2)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Promise::markOpaqueGcRoots (GcHeap* gcHeap)
[+] Promise::markOpaqueGcRoots(GcHeap* gcHeap)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_result.m_type && (m_result.m_type->getFlags () & TypeFlag_GcRoot))
[+] 	if (m_result.m_type && (m_result.m_type->getFlags() & TypeFlag_GcRoot))
[-] 		m_result.m_type->markGcRoots (&m_result, gcHeap);
[+] 		m_result.m_type->markGcRoots(&m_result, gcHeap);
[-] 	sl::Iterator <AsyncWait> it = m_asyncWaitList.getHead ();
[+] 	sl::Iterator<AsyncWait> it = m_asyncWaitList.getHead();
[-] 			gcHeap->markClass (it->m_handlerPtr.m_closure->m_box);
[+] 			gcHeap->markClass(it->m_handlerPtr.m_closure->m_box);
[-] 		gcHeap->addShadowStackFrame (m_gcShadowStackFrame);
[+] 		gcHeap->addShadowStackFrame(m_gcShadowStackFrame);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Promise::wait_0 (FunctionPtr handlerPtr)
[+] Promise::wait_0(FunctionPtr handlerPtr)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		return addAsyncWait_l (AsyncWaitKind_NoArgs, handlerPtr);
[+] 		return addAsyncWait_l(AsyncWaitKind_NoArgs, handlerPtr);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	callVoidFunctionPtr (handlerPtr);
[+] 	callVoidFunctionPtr(handlerPtr);
[-] Promise::wait_1 (FunctionPtr handlerPtr)
[+] Promise::wait_1(FunctionPtr handlerPtr)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		return addAsyncWait_l (AsyncWaitKind_ErrorArg, handlerPtr);
[+] 		return addAsyncWait_l(AsyncWaitKind_ErrorArg, handlerPtr);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	callVoidFunctionPtr (handlerPtr, m_errorPtr);
[+] 	callVoidFunctionPtr(handlerPtr, m_errorPtr);
[-] Promise::wait_2 (FunctionPtr handlerPtr)
[+] Promise::wait_2(FunctionPtr handlerPtr)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		return addAsyncWait_l (AsyncWaitKind_ResultErrorArgs, handlerPtr);
[+] 		return addAsyncWait_l(AsyncWaitKind_ResultErrorArgs, handlerPtr);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	callVoidFunctionPtr (handlerPtr, m_result, m_errorPtr);
[+] 	callVoidFunctionPtr(handlerPtr, m_result, m_errorPtr);
[-] Promise::cancelWait (uintptr_t handle)
[+] Promise::cancelWait(uintptr_t handle)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	sl::HandleTableIterator <AsyncWait*> it = m_asyncWaitMap.find ((uintptr_t) handle);
[+] 	sl::HandleTableIterator<AsyncWait*> it = m_asyncWaitMap.find((uintptr_t)handle);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		err::setError (err::Error (err::SystemErrorCode_InvalidParameter));
[+] 		err::setError(err::Error(err::SystemErrorCode_InvalidParameter));
[-] 	m_asyncWaitList.erase (it->m_value);
[+] 	m_asyncWaitList.erase(it->m_value);
[-] 	m_asyncWaitMap.erase (it);
[+] 	m_asyncWaitMap.erase(it);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Promise::addAsyncWait_l (
[+] Promise::addAsyncWait_l(
[-] 	AsyncWait* wait = AXL_MEM_NEW (AsyncWait);
[+] 	AsyncWait* wait = AXL_MEM_NEW(AsyncWait);
[-] 	m_asyncWaitList.insertTail (wait);
[+] 	m_asyncWaitList.insertTail(wait);
[-] 	uintptr_t handle = m_asyncWaitMap.add (wait);
[+] 	uintptr_t handle = m_asyncWaitMap.add(wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Promise::blockingWaitImpl ()
[+] Promise::blockingWaitImpl()
[-]  	m_lock.lock ();
[+]  	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_syncWaitList.insertTail (&wait);
[+] 	m_syncWaitList.insertTail(&wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	event.wait ();
[+] 	event.wait();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_syncWaitList.remove (&wait);
[+] 	m_syncWaitList.remove(&wait);
[-] 	ASSERT (m_state == State_Completed);
[+] 	ASSERT(m_state == State_Completed);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 		err::setError ((const err::ErrorHdr*) m_errorPtr.m_p);
[+] 		err::setError((const err::ErrorHdr*) m_errorPtr.m_p);
[-] 		gcHeap->getRuntime ()->dynamicThrow ();
[+] 		gcHeap->getRuntime()->dynamicThrow();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Promisifier::complete_2 (
[+] Promisifier::complete_2(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		TRACE ("-- WARNING: ignoring repetitve completion for jnc.Promise: %p\n", this);
[+] 		TRACE("-- WARNING: ignoring repetitve completion for jnc.Promise: %p\n", this);
[-] 	sl::Iterator <SyncWait> syncIt = m_syncWaitList.getHead ();
[+] 	sl::Iterator<SyncWait> syncIt = m_syncWaitList.getHead();
[-] 		syncIt->m_event->signal ();
[+] 		syncIt->m_event->signal();
[-] 	while (!m_asyncWaitList.isEmpty ())
[+] 	while (!m_asyncWaitList.isEmpty())
[-] 		AsyncWait* wait = *m_asyncWaitList.getHead ();
[+] 		AsyncWait* wait = *m_asyncWaitList.getHead();
[-] 		m_asyncWaitMap.eraseKey (wait->m_handle);
[+] 		m_asyncWaitMap.eraseKey(wait->m_handle);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		callVoidFunctionPtr (wait->m_handlerPtr, m_result, m_errorPtr);
[+] 		callVoidFunctionPtr(wait->m_handlerPtr, m_result, m_errorPtr);
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		m_asyncWaitList.erase (wait);
[+] 		m_asyncWaitList.erase(wait);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Reactor.cpp
----------------------
[-] ReactorImpl_getType (jnc_Module* module)
[+] ReactorImpl_getType(jnc_Module* module)
[-] 	return (jnc_ClassType*) module->m_typeMgr.getStdType (StdType_ReactorBase);
[+] 	return (jnc_ClassType*)module->m_typeMgr.getStdType(StdType_ReactorBase);
[-] ReactorImpl_getQualifiedName ()
[+] ReactorImpl_getQualifiedName()
[-] ReactorImpl_getOpaqueClassTypeInfo ()
[+] ReactorImpl_getOpaqueClassTypeInfo()
[-] 		sizeof (ReactorImpl), // m_size
[+] 		sizeof(ReactorImpl), // m_size
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (ReactorImpl)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(ReactorImpl)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <ReactorImpl>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<ReactorImpl>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <ReactorImpl>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<ReactorImpl>)
[-] 	JNC_MAP_FUNCTION ("start", &ReactorImpl::start);
[+] 	JNC_MAP_FUNCTION("start", &ReactorImpl::start);
[-] 	JNC_MAP_FUNCTION ("stop", &ReactorImpl::stop);
[+] 	JNC_MAP_FUNCTION("stop", &ReactorImpl::stop);
[-] 	JNC_MAP_FUNCTION ("restart", &ReactorImpl::restart);
[+] 	JNC_MAP_FUNCTION("restart", &ReactorImpl::restart);
[-] 	JNC_MAP_FUNCTION ("!addOnChangedBinding", &ReactorImpl::addOnChangedBinding);
[+] 	JNC_MAP_FUNCTION("!addOnChangedBinding", &ReactorImpl::addOnChangedBinding);
[-] 	JNC_MAP_FUNCTION ("!addOnEventBinding", &ReactorImpl::addOnEventBinding);
[+] 	JNC_MAP_FUNCTION("!addOnEventBinding", &ReactorImpl::addOnEventBinding);
[-] 	JNC_MAP_FUNCTION ("!resetOnChangedBindings", &ReactorImpl::resetOnChangedBindings);
[+] 	JNC_MAP_FUNCTION("!resetOnChangedBindings", &ReactorImpl::resetOnChangedBindings);
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] ReactorImpl::ReactorImpl ()
[+] ReactorImpl::ReactorImpl()
[-] 	ASSERT (isClassType (m_ifaceHdr.m_box->m_type, ClassTypeKind_Reactor));
[+] 	ASSERT(isClassType(m_ifaceHdr.m_box->m_type, ClassTypeKind_Reactor));
[-] 	ct::ReactorClassType* reactorType = (ct::ReactorClassType*) m_ifaceHdr.m_box->m_type;
[+] 	ct::ReactorClassType* reactorType = (ct::ReactorClassType*)m_ifaceHdr.m_box->m_type;
[-] 	size_t reactionCount = reactorType->getReactionCount ();
[+] 	size_t reactionCount = reactorType->getReactionCount();
[-] 	m_reactionArray.setCount (reactionCount);
[+] 	m_reactionArray.setCount(reactionCount);
[-] 		m_reactionArray [i] = AXL_MEM_NEW (Reaction);
[+] 		m_reactionArray[i] = AXL_MEM_NEW(Reaction);
[-] 	m_pendingReactionMap.setBitCount (reactionCount);
[+] 	m_pendingReactionMap.setBitCount(reactionCount);
[-] ReactorImpl::start ()
[+] ReactorImpl::start()
[-] 	m_pendingReactionMap.setBitRange (0, -1); // enqueue all reactions
[+] 	m_pendingReactionMap.setBitRange(0, -1); // enqueue all reactions
[-] 	reactionLoop ();
[+] 	reactionLoop();
[-] 	ASSERT (m_state == State_Reacting);
[+] 	ASSERT(m_state == State_Reacting);
[-] ReactorImpl::stop ()
[+] ReactorImpl::stop()
[-] 	sl::Iterator <Binding> it = m_bindingList.getHead ();
[+] 	sl::Iterator<Binding> it = m_bindingList.getHead();
[-] 		((rtl::MulticastImpl*) it->m_multicast)->removeHandler (it->m_handler);
[+] 		((rtl::MulticastImpl*)it->m_multicast)->removeHandler(it->m_handler);
[-] 	size_t reactionCount = m_reactionArray.getCount ();
[+] 	size_t reactionCount = m_reactionArray.getCount();
[-] 		Reaction* reaction = m_reactionArray [i];
[+] 		Reaction* reaction = m_reactionArray[i];
[-] 		reaction->m_bindingArray.clear ();
[+] 		reaction->m_bindingArray.clear();
[-] 	m_pendingReactionMap.clear ();
[+] 	m_pendingReactionMap.clear();
[-] 	m_pendingOnChangedBindingArray.clear ();
[+] 	m_pendingOnChangedBindingArray.clear();
[-] 	m_pendingOnEventBindingArray.clear ();
[+] 	m_pendingOnEventBindingArray.clear();
[-] 	m_bindingList.clear ();
[+] 	m_bindingList.clear();
[-] 	m_bindingMap.clear ();
[+] 	m_bindingMap.clear();
[-] ReactorImpl::onChanged (Binding* binding)
[+] ReactorImpl::onChanged(Binding* binding)
[-] 	m_pendingReactionMap.merge (binding->m_reactionMap, sl::BitOpKind_Or);
[+] 	m_pendingReactionMap.merge(binding->m_reactionMap, sl::BitOpKind_Or);
[-] 	reactionLoop ();
[+] 	reactionLoop();
[-] 	ASSERT (m_state == State_Reacting);
[+] 	ASSERT(m_state == State_Reacting);
[-] ReactorImpl::reactionLoop ()
[+] ReactorImpl::reactionLoop()
[-] 	ASSERT (isClassType (m_ifaceHdr.m_box->m_type, ClassTypeKind_Reactor));
[+] 	ASSERT(isClassType(m_ifaceHdr.m_box->m_type, ClassTypeKind_Reactor));
[-] 	ct::ReactorClassType* reactorType = (ct::ReactorClassType*) m_ifaceHdr.m_box->m_type;
[+] 	ct::ReactorClassType* reactorType = (ct::ReactorClassType*)m_ifaceHdr.m_box->m_type;
[-] 	Function* reaction = reactorType->getReaction ();
[+] 	Function* reaction = reactorType->getReaction();
[-] 	ReactionFunc* reactionFunc = (ReactionFunc*) reaction->getMachineCode ();
[+] 	ReactionFunc* reactionFunc = (ReactionFunc*)reaction->getMachineCode();
[-] 	size_t parentOffset = reactorType->getParentOffset ();
[+] 	size_t parentOffset = reactorType->getParentOffset();
[-] 	IfaceHdr* parent = parentOffset ? (IfaceHdr*) ((char*) this - parentOffset) : NULL;
[+] 	IfaceHdr* parent = parentOffset ? (IfaceHdr*)((char*)this - parentOffset) : NULL;
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Binding*> oldBindingArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Binding*> oldBindingArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	size_t reactionCount = m_reactionArray.getCount ();
[+] 	size_t reactionCount = m_reactionArray.getCount();
[-] 		m_reactionArray [i]->m_activationCount = 0;
[+] 		m_reactionArray[i]->m_activationCount = 0;
[-] 		i = m_pendingReactionMap.findBit (i + 1);
[+] 		i = m_pendingReactionMap.findBit(i + 1);
[-] 			i = m_pendingReactionMap.findBit (0); // wrap
[+] 			i = m_pendingReactionMap.findBit(0); // wrap
[-] 		m_pendingReactionMap.setBit (i, false);
[+] 		m_pendingReactionMap.setBit(i, false);
[-] 		Reaction* reaction = m_reactionArray [i];
[+] 		Reaction* reaction = m_reactionArray[i];
[-] 		ASSERT (reaction);
[+] 		ASSERT(reaction);
[-] 		m_pendingOnChangedBindingArray.clear ();
[+] 		m_pendingOnChangedBindingArray.clear();
[-] 		m_pendingOnEventBindingArray.clear ();
[+] 		m_pendingOnEventBindingArray.clear();
[-] 		reactionFunc (this, i);
[+] 		reactionFunc(this, i);
[-] 		size_t oldBindingCount = reaction->m_bindingArray.getCount ();
[+] 		size_t oldBindingCount = reaction->m_bindingArray.getCount();
[-] 		oldBindingArray.copy (reaction->m_bindingArray, oldBindingCount);
[+] 		oldBindingArray.copy(reaction->m_bindingArray, oldBindingCount);
[-] 		size_t bindingCount = m_pendingOnChangedBindingArray.getCount ();
[+] 		size_t bindingCount = m_pendingOnChangedBindingArray.getCount();
[-] 			Multicast* multicast = m_pendingOnChangedBindingArray [j];
[+] 			Multicast* multicast = m_pendingOnChangedBindingArray[j];
[-] 			sl::HashTableIterator <Multicast*, Binding*> it = m_bindingMap.visit (multicast);
[+] 			sl::HashTableIterator<Multicast*, Binding*> it = m_bindingMap.visit(multicast);
[-] 				binding = subscribe (multicast);
[+] 				binding = subscribe(multicast);
[-] 			if (!binding->m_reactionMap.getBit (i))
[+] 			if (!binding->m_reactionMap.getBit(i))
[-] 				binding->m_reactionMap.setBitResize (i);
[+] 				binding->m_reactionMap.setBitResize(i);
[-] 				ASSERT (reaction->m_bindingArray.find (binding) == -1);
[+] 				ASSERT(reaction->m_bindingArray.find(binding) == -1);
[-] 				reaction->m_bindingArray.append (binding);
[+] 				reaction->m_bindingArray.append(binding);
[-] 			Binding* binding = oldBindingArray [j];
[+] 			Binding* binding = oldBindingArray[j];
[-] 			if (binding->m_reactionMap.findBit (0) != -1)
[+] 			if (binding->m_reactionMap.findBit(0) != -1)
[-] 			((rtl::MulticastImpl*) binding->m_multicast)->removeHandler (binding->m_handler);
[+] 			((rtl::MulticastImpl*)binding->m_multicast)->removeHandler(binding->m_handler);
[-] 			m_bindingMap.erase (binding->m_bindingMapIt);
[+] 			m_bindingMap.erase(binding->m_bindingMapIt);
[-] 			m_bindingList.erase (binding);
[+] 			m_bindingList.erase(binding);
[-] 		if (!m_pendingOnEventBindingArray.isEmpty ())
[+] 		if (!m_pendingOnEventBindingArray.isEmpty())
[-] 			Function* onEvent = reactorType->findOnEventHandler (i);
[+] 			Function* onEvent = reactorType->findOnEventHandler(i);
[-] 			ASSERT (onEvent);
[+] 			ASSERT(onEvent);
[-] 			AXL_TODO ("currently, onevent handlers adjust 'this' internally -- need to clean that up and pass 'parent' directly")
[+] 			AXL_TODO("currently, onevent handlers adjust 'this' internally -- need to clean that up and pass 'parent' directly")
[-] 				onEvent->getMachineCode (),
[+] 				onEvent->getMachineCode(),
[-] 			size_t bindingCount = m_pendingOnEventBindingArray.getCount ();
[+] 			size_t bindingCount = m_pendingOnEventBindingArray.getCount();
[-] 				Multicast* multicast = m_pendingOnEventBindingArray [j];
[+] 				Multicast* multicast = m_pendingOnEventBindingArray[j];
[-] 				Binding* binding = subscribe (multicast, onEventPtr);
[+] 				Binding* binding = subscribe(multicast, onEventPtr);
[-] 				reaction->m_bindingArray.append (binding);
[+] 				reaction->m_bindingArray.append(binding);
[-] ReactorImpl::subscribe (Multicast* multicast)
[+] ReactorImpl::subscribe(Multicast* multicast)
[-] 	Binding* binding = AXL_MEM_NEW (Binding);
[+] 	Binding* binding = AXL_MEM_NEW(Binding);
[-] 	m_bindingList.insertTail (binding);
[+] 	m_bindingList.insertTail(binding);
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	ClassType* closureType = (ClassType*) runtime->getModule ()->m_typeMgr.getStdType (StdType_ReactorClosure);
[+] 	ClassType* closureType = (ClassType*)runtime->getModule()->m_typeMgr.getStdType(StdType_ReactorClosure);
[-] 	ReactorClosure* closure = (ReactorClosure*) runtime->getGcHeap ()->allocateClass (closureType);
[+] 	ReactorClosure* closure = (ReactorClosure*)runtime->getGcHeap()->allocateClass(closureType);
[-] 	functionPtr.m_p = jnc_pvoid_cast (onChangedThunk);
[+] 	functionPtr.m_p = jnc_pvoid_cast(onChangedThunk);
[-] 	binding->m_handler = ((MulticastImpl*) multicast)->addHandler (functionPtr);
[+] 	binding->m_handler = ((MulticastImpl*)multicast)->addHandler(functionPtr);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] ReactorImpl::subscribe (
[+] ReactorImpl::subscribe(
[-] 	Binding* binding = AXL_MEM_NEW (Binding);
[+] 	Binding* binding = AXL_MEM_NEW(Binding);
[-] 	binding->m_handler = ((MulticastImpl*) multicast)->addHandler (functionPtr);
[+] 	binding->m_handler = ((MulticastImpl*)multicast)->addHandler(functionPtr);
[-] 	m_bindingList.insertTail (binding);
[+] 	m_bindingList.insertTail(binding);
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Regex.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (RegexState)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(RegexState)
[-] 	JNC_MAP_CONSTRUCTOR (&RegexState::construct)
[+] 	JNC_MAP_CONSTRUCTOR(&RegexState::construct)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_matchLengthLimit", &RegexState::setMatchLengthLimit)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_matchLengthLimit", &RegexState::setMatchLengthLimit)
[-] 	JNC_MAP_AUTOGET_PROPERTY ("m_currentOffset", &RegexState::setCurrentOffset)
[+] 	JNC_MAP_AUTOGET_PROPERTY("m_currentOffset", &RegexState::setCurrentOffset)
[-] 	JNC_MAP_FUNCTION ("reset", &RegexState::reset)
[+] 	JNC_MAP_FUNCTION("reset", &RegexState::reset)
[-] 	JNC_MAP_FUNCTION ("exec", &RegexState::exec)
[+] 	JNC_MAP_FUNCTION("exec", &RegexState::exec)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (RegexDfa)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(RegexDfa)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <RegexDfa>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<RegexDfa>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <RegexDfa>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<RegexDfa>)
[-] 	JNC_MAP_FUNCTION ("clear", &RegexDfa::clear)
[+] 	JNC_MAP_FUNCTION("clear", &RegexDfa::clear)
[-] 	JNC_MAP_FUNCTION ("incrementalCompile", &RegexDfa::incrementalCompile)
[+] 	JNC_MAP_FUNCTION("incrementalCompile", &RegexDfa::incrementalCompile)
[-] 	JNC_MAP_FUNCTION ("finalize", &RegexDfa::finalize)
[+] 	JNC_MAP_FUNCTION("finalize", &RegexDfa::finalize)
[-] 	JNC_MAP_FUNCTION ("match", &RegexDfa::match)
[+] 	JNC_MAP_FUNCTION("match", &RegexDfa::match)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] RegexState::construct (bool isIncremental)
[+] RegexState::construct(bool isIncremental)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	m_matchBufferPtr = gcHeap->allocateBuffer (m_matchLengthLimit);
[+] 	m_matchBufferPtr = gcHeap->allocateBuffer(m_matchLengthLimit);
[-] RegexState::markOpaqueGcRoots (GcHeap* gcHeap)
[+] RegexState::markOpaqueGcRoots(GcHeap* gcHeap)
[-] 		gcHeap->weakMark (m_matchBufferPtr.m_validator->m_validatorBox);
[+] 		gcHeap->weakMark(m_matchBufferPtr.m_validator->m_validatorBox);
[-] 		gcHeap->markData (m_matchBufferPtr.m_validator->m_targetBox);
[+] 		gcHeap->markData(m_matchBufferPtr.m_validator->m_targetBox);
[-] 		gcHeap->weakMark (m_groupOffsetArrayPtr.m_validator->m_validatorBox);
[+] 		gcHeap->weakMark(m_groupOffsetArrayPtr.m_validator->m_validatorBox);
[-] 		gcHeap->markData (m_groupOffsetArrayPtr.m_validator->m_targetBox);
[+] 		gcHeap->markData(m_groupOffsetArrayPtr.m_validator->m_targetBox);
[-] RegexState::setMatchLengthLimit (size_t length)
[+] RegexState::setMatchLengthLimit(size_t length)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr ptr = gcHeap->allocateBuffer (m_matchLengthLimit);
[+] 	DataPtr ptr = gcHeap->allocateBuffer(m_matchLengthLimit);
[-] 		memcpy (ptr.m_p, m_matchBufferPtr.m_p, m_matchLength);
[+] 		memcpy(ptr.m_p, m_matchBufferPtr.m_p, m_matchLength);
[-] RegexState::setCurrentOffset (size_t offset)
[+] RegexState::setCurrentOffset(size_t offset)
[-] RegexState::reset ()
[+] RegexState::reset()
[-] 	memset (&m_match, 0, sizeof (RegexMatch));
[+] 	memset(&m_match, 0, sizeof(RegexMatch));
[-] RegexState::exec (
[+] RegexState::exec(
[-] 		setDfa (dfa);
[+] 		setDfa(dfa);
[-] 		length = strLen (ptr);
[+] 		length = strLen(ptr);
[-] 		ASSERT (m_isIncremental);
[+] 		ASSERT(m_isIncremental);
[-] 		result = writeData ((uchar_t*) m_matchBufferPtr.m_p + replayBufferOffset, replayLength);
[+] 		result = writeData((uchar_t*)m_matchBufferPtr.m_p + replayBufferOffset, replayLength);
[-] 		switch (result)
[+] 		switch(result)
[-] 			softReset ();
[+] 			softReset();
[-] 			if ((intptr_t) consumedLength < 0)
[+] 			if ((intptr_t)consumedLength < 0)
[-] 				memmove (
[+] 				memmove(
[-] 					(uchar_t*) m_matchBufferPtr.m_p + m_replayBufferOffset + m_replayLength,
[+] 					(uchar_t*)m_matchBufferPtr.m_p + m_replayBufferOffset + m_replayLength,
[-] 					(uchar_t*) m_matchBufferPtr.m_p + replayBufferOffset + consumedLength,
[+] 					(uchar_t*)m_matchBufferPtr.m_p + replayBufferOffset + consumedLength,
[-] 		ASSERT (!m_replayLength);
[+] 		ASSERT(!m_replayLength);
[-] 		result = eof ();
[+] 		result = eof();
[-] 		result = writeData ((uchar_t*) ptr.m_p, length);
[+] 		result = writeData((uchar_t*)ptr.m_p, length);
[-] 			result = eof ();
[+] 			result = eof();
[-] 		softReset ();
[+] 		softReset();
[-] 	if ((intptr_t) m_consumedLength < 0)
[+] 	if ((intptr_t)m_consumedLength < 0)
[-] RegexState::setDfa (ct::Dfa* dfa)
[+] RegexState::setDfa(ct::Dfa* dfa)
[-] 	m_groupCount = dfa->getGroupCount ();
[+] 	m_groupCount = dfa->getGroupCount();
[-] 	m_maxSubMatchCount = dfa->getMaxSubMatchCount ();
[+] 	m_maxSubMatchCount = dfa->getMaxSubMatchCount();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	Module* module = gcHeap->getRuntime ()->getModule ();
[+] 	Module* module = gcHeap->getRuntime()->getModule();
[-] 	Type* matchType = module->m_typeMgr.getStdType (StdType_RegexMatch);
[+] 	Type* matchType = module->m_typeMgr.getStdType(StdType_RegexMatch);
[-] 	Type* sizeType = module->m_typeMgr.getPrimitiveType (TypeKind_SizeT);
[+] 	Type* sizeType = module->m_typeMgr.getPrimitiveType(TypeKind_SizeT);
[-] 	m_groupOffsetArrayPtr = m_groupCount ? gcHeap->allocateArray (sizeType, m_groupCount * 2) : g_nullPtr;
[+] 	m_groupOffsetArrayPtr = m_groupCount ? gcHeap->allocateArray(sizeType, m_groupCount * 2) : g_nullPtr;
[-] 	m_subMatchArrayPtr = m_maxSubMatchCount ? gcHeap->allocateArray (matchType, m_maxSubMatchCount) : g_nullPtr;
[+] 	m_subMatchArrayPtr = m_maxSubMatchCount ? gcHeap->allocateArray(matchType, m_maxSubMatchCount) : g_nullPtr;
[-] 	softReset ();
[+] 	softReset();
[-] RegexState::processGroupSet (ct::DfaGroupSet* groupSet)
[+] RegexState::processGroupSet(ct::DfaGroupSet* groupSet)
[-] 	size_t* offsetArray = (size_t*) m_groupOffsetArrayPtr.m_p;
[+] 	size_t* offsetArray = (size_t*)m_groupOffsetArrayPtr.m_p;
[-] 	size_t count = groupSet->m_openArray.getCount ();
[+] 	size_t count = groupSet->m_openArray.getCount();
[-] 		size_t groupId = groupSet->m_openArray [i];
[+] 		size_t groupId = groupSet->m_openArray[i];
[-] 		ASSERT (groupId < m_groupCount);
[+] 		ASSERT(groupId < m_groupCount);
[-] 		offsetArray [groupId * 2] = offset;
[+] 		offsetArray[groupId * 2] = offset;
[-] 		offsetArray [groupId * 2 + 1] = offset;
[+] 		offsetArray[groupId * 2 + 1] = offset;
[-] 	count = groupSet->m_closeArray.getCount ();
[+] 	count = groupSet->m_closeArray.getCount();
[-] 		size_t groupId = groupSet->m_closeArray [i];
[+] 		size_t groupId = groupSet->m_closeArray[i];
[-] 		ASSERT (groupId < m_groupCount);
[+] 		ASSERT(groupId < m_groupCount);
[-] 		offsetArray [groupId * 2 + 1] = m_currentOffset - m_matchOffset;
[+] 		offsetArray[groupId * 2 + 1] = m_currentOffset - m_matchOffset;
[-] RegexState::softReset ()
[+] RegexState::softReset()
[-] 	memset (m_groupOffsetArrayPtr.m_p, -1, m_groupCount * sizeof (size_t) * 2);
[+] 	memset(m_groupOffsetArrayPtr.m_p, -1, m_groupCount * sizeof(size_t)* 2);
[-] 		ct::DfaStateInfo* state = m_dfa->getStateInfo (0);
[+] 		ct::DfaStateInfo* state = m_dfa->getStateInfo(0);
[-] 			processGroupSet (state->m_groupSet);
[+] 			processGroupSet(state->m_groupSet);
[-] RegexState::eof ()
[+] RegexState::eof()
[-] 	ASSERT (m_lastAcceptMatchLength <= m_matchLength);
[+] 	ASSERT(m_lastAcceptMatchLength <= m_matchLength);
[-] 		rollback ();
[+] 		rollback();
[-] 		match (m_lastAcceptStateId);
[+] 		match(m_lastAcceptStateId);
[-] RegexState::writeData (
[+] RegexState::writeData(
[-] 		size_t result = writeChar (c);
[+] 		size_t result = writeChar(c);
[-] RegexState::writeChar (uchar_t c)
[+] RegexState::writeChar(uchar_t c)
[-] 	((uchar_t*) m_matchBufferPtr.m_p) [m_matchLength++] = c;
[+] 	((uchar_t*)m_matchBufferPtr.m_p) [m_matchLength++] = c;
[-] 	uintptr_t targetStateId = m_dfa->getTransition (m_stateId, c);
[+] 	uintptr_t targetStateId = m_dfa->getTransition(m_stateId, c);
[-] 		return gotoState (targetStateId);
[+] 		return gotoState(targetStateId);
[-] 	rollback ();
[+] 	rollback();
[-] RegexState::gotoState (size_t stateId)
[+] RegexState::gotoState(size_t stateId)
[-] 	ct::DfaStateInfo* state = m_dfa->getStateInfo (stateId);
[+] 	ct::DfaStateInfo* state = m_dfa->getStateInfo(stateId);
[-] 		processGroupSet (state->m_groupSet);
[+] 		processGroupSet(state->m_groupSet);
[-] 		match (stateId);
[+] 		match(stateId);
[-] RegexState::match (size_t stateId)
[+] RegexState::match(size_t stateId)
[-] 	ASSERT ((intptr_t) stateId >= 0);
[+] 	ASSERT((intptr_t)stateId >= 0);
[-] 	m_match.m_textPtr = jnc::strDup ((char*) m_matchBufferPtr.m_p, m_matchLength);
[+] 	m_match.m_textPtr = jnc::strDup((char*)m_matchBufferPtr.m_p, m_matchLength);
[-] 	ct::DfaStateInfo* state = m_dfa->getStateInfo (stateId);
[+] 	ct::DfaStateInfo* state = m_dfa->getStateInfo(stateId);
[-] 	ASSERT (state->m_acceptInfo);
[+] 	ASSERT(state->m_acceptInfo);
[-] 		processGroupSet (state->m_groupSet);
[+] 		processGroupSet(state->m_groupSet);
[-] 	RegexMatch* subMatchArray = (RegexMatch*) m_subMatchArrayPtr.m_p;
[+] 	RegexMatch* subMatchArray = (RegexMatch*)m_subMatchArrayPtr.m_p;
[-] 	size_t* offsetArray = (size_t*) m_groupOffsetArrayPtr.m_p;
[+] 	size_t* offsetArray = (size_t*)m_groupOffsetArrayPtr.m_p;
[-] 		RegexMatch* subLexeme = &subMatchArray [i];
[+] 		RegexMatch* subLexeme = &subMatchArray[i];
[-] 		size_t offset = offsetArray [j++];
[+] 		size_t offset = offsetArray[j++];
[-] 		size_t length = offsetArray [j++] - offset;
[+] 		size_t length = offsetArray[j++] - offset;
[-] 			ASSERT (offset + length <= m_matchLength);
[+] 			ASSERT(offset + length <= m_matchLength);
[-] 			subLexeme->m_textPtr = jnc::strDup ((char*) m_matchBufferPtr.m_p + offset, length);
[+] 			subLexeme->m_textPtr = jnc::strDup((char*)m_matchBufferPtr.m_p + offset, length);
[-] 	softReset ();
[+] 	softReset();
[-] RegexState::rollback ()
[+] RegexState::rollback()
[-] 	ASSERT (m_lastAcceptStateId != -1 && m_lastAcceptMatchLength);
[+] 	ASSERT(m_lastAcceptStateId != -1 && m_lastAcceptMatchLength);
[-] 	size_t* offsetArray = (size_t*) m_groupOffsetArrayPtr.m_p;
[+] 	size_t* offsetArray = (size_t*)m_groupOffsetArrayPtr.m_p;
[-] 		if (offsetArray [j] == -1)
[+] 		if (offsetArray[j] == -1)
[-] 		if (offsetArray [j] >= m_matchLength)
[+] 		if (offsetArray[j] >= m_matchLength)
[-] 			offsetArray [j] = -1;
[+] 			offsetArray[j] = -1;
[-] 			offsetArray [j + 1] = -1;
[+] 			offsetArray[j + 1] = -1;
[-] 		else if (offsetArray [j + 1] > m_matchLength)
[+] 		else if (offsetArray[j + 1] > m_matchLength)
[-] 			ASSERT (offsetArray [j] < m_matchLength);
[+] 			ASSERT(offsetArray[j] < m_matchLength);
[-] 			offsetArray [j + 1] = m_matchLength;
[+] 			offsetArray[j + 1] = m_matchLength;
[-] 	match (m_lastAcceptStateId);
[+] 	match(m_lastAcceptStateId);
[-] RegexDfa::clear ()
[+] RegexDfa::clear()
[-] 	m_regex.clear ();
[+] 	m_regex.clear();
[-] 	m_acceptContextList.clear ();
[+] 	m_acceptContextList.clear();
[-] 	m_dfa.clear ();
[+] 	m_dfa.clear();
[-] RegexDfa::incrementalCompile (
[+] RegexDfa::incrementalCompile(
[-] 	if (!m_dfa.isEmpty ())
[+] 	if (!m_dfa.isEmpty())
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 		length = jnc::strLen (regexStringPtr);
[+] 		length = jnc::strLen(regexStringPtr);
[-] 	ct::ReSwitchAcceptContext* context = AXL_MEM_NEW (ct::ReSwitchAcceptContext);
[+] 	ct::ReSwitchAcceptContext* context = AXL_MEM_NEW(ct::ReSwitchAcceptContext);
[-] 	context->m_firstGroupId = m_regex.getGroupCount ();
[+] 	context->m_firstGroupId = m_regex.getGroupCount();
[-] 	context->m_actionIdx = m_acceptContextList.getCount ();
[+] 	context->m_actionIdx = m_acceptContextList.getCount();
[-] 	m_acceptContextList.insertTail (context);
[+] 	m_acceptContextList.insertTail(context);
[-] 	fsm::RegexCompiler compiler (&m_regex);
[+] 	fsm::RegexCompiler compiler(&m_regex);
[-] 	return compiler.incrementalCompile (sl::StringRef ((const char*) regexStringPtr.m_p, length), context);
[+] 	return compiler.incrementalCompile(sl::StringRef((const char*) regexStringPtr.m_p, length), context);
[-] RegexDfa::finalize ()
[+] RegexDfa::finalize()
[-] 	if (!m_dfa.isEmpty ())
[+] 	if (!m_dfa.isEmpty())
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	fsm::RegexCompiler regexCompiler (&m_regex);
[+] 	fsm::RegexCompiler regexCompiler(&m_regex);
[-] 	regexCompiler.finalize ();
[+] 	regexCompiler.finalize();
[-] 	sl::Iterator <ct::ReSwitchAcceptContext> prev = m_acceptContextList.getHead ();
[+] 	sl::Iterator<ct::ReSwitchAcceptContext> prev = m_acceptContextList.getHead();
[-] 	sl::Iterator <ct::ReSwitchAcceptContext> next = prev.getNext ();
[+] 	sl::Iterator<ct::ReSwitchAcceptContext> next = prev.getNext();
[-] 		err::setError ("empty regular expression");
[+] 		err::setError("empty regular expression");
[-] 	prev->m_groupCount = m_regex.getGroupCount () - prev->m_firstGroupId;
[+] 	prev->m_groupCount = m_regex.getGroupCount() - prev->m_firstGroupId;
[-] 	return m_dfa.build (&m_regex);
[+] 	return m_dfa.build(&m_regex);
[-] RegexDfa::match (
[+] RegexDfa::match(
[-] 	size_t stateId = state->exec (&m_dfa, ptr, length);
[+] 	size_t stateId = state->exec(&m_dfa, ptr, length);
[-] 	if ((intptr_t) stateId <= 0)
[+] 	if ((intptr_t)stateId <= 0)
[-] 		err::setError ("regular expression mismatch");
[+] 		err::setError("regular expression mismatch");
[-] 	sl::Array <fsm::DfaState*> stateArray = m_regex.getDfaStateArray ();
[+] 	sl::Array<fsm::DfaState*> stateArray = m_regex.getDfaStateArray();
[-] 	fsm::DfaState* dfaState = stateArray [stateId];
[+] 	fsm::DfaState* dfaState = stateArray[stateId];
[-] 	ASSERT (dfaState->m_isAccept);
[+] 	ASSERT(dfaState->m_isAccept);
[-] 	ct::ReSwitchAcceptContext* context = (ct::ReSwitchAcceptContext*) dfaState->m_acceptContext;
[+] 	ct::ReSwitchAcceptContext* context = (ct::ReSwitchAcceptContext*)dfaState->m_acceptContext;
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_DynamicLayout.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (DynamicLayout)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(DynamicLayout)
[-] 		size_t hash () const
[+] 		size_t hash() const
[-] 			return sl::djb2 (this, sizeof (Key));
[+] 			return sl::djb2(this, sizeof(Key));
[-] 		bool isEqual (const Key& key) const
[+] 		bool isEqual(const Key& key) const
[-] 		sl::Array <size_t> m_endOffsetArray;
[+] 		sl::Array<size_t> m_endOffsetArray;
[-] 	sl::DuckTypeHashTable <Key, Entry*> m_map;
[+] 	sl::DuckTypeHashTable<Key, Entry*> m_map;
[-] 	sl::List <Entry> m_list;
[+] 	sl::List<Entry> m_list;
[-] 	getType (Module* module);
[+] 	getType(Module* module);
[-] 	getDynamicFieldSize (
[+] 	getDynamicFieldSize(
[-] 	getDynamicFieldEndOffset (
[+] 	getDynamicFieldEndOffset(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_DynamicLib.h
----------------------
[-] JNC_DECLARE_CLASS_TYPE (DynamicLib)
[+] JNC_DECLARE_CLASS_TYPE(DynamicLib)
[-] 	open (DataPtr fileNamePtr)
[+] 	open(DataPtr fileNamePtr)
[-] 		return openImpl ((const char*) fileNamePtr.m_p);
[+] 		return openImpl((const char*) fileNamePtr.m_p);
[-] 	openImpl (const sl::StringRef& fileName);
[+] 	openImpl(const sl::StringRef& fileName);
[-] 	close ()
[+] 	close()
[-] 		getDynamicLibrary ()->close ();
[+] 		getDynamicLibrary()->close();
[-] 	getFunction (DataPtr namePtr)
[+] 	getFunction(DataPtr namePtr)
[-] 		return getFunctionImpl ((const char*) namePtr.m_p);
[+] 		return getFunctionImpl((const char*) namePtr.m_p);
[-] 	getFunctionImpl (const sl::StringRef& name);
[+] 	getFunctionImpl(const sl::StringRef& name);
[-] 	getDynamicLibrary ()
[+] 	getDynamicLibrary()
[-] 		ASSERT (sizeof (sys::DynamicLibrary) == sizeof (m_handle));
[+] 		ASSERT(sizeof(sys::DynamicLibrary) == sizeof(m_handle));
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Multicast.h
----------------------
[-] 	destruct ();
[+] 	destruct();
[-] 	clear ();
[+] 	clear();
[-] 	setHandler (FunctionPtr ptr);
[+] 	setHandler(FunctionPtr ptr);
[-] 	setHandler_t (void* p);
[+] 	setHandler_t(void* p);
[-] 	addHandler (FunctionPtr ptr)
[+] 	addHandler(FunctionPtr ptr)
[-] 		return ptr.m_p ? addHandlerImpl (ptr) : NULL;
[+] 		return ptr.m_p ? addHandlerImpl(ptr) : NULL;
[-] 	addHandler_t (void* p)
[+] 	addHandler_t(void* p)
[-] 		return p ? addHandlerImpl (p) : NULL;
[+] 		return p ? addHandlerImpl(p) : NULL;
[-] 	removeHandler (handle_t handle)
[+] 	removeHandler(handle_t handle)
[-] 		return removeHandlerImpl <FunctionPtr> (handle);
[+] 		return removeHandlerImpl<FunctionPtr> (handle);
[-] 	removeHandler_t (handle_t handle)
[+] 	removeHandler_t(handle_t handle)
[-] 		return removeHandlerImpl <void*> (handle);
[+] 		return removeHandlerImpl<void*> (handle);
[-] 	getSnapshot ();
[+] 	getSnapshot();
[-] 	sl::HandleTable <size_t>*
[+] 	sl::HandleTable<size_t>*
[-] 	getHandleTable ();
[+] 	getHandleTable();
[-] 	setCount (
[+] 	setCount(
[-] 	setHandlerImpl (T ptr)
[+] 	setHandlerImpl(T ptr)
[-] 		bool result = setCount (1, sizeof (T));
[+] 		bool result = setCount(1, sizeof(T));
[-] 		*(T*) m_ptr.m_p = ptr;
[+] 		*(T*)m_ptr.m_p = ptr;
[-] 		sl::HandleTable <size_t>* handleTable = getHandleTable ();
[+] 		sl::HandleTable<size_t>* handleTable = getHandleTable();
[-] 		handleTable->clear ();
[+] 		handleTable->clear();
[-] 		return (handle_t) handleTable->add (0);
[+] 		return (handle_t)handleTable->add(0);
[-] 	addHandlerImpl (T ptr)
[+] 	addHandlerImpl(T ptr)
[-] 		bool result = setCount (i + 1, sizeof (T));
[+] 		bool result = setCount(i + 1, sizeof(T));
[-] 		*((T*) m_ptr.m_p + i) = ptr;
[+] 		*((T*)m_ptr.m_p + i) = ptr;
[-] 		return (handle_t) getHandleTable ()->add (i);
[+] 		return (handle_t)getHandleTable()->add(i);
[-] 	removeHandlerImpl (handle_t handle)
[+] 	removeHandlerImpl(handle_t handle)
[-] 		sl::HandleTable <size_t>* handleTable = (sl::HandleTable <size_t>*) m_handleTable;
[+] 		sl::HandleTable<size_t>* handleTable = (sl::HandleTable<size_t>*) m_handleTable;
[-] 		sl::HandleTableIterator <size_t> it = handleTable->find ((uintptr_t) handle);
[+] 		sl::HandleTableIterator<size_t> it = handleTable->find((uintptr_t)handle);
[-] 		ASSERT (i < m_count);
[+] 		ASSERT(i < m_count);
[-] 		ptr = *((T*) m_ptr.m_p + i);
[+] 		ptr = *((T*)m_ptr.m_p + i);
[-] 		size_t moveSize = (m_count - i - 1) * sizeof (T);
[+] 		size_t moveSize = (m_count - i - 1) * sizeof(T);
[-] 			memmove ((T*) m_ptr.m_p + i, (T*) m_ptr.m_p + i + 1, moveSize);
[+] 			memmove((T*)m_ptr.m_p + i, (T*)m_ptr.m_p + i + 1, moveSize);
[-] 		memset ((T*) m_ptr.m_p + m_count, 0, sizeof (T));
[+] 		memset((T*)m_ptr.m_p + m_count, 0, sizeof(T));
[-] 		sl::HandleTableIterator <size_t> it0 = it;
[+] 		sl::HandleTableIterator<size_t> it0 = it;
[-] 		handleTable->erase (it0);
[+] 		handleTable->erase(it0);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Promise.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Promise)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Promise)
[-] JNC_DECLARE_CLASS_TYPE (Promisifier)
[+] JNC_DECLARE_CLASS_TYPE(Promisifier)
[-] 	sl::AuxList <SyncWait> m_syncWaitList;
[+] 	sl::AuxList<SyncWait> m_syncWaitList;
[-] 	sl::List <AsyncWait> m_asyncWaitList;
[+] 	sl::List<AsyncWait> m_asyncWaitList;
[-] 	sl::HandleTable <AsyncWait*> m_asyncWaitMap;
[+] 	sl::HandleTable<AsyncWait*> m_asyncWaitMap;
[-] 	markOpaqueGcRoots (GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(GcHeap* gcHeap);
[-] 	wait_0 (FunctionPtr handlerPtr);
[+] 	wait_0(FunctionPtr handlerPtr);
[-] 	wait_1 (FunctionPtr handlerPtr);
[+] 	wait_1(FunctionPtr handlerPtr);
[-] 	wait_2 (FunctionPtr handlerPtr);
[+] 	wait_2(FunctionPtr handlerPtr);
[-] 	cancelWait (uintptr_t handle);
[+] 	cancelWait(uintptr_t handle);
[-] 	blockingWait (Promise* self)
[+] 	blockingWait(Promise* self)
[-] 		return self->blockingWaitImpl ();
[+] 		return self->blockingWaitImpl();
[-] 	asyncWait ()
[+] 	asyncWait()
[-] 	addAsyncWait_l (
[+] 	addAsyncWait_l(
[-] 	blockingWaitImpl ();
[+] 	blockingWaitImpl();
[-] 	markOpaqueGcRoots (GcHeap* gcHeap)
[+] 	markOpaqueGcRoots(GcHeap* gcHeap)
[-] 		Promise::markOpaqueGcRoots (gcHeap);
[+] 		Promise::markOpaqueGcRoots(gcHeap);
[-] 	complete_0 ()
[+] 	complete_0()
[-] 		complete_2 (g_nullVariant, g_nullPtr);
[+] 		complete_2(g_nullVariant, g_nullPtr);
[-] 	complete_1 (DataPtr errorPtr)
[+] 	complete_1(DataPtr errorPtr)
[-] 		complete_2 (g_nullVariant, errorPtr);
[+] 		complete_2(g_nullVariant, errorPtr);
[-] 	complete_2 (
[+] 	complete_2(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Reactor.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (ReactorImpl)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(ReactorImpl)
[-] 		sl::HashTableIterator <Multicast*, Binding*> m_bindingMapIt;
[+] 		sl::HashTableIterator<Multicast*, Binding*> m_bindingMapIt;
[-] 		sl::Array <Binding*> m_bindingArray;
[+] 		sl::Array<Binding*> m_bindingArray;
[-] 	ReactionFunc (
[+] 	ReactionFunc(
[-] 	sl::AutoPtrArray <Reaction> m_reactionArray;
[+] 	sl::AutoPtrArray<Reaction> m_reactionArray;
[-] 	sl::Array <Multicast*> m_pendingOnChangedBindingArray;
[+] 	sl::Array<Multicast*> m_pendingOnChangedBindingArray;
[-] 	sl::Array <Multicast*> m_pendingOnEventBindingArray;
[+] 	sl::Array<Multicast*> m_pendingOnEventBindingArray;
[-] 	sl::List <Binding> m_bindingList;
[+] 	sl::List<Binding> m_bindingList;
[-] 	sl::HashTable <Multicast*, Binding*, sl::HashId <Multicast*> > m_bindingMap;
[+] 	sl::HashTable<Multicast*, Binding*, sl::HashId<Multicast*> > m_bindingMap;
[-] 	ReactorImpl ();
[+] 	ReactorImpl();
[-] 	~ReactorImpl ()
[+] 	~ReactorImpl()
[-] 		stop ();
[+] 		stop();
[-] 	start ();
[+] 	start();
[-] 	stop ();
[+] 	stop();
[-] 	restart ()
[+] 	restart()
[-] 		stop ();
[+] 		stop();
[-] 		start ();
[+] 		start();
[-] 	addOnChangedBinding (Multicast* multicast)
[+] 	addOnChangedBinding(Multicast* multicast)
[-] 		ASSERT (m_state == State_Reacting);
[+] 		ASSERT(m_state == State_Reacting);
[-] 		m_pendingOnChangedBindingArray.append (multicast);
[+] 		m_pendingOnChangedBindingArray.append(multicast);
[-] 	addOnEventBinding (Multicast* multicast)
[+] 	addOnEventBinding(Multicast* multicast)
[-] 		ASSERT (m_state == State_Reacting);
[+] 		ASSERT(m_state == State_Reacting);
[-] 		m_pendingOnEventBindingArray.append (multicast);
[+] 		m_pendingOnEventBindingArray.append(multicast);
[-] 	resetOnChangedBindings ()
[+] 	resetOnChangedBindings()
[-] 		ASSERT (m_state == State_Reacting);
[+] 		ASSERT(m_state == State_Reacting);
[-] 		m_pendingOnChangedBindingArray.clear ();
[+] 		m_pendingOnChangedBindingArray.clear();
[-] 	reactionLoop ();
[+] 	reactionLoop();
[-] 	onChanged (Binding* binding);
[+] 	onChanged(Binding* binding);
[-] 	onChangedThunk (ReactorClosure* closure)
[+] 	onChangedThunk(ReactorClosure* closure)
[-] 		((ReactorImpl*) closure->m_self)->onChanged ((Binding*) closure->m_binding);
[+] 		((ReactorImpl*)closure->m_self)->onChanged((Binding*)closure->m_binding);
[-] 	subscribe (Multicast* multicast);
[+] 	subscribe(Multicast* multicast);
[-] 	subscribe (
[+] 	subscribe(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc_rtl_Regex.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (RegexState)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(RegexState)
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (RegexDfa)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(RegexDfa)
[-] 	construct (bool isIncremental);
[+] 	construct(bool isIncremental);
[-] 	markOpaqueGcRoots (GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(GcHeap* gcHeap);
[-] 	setMatchLengthLimit (size_t length);
[+] 	setMatchLengthLimit(size_t length);
[-] 	setCurrentOffset (size_t offset);
[+] 	setCurrentOffset(size_t offset);
[-] 	reset ();
[+] 	reset();
[-] 	exec (
[+] 	exec(
[-] 	processGroupSet (ct::DfaGroupSet* groupSet);
[+] 	processGroupSet(ct::DfaGroupSet* groupSet);
[-] 	setDfa (ct::Dfa* dfa);
[+] 	setDfa(ct::Dfa* dfa);
[-] 	softReset ();
[+] 	softReset();
[-] 	eof ();
[+] 	eof();
[-] 	writeData (
[+] 	writeData(
[-] 	writeChar (uchar_t c);
[+] 	writeChar(uchar_t c);
[-] 	gotoState (size_t stateId);
[+] 	gotoState(size_t stateId);
[-] 	match (size_t stateId);
[+] 	match(size_t stateId);
[-] 	rollback ();
[+] 	rollback();
[-] 	sl::List <ct::ReSwitchAcceptContext> m_acceptContextList;
[+] 	sl::List<ct::ReSwitchAcceptContext> m_acceptContextList;
[-] 	clear ();
[+] 	clear();
[-] 	incrementalCompile (
[+] 	incrementalCompile(
[-] 	finalize ();
[+] 	finalize();
[-] 	match (
[+] 	match(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Array.cpp
----------------------
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Array)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Array)
[-] 	JNC_MAP_FUNCTION ("clear", &Array::clear)
[+] 	JNC_MAP_FUNCTION("clear", &Array::clear)
[-] 	JNC_MAP_FUNCTION ("setCount", &Array::setCount)
[+] 	JNC_MAP_FUNCTION("setCount", &Array::setCount)
[-] 	JNC_MAP_FUNCTION ("reserve", &Array::reserve)
[+] 	JNC_MAP_FUNCTION("reserve", &Array::reserve)
[-] 	JNC_MAP_FUNCTION ("copy", &Array::copy)
[+] 	JNC_MAP_FUNCTION("copy", &Array::copy)
[-] 	JNC_MAP_FUNCTION ("insert", &Array::insert)
[+] 	JNC_MAP_FUNCTION("insert", &Array::insert)
[-] 	JNC_MAP_FUNCTION ("remove", &Array::remove)
[+] 	JNC_MAP_FUNCTION("remove", &Array::remove)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Array::clear ()
[+] Array::clear()
[-] 	memset (m_ptr.m_p, 0, m_count * sizeof (Variant));
[+] 	memset(m_ptr.m_p, 0, m_count * sizeof(Variant));
[-] Array::setCount (size_t count)
[+] Array::setCount(size_t count)
[-] 		Variant* p = (Variant*) m_ptr.m_p;
[+] 		Variant* p = (Variant*)m_ptr.m_p;
[-] 		memset (p + count, 0, (m_count - count) * sizeof (Variant));
[+] 		memset(p + count, 0, (m_count - count) * sizeof(Variant));
[-] 		bool result = reserve (count);
[+] 		bool result = reserve(count);
[-] Array::reserve (size_t count)
[+] Array::reserve(size_t count)
[-] 	Type* type = m_box->m_type->getModule ()->getPrimitiveType (TypeKind_Variant);
[+] 	Type* type = m_box->m_type->getModule()->getPrimitiveType(TypeKind_Variant);
[-] 	size_t maxCount = sl::getAllocSize (count);
[+] 	size_t maxCount = sl::getAllocSize(count);
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	DataPtr ptr = gcHeap->tryAllocateArray (type, maxCount);
[+] 	DataPtr ptr = gcHeap->tryAllocateArray(type, maxCount);
[-] 	memcpy (ptr.m_p, m_ptr.m_p, m_count * sizeof (Variant));
[+] 	memcpy(ptr.m_p, m_ptr.m_p, m_count * sizeof(Variant));
[-] Array::copy (
[+] Array::copy(
[-] 	bool result = reserve (count);
[+] 	bool result = reserve(count);
[-] 	memcpy (m_ptr.m_p, ptr.m_p, count * sizeof (Variant));
[+] 	memcpy(m_ptr.m_p, ptr.m_p, count * sizeof(Variant));
[-] Array::insert (
[+] Array::insert(
[-] 	bool result = reserve (newCount);
[+] 	bool result = reserve(newCount);
[-] 	Variant* p = (Variant*) m_ptr.m_p;
[+] 	Variant* p = (Variant*)m_ptr.m_p;
[-] 		memmove (p + index + count, p + index, (m_count - index) * sizeof (Variant));
[+] 		memmove(p + index + count, p + index, (m_count - index) * sizeof(Variant));
[-] 	memcpy (p + index, ptr.m_p, count * sizeof (Variant));
[+] 	memcpy(p + index, ptr.m_p, count * sizeof(Variant));
[-] Array::remove (
[+] Array::remove(
[-] 	Variant* p = (Variant*) m_ptr.m_p;
[+] 	Variant* p = (Variant*)m_ptr.m_p;
[-] 	memmove (p + index, p + tailIdx, (m_count - tailIdx) * sizeof (Variant));
[+] 	memmove(p + index, p + tailIdx, (m_count - tailIdx) * sizeof(Variant));
[-] 	memset (p + newCount, 0, count * sizeof (Variant));
[+] 	memset(p + newCount, 0, count * sizeof(Variant));
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Buffer.cpp
----------------------
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Buffer)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Buffer)
[-] 	JNC_MAP_FUNCTION ("clear", &Buffer::clear)
[+] 	JNC_MAP_FUNCTION("clear", &Buffer::clear)
[-] 	JNC_MAP_FUNCTION ("setSize", &Buffer::setSize)
[+] 	JNC_MAP_FUNCTION("setSize", &Buffer::setSize)
[-] 	JNC_MAP_FUNCTION ("reserve", &Buffer::reserve)
[+] 	JNC_MAP_FUNCTION("reserve", &Buffer::reserve)
[-] 	JNC_MAP_FUNCTION ("copy", &Buffer::copy)
[+] 	JNC_MAP_FUNCTION("copy", &Buffer::copy)
[-] 	JNC_MAP_FUNCTION ("insert", &Buffer::insert)
[+] 	JNC_MAP_FUNCTION("insert", &Buffer::insert)
[-] 	JNC_MAP_FUNCTION ("remove", &Buffer::remove)
[+] 	JNC_MAP_FUNCTION("remove", &Buffer::remove)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Buffer::setSize (size_t size)
[+] Buffer::setSize(size_t size)
[-] 		bool result = reserve (size);
[+] 		bool result = reserve(size);
[-] 		memset ((char*) m_ptr.m_p + m_size, 0, size - m_size);
[+] 		memset((char*)m_ptr.m_p + m_size, 0, size - m_size);
[-] Buffer::reserve (size_t size)
[+] Buffer::reserve(size_t size)
[-] 	size_t maxSize = sl::getAllocSize (size);
[+] 	size_t maxSize = sl::getAllocSize(size);
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	DataPtr ptr = gcHeap->tryAllocateBuffer (maxSize);
[+] 	DataPtr ptr = gcHeap->tryAllocateBuffer(maxSize);
[-] 	memcpy (ptr.m_p, m_ptr.m_p, m_size);
[+] 	memcpy(ptr.m_p, m_ptr.m_p, m_size);
[-] Buffer::copy (
[+] Buffer::copy(
[-] 	bool result = reserve (size);
[+] 	bool result = reserve(size);
[-] 	memcpy (m_ptr.m_p, ptr.m_p, size);
[+] 	memcpy(m_ptr.m_p, ptr.m_p, size);
[-] Buffer::insert (
[+] Buffer::insert(
[-] 	bool result = reserve (newSize);
[+] 	bool result = reserve(newSize);
[-] 	char* p = (char*) m_ptr.m_p;
[+] 	char* p = (char*)m_ptr.m_p;
[-] 		memmove (p + offset + size, p + offset, m_size - offset);
[+] 		memmove(p + offset + size, p + offset, m_size - offset);
[-] 	memcpy (p + offset, ptr.m_p, size);
[+] 	memcpy(p + offset, ptr.m_p, size);
[-] Buffer::remove (
[+] Buffer::remove(
[-] 	char* p = (char*) m_ptr.m_p;
[+] 	char* p = (char*)m_ptr.m_p;
[-] 	memmove (p + offset, p + tailIdx, m_size - tailIdx);
[+] 	memmove(p + offset, p + tailIdx, m_size - tailIdx);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Error.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Error)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Error)
[-] 	JNC_MAP_CONST_PROPERTY ("m_description", Error::getDescription_s)
[+] 	JNC_MAP_CONST_PROPERTY("m_description", Error::getDescription_s)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Error::getDescription ()
[+] Error::getDescription()
[-] 	sl::String string = err::ErrorHdr::getDescription ();
[+] 	sl::String string = err::ErrorHdr::getDescription();
[-] 	return strDup (string, string.getLength ());
[+] 	return strDup(string, string.getLength());
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Guid.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Guid)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Guid)
[-] 	JNC_MAP_FUNCTION ("getString", &Guid::getString)
[+] 	JNC_MAP_FUNCTION("getString", &Guid::getString)
[-] 	JNC_MAP_FUNCTION ("parse",     &Guid::parse)
[+] 	JNC_MAP_FUNCTION("parse",     &Guid::parse)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Guid::getString (
[+] Guid::getString(
[-] 	Guid* self = (Guid*) selfPtr.m_p;
[+] 	Guid* self = (Guid*)selfPtr.m_p;
[-] 	sl::String string = self->sl::Guid::getString (flags);
[+] 	sl::String string = self->sl::Guid::getString(flags);
[-] 	return strDup (string);
[+] 	return strDup(string);
[-] Guid::parse (
[+] Guid::parse(
[-] 	Guid* self = (Guid*) selfPtr.m_p;
[+] 	Guid* self = (Guid*)selfPtr.m_p;
[-] 	return self->sl::Guid::parse ((const char*) stringPtr.m_p);
[+] 	return self->sl::Guid::parse((const char*) stringPtr.m_p);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_HashTable.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (HashTable)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(HashTable)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <HashTable, HashFunc*, IsEqualFunc*>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<HashTable, HashFunc*, IsEqualFunc*>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <HashTable>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<HashTable>)
[-] 	JNC_MAP_FUNCTION ("clear",  &HashTable::clear)
[+] 	JNC_MAP_FUNCTION("clear",  &HashTable::clear)
[-] 	JNC_MAP_FUNCTION ("find", &HashTable::find)
[+] 	JNC_MAP_FUNCTION("find", &HashTable::find)
[-] 	JNC_MAP_FUNCTION ("visit", &HashTable::visit)
[+] 	JNC_MAP_FUNCTION("visit", &HashTable::visit)
[-] 	JNC_MAP_FUNCTION ("remove", &HashTable::remove)
[+] 	JNC_MAP_FUNCTION("remove", &HashTable::remove)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] HashTable::visitImpl (Variant key)
[+] HashTable::visitImpl(Variant key)
[-] 	sl::MapIterator <Variant, DataPtr> it = m_hashTable.visit (key);
[+] 	sl::MapIterator<Variant, DataPtr> it = m_hashTable.visit(key);
[-] 		it->m_value = m_map.add (it);
[+] 		it->m_value = m_map.add(it);
[-] 		ASSERT (m_map.m_count == m_hashTable.getCount ());
[+] 		ASSERT(m_map.m_count == m_hashTable.getCount());
[-] HashTable::remove (DataPtr entryPtr)
[+] HashTable::remove(DataPtr entryPtr)
[-] 	MapEntry* entry = (MapEntry*) entryPtr.m_p;
[+] 	MapEntry* entry = (MapEntry*)entryPtr.m_p;
[-] 		err::setError ("attempt to remove an invalid map entry from the hash table");
[+] 		err::setError("attempt to remove an invalid map entry from the hash table");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 	m_hashTable.erase ((sl::HashTableEntry <Variant, DataPtr>*) entry->m_mapEntry);
[+] 	m_hashTable.erase((sl::HashTableEntry<Variant, DataPtr>*) entry->m_mapEntry);
[-] 	m_map.remove (entry);
[+] 	m_map.remove(entry);
[-] 	ASSERT (m_map.m_count == m_hashTable.getCount ());
[+] 	ASSERT(m_map.m_count == m_hashTable.getCount());
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_List.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (ListEntry)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(ListEntry)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (List)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(List)
[-] 	JNC_MAP_FUNCTION ("clear", &List::clear)
[+] 	JNC_MAP_FUNCTION("clear", &List::clear)
[-] 	JNC_MAP_FUNCTION ("takeOver", &List::takeOver)
[+] 	JNC_MAP_FUNCTION("takeOver", &List::takeOver)
[-] 	JNC_MAP_FUNCTION ("insertHead", &List::insertHead)
[+] 	JNC_MAP_FUNCTION("insertHead", &List::insertHead)
[-] 	JNC_MAP_FUNCTION ("insertTail", &List::insertTail)
[+] 	JNC_MAP_FUNCTION("insertTail", &List::insertTail)
[-] 	JNC_MAP_FUNCTION ("insertBefore", &List::insertBefore)
[+] 	JNC_MAP_FUNCTION("insertBefore", &List::insertBefore)
[-] 	JNC_MAP_FUNCTION ("insertAfter", &List::insertAfter)
[+] 	JNC_MAP_FUNCTION("insertAfter", &List::insertAfter)
[-] 	JNC_MAP_FUNCTION ("moveToHead", &List::moveToHead)
[+] 	JNC_MAP_FUNCTION("moveToHead", &List::moveToHead)
[-] 	JNC_MAP_FUNCTION ("moveToTail", &List::moveToTail)
[+] 	JNC_MAP_FUNCTION("moveToTail", &List::moveToTail)
[-] 	JNC_MAP_FUNCTION ("moveBefore", &List::moveBefore)
[+] 	JNC_MAP_FUNCTION("moveBefore", &List::moveBefore)
[-] 	JNC_MAP_FUNCTION ("moveAfter", &List::moveAfter)
[+] 	JNC_MAP_FUNCTION("moveAfter", &List::moveAfter)
[-] 	JNC_MAP_FUNCTION ("removeHead", &List::removeHead)
[+] 	JNC_MAP_FUNCTION("removeHead", &List::removeHead)
[-] 	JNC_MAP_FUNCTION ("removeTail", &List::removeTail)
[+] 	JNC_MAP_FUNCTION("removeTail", &List::removeTail)
[-] 	JNC_MAP_FUNCTION ("remove", &List::remove)
[+] 	JNC_MAP_FUNCTION("remove", &List::remove)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] List::clear ()
[+] List::clear()
[-] 	ListEntry* entry = (ListEntry*) m_headPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)m_headPtr.m_p;
[-] 	for (; entry; entry = (ListEntry*) entry->m_nextPtr.m_p)
[+] 	for (; entry; entry = (ListEntry*)entry->m_nextPtr.m_p)
[-] List::takeOver (List* list)
[+] List::takeOver(List* list)
[-] 		clear ();
[+] 		clear();
[-] 	ListEntry* entry = (ListEntry*) list->m_headPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)list->m_headPtr.m_p;
[-] 	for (; entry; entry = (ListEntry*) entry->m_nextPtr.m_p)
[+] 	for (; entry; entry = (ListEntry*)entry->m_nextPtr.m_p)
[-] List::insertHead (
[+] List::insertHead(
[-] 	DataPtr entryPtr = allocateListEntry ();
[+] 	DataPtr entryPtr = allocateListEntry();
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	self->insertHeadImpl (entryPtr);
[+] 	self->insertHeadImpl(entryPtr);
[-] List::insertTail (
[+] List::insertTail(
[-] 	DataPtr entryPtr = allocateListEntry ();
[+] 	DataPtr entryPtr = allocateListEntry();
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	self->insertTailImpl (entryPtr);
[+] 	self->insertTailImpl(entryPtr);
[-] List::insertBefore (
[+] List::insertBefore(
[-] 	DataPtr entryPtr = allocateListEntry ();
[+] 	DataPtr entryPtr = allocateListEntry();
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	self->insertBeforeImpl (entryPtr, beforePtr);
[+] 	self->insertBeforeImpl(entryPtr, beforePtr);
[-] List::insertAfter (
[+] List::insertAfter(
[-] 	DataPtr entryPtr = allocateListEntry ();
[+] 	DataPtr entryPtr = allocateListEntry();
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	self->insertAfterImpl (entryPtr, afterPtr);
[+] 	self->insertAfterImpl(entryPtr, afterPtr);
[-] List::moveToHead (DataPtr entryPtr)
[+] List::moveToHead(DataPtr entryPtr)
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	removeImpl (entry);
[+] 	removeImpl(entry);
[-] 	insertHeadImpl (entryPtr);
[+] 	insertHeadImpl(entryPtr);
[-] List::moveToTail (DataPtr entryPtr)
[+] List::moveToTail(DataPtr entryPtr)
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	removeImpl (entry);
[+] 	removeImpl(entry);
[-] 	insertTailImpl (entryPtr);
[+] 	insertTailImpl(entryPtr);
[-] List::moveBefore (
[+] List::moveBefore(
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	removeImpl (entry);
[+] 	removeImpl(entry);
[-] 	insertBeforeImpl (entryPtr, beforePtr);
[+] 	insertBeforeImpl(entryPtr, beforePtr);
[-] List::moveAfter (
[+] List::moveAfter(
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	removeImpl (entry);
[+] 	removeImpl(entry);
[-] 	insertAfterImpl (entryPtr, afterPtr);
[+] 	insertAfterImpl(entryPtr, afterPtr);
[-] List::remove (
[+] List::remove(
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	self->removeImpl (entry);
[+] 	self->removeImpl(entry);
[-] List::allocateListEntry ()
[+] List::allocateListEntry()
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	ASSERT (runtime);
[+] 	ASSERT(runtime);
[-] 	return createData <ListEntry> (runtime);
[+] 	return createData<ListEntry> (runtime);
[-] List::insertHeadImpl (DataPtr entryPtr)
[+] List::insertHeadImpl(DataPtr entryPtr)
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	ASSERT (entry->m_list == this);
[+] 	ASSERT(entry->m_list == this);
[-] 		((ListEntry*) m_headPtr.m_p)->m_prevPtr = entryPtr;
[+] 		((ListEntry*)m_headPtr.m_p)->m_prevPtr = entryPtr;
[-] List::insertTailImpl (DataPtr entryPtr)
[+] List::insertTailImpl(DataPtr entryPtr)
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	ASSERT (entry->m_list == this);
[+] 	ASSERT(entry->m_list == this);
[-] 		((ListEntry*) m_tailPtr.m_p)->m_nextPtr = entryPtr;
[+] 		((ListEntry*)m_tailPtr.m_p)->m_nextPtr = entryPtr;
[-] List::insertBeforeImpl (
[+] List::insertBeforeImpl(
[-] 		return insertTailImpl (entryPtr);
[+] 		return insertTailImpl(entryPtr);
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	ListEntry* before = (ListEntry*) beforePtr.m_p;
[+] 	ListEntry* before = (ListEntry*)beforePtr.m_p;
[-] 	ListEntry* prev = (ListEntry*) before->m_prevPtr.m_p;
[+] 	ListEntry* prev = (ListEntry*)before->m_prevPtr.m_p;
[-] 	ASSERT (entry->m_list == this);
[+] 	ASSERT(entry->m_list == this);
[-] List::insertAfterImpl (
[+] List::insertAfterImpl(
[-] 		return insertHeadImpl (entryPtr);
[+] 		return insertHeadImpl(entryPtr);
[-] 	ListEntry* entry = (ListEntry*) entryPtr.m_p;
[+] 	ListEntry* entry = (ListEntry*)entryPtr.m_p;
[-] 	ListEntry* after = (ListEntry*) afterPtr.m_p;
[+] 	ListEntry* after = (ListEntry*)afterPtr.m_p;
[-] 	ListEntry* next = (ListEntry*) after->m_nextPtr.m_p;
[+] 	ListEntry* next = (ListEntry*)after->m_nextPtr.m_p;
[-] 	ASSERT (entry->m_list == this);
[+] 	ASSERT(entry->m_list == this);
[-] List::removeImpl (ListEntry* entry)
[+] List::removeImpl(ListEntry* entry)
[-] 	ASSERT (entry->m_list == this);
[+] 	ASSERT(entry->m_list == this);
[-] 	ListEntry* next = (ListEntry*) entry->m_nextPtr.m_p;
[+] 	ListEntry* next = (ListEntry*)entry->m_nextPtr.m_p;
[-] 	ListEntry* prev = (ListEntry*) entry->m_prevPtr.m_p;
[+] 	ListEntry* prev = (ListEntry*)entry->m_prevPtr.m_p;
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Map.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (MapEntry)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(MapEntry)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Map::clear ()
[+] Map::clear()
[-] Map::add (const sl::MapIterator <Variant, DataPtr>& it)
[+] Map::add(const sl::MapIterator<Variant, DataPtr>& it)
[-] 	Runtime* runtime = getCurrentThreadRuntime ();
[+] 	Runtime* runtime = getCurrentThreadRuntime();
[-] 	Type* entryType = MapEntry::getType (runtime->getModule ());
[+] 	Type* entryType = MapEntry::getType(runtime->getModule());
[-] 	DataPtr entryPtr = runtime->getGcHeap ()->allocateData (entryType);
[+] 	DataPtr entryPtr = runtime->getGcHeap()->allocateData(entryType);
[-] 	MapEntry* entry = (MapEntry*) entryPtr.m_p;
[+] 	MapEntry* entry = (MapEntry*)entryPtr.m_p;
[-] 	sl::MapEntry <Variant, DataPtr>* next = (sl::MapEntry <Variant, DataPtr>*) it->getNext ();
[+] 	sl::MapEntry<Variant, DataPtr>* next = (sl::MapEntry<Variant, DataPtr>*) it->getNext();
[-] 	sl::MapEntry <Variant, DataPtr>* prev = (sl::MapEntry <Variant, DataPtr>*) it->getPrev ();
[+] 	sl::MapEntry<Variant, DataPtr>* prev = (sl::MapEntry<Variant, DataPtr>*) it->getPrev();
[-] 	entry->m_key = it->getKey ();
[+] 	entry->m_key = it->getKey();
[-] 	entry->m_mapEntry = it.getEntry ();
[+] 	entry->m_mapEntry = it.getEntry();
[-] 		((MapEntry*) entry->m_prevPtr.m_p)->m_nextPtr = entryPtr;
[+] 		((MapEntry*)entry->m_prevPtr.m_p)->m_nextPtr = entryPtr;
[-] 		((MapEntry*) entry->m_nextPtr.m_p)->m_prevPtr = entryPtr;
[+] 		((MapEntry*)entry->m_nextPtr.m_p)->m_prevPtr = entryPtr;
[-] Map::remove (MapEntry* entry)
[+] Map::remove(MapEntry* entry)
[-] 	ASSERT (entry->m_map == this);
[+] 	ASSERT(entry->m_map == this);
[-] 	ASSERT (entry->m_prevPtr.m_p || m_headPtr.m_p == entry);
[+] 	ASSERT(entry->m_prevPtr.m_p || m_headPtr.m_p == entry);
[-] 	ASSERT (entry->m_nextPtr.m_p || m_tailPtr.m_p == entry);
[+] 	ASSERT(entry->m_nextPtr.m_p || m_tailPtr.m_p == entry);
[-] 		((MapEntry*) entry->m_prevPtr.m_p)->m_nextPtr = entry->m_nextPtr;
[+] 		((MapEntry*)entry->m_prevPtr.m_p)->m_nextPtr = entry->m_nextPtr;
[-] 		((MapEntry*) entry->m_nextPtr.m_p)->m_prevPtr = entry->m_prevPtr;
[+] 		((MapEntry*)entry->m_nextPtr.m_p)->m_prevPtr = entry->m_prevPtr;
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_RbTree.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (RbTree)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(RbTree)
[-] 	JNC_MAP_CONSTRUCTOR (&(jnc::construct <RbTree, CmpFunc*>))
[+] 	JNC_MAP_CONSTRUCTOR(&(jnc::construct<RbTree, CmpFunc*>))
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <RbTree>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<RbTree>)
[-] 	JNC_MAP_FUNCTION ("clear",  &RbTree::clear)
[+] 	JNC_MAP_FUNCTION("clear",  &RbTree::clear)
[-] 	JNC_MAP_FUNCTION ("find", &RbTree::find)
[+] 	JNC_MAP_FUNCTION("find", &RbTree::find)
[-] 	JNC_MAP_OVERLOAD (&RbTree::findEx)
[+] 	JNC_MAP_OVERLOAD(&RbTree::findEx)
[-] 	JNC_MAP_FUNCTION ("visit", &RbTree::visit)
[+] 	JNC_MAP_FUNCTION("visit", &RbTree::visit)
[-] 	JNC_MAP_FUNCTION ("remove", &RbTree::remove)
[+] 	JNC_MAP_FUNCTION("remove", &RbTree::remove)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] cmpVariant (
[+] cmpVariant(
[-] 		key1.relationalOperator (&key2, BinOpKind_Eq, &result) && result ? 0 :
[+] 		key1.relationalOperator(&key2, BinOpKind_Eq, &result) && result ? 0 :
[-] 		key1.relationalOperator (&key2, BinOpKind_Lt, &result) && result ? -1 : 1;
[+] 		key1.relationalOperator(&key2, BinOpKind_Lt, &result) && result ? -1 : 1;
[-] RbTree::visitImpl (Variant key)
[+] RbTree::visitImpl(Variant key)
[-] 	sl::MapIterator <Variant, DataPtr> it = m_rbTree.visit (key);
[+] 	sl::MapIterator<Variant, DataPtr> it = m_rbTree.visit(key);
[-] 		it->m_value = m_map.add (it);
[+] 		it->m_value = m_map.add(it);
[-] 		ASSERT (m_map.m_count == m_rbTree.getCount ());
[+] 		ASSERT(m_map.m_count == m_rbTree.getCount());
[-] RbTree::remove (DataPtr entryPtr)
[+] RbTree::remove(DataPtr entryPtr)
[-] 	MapEntry* entry = (MapEntry*) entryPtr.m_p;
[+] 	MapEntry* entry = (MapEntry*)entryPtr.m_p;
[-] 		err::setError ("attempt to remove an invalid map entry from the red-black tree");
[+] 		err::setError("attempt to remove an invalid map entry from the red-black tree");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 	m_map.remove (entry);
[+] 	m_map.remove(entry);
[-] 	m_rbTree.erase ((sl::RbTreeNode <Variant, DataPtr>*) entry->m_mapEntry);
[+] 	m_rbTree.erase((sl::RbTreeNode<Variant, DataPtr>*) entry->m_mapEntry);
[-] 	ASSERT (m_map.m_count == m_rbTree.getCount ());
[+] 	ASSERT(m_map.m_count == m_rbTree.getCount());
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_StdLib.cpp
----------------------
[-] stdGets (
[+] stdGets(
[-] 	char* p = (char*) buffer;
[+] 	char* p = (char*)buffer;
[-] 	fgets (p, size, stdin);
[+] 	fgets(p, size, stdin);
[-] 	return strnlen (p, size);
[+] 	return strnlen(p, size);
[-] stdPrintOut (
[+] stdPrintOut(
[-] 	return fwrite (p, size, 1, stdout);
[+] 	return fwrite(p, size, 1, stdout);
[-] stdPrintErr (
[+] stdPrintErr(
[-] 	return fwrite (p, size, 1, stderr);
[+] 	return fwrite(p, size, 1, stderr);
[-] atoi (DataPtr ptr)
[+] atoi(DataPtr ptr)
[-] 	return ptr.m_p ? ::atoi ((char*) ptr.m_p) : 0;
[+] 	return ptr.m_p ? ::atoi((char*)ptr.m_p) : 0;
[-] strtol (
[+] strtol(
[-] 	char* end = (char*) ptr.m_p;
[+] 	char* end = (char*)ptr.m_p;
[-] 		result = ::strtol ((char*) ptr.m_p, &end, radix);
[+] 		result = ::strtol((char*)ptr.m_p, &end, radix);
[-] 		((DataPtr*) endPtr.m_p)->m_p = end;
[+] 		((DataPtr*)endPtr.m_p)->m_p = end;
[-] 		((DataPtr*) endPtr.m_p)->m_validator = ptr.m_validator;
[+] 		((DataPtr*)endPtr.m_p)->m_validator = ptr.m_validator;
[-] toUpper (uint32_t c)
[+] toUpper(uint32_t c)
[-] 	return enc::utfToUpperCase (c);
[+] 	return enc::utfToUpperCase(c);
[-] toLower (uint32_t c)
[+] toLower(uint32_t c)
[-] 	return enc::utfToLowerCase (c);
[+] 	return enc::utfToLowerCase(c);
[-] getErrorPtr (const err::ErrorHdr* error)
[+] getErrorPtr(const err::ErrorHdr* error)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (error->m_size);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(error->m_size);
[-] 	memcpy (resultPtr.m_p, error, error->m_size);
[+] 	memcpy(resultPtr.m_p, error, error->m_size);
[-] getLastError ()
[+] getLastError()
[-] 	return getErrorPtr (err::getLastError ());
[+] 	return getErrorPtr(err::getLastError());
[-] setErrno (int code)
[+] setErrno(int code)
[-] 	err::setErrno (code);
[+] 	err::setErrno(code);
[-] setError_0 (DataPtr errorPtr)
[+] setError_0(DataPtr errorPtr)
[-] 	err::setError ((const err::ErrorHdr*) errorPtr.m_p);
[+] 	err::setError((const err::ErrorHdr*) errorPtr.m_p);
[-] setError_1 (DataPtr stringPtr)
[+] setError_1(DataPtr stringPtr)
[-] 	err::setError ((const char*) stringPtr.m_p);
[+] 	err::setError((const char*) stringPtr.m_p);
[-] memCmp (
[+] memCmp(
[-] 		memcmp (ptr1.m_p, ptr2.m_p, size);
[+] 		memcmp(ptr1.m_p, ptr2.m_p, size);
[-] memChr (
[+] memChr(
[-] 	void* p = memchr (ptr.m_p, c, size);
[+] 	void* p = memchr(ptr.m_p, c, size);
[-] memMem (
[+] memMem(
[-] 	void* p = sl::memMem (ptr1.m_p, size1, ptr2.m_p, size2);
[+] 	void* p = sl::memMem(ptr1.m_p, size1, ptr2.m_p, size2);
[-] memCpy (
[+] memCpy(
[-] 		memcpy (dstPtr.m_p, srcPtr.m_p, size);
[+] 		memcpy(dstPtr.m_p, srcPtr.m_p, size);
[-] memMove (
[+] memMove(
[-] 		memmove (dstPtr.m_p, srcPtr.m_p, size);
[+] 		memmove(dstPtr.m_p, srcPtr.m_p, size);
[-] memSet (
[+] memSet(
[-] 		memset (ptr.m_p, c, size);
[+] 		memset(ptr.m_p, c, size);
[-] memCat (
[+] memCat(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (totalSize);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(totalSize);
[-] 	char* p = (char*) resultPtr.m_p;
[+] 	char* p = (char*)resultPtr.m_p;
[-] 		memcpy (p, ptr1.m_p, size1);
[+] 		memcpy(p, ptr1.m_p, size1);
[-] 		memcpy (p + size1, ptr2.m_p, size2);
[+] 		memcpy(p + size1, ptr2.m_p, size2);
[-] memDup (
[+] memDup(
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (size);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(size);
[-] 		memcpy (resultPtr.m_p, ptr.m_p, size);
[+] 		memcpy(resultPtr.m_p, ptr.m_p, size);
[-] 		memset (resultPtr.m_p, 0, size);
[+] 		memset(resultPtr.m_p, 0, size);
[-] memDjb2 (
[+] memDjb2(
[-] 	return sl::djb2 (ptr.m_p, size);
[+] 	return sl::djb2(ptr.m_p, size);
[-] strCmp (
[+] strCmp(
[-] 		strcmp ((char*) ptr1.m_p, (char*) ptr2.m_p);
[+] 		strcmp((char*)ptr1.m_p, (char*)ptr2.m_p);
[-] strnCmp (
[+] strnCmp(
[-] 		strncmp ((char*) ptr1.m_p, (char*) ptr2.m_p, length);
[+] 		strncmp((char*)ptr1.m_p, (char*)ptr2.m_p, length);
[-] striCmp (
[+] striCmp(
[-] 		_stricmp ((char*) ptr1.m_p, (char*) ptr2.m_p);
[+] 		_stricmp((char*)ptr1.m_p, (char*)ptr2.m_p);
[-] strniCmp (
[+] strniCmp(
[-] 		_strnicmp ((char*) ptr1.m_p, (char*) ptr2.m_p, length);
[+] 		_strnicmp((char*)ptr1.m_p, (char*)ptr2.m_p, length);
[-] strChr (
[+] strChr(
[-] 	char* p = strchr ((char*) ptr.m_p, c);
[+] 	char* p = strchr((char*)ptr.m_p, c);
[-] striChr (
[+] striChr(
[-] 	size_t length = strLen (ptr);
[+] 	size_t length = strLen(ptr);
[-] 	find.setPattern (enc::CharCodecKind_Ascii, &c, 1, sl::TextBoyerMooreFlag_CaseInsensitive);
[+] 	find.setPattern(enc::CharCodecKind_Ascii, &c, 1, sl::TextBoyerMooreFlag_CaseInsensitive);
[-] 	size_t offset = find.find (enc::CharCodecKind_Ascii, ptr.m_p, length);
[+] 	size_t offset = find.find(enc::CharCodecKind_Ascii, ptr.m_p, length);
[-] 	resultPtr.m_p = (char*) ptr.m_p + offset;
[+] 	resultPtr.m_p = (char*)ptr.m_p + offset;
[-] strStr (
[+] strStr(
[-] 	char* p = strstr ((char*) ptr1.m_p, (char*) ptr2.m_p);
[+] 	char* p = strstr((char*)ptr1.m_p, (char*)ptr2.m_p);
[-] striStr (
[+] striStr(
[-] 	size_t length1 = strLen (ptr1);
[+] 	size_t length1 = strLen(ptr1);
[-] 	size_t length2 = strLen (ptr2);
[+] 	size_t length2 = strLen(ptr2);
[-] 	find.setPattern (enc::CharCodecKind_Ascii, ptr2.m_p, length2, sl::TextBoyerMooreFlag_CaseInsensitive);
[+] 	find.setPattern(enc::CharCodecKind_Ascii, ptr2.m_p, length2, sl::TextBoyerMooreFlag_CaseInsensitive);
[-] 	size_t offset = find.find (enc::CharCodecKind_Ascii, ptr1.m_p, length1);
[+] 	size_t offset = find.find(enc::CharCodecKind_Ascii, ptr1.m_p, length1);
[-] 	resultPtr.m_p = (char*) ptr1.m_p + offset;
[+] 	resultPtr.m_p = (char*)ptr1.m_p + offset;
[-] strCpy (
[+] strCpy(
[-] 		err::setError ("null data pointer access");
[+] 		err::setError("null data pointer access");
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 	size_t dstLength = dstPtr.m_p < dstPtr.m_validator->m_rangeEnd ? (char*) dstPtr.m_validator->m_rangeEnd - (char*) dstPtr.m_p : 0;
[+] 	size_t dstLength = dstPtr.m_p < dstPtr.m_validator->m_rangeEnd ? (char*)dstPtr.m_validator->m_rangeEnd - (char*)dstPtr.m_p : 0;
[-] 	size_t srcLength = strLen (srcPtr);
[+] 	size_t srcLength = strLen(srcPtr);
[-] 		memcpy (dstPtr.m_p, srcPtr.m_p, dstLength);
[+] 		memcpy(dstPtr.m_p, srcPtr.m_p, dstLength);
[-] 		memcpy (dstPtr.m_p, srcPtr.m_p, srcLength);
[+] 		memcpy(dstPtr.m_p, srcPtr.m_p, srcLength);
[-] 		((char*) dstPtr.m_p) [srcLength] = 0;
[+] 		((char*)dstPtr.m_p) [srcLength] = 0;
[-] strCat (
[+] strCat(
[-] 	size_t length1 = strLen (ptr1);
[+] 	size_t length1 = strLen(ptr1);
[-] 	size_t length2 = strLen (ptr2);
[+] 	size_t length2 = strLen(ptr2);
[-] 	return memCat (ptr1, length1, ptr2, length2 + 1);
[+] 	return memCat(ptr1, length1, ptr2, length2 + 1);
[-] strDup (
[+] strDup(
[-] 		length = strLen (ptr);
[+] 		length = strLen(ptr);
[-] 	return jnc::strDup ((const char*) ptr.m_p, length);
[+] 	return jnc::strDup((const char*) ptr.m_p, length);
[-] strDjb2 (DataPtr ptr)
[+] strDjb2(DataPtr ptr)
[-] 	size_t length = strLen (ptr);
[+] 	size_t length = strLen(ptr);
[-] 	return sl::djb2 (ptr.m_p, length);
[+] 	return sl::djb2(ptr.m_p, length);
[-] striDjb2 (DataPtr ptr)
[+] striDjb2(DataPtr ptr)
[-] 	size_t length = strLen (ptr);
[+] 	size_t length = strLen(ptr);
[-] 	return sl::djb2_op (::tolower, (char*) ptr.m_p, length);
[+] 	return sl::djb2_op(::tolower, (char*)ptr.m_p, length);
[-] format (
[+] format(
[-] 	AXL_VA_DECL (va, formatStringPtr);
[+] 	AXL_VA_DECL(va, formatStringPtr);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.format_va ((const char*) formatStringPtr.m_p, va);
[+] 	string.format_va((const char*) formatStringPtr.m_p, va);
[-] 	size_t length = string.getLength ();
[+] 	size_t length = string.getLength();
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer (length + 1);
[+] 	DataPtr resultPtr = gcHeap->tryAllocateBuffer(length + 1);
[-] 	memcpy (resultPtr.m_p, string.sz (), length);
[+] 	memcpy(resultPtr.m_p, string.sz(), length);
[-] gets ()
[+] gets()
[-] 	char buffer [1024];
[+] 	char buffer[1024];
[-] 	size_t length = g_getsFunc (buffer, sizeof (buffer));
[+] 	size_t length = g_getsFunc(buffer, sizeof(buffer));
[-] 	return jnc::strDup (buffer, length);
[+] 	return jnc::strDup(buffer, length);
[-] print (DataPtr ptr)
[+] print(DataPtr ptr)
[-] 	size_t length = strLen (ptr);
[+] 	size_t length = strLen(ptr);
[-] 	return g_printOutFunc (ptr.m_p, length);
[+] 	return g_printOutFunc(ptr.m_p, length);
[-] print_u (const char* s)
[+] print_u(const char* s)
[-] 	return s ? g_printOutFunc (s, strlen (s)) : 0;
[+] 	return s ? g_printOutFunc(s, strlen(s)) : 0;
[-] perror (DataPtr ptr)
[+] perror(DataPtr ptr)
[-] 	size_t length = strLen (ptr);
[+] 	size_t length = strLen(ptr);
[-] 	return g_printErrFunc (ptr.m_p, length);
[+] 	return g_printErrFunc(ptr.m_p, length);
[-] printf (
[+] printf(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	sl::String string = sl::formatString_va (formatString, va);
[+] 	sl::String string = sl::formatString_va(formatString, va);
[-] 	return g_printOutFunc (string.cp (), string.getLength ());
[+] 	return g_printOutFunc(string.cp(), string.getLength());
[-] resetDynamicLayout (DataPtr ptr)
[+] resetDynamicLayout(DataPtr ptr)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->resetDynamicLayout (ptr.m_validator->m_targetBox);
[+] 	gcHeap->resetDynamicLayout(ptr.m_validator->m_targetBox);
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_FUNCTION_MAP (jnc_StdLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(jnc_StdLib)
[-] 	JNC_MAP_FUNCTION ("std.getLastError",       getLastError)
[+] 	JNC_MAP_FUNCTION("std.getLastError",       getLastError)
[-] 	JNC_MAP_FUNCTION ("std.setErrno",           setErrno)
[+] 	JNC_MAP_FUNCTION("std.setErrno",           setErrno)
[-] 	JNC_MAP_FUNCTION ("std.setError",           setError_0)
[+] 	JNC_MAP_FUNCTION("std.setError",           setError_0)
[-] 	JNC_MAP_OVERLOAD (setError_1)
[+] 	JNC_MAP_OVERLOAD(setError_1)
[-] 	JNC_MAP_FUNCTION ("std.format",             format)
[+] 	JNC_MAP_FUNCTION("std.format",             format)
[-] 	JNC_MAP_FUNCTION ("std.resetDynamicLayout", resetDynamicLayout)
[+] 	JNC_MAP_FUNCTION("std.resetDynamicLayout", resetDynamicLayout)
[-] 	JNC_MAP_FUNCTION ("strlen",   jnc::strLen)
[+] 	JNC_MAP_FUNCTION("strlen",   jnc::strLen)
[-] 	JNC_MAP_FUNCTION ("strcmp",   strCmp)
[+] 	JNC_MAP_FUNCTION("strcmp",   strCmp)
[-] 	JNC_MAP_FUNCTION ("strncmp",  strnCmp)
[+] 	JNC_MAP_FUNCTION("strncmp",  strnCmp)
[-] 	JNC_MAP_FUNCTION ("stricmp",  striCmp)
[+] 	JNC_MAP_FUNCTION("stricmp",  striCmp)
[-] 	JNC_MAP_FUNCTION ("strnicmp", strniCmp)
[+] 	JNC_MAP_FUNCTION("strnicmp", strniCmp)
[-] 	JNC_MAP_FUNCTION ("strchr",   strChr)
[+] 	JNC_MAP_FUNCTION("strchr",   strChr)
[-] 	JNC_MAP_FUNCTION ("strichr",  striChr)
[+] 	JNC_MAP_FUNCTION("strichr",  striChr)
[-] 	JNC_MAP_FUNCTION ("strstr",   strStr)
[+] 	JNC_MAP_FUNCTION("strstr",   strStr)
[-] 	JNC_MAP_FUNCTION ("stristr",  striStr)
[+] 	JNC_MAP_FUNCTION("stristr",  striStr)
[-] 	JNC_MAP_FUNCTION ("strcpy",   strCpy)
[+] 	JNC_MAP_FUNCTION("strcpy",   strCpy)
[-] 	JNC_MAP_FUNCTION ("strcat",   strCat)
[+] 	JNC_MAP_FUNCTION("strcat",   strCat)
[-] 	JNC_MAP_FUNCTION ("strdup",   strDup)
[+] 	JNC_MAP_FUNCTION("strdup",   strDup)
[-] 	JNC_MAP_FUNCTION ("strdjb2",  strDjb2)
[+] 	JNC_MAP_FUNCTION("strdjb2",  strDjb2)
[-] 	JNC_MAP_FUNCTION ("stridjb2", striDjb2)
[+] 	JNC_MAP_FUNCTION("stridjb2", striDjb2)
[-] 	JNC_MAP_FUNCTION ("memcmp",   memCmp)
[+] 	JNC_MAP_FUNCTION("memcmp",   memCmp)
[-] 	JNC_MAP_FUNCTION ("memchr",   memChr)
[+] 	JNC_MAP_FUNCTION("memchr",   memChr)
[-] 	JNC_MAP_FUNCTION ("memmem",   memMem)
[+] 	JNC_MAP_FUNCTION("memmem",   memMem)
[-] 	JNC_MAP_FUNCTION ("memcpy",   memCpy)
[+] 	JNC_MAP_FUNCTION("memcpy",   memCpy)
[-] 	JNC_MAP_FUNCTION ("memmove",  memMove)
[+] 	JNC_MAP_FUNCTION("memmove",  memMove)
[-] 	JNC_MAP_FUNCTION ("memset",   memSet)
[+] 	JNC_MAP_FUNCTION("memset",   memSet)
[-] 	JNC_MAP_FUNCTION ("memcat",   memCat)
[+] 	JNC_MAP_FUNCTION("memcat",   memCat)
[-] 	JNC_MAP_FUNCTION ("memdup",   memDup)
[+] 	JNC_MAP_FUNCTION("memdup",   memDup)
[-] 	JNC_MAP_FUNCTION ("memdjb2",  memDjb2)
[+] 	JNC_MAP_FUNCTION("memdjb2",  memDjb2)
[-] 	JNC_MAP_FUNCTION ("rand",     ::rand)
[+] 	JNC_MAP_FUNCTION("rand",     ::rand)
[-] 	JNC_MAP_FUNCTION ("atoi",     jnc::std::atoi)
[+] 	JNC_MAP_FUNCTION("atoi",     jnc::std::atoi)
[-] 	JNC_MAP_FUNCTION ("strtol",   jnc::std::strtol)
[+] 	JNC_MAP_FUNCTION("strtol",   jnc::std::strtol)
[-] 	JNC_MAP_FUNCTION ("toupper",  toUpper)
[+] 	JNC_MAP_FUNCTION("toupper",  toUpper)
[-] 	JNC_MAP_FUNCTION ("tolower",  toLower)
[+] 	JNC_MAP_FUNCTION("tolower",  toLower)
[-] 	JNC_MAP_FUNCTION ("gets",     jnc::std::gets)
[+] 	JNC_MAP_FUNCTION("gets",     jnc::std::gets)
[-] 	JNC_MAP_FUNCTION ("print",    jnc::std::print)
[+] 	JNC_MAP_FUNCTION("print",    jnc::std::print)
[-] 	JNC_MAP_FUNCTION ("print_u",  print_u)
[+] 	JNC_MAP_FUNCTION("print_u",  print_u)
[-] 	JNC_MAP_FUNCTION ("perror",   jnc::std::perror)
[+] 	JNC_MAP_FUNCTION("perror",   jnc::std::perror)
[-] 	JNC_MAP_FUNCTION ("printf",   jnc::std::printf)
[+] 	JNC_MAP_FUNCTION("printf",   jnc::std::printf)
[-] 	JNC_MAP_TYPE (Guid)
[+] 	JNC_MAP_TYPE(Guid)
[-] 	JNC_MAP_TYPE (Error)
[+] 	JNC_MAP_TYPE(Error)
[-] 	JNC_MAP_TYPE (StringBuilder)
[+] 	JNC_MAP_TYPE(StringBuilder)
[-] 	JNC_MAP_TYPE (Buffer)
[+] 	JNC_MAP_TYPE(Buffer)
[-] 	JNC_MAP_TYPE (Array)
[+] 	JNC_MAP_TYPE(Array)
[-] 	JNC_MAP_TYPE (ListEntry)
[+] 	JNC_MAP_TYPE(ListEntry)
[-] 	JNC_MAP_TYPE (List)
[+] 	JNC_MAP_TYPE(List)
[-] 	JNC_MAP_TYPE (MapEntry)
[+] 	JNC_MAP_TYPE(MapEntry)
[-] 	JNC_MAP_TYPE (HashTable)
[+] 	JNC_MAP_TYPE(HashTable)
[-] 	JNC_MAP_TYPE (RbTree)
[+] 	JNC_MAP_TYPE(RbTree)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (jnc_StdLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(jnc_StdLib)
[-] 	JNC_LIB_SOURCE_FILE ("std_globals.jnc",   g_std_globalsSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_globals.jnc",   g_std_globalsSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_Guid.jnc",      g_std_GuidSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_Guid.jnc",      g_std_GuidSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_Error.jnc",     g_std_ErrorSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_Error.jnc",     g_std_ErrorSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_String.jnc",    g_std_StringSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_String.jnc",    g_std_StringSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_Buffer.jnc",    g_std_BufferSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_Buffer.jnc",    g_std_BufferSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_Array.jnc",     g_std_ArraySrc)
[+] 	JNC_LIB_SOURCE_FILE("std_Array.jnc",     g_std_ArraySrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_List.jnc",      g_std_ListSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_List.jnc",      g_std_ListSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_MapEntry.jnc",  g_std_MapEntrySrc)
[+] 	JNC_LIB_SOURCE_FILE("std_MapEntry.jnc",  g_std_MapEntrySrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_HashTable.jnc", g_std_HashTableSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_HashTable.jnc", g_std_HashTableSrc)
[-] 	JNC_LIB_SOURCE_FILE ("std_RbTree.jnc",    g_std_RbTreeSrc)
[+] 	JNC_LIB_SOURCE_FILE("std_RbTree.jnc",    g_std_RbTreeSrc)
[-] 	JNC_LIB_IMPORT ("std_globals.jnc")
[+] 	JNC_LIB_IMPORT("std_globals.jnc")
[-] 	JNC_LIB_IMPORT ("std_Error.jnc")
[+] 	JNC_LIB_IMPORT("std_Error.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (jnc_StdLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(jnc_StdLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (HashTable)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(HashTable)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (RbTree)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(RbTree)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] jnc_StdLib_setStdIo (
[+] jnc_StdLib_setStdIo(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_String.cpp
----------------------
[-] JNC_DEFINE_CLASS_TYPE (
[+] JNC_DEFINE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (StringBuilder)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(StringBuilder)
[-] 	JNC_MAP_FUNCTION ("clear", &StringBuilder::clear)
[+] 	JNC_MAP_FUNCTION("clear", &StringBuilder::clear)
[-] 	JNC_MAP_FUNCTION ("reserve", &StringBuilder::reserve)
[+] 	JNC_MAP_FUNCTION("reserve", &StringBuilder::reserve)
[-] 	JNC_MAP_FUNCTION ("copy", &StringBuilder::copy_utf8)
[+] 	JNC_MAP_FUNCTION("copy", &StringBuilder::copy_utf8)
[-] 	JNC_MAP_OVERLOAD (&StringBuilder::copy_utf16)
[+] 	JNC_MAP_OVERLOAD(&StringBuilder::copy_utf16)
[-] 	JNC_MAP_OVERLOAD (&StringBuilder::copy_utf32)
[+] 	JNC_MAP_OVERLOAD(&StringBuilder::copy_utf32)
[-] 	JNC_MAP_FUNCTION ("insert", &StringBuilder::insert_utf8)
[+] 	JNC_MAP_FUNCTION("insert", &StringBuilder::insert_utf8)
[-] 	JNC_MAP_OVERLOAD (&StringBuilder::insert_utf16)
[+] 	JNC_MAP_OVERLOAD(&StringBuilder::insert_utf16)
[-] 	JNC_MAP_OVERLOAD (&StringBuilder::insert_utf32)
[+] 	JNC_MAP_OVERLOAD(&StringBuilder::insert_utf32)
[-] 	JNC_MAP_FUNCTION ("remove", &StringBuilder::remove)
[+] 	JNC_MAP_FUNCTION("remove", &StringBuilder::remove)
[-] 	JNC_MAP_FUNCTION ("detachString", &StringBuilder::detachString)
[+] 	JNC_MAP_FUNCTION("detachString", &StringBuilder::detachString)
[-] 	JNC_MAP_FUNCTION ("cloneString", &StringBuilder::cloneString)
[+] 	JNC_MAP_FUNCTION("cloneString", &StringBuilder::cloneString)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] StringBuilder::reserve (size_t length)
[+] StringBuilder::reserve(size_t length)
[-] 	size_t size = sl::getAllocSize (length + 1); // reserve space for null
[+] 	size_t size = sl::getAllocSize(length + 1); // reserve space for null
[-] 	ASSERT (size > length);
[+] 	ASSERT(size > length);
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	DataPtr ptr = gcHeap->tryAllocateBuffer (size);
[+] 	DataPtr ptr = gcHeap->tryAllocateBuffer(size);
[-] 	memcpy (ptr.m_p, m_ptr.m_p, m_length);
[+] 	memcpy(ptr.m_p, m_ptr.m_p, m_length);
[-] StringBuilder::copy_utf8 (
[+] StringBuilder::copy_utf8(
[-] 		length = strLen (ptr);
[+] 		length = strLen(ptr);
[-] 	return copyImpl ((char*) ptr.m_p, length);
[+] 	return copyImpl((char*)ptr.m_p, length);
[-] StringBuilder::copy_utf16 (
[+] StringBuilder::copy_utf16(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy ((utf16_t*) ptr.m_p, length);
[+] 	string.copy((utf16_t*)ptr.m_p, length);
[-] 	return copyImpl (string, string.getLength ());
[+] 	return copyImpl(string, string.getLength());
[-] StringBuilder::copy_utf32 (
[+] StringBuilder::copy_utf32(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy ((utf32_t*) ptr.m_p, length);
[+] 	string.copy((utf32_t*)ptr.m_p, length);
[-] 	return copyImpl (string, string.getLength ());
[+] 	return copyImpl(string, string.getLength());
[-] StringBuilder::insert_utf8 (
[+] StringBuilder::insert_utf8(
[-] 		length = strLen (ptr);
[+] 		length = strLen(ptr);
[-] 	return insertImpl (offset, (char*) ptr.m_p, length);
[+] 	return insertImpl(offset, (char*)ptr.m_p, length);
[-] StringBuilder::insert_utf16 (
[+] StringBuilder::insert_utf16(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy ((utf16_t*) ptr.m_p, length);
[+] 	string.copy((utf16_t*)ptr.m_p, length);
[-] 	return insertImpl (offset, string, string.getLength ());
[+] 	return insertImpl(offset, string, string.getLength());
[-] StringBuilder::insert_utf32 (
[+] StringBuilder::insert_utf32(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy ((utf32_t*) ptr.m_p, length);
[+] 	string.copy((utf32_t*)ptr.m_p, length);
[-] 	return insertImpl (offset, string, string.getLength ());
[+] 	return insertImpl(offset, string, string.getLength());
[-] StringBuilder::remove (
[+] StringBuilder::remove(
[-] 	char* p = (char*) m_ptr.m_p;
[+] 	char* p = (char*)m_ptr.m_p;
[-] 	memmove (p + offset, p + tailIdx, m_length - tailIdx);
[+] 	memmove(p + offset, p + tailIdx, m_length - tailIdx);
[-] StringBuilder::detachString (StringBuilder* self)
[+] StringBuilder::detachString(StringBuilder* self)
[-] 		GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 		GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 		return gcHeap->tryAllocateBuffer (1); // empty string + null
[+] 		return gcHeap->tryAllocateBuffer(1); // empty string + null
[-] 	((char*) self->m_ptr.m_p) [self->m_length] = 0;
[+] 	((char*)self->m_ptr.m_p) [self->m_length] = 0;
[-] StringBuilder::cloneString (StringBuilder* self)
[+] StringBuilder::cloneString(StringBuilder* self)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 		return gcHeap->tryAllocateBuffer (1); // empty string + null
[+] 		return gcHeap->tryAllocateBuffer(1); // empty string + null
[-] 	DataPtr ptr = gcHeap->tryAllocateBuffer (self->m_length + 1);
[+] 	DataPtr ptr = gcHeap->tryAllocateBuffer(self->m_length + 1);
[-] 	memcpy (ptr.m_p, self->m_ptr.m_p, self->m_length);
[+] 	memcpy(ptr.m_p, self->m_ptr.m_p, self->m_length);
[-] StringBuilder::copyImpl (
[+] StringBuilder::copyImpl(
[-] 	ASSERT (length != -1);
[+] 	ASSERT(length != -1);
[-] 	bool result = reserve (length);
[+] 	bool result = reserve(length);
[-] 	memcpy (m_ptr.m_p, p, length);
[+] 	memcpy(m_ptr.m_p, p, length);
[-] StringBuilder::insertImpl (
[+] StringBuilder::insertImpl(
[-] 	ASSERT (length != -1);
[+] 	ASSERT(length != -1);
[-] 	bool result = reserve (newLength);
[+] 	bool result = reserve(newLength);
[-] 	char* dst = (char*) m_ptr.m_p;
[+] 	char* dst = (char*)m_ptr.m_p;
[-] 		memmove (dst + offset + length, dst + offset, m_length - offset);
[+] 		memmove(dst + offset + length, dst + offset, m_length - offset);
[-] 	memcpy (dst + offset, src, length);
[+] 	memcpy(dst + offset, src, length);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Array.h
----------------------
[-] JNC_DECLARE_CLASS_TYPE (Array)
[+] JNC_DECLARE_CLASS_TYPE(Array)
[-] 	clear ();
[+] 	clear();
[-] 	setCount (size_t count);
[+] 	setCount(size_t count);
[-] 	reserve (size_t count);
[+] 	reserve(size_t count);
[-] 	copy (
[+] 	copy(
[-] 	insert (
[+] 	insert(
[-] 	remove (
[+] 	remove(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Buffer.h
----------------------
[-] JNC_DECLARE_CLASS_TYPE (Buffer)
[+] JNC_DECLARE_CLASS_TYPE(Buffer)
[-] 	clear ()
[+] 	clear()
[-] 	setSize (size_t size);
[+] 	setSize(size_t size);
[-] 	reserve (size_t size);
[+] 	reserve(size_t size);
[-] 	copy (
[+] 	copy(
[-] 	insert (
[+] 	insert(
[-] 	remove (
[+] 	remove(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Error.h
----------------------
[-] JNC_DECLARE_TYPE (Error)
[+] JNC_DECLARE_TYPE(Error)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (Error)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(Error)
[-] 	getDescription ();
[+] 	getDescription();
[-] 	getDescription_s (DataPtr selfPtr)
[+] 	getDescription_s(DataPtr selfPtr)
[-] 		return ((Error*) selfPtr.m_p)->getDescription ();
[+] 		return ((Error*)selfPtr.m_p)->getDescription();
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Guid.h
----------------------
[-] JNC_DECLARE_TYPE (Guid)
[+] JNC_DECLARE_TYPE(Guid)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (Guid)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(Guid)
[-] 	getString (
[+] 	getString(
[-] 	parse (
[+] 	parse(
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_HashTable.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (HashTable)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(HashTable)
[-] HashFunc (Variant key);
[+] HashFunc(Variant key);
[-] hashVariant (Variant key)
[+] hashVariant(Variant key)
[-] 	return key.hash ();
[+] 	return key.hash();
[-] IsEqualFunc (
[+] IsEqualFunc(
[-] isEqualVariant (
[+] isEqualVariant(
[-] 	return key1.isEqual (key2);
[+] 	return key1.isEqual(key2);
[-] 	HashIndirect (HashFunc* func = NULL)
[+] 	HashIndirect(HashFunc* func = NULL)
[-] 		ASSERT (m_func);
[+] 		ASSERT(m_func);
[-] 		return m_func (key);
[+] 		return m_func(key);
[-] 	IsEqualIndirect (IsEqualFunc* func = NULL)
[+] 	IsEqualIndirect(IsEqualFunc* func = NULL)
[-] 		ASSERT (m_func);
[+] 		ASSERT(m_func);
[-] 		return m_func (key1, key2);
[+] 		return m_func(key1, key2);
[-] 	sl::HashTable <Variant, DataPtr, HashIndirect, IsEqualIndirect> m_hashTable;
[+] 	sl::HashTable<Variant, DataPtr, HashIndirect, IsEqualIndirect> m_hashTable;
[-] 	HashTable (
[+] 	HashTable(
[-] 		m_hashTable (HashIndirect (hashFunc), IsEqualIndirect (isEqualFunc))
[+] 		m_hashTable(HashIndirect(hashFunc), IsEqualIndirect(isEqualFunc))
[-] 	clear ()
[+] 	clear()
[-] 		m_map.clear ();
[+] 		m_map.clear();
[-] 		m_hashTable.clear ();
[+] 		m_hashTable.clear();
[-] 	visit (
[+] 	visit(
[-] 		return self->visitImpl (key);
[+] 		return self->visitImpl(key);
[-] 	find (
[+] 	find(
[-] 		return self->m_hashTable.findValue (key, g_nullPtr);
[+] 		return self->m_hashTable.findValue(key, g_nullPtr);
[-] 	remove (DataPtr entryPtr);
[+] 	remove(DataPtr entryPtr);
[-] 	visitImpl (Variant key);
[+] 	visitImpl(Variant key);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_List.h
----------------------
[-] JNC_DECLARE_TYPE (ListEntry)
[+] JNC_DECLARE_TYPE(ListEntry)
[-] JNC_DECLARE_CLASS_TYPE (List)
[+] JNC_DECLARE_CLASS_TYPE(List)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (ListEntry)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(ListEntry)
[-] 	clear ();
[+] 	clear();
[-] 	takeOver (List* list);
[+] 	takeOver(List* list);
[-] 	insertHead (
[+] 	insertHead(
[-] 	insertTail (
[+] 	insertTail(
[-] 	insertBefore (
[+] 	insertBefore(
[-] 	insertAfter (
[+] 	insertAfter(
[-] 	moveToHead (DataPtr entryPtr);
[+] 	moveToHead(DataPtr entryPtr);
[-] 	moveToTail (DataPtr entryPtr);
[+] 	moveToTail(DataPtr entryPtr);
[-] 	moveBefore (
[+] 	moveBefore(
[-] 	moveAfter (
[+] 	moveAfter(
[-] 	removeHead (List* self)
[+] 	removeHead(List* self)
[-] 		return remove (self, self->m_headPtr);
[+] 		return remove(self, self->m_headPtr);
[-] 	removeTail (List* self)
[+] 	removeTail(List* self)
[-] 		return remove (self, self->m_tailPtr);
[+] 		return remove(self, self->m_tailPtr);
[-] 	remove (
[+] 	remove(
[-] 	allocateListEntry ();
[+] 	allocateListEntry();
[-] 	insertHeadImpl (DataPtr entryPtr);
[+] 	insertHeadImpl(DataPtr entryPtr);
[-] 	insertTailImpl (DataPtr entryPtr);
[+] 	insertTailImpl(DataPtr entryPtr);
[-] 	insertBeforeImpl (
[+] 	insertBeforeImpl(
[-] 	insertAfterImpl (
[+] 	insertAfterImpl(
[-] 	removeImpl (ListEntry* entry);
[+] 	removeImpl(ListEntry* entry);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_Map.h
----------------------
[-] JNC_DECLARE_TYPE (MapEntry)
[+] JNC_DECLARE_TYPE(MapEntry)
[-] 	JNC_DECLARE_TYPE_STATIC_METHODS (MapEntry)
[+] 	JNC_DECLARE_TYPE_STATIC_METHODS(MapEntry)
[-] 	sl::MapEntry <Variant, DataPtr>* m_mapEntry;
[+] 	sl::MapEntry<Variant, DataPtr>* m_mapEntry;
[-] 	clear ();
[+] 	clear();
[-] 	add (const sl::MapIterator <Variant, DataPtr>& it);
[+] 	add(const sl::MapIterator<Variant, DataPtr>& it);
[-] 	remove (MapEntry* entry);
[+] 	remove(MapEntry* entry);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_RbTree.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (RbTree)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(RbTree)
[-] CmpFunc (
[+] CmpFunc(
[-] cmpVariant (
[+] cmpVariant(
[-] 	CmpIndirect (CmpFunc* func = NULL)
[+] 	CmpIndirect(CmpFunc* func = NULL)
[-] 		ASSERT (m_func);
[+] 		ASSERT(m_func);
[-] 		return m_func (key1, key2);
[+] 		return m_func(key1, key2);
[-] 	sl::RbTree <Variant, DataPtr, CmpIndirect> m_rbTree;
[+] 	sl::RbTree<Variant, DataPtr, CmpIndirect> m_rbTree;
[-] 	RbTree (CmpFunc* cmpFunc):
[+] 	RbTree(CmpFunc* cmpFunc):
[-] 		m_rbTree (CmpIndirect (cmpFunc))
[+] 		m_rbTree(CmpIndirect(cmpFunc))
[-] 	clear ()
[+] 	clear()
[-] 		m_map.clear ();
[+] 		m_map.clear();
[-] 		m_rbTree.clear ();
[+] 		m_rbTree.clear();
[-] 	visit (
[+] 	visit(
[-] 		return self->visitImpl (key);
[+] 		return self->visitImpl(key);
[-] 	find (
[+] 	find(
[-] 		return self->m_rbTree.findValue (key, g_nullPtr);
[+] 		return self->m_rbTree.findValue(key, g_nullPtr);
[-] 	findEx (
[+] 	findEx(
[-] 		return self->m_rbTree.findValue (key, relOp, g_nullPtr);
[+] 		return self->m_rbTree.findValue(key, relOp, g_nullPtr);
[-] 	remove (DataPtr entryPtr);
[+] 	remove(DataPtr entryPtr);
[-] 	visitImpl (Variant key);
[+] 	visitImpl(Variant key);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_StdLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc_std_String.h
----------------------
[-] JNC_DECLARE_CLASS_TYPE (StringBuilder)
[+] JNC_DECLARE_CLASS_TYPE(StringBuilder)
[-] 	clear ()
[+] 	clear()
[-] 	reserve (size_t size);
[+] 	reserve(size_t size);
[-] 	copy_utf8 (
[+] 	copy_utf8(
[-] 	copy_utf16 (
[+] 	copy_utf16(
[-] 	copy_utf32 (
[+] 	copy_utf32(
[-] 	insert_utf8 (
[+] 	insert_utf8(
[-] 	insert_utf16 (
[+] 	insert_utf16(
[-] 	insert_utf32 (
[+] 	insert_utf32(
[-] 	remove (
[+] 	remove(
[-] 	detachString (StringBuilder* self);
[+] 	detachString(StringBuilder* self);
[-] 	cloneString (StringBuilder* self);
[+] 	cloneString(StringBuilder* self);
[-] 	copyImpl (
[+] 	copyImpl(
[-] 	insertImpl (
[+] 	insertImpl(
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Event.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Event)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Event)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Event>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Event>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Event>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Event>)
[-] 	JNC_MAP_FUNCTION ("signal", &Event::signal)
[+] 	JNC_MAP_FUNCTION("signal", &Event::signal)
[-] 	JNC_MAP_FUNCTION ("reset", &Event::reset)
[+] 	JNC_MAP_FUNCTION("reset", &Event::reset)
[-] 	JNC_MAP_FUNCTION ("wait", &Event::wait)
[+] 	JNC_MAP_FUNCTION("wait", &Event::wait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Event::wait (uint_t timeout)
[+] Event::wait(uint_t timeout)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	result = m_event.wait (timeout);
[+] 	result = m_event.wait(timeout);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Lock.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Lock)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Lock)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Lock>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Lock>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Lock>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Lock>)
[-] 	JNC_MAP_FUNCTION ("lock", &Lock::lock)
[+] 	JNC_MAP_FUNCTION("lock", &Lock::lock)
[-] 	JNC_MAP_FUNCTION ("unlock", &Lock::unlock)
[+] 	JNC_MAP_FUNCTION("unlock", &Lock::unlock)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Lock::lock ()
[+] Lock::lock()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_NotificationEvent.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (NotificationEvent)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(NotificationEvent)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <NotificationEvent>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<NotificationEvent>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <NotificationEvent>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<NotificationEvent>)
[-] 	JNC_MAP_FUNCTION ("signal", &NotificationEvent::signal)
[+] 	JNC_MAP_FUNCTION("signal", &NotificationEvent::signal)
[-] 	JNC_MAP_FUNCTION ("reset", &NotificationEvent::reset)
[+] 	JNC_MAP_FUNCTION("reset", &NotificationEvent::reset)
[-] 	JNC_MAP_FUNCTION ("wait", &NotificationEvent::wait)
[+] 	JNC_MAP_FUNCTION("wait", &NotificationEvent::wait)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] NotificationEvent::wait (uint_t timeout)
[+] NotificationEvent::wait(uint_t timeout)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	result = m_event.wait (timeout);
[+] 	result = m_event.wait(timeout);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_SysLib.cpp
----------------------
[-] getCurrentThreadId ()
[+] getCurrentThreadId()
[-] 	return (intptr_t) axl::sys::getCurrentThreadId ();
[+] 	return (intptr_t)axl::sys::getCurrentThreadId();
[-] getEnv (DataPtr namePtr)
[+] getEnv(DataPtr namePtr)
[-] 	const char* value = getenv ((const char*) namePtr.m_p);
[+] 	const char* value = getenv((const char*) namePtr.m_p);
[-] 	return strDup (value);
[+] 	return strDup(value);
[-] setEnv (
[+] setEnv(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String envString (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String envString(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	envString.format ("%s=%s", namePtr.m_p, valuePtr.m_p ? valuePtr.m_p : "");
[+] 	envString.format("%s=%s", namePtr.m_p, valuePtr.m_p ? valuePtr.m_p : "");
[-] 	_putenv (envString);
[+] 	_putenv(envString);
[-] 	setenv (
[+] 	setenv(
[-] sleep (uint32_t msCount)
[+] sleep(uint32_t msCount)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	::SleepEx (msCount, TRUE); // alertable wait (so we can abort with an APC)
[+] 	::SleepEx(msCount, TRUE); // alertable wait (so we can abort with an APC)
[-] 	axl::sys::sleep (msCount);
[+] 	axl::sys::sleep(msCount);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] collectGarbage ()
[+] collectGarbage()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->collect ();
[+] 	gcHeap->collect();
[-] getGcStats ()
[+] getGcStats()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->getStats (&stats);
[+] 	gcHeap->getStats(&stats);
[-] getGcTriggers ()
[+] getGcTriggers()
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->getSizeTriggers (&triggers);
[+] 	gcHeap->getSizeTriggers(&triggers);
[-] setGcTriggers (GcSizeTriggers triggers)
[+] setGcTriggers(GcSizeTriggers triggers)
[-] 	GcHeap* gcHeap = getCurrentThreadGcHeap ();
[+] 	GcHeap* gcHeap = getCurrentThreadGcHeap();
[-] 	ASSERT (gcHeap);
[+] 	ASSERT(gcHeap);
[-] 	gcHeap->setSizeTriggers (&triggers);
[+] 	gcHeap->setSizeTriggers(&triggers);
[-] initSystemInfo (SystemInfo* systemInfo)
[+] initSystemInfo(SystemInfo* systemInfo)
[-] 	const g::SystemInfo* axlSystemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* axlSystemInfo = g::getModule()->getSystemInfo();
[-] getSystemInfo ()
[+] getSystemInfo()
[-] 	axl::sl::callOnce (initSystemInfo, &systemInfo);
[+] 	axl::sl::callOnce(initSystemInfo, &systemInfo);
[-] formatTimestamp_0 (
[+] formatTimestamp_0(
[-] 	axl::sys::Time time (timestamp);
[+] 	axl::sys::Time time(timestamp);
[-] 	sl::String string = time.format ((const char*) format.m_p);
[+] 	sl::String string = time.format((const char*) format.m_p);
[-] 	return strDup (string);
[+] 	return strDup(string);
[-] formatTimestamp_1 (
[+] formatTimestamp_1(
[-] 	axl::sys::Time time (timestamp, timeZone);
[+] 	axl::sys::Time time(timestamp, timeZone);
[-] 	sl::String string = time.format ((const char*) format.m_p);
[+] 	sl::String string = time.format((const char*) format.m_p);
[-] 	return strDup (string);
[+] 	return strDup(string);
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (jnc_SysLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(jnc_SysLib)
[-] 	JNC_LIB_SOURCE_FILE ("sys_globals.jnc", g_sys_globalsSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_globals.jnc", g_sys_globalsSrc)
[-] 	JNC_LIB_SOURCE_FILE ("sys_Lock.jnc",    g_sys_LockSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_Lock.jnc",    g_sys_LockSrc)
[-] 	JNC_LIB_SOURCE_FILE ("sys_Event.jnc",   g_sys_EventSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_Event.jnc",   g_sys_EventSrc)
[-] 	JNC_LIB_SOURCE_FILE ("sys_NotificationEvent.jnc", g_sys_NotificationEventSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_NotificationEvent.jnc", g_sys_NotificationEventSrc)
[-] 	JNC_LIB_SOURCE_FILE ("sys_Thread.jnc",  g_sys_ThreadSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_Thread.jnc",  g_sys_ThreadSrc)
[-] 	JNC_LIB_SOURCE_FILE ("sys_Timer.jnc",   g_sys_TimerSrc)
[+] 	JNC_LIB_SOURCE_FILE("sys_Timer.jnc",   g_sys_TimerSrc)
[-] 	JNC_LIB_IMPORT ("sys_globals.jnc")
[+] 	JNC_LIB_IMPORT("sys_globals.jnc")
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (jnc_SysLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(jnc_SysLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Lock)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Lock)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Event)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Event)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (NotificationEvent)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(NotificationEvent)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Thread)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Thread)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (Timer)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(Timer)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (jnc_SysLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(jnc_SysLib)
[-] 	JNC_MAP_FUNCTION ("sys.getCurrentThreadId",  getCurrentThreadId)
[+] 	JNC_MAP_FUNCTION("sys.getCurrentThreadId",  getCurrentThreadId)
[-] 	JNC_MAP_FUNCTION ("sys.getTimestamp",        axl::sys::getTimestamp)
[+] 	JNC_MAP_FUNCTION("sys.getTimestamp",        axl::sys::getTimestamp)
[-] 	JNC_MAP_FUNCTION ("sys.getPreciseTimestamp", axl::sys::getPreciseTimestamp)
[+] 	JNC_MAP_FUNCTION("sys.getPreciseTimestamp", axl::sys::getPreciseTimestamp)
[-] 	JNC_MAP_FUNCTION ("sys.formatTimestamp",     formatTimestamp_0)
[+] 	JNC_MAP_FUNCTION("sys.formatTimestamp",     formatTimestamp_0)
[-] 	JNC_MAP_OVERLOAD (formatTimestamp_1)
[+] 	JNC_MAP_OVERLOAD(formatTimestamp_1)
[-] 	JNC_MAP_FUNCTION ("sys.sleep",               jnc::sys::sleep)
[+] 	JNC_MAP_FUNCTION("sys.sleep",               jnc::sys::sleep)
[-] 	JNC_MAP_FUNCTION ("sys.collectGarbage",      collectGarbage)
[+] 	JNC_MAP_FUNCTION("sys.collectGarbage",      collectGarbage)
[-] 	JNC_MAP_FUNCTION ("sys.getGcStats",          getGcStats)
[+] 	JNC_MAP_FUNCTION("sys.getGcStats",          getGcStats)
[-] 	JNC_MAP_PROPERTY ("sys.g_gcTriggers",        getGcTriggers, setGcTriggers)
[+] 	JNC_MAP_PROPERTY("sys.g_gcTriggers",        getGcTriggers, setGcTriggers)
[-] 	JNC_MAP_PROPERTY ("sys.g_env",               getEnv, setEnv)
[+] 	JNC_MAP_PROPERTY("sys.g_env",               getEnv, setEnv)
[-] 	JNC_MAP_VARIABLE ("sys.g_systemInfo",        getSystemInfo ())
[+] 	JNC_MAP_VARIABLE("sys.g_systemInfo",        getSystemInfo ())
[-] 	JNC_MAP_TYPE (Lock)
[+] 	JNC_MAP_TYPE(Lock)
[-] 	JNC_MAP_TYPE (Event)
[+] 	JNC_MAP_TYPE(Event)
[-] 	JNC_MAP_TYPE (Thread)
[+] 	JNC_MAP_TYPE(Thread)
[-] 	JNC_MAP_TYPE (Timer)
[+] 	JNC_MAP_TYPE(Timer)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Thread.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Thread)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Thread)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Thread>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Thread>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Thread>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Thread>)
[-] 	JNC_MAP_FUNCTION ("start", &Thread::start)
[+] 	JNC_MAP_FUNCTION("start", &Thread::start)
[-] 	JNC_MAP_FUNCTION ("wait", &Thread::wait)
[+] 	JNC_MAP_FUNCTION("wait", &Thread::wait)
[-] 	JNC_MAP_FUNCTION ("waitAndClose", &Thread::waitAndClose)
[+] 	JNC_MAP_FUNCTION("waitAndClose", &Thread::waitAndClose)
[-] 	JNC_MAP_FUNCTION ("terminate", &Thread::terminate)
[+] 	JNC_MAP_FUNCTION("terminate", &Thread::terminate)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Thread::start (FunctionPtr ptr)
[+] Thread::start(FunctionPtr ptr)
[-] 	if (m_thread.isOpen ())
[+] 	if (m_thread.isOpen())
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	result = m_thread.start ();
[+] 	result = m_thread.start();
[-] 	m_threadId = (uintptr_t) m_thread.getThreadId ();
[+] 	m_threadId = (uintptr_t)m_thread.getThreadId();
[-] Thread::wait (uint_t timeout)
[+] Thread::wait(uint_t timeout)
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	ASSERT (gcHeap == getCurrentThreadGcHeap ());
[+] 	ASSERT(gcHeap == getCurrentThreadGcHeap());
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	result = m_thread.wait (timeout);
[+] 	result = m_thread.wait(timeout);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
[-] Thread::waitAndClose (uint_t timeout)
[+] Thread::waitAndClose(uint_t timeout)
[-] 	GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 	ASSERT (gcHeap == getCurrentThreadGcHeap ());
[+] 	ASSERT(gcHeap == getCurrentThreadGcHeap());
[-] 	gcHeap->enterWaitRegion ();
[+] 	gcHeap->enterWaitRegion();
[-] 	m_thread.waitAndClose (timeout);
[+] 	m_thread.waitAndClose(timeout);
[-] 	gcHeap->leaveWaitRegion ();
[+] 	gcHeap->leaveWaitRegion();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Timer.cpp
----------------------
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (Timer)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(Timer)
[-] 	JNC_MAP_CONSTRUCTOR (&jnc::construct <Timer>)
[+] 	JNC_MAP_CONSTRUCTOR(&jnc::construct<Timer>)
[-] 	JNC_MAP_DESTRUCTOR (&jnc::destruct <Timer>)
[+] 	JNC_MAP_DESTRUCTOR(&jnc::destruct<Timer>)
[-] 	JNC_MAP_FUNCTION ("start", &Timer::start)
[+] 	JNC_MAP_FUNCTION("start", &Timer::start)
[-] 	JNC_MAP_FUNCTION ("stop", &Timer::stop)
[+] 	JNC_MAP_FUNCTION("stop", &Timer::stop)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] Timer::start (
[+] Timer::start(
[-] 	stop ();
[+] 	stop();
[-] 	m_stopEvent.reset ();
[+] 	m_stopEvent.reset();
[-] 	result = m_thread.start ();
[+] 	result = m_thread.start();
[-] Timer::stop ()
[+] Timer::stop()
[-] 	m_stopEvent.signal ();
[+] 	m_stopEvent.signal();
[-] 	if (m_thread.getThreadId () != axl::sys::getCurrentThreadId ())
[+] 	if (m_thread.getThreadId() != axl::sys::getCurrentThreadId())
[-] 		GcHeap* gcHeap = m_runtime->getGcHeap ();
[+] 		GcHeap* gcHeap = m_runtime->getGcHeap();
[-] 		ASSERT (gcHeap == getCurrentThreadGcHeap ());
[+] 		ASSERT(gcHeap == getCurrentThreadGcHeap());
[-] 		gcHeap->enterWaitRegion ();
[+] 		gcHeap->enterWaitRegion();
[-] 		m_thread.waitAndClose ();
[+] 		m_thread.waitAndClose();
[-] 		gcHeap->leaveWaitRegion ();
[+] 		gcHeap->leaveWaitRegion();
[-] Timer::threadFunc ()
[+] Timer::threadFunc()
[-] 	uint64_t timestamp = axl::sys::getTimestamp ();
[+] 	uint64_t timestamp = axl::sys::getTimestamp();
[-] 		uint_t delay = (uint_t) ((m_dueTime - timestamp) / 10000);
[+] 		uint_t delay = (uint_t)((m_dueTime - timestamp) / 10000);
[-] 		result = m_stopEvent.wait (delay);
[+] 		result = m_stopEvent.wait(delay);
[-] 	callVoidFunctionPtr (m_runtime, m_timerFuncPtr);
[+] 	callVoidFunctionPtr(m_runtime, m_timerFuncPtr);
[-] 		result = m_stopEvent.wait (m_interval);
[+] 		result = m_stopEvent.wait(m_interval);
[-] 		callVoidFunctionPtr (m_runtime, m_timerFuncPtr);
[+] 		callVoidFunctionPtr(m_runtime, m_timerFuncPtr);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Event.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Event)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Event)
[-] 	signal ()
[+] 	signal()
[-] 		m_event.signal ();
[+] 		m_event.signal();
[-] 	reset ()
[+] 	reset()
[-] 		m_event.reset ();
[+] 		m_event.reset();
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Lock.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Lock)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Lock)
[-] 	lock ();
[+] 	lock();
[-] 	unlock ()
[+] 	unlock()
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_NotificationEvent.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (NotificationEvent)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(NotificationEvent)
[-] 	signal ()
[+] 	signal()
[-] 		m_event.signal ();
[+] 		m_event.signal();
[-] 	reset ()
[+] 	reset()
[-] 		m_event.reset ();
[+] 		m_event.reset();
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_SysLib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Thread.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Thread)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Thread)
[-] 	class ThreadImpl: public axl::sys::ThreadImpl <ThreadImpl>
[+] 	class ThreadImpl: public axl::sys::ThreadImpl<ThreadImpl>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Thread, m_thread)->threadFunc ();
[+] 			containerof(this, Thread, m_thread)->threadFunc();
[-] 	Thread ()
[+] 	Thread()
[-] 		m_runtime = getCurrentThreadRuntime ();
[+] 		m_runtime = getCurrentThreadRuntime();
[-] 		ASSERT (m_runtime);
[+] 		ASSERT(m_runtime);
[-] 	~Thread ()
[+] 	~Thread()
[-] 		waitAndClose (-1);
[+] 		waitAndClose(-1);
[-] 	start (FunctionPtr ptr);
[+] 	start(FunctionPtr ptr);
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
[-] 	waitAndClose (uint_t timeout);
[+] 	waitAndClose(uint_t timeout);
[-] 	terminate ()
[+] 	terminate()
[-] 		return m_thread.terminate ();
[+] 		return m_thread.terminate();
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		callVoidFunctionPtr (m_runtime, m_threadFuncPtr);
[+] 		callVoidFunctionPtr(m_runtime, m_threadFuncPtr);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc_sys_Timer.h
----------------------
[-] JNC_DECLARE_OPAQUE_CLASS_TYPE (Timer)
[+] JNC_DECLARE_OPAQUE_CLASS_TYPE(Timer)
[-] 	class ThreadImpl: public axl::sys::ThreadImpl <ThreadImpl>
[+] 	class ThreadImpl: public axl::sys::ThreadImpl<ThreadImpl>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, Timer, m_thread)->threadFunc ();
[+] 			containerof(this, Timer, m_thread)->threadFunc();
[-] 	Timer ()
[+] 	Timer()
[-] 		m_runtime = getCurrentThreadRuntime ();
[+] 		m_runtime = getCurrentThreadRuntime();
[-] 		ASSERT (m_runtime);
[+] 		ASSERT(m_runtime);
[-] 	~Timer ()
[+] 	~Timer()
[-] 		stop ();
[+] 		stop();
[-] 	start (
[+] 	start(
[-] 	stop ();
[+] 	stop();
[-] 	threadFunc ();
[+] 	threadFunc();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_ExceptionMgr.cpp
----------------------
[-] ExceptionMgr::install ()
[+] ExceptionMgr::install()
[-] 	sigemptyset (&signalMask);
[+] 	sigemptyset(&signalMask);
[-] 	sigaddset (&signalMask, SIGSEGV);
[+] 	sigaddset(&signalMask, SIGSEGV);
[-] 	sigaddset (&signalMask, SIGBUS);
[+] 	sigaddset(&signalMask, SIGBUS);
[-] 	sigaddset (&signalMask, SIGFPE);
[+] 	sigaddset(&signalMask, SIGFPE);
[-] 	result = sigaction (SIGSEGV, &sigAction, &m_prevSigActionTable [SIGSEGV]);
[+] 	result = sigaction(SIGSEGV, &sigAction, &m_prevSigActionTable[SIGSEGV]);
[-] 	ASSERT (result == 0);
[+] 	ASSERT(result == 0);
[-] 	result = sigaction (SIGBUS, &sigAction, &m_prevSigActionTable [SIGBUS]);
[+] 	result = sigaction(SIGBUS, &sigAction, &m_prevSigActionTable[SIGBUS]);
[-] 	ASSERT (result == 0);
[+] 	ASSERT(result == 0);
[-] 	result = sigaction (SIGFPE, &sigAction, &m_prevSigActionTable [SIGFPE]);
[+] 	result = sigaction(SIGFPE, &sigAction, &m_prevSigActionTable[SIGFPE]);
[-] 	ASSERT (result == 0);
[+] 	ASSERT(result == 0);
[-] 	result = sigaction (SIGUSR1, &sigAction, &m_prevSigActionTable [SIGUSR1]);
[+] 	result = sigaction(SIGUSR1, &sigAction, &m_prevSigActionTable[SIGUSR1]);
[-] 	ASSERT (result == 0);
[+] 	ASSERT(result == 0);
[-] ExceptionMgr::signalHandler (
[+] ExceptionMgr::signalHandler(
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
[-] 		sl::getSimpleSingleton <ExceptionMgr> ()->invokePrevSignalHandler (signal, signalInfo, context);
[+] 		sl::getSimpleSingleton<ExceptionMgr> ()->invokePrevSignalHandler(signal, signalInfo, context);
[-] 		GcHeap* gcHeap = tls->m_runtime->getGcHeap ();
[+] 		GcHeap* gcHeap = tls->m_runtime->getGcHeap();
[-] 		if (signalInfo->si_addr == gcHeap->getGuardPage ())
[+] 		if (signalInfo->si_addr == gcHeap->getGuardPage())
[-] 			gcHeap->handleGuardPageHit (&tls->m_gcMutatorThread);
[+] 			gcHeap->handleGuardPageHit(&tls->m_gcMutatorThread);
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 		sl::getSimpleSingleton <ExceptionMgr> ()->invokePrevSignalHandler (signal, signalInfo, context);
[+] 		sl::getSimpleSingleton<ExceptionMgr> ()->invokePrevSignalHandler(signal, signalInfo, context);
[-] 		AXL_TODO ("add extra variables to the SJLJ frame to store error information");
[+] 		AXL_TODO("add extra variables to the SJLJ frame to store error information");
[-] 		longjmp (tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[+] 		longjmp(tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] ExceptionMgr::signalHandler_SIGUSR (
[+] ExceptionMgr::signalHandler_SIGUSR(
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
[-] 		sl::getSimpleSingleton <ExceptionMgr> ()->invokePrevSignalHandler (signal, signalInfo, context);
[+] 		sl::getSimpleSingleton<ExceptionMgr> ()->invokePrevSignalHandler(signal, signalInfo, context);
[-] ExceptionMgr::invokePrevSignalHandler (
[+] ExceptionMgr::invokePrevSignalHandler(
[-] 	const struct sigaction* prevSigAction = &m_prevSigActionTable [signal];
[+] 	const struct sigaction* prevSigAction = &m_prevSigActionTable[signal];
[-] 		sigaction (signal, &m_prevSigActionTable [signal], NULL);
[+] 		sigaction(signal, &m_prevSigActionTable[signal], NULL);
[-] 		raise (signal);
[+] 		raise(signal);
[-] 		prevSigAction->sa_handler (signal);
[+] 		prevSigAction->sa_handler(signal);
[-] 		prevSigAction->sa_sigaction (signal, signalInfo, context);
[+] 		prevSigAction->sa_sigaction(signal, signalInfo, context);
[-] ExceptionMgr::install ()
[+] ExceptionMgr::install()
[-] 	::AddVectoredExceptionHandler (true, vectoredExceptionHandler);
[+] 	::AddVectoredExceptionHandler(true, vectoredExceptionHandler);
[-] ExceptionMgr::vectoredExceptionHandler (EXCEPTION_POINTERS* exceptionPointers)
[+] ExceptionMgr::vectoredExceptionHandler(EXCEPTION_POINTERS* exceptionPointers)
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
[-] 	GcHeap* gcHeap = tls->m_runtime->getGcHeap ();
[+] 	GcHeap* gcHeap = tls->m_runtime->getGcHeap();
[-] 		exceptionPointers->ExceptionRecord->ExceptionInformation [1] == (uintptr_t) gcHeap->getGuardPage ())
[+] 		exceptionPointers->ExceptionRecord->ExceptionInformation[1] == (uintptr_t)gcHeap->getGuardPage())
[-] 		gcHeap->handleGuardPageHit (&tls->m_gcMutatorThread);
[+] 		gcHeap->handleGuardPageHit(&tls->m_gcMutatorThread);
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 		AXL_TODO ("encode SEH information better");
[+] 		AXL_TODO("encode SEH information better");
[-] 		sys::win::setNtStatus (status);
[+] 		sys::win::setNtStatus(status);
[-] 		_JUMP_BUFFER* pBuffer = (_JUMP_BUFFER*) tlsVariableTable->m_sjljFrame->m_jmpBuf;
[+] 		_JUMP_BUFFER* pBuffer = (_JUMP_BUFFER*)tlsVariableTable->m_sjljFrame->m_jmpBuf;
[-] 		longjmp (tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[+] 		longjmp(tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_GcHeap.cpp
----------------------
[-] GcHeap::GcHeap ()
[+] GcHeap::GcHeap()
[-] 	m_runtime = containerof (this, Runtime, m_gcHeap);
[+] 	m_runtime = containerof(this, Runtime, m_gcHeap);
[-] 	m_idleEvent.signal ();
[+] 	m_idleEvent.signal();
[-] 	memset (&m_stats, 0, sizeof (m_stats));
[+] 	memset(&m_stats, 0, sizeof(m_stats));
[-] 	m_guardPage.alloc (4 * 1024); // typical page size (OS will not give us less than that anyway)
[+] 	m_guardPage.alloc(4 * 1024); // typical page size (OS will not give us less than that anyway)
[-] 	m_guardPage.map (
[+] 	m_guardPage.map(
[-] GcHeap::getStats (GcStats* stats)
[+] GcHeap::getStats(GcStats* stats)
[-] 	m_lock.lock (); // no need to wait for idle to just get stats
[+] 	m_lock.lock(); // no need to wait for idle to just get stats
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::getCurrentGcMutatorThread ()
[+] GcHeap::getCurrentGcMutatorThread()
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
[-] GcHeap::setSizeTriggers (
[+] GcHeap::setSizeTriggers(
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	if (isCollectionTriggered_l ())
[+] 	if (isCollectionTriggered_l())
[-] 		collect_l (isMutatorThread);
[+] 		collect_l(isMutatorThread);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] GcHeap::startup (ct::Module* module)
[+] GcHeap::startup(ct::Module* module)
[-] 	ASSERT (m_state == State_Idle);
[+] 	ASSERT(m_state == State_Idle);
[-] 	memset (&m_stats, 0, sizeof (m_stats));
[+] 	memset(&m_stats, 0, sizeof(m_stats));
[-] 	if (module->getCompileFlags () & ModuleCompileFlag_SimpleGcSafePoint)
[+] 	if (module->getCompileFlags() & ModuleCompileFlag_SimpleGcSafePoint)
[-] 		ct::Variable* safePointTriggerVariable = module->m_variableMgr.getStdVariable (ct::StdVariable_GcSafePointTrigger);
[+] 		ct::Variable* safePointTriggerVariable = module->m_variableMgr.getStdVariable(ct::StdVariable_GcSafePointTrigger);
[-] 		*(void**) safePointTriggerVariable->getStaticData () = m_guardPage;
[+] 		*(void**) safePointTriggerVariable->getStaticData() = m_guardPage;
[-] 	addStaticRootVariables (module->m_variableMgr.getStaticGcRootArray ());
[+] 	addStaticRootVariables(module->m_variableMgr.getStaticGcRootArray());
[-] 	ct::Function* destructor = module->getDestructor ();
[+] 	ct::Function* destructor = module->getDestructor();
[-] 		addStaticDestructor ((StaticDestructFunc*) destructor->getMachineCode ());
[+] 		addStaticDestructor((StaticDestructFunc*)destructor->getMachineCode());
[-] 	return m_destructThread.start ();
[+] 	return m_destructThread.start();
[-] abortApc (ULONG_PTR context)
[+] abortApc(ULONG_PTR context)
[-] GcHeap::abort ()
[+] GcHeap::abort()
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	size_t handshakeCount = stopTheWorld_l (isMutatorThread);
[+] 	size_t handshakeCount = stopTheWorld_l(isMutatorThread);
[-] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead ();
[+] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead();
[-] 		handle_t h = ::OpenThread (THREAD_ALL_ACCESS, false, (dword_t) threadIt->m_threadId);
[+] 		handle_t h = ::OpenThread(THREAD_ALL_ACCESS, false, (dword_t)threadIt->m_threadId);
[-] 		::QueueUserAPC (abortApc, h, 0);
[+] 		::QueueUserAPC(abortApc, h, 0);
[-] 		::CloseHandle (h);
[+] 		::CloseHandle(h);
[-] 		::pthread_kill ((pthread_t) threadIt->m_threadId, SIGUSR1);
[+] 		::pthread_kill((pthread_t)threadIt->m_threadId, SIGUSR1);
[-] 	resumeTheWorld (handshakeCount);
[+] 	resumeTheWorld(handshakeCount);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_idleEvent.signal ();
[+] 	m_idleEvent.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::waitIdleAndLock ()
[+] GcHeap::waitIdleAndLock()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			m_idleEvent.wait ();
[+] 			m_idleEvent.wait();
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 			safePoint ();
[+] 			safePoint();
[-] 			m_lock.lock ();
[+] 			m_lock.lock();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 				m_idleEvent.wait ();
[+] 				m_idleEvent.wait();
[-] 				m_lock.lock ();
[+] 				m_lock.lock();
[-] GcHeap::isCollectionTriggered_l ()
[+] GcHeap::isCollectionTriggered_l()
[-] GcHeap::incrementAllocSize_l (size_t size)
[+] GcHeap::incrementAllocSize_l(size_t size)
[-] GcHeap::incrementAllocSizeAndLock (size_t size)
[+] GcHeap::incrementAllocSizeAndLock(size_t size)
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (isMutatorThread);
[+] 	ASSERT(isMutatorThread);
[-] 	incrementAllocSize_l (size);
[+] 	incrementAllocSize_l(size);
[-] 	if (isCollectionTriggered_l ())
[+] 	if (isCollectionTriggered_l())
[-] 		collect_l (isMutatorThread);
[+] 		collect_l(isMutatorThread);
[-] 		waitIdleAndLock ();
[+] 		waitIdleAndLock();
[-] GcHeap::addBoxIfDynamicFrame (Box* box)
[+] GcHeap::addBoxIfDynamicFrame(Box* box)
[-] 	Tls* tls = rt::getCurrentThreadTls ();
[+] 	Tls* tls = rt::getCurrentThreadTls();
[-] 	ASSERT (tls);
[+] 	ASSERT(tls);
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 	ASSERT (tlsVariableTable->m_gcShadowStackTop);
[+] 	ASSERT(tlsVariableTable->m_gcShadowStackTop);
[-] 	if (!map || map->getMapKind () != ct::GcShadowStackFrameMapKind_Dynamic)
[+] 	if (!map || map->getMapKind() != ct::GcShadowStackFrameMapKind_Dynamic)
[-] 	map->addBox (box);
[+] 	map->addBox(box);
[-] GcHeap::tryAllocateClass (ct::ClassType* type)
[+] GcHeap::tryAllocateClass(ct::ClassType* type)
[-] 	size_t size = type->getSize ();
[+] 	size_t size = type->getSize();
[-] 	Box* box = (Box*) AXL_MEM_ALLOCATE (size);
[+] 	Box* box = (Box*)AXL_MEM_ALLOCATE(size);
[-] 		err::setFormatStringError ("not enough memory for '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("not enough memory for '%s'", type->getTypeString ().sz ());
[-] 	primeClass (box, type);
[+] 	primeClass(box, type);
[-] 	addBoxIfDynamicFrame (box);
[+] 	addBoxIfDynamicFrame(box);
[-] 	incrementAllocSizeAndLock (size);
[+] 	incrementAllocSizeAndLock(size);
[-] 	m_allocBoxArray.append (box);
[+] 	m_allocBoxArray.append(box);
[-] 	addClassBox_l (box);
[+] 	addClassBox_l(box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	return (IfaceHdr*) (box + 1);
[+] 	return (IfaceHdr*)(box + 1);
[-] GcHeap::allocateClass (ct::ClassType* type)
[+] GcHeap::allocateClass(ct::ClassType* type)
[-] 	IfaceHdr* iface = tryAllocateClass (type);
[+] 	IfaceHdr* iface = tryAllocateClass(type);
[-] 		Runtime::dynamicThrow ();
[+] 		Runtime::dynamicThrow();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] GcHeap::addClassBox_l (Box* box)
[+] GcHeap::addClassBox_l(Box* box)
[-] 	ASSERT (box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ct::ClassType* classType = (ct::ClassType*) box->m_type;
[+] 	ct::ClassType* classType = (ct::ClassType*)box->m_type;
[-] 	IfaceHdr* ifaceHdr = (IfaceHdr*) (box + 1);
[+] 	IfaceHdr* ifaceHdr = (IfaceHdr*)(box + 1);
[-] 	addBaseTypeClassFieldBoxes_l (classType, ifaceHdr);
[+] 	addBaseTypeClassFieldBoxes_l(classType, ifaceHdr);
[-] 	addClassFieldBoxes_l (classType, ifaceHdr);
[+] 	addClassFieldBoxes_l(classType, ifaceHdr);
[-] 	m_classBoxArray.append (box); // after all the fields
[+] 	m_classBoxArray.append(box); // after all the fields
[-] 	if (classType->getDestructor ())
[+] 	if (classType->getDestructor())
[-] 		m_destructibleClassBoxArray.append (box);
[+] 		m_destructibleClassBoxArray.append(box);
[-] GcHeap::addBaseTypeClassFieldBoxes_l (
[+] GcHeap::addBaseTypeClassFieldBoxes_l(
[-] 	char* p = (char*) ifaceHdr;
[+] 	char* p = (char*)ifaceHdr;
[-] 	sl::Array <ct::BaseTypeSlot*> baseTypeArray = type->getBaseTypeArray ();
[+] 	sl::Array<ct::BaseTypeSlot*> baseTypeArray = type->getBaseTypeArray();
[-] 	size_t count = baseTypeArray.getCount ();
[+] 	size_t count = baseTypeArray.getCount();
[-] 		ct::BaseTypeSlot* slot = baseTypeArray [i];
[+] 		ct::BaseTypeSlot* slot = baseTypeArray[i];
[-] 		ct::Type* baseType = slot->getType ();
[+] 		ct::Type* baseType = slot->getType();
[-] 		if (baseType->getTypeKind () != TypeKind_Class)
[+] 		if (baseType->getTypeKind() != TypeKind_Class)
[-] 		ct::ClassType* baseClassType = (ct::ClassType*) baseType;
[+] 		ct::ClassType* baseClassType = (ct::ClassType*)baseType;
[-] 		IfaceHdr* baseIfaceHdr = (IfaceHdr*) (p + slot->getOffset ());
[+] 		IfaceHdr* baseIfaceHdr = (IfaceHdr*)(p + slot->getOffset());
[-] 		addBaseTypeClassFieldBoxes_l (baseClassType, baseIfaceHdr);
[+] 		addBaseTypeClassFieldBoxes_l(baseClassType, baseIfaceHdr);
[-] 		addClassFieldBoxes_l (baseClassType, baseIfaceHdr);
[+] 		addClassFieldBoxes_l(baseClassType, baseIfaceHdr);
[-] GcHeap::addClassFieldBoxes_l (
[+] GcHeap::addClassFieldBoxes_l(
[-] 	char* p = (char*) ifaceHdr;
[+] 	char* p = (char*)ifaceHdr;
[-] 	sl::Array <ct::StructField*> classFieldArray = type->getClassMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> classFieldArray = type->getClassMemberFieldArray();
[-] 	size_t count = classFieldArray.getCount ();
[+] 	size_t count = classFieldArray.getCount();
[-] 		ct::StructField* field = classFieldArray [i];
[+] 		ct::StructField* field = classFieldArray[i];
[-] 		Box* childBox = (Box*) (p + field->getOffset ());
[+] 		Box* childBox = (Box*)(p + field->getOffset());
[-] 		ASSERT (
[+] 		ASSERT(
[-] 			field->getType ()->getTypeKind () == TypeKind_Class &&
[+] 			field->getType()->getTypeKind() == TypeKind_Class &&
[-] 			childBox->m_type == field->getType ());
[+] 			childBox->m_type == field->getType());
[-] 		addClassBox_l (childBox);
[+] 		addClassBox_l(childBox);
[-] GcHeap::addStaticClassDestructor_l (
[+] GcHeap::addStaticClassDestructor_l(
[-] 	ASSERT (iface->m_box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(iface->m_box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ct::ClassType* classType = (ct::ClassType*) iface->m_box->m_type;
[+] 	ct::ClassType* classType = (ct::ClassType*)iface->m_box->m_type;
[-] 	StaticDestructor* destruct = AXL_MEM_NEW (StaticDestructor);
[+] 	StaticDestructor* destruct = AXL_MEM_NEW(StaticDestructor);
[-] 	addStaticBaseTypeClassFieldDestructors_l (classType, iface);
[+] 	addStaticBaseTypeClassFieldDestructors_l(classType, iface);
[-] 	addStaticClassFieldDestructors_l (classType, iface);
[+] 	addStaticClassFieldDestructors_l(classType, iface);
[-] 	m_staticDestructorList.insertTail (destruct); // after all the fields
[+] 	m_staticDestructorList.insertTail(destruct); // after all the fields
[-] GcHeap::addStaticBaseTypeClassFieldDestructors_l (
[+] GcHeap::addStaticBaseTypeClassFieldDestructors_l(
[-] 	char* p = (char*) ifaceHdr;
[+] 	char* p = (char*)ifaceHdr;
[-] 	sl::Array <ct::BaseTypeSlot*> baseTypeArray = type->getBaseTypeArray ();
[+] 	sl::Array<ct::BaseTypeSlot*> baseTypeArray = type->getBaseTypeArray();
[-] 	size_t count = baseTypeArray.getCount ();
[+] 	size_t count = baseTypeArray.getCount();
[-] 		ct::BaseTypeSlot* slot = baseTypeArray [i];
[+] 		ct::BaseTypeSlot* slot = baseTypeArray[i];
[-] 		ct::Type* baseType = slot->getType ();
[+] 		ct::Type* baseType = slot->getType();
[-] 		if (baseType->getTypeKind () != TypeKind_Class)
[+] 		if (baseType->getTypeKind() != TypeKind_Class)
[-] 		ct::ClassType* baseClassType = (ct::ClassType*) baseType;
[+] 		ct::ClassType* baseClassType = (ct::ClassType*)baseType;
[-] 		IfaceHdr* baseIfaceHdr = (IfaceHdr*) (p + slot->getOffset ());
[+] 		IfaceHdr* baseIfaceHdr = (IfaceHdr*)(p + slot->getOffset());
[-] 		addStaticBaseTypeClassFieldDestructors_l (baseClassType, baseIfaceHdr);
[+] 		addStaticBaseTypeClassFieldDestructors_l(baseClassType, baseIfaceHdr);
[-] 		addStaticClassFieldDestructors_l (baseClassType, baseIfaceHdr);
[+] 		addStaticClassFieldDestructors_l(baseClassType, baseIfaceHdr);
[-] GcHeap::addStaticClassFieldDestructors_l (
[+] GcHeap::addStaticClassFieldDestructors_l(
[-] 	char* p = (char*) ifaceHdr;
[+] 	char* p = (char*)ifaceHdr;
[-] 	sl::Array <ct::StructField*> classFieldArray = type->getClassMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> classFieldArray = type->getClassMemberFieldArray();
[-] 	size_t count = classFieldArray.getCount ();
[+] 	size_t count = classFieldArray.getCount();
[-] 		ct::StructField* field = classFieldArray [i];
[+] 		ct::StructField* field = classFieldArray[i];
[-] 		ct::ClassType* fieldType = (ct::ClassType*) field->getType ();
[+] 		ct::ClassType* fieldType = (ct::ClassType*)field->getType();
[-] 		ASSERT (fieldType->getTypeKind () == TypeKind_Class);
[+] 		ASSERT(fieldType->getTypeKind() == TypeKind_Class);
[-] 		ct::Function* destructor = fieldType->getDestructor ();
[+] 		ct::Function* destructor = fieldType->getDestructor();
[-] 		DestructFunc* destructFunc = (DestructFunc*) destructor->getMachineCode ();
[+] 		DestructFunc* destructFunc = (DestructFunc*)destructor->getMachineCode();
[-] 		Box* childBox = (Box*) (p + field->getOffset ());
[+] 		Box* childBox = (Box*)(p + field->getOffset());
[-] 		ASSERT (childBox->m_type == fieldType);
[+] 		ASSERT(childBox->m_type == fieldType);
[-] 		addStaticClassDestructor_l (destructFunc, (IfaceHdr*) (childBox + 1));
[+] 		addStaticClassDestructor_l(destructFunc, (IfaceHdr*)(childBox + 1));
[-] GcHeap::tryAllocateData (ct::Type* type)
[+] GcHeap::tryAllocateData(ct::Type* type)
[-] 	size_t size = type->getSize ();
[+] 	size_t size = type->getSize();
[-] 	DataBox* box = AXL_MEM_NEW_EXTRA (DataBox, size);
[+] 	DataBox* box = AXL_MEM_NEW_EXTRA(DataBox, size);
[-] 		err::setFormatStringError ("not enough memory for '%s'", type->getTypeString ().sz ());
[+] 		err::setFormatStringError("not enough memory for '%s'", type->getTypeString ().sz ());
[-] 	memset (box + 1, 0, size);
[+] 	memset(box + 1, 0, size);
[-] 	box->m_validator.m_validatorBox = (Box*) box;
[+] 	box->m_validator.m_validatorBox = (Box*)box;
[-] 	box->m_validator.m_targetBox = (Box*) box;
[+] 	box->m_validator.m_targetBox = (Box*)box;
[-] 	box->m_validator.m_rangeEnd = (char*) box->m_validator.m_rangeBegin + size;
[+] 	box->m_validator.m_rangeEnd = (char*)box->m_validator.m_rangeBegin + size;
[-] 	addBoxIfDynamicFrame (&box->m_box);
[+] 	addBoxIfDynamicFrame(&box->m_box);
[-] 	incrementAllocSizeAndLock (size);
[+] 	incrementAllocSizeAndLock(size);
[-] 	m_allocBoxArray.append ((Box*) box);
[+] 	m_allocBoxArray.append((Box*)box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::allocateData (ct::Type* type)
[+] GcHeap::allocateData(ct::Type* type)
[-] 	DataPtr ptr = tryAllocateData (type);
[+] 	DataPtr ptr = tryAllocateData(type);
[-] 		Runtime::dynamicThrow ();
[+] 		Runtime::dynamicThrow();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] GcHeap::tryAllocateArray (
[+] GcHeap::tryAllocateArray(
[-] 	size_t size = type->getSize () * count;
[+] 	size_t size = type->getSize() * count;
[-] 	DynamicArrayBox* box = AXL_MEM_NEW_EXTRA (DynamicArrayBox, size);
[+] 	DynamicArrayBox* box = AXL_MEM_NEW_EXTRA(DynamicArrayBox, size);
[-] 		err::setFormatStringError ("not enough memory for '%s [%d]'", type->getTypeString ().sz (), count);
[+] 		err::setFormatStringError("not enough memory for '%s [%d]'", type->getTypeString ().sz (), count);
[-] 	memset (box + 1, 0, size);
[+] 	memset(box + 1, 0, size);
[-] 	box->m_validator.m_validatorBox = (Box*) box;
[+] 	box->m_validator.m_validatorBox = (Box*)box;
[-] 	box->m_validator.m_targetBox = (Box*) box;
[+] 	box->m_validator.m_targetBox = (Box*)box;
[-] 	box->m_validator.m_rangeEnd = (char*) box->m_validator.m_rangeBegin + size;
[+] 	box->m_validator.m_rangeEnd = (char*)box->m_validator.m_rangeBegin + size;
[-] 	addBoxIfDynamicFrame (&box->m_box);
[+] 	addBoxIfDynamicFrame(&box->m_box);
[-] 	incrementAllocSizeAndLock (size);
[+] 	incrementAllocSizeAndLock(size);
[-] 	m_allocBoxArray.append ((Box*) box);
[+] 	m_allocBoxArray.append((Box*)box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::allocateArray (
[+] GcHeap::allocateArray(
[-] 	DataPtr ptr = tryAllocateArray (type, count);
[+] 	DataPtr ptr = tryAllocateArray(type, count);
[-] 		Runtime::dynamicThrow ();
[+] 		Runtime::dynamicThrow();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] GcHeap::tryAllocateBuffer (size_t size)
[+] GcHeap::tryAllocateBuffer(size_t size)
[-] 	ct::Module* module = m_runtime->getModule ();
[+] 	ct::Module* module = m_runtime->getModule();
[-] 	ASSERT (module);
[+] 	ASSERT(module);
[-] 	ct::Type* type = module->m_typeMgr.getPrimitiveType (TypeKind_Char);
[+] 	ct::Type* type = module->m_typeMgr.getPrimitiveType(TypeKind_Char);
[-] 	return tryAllocateArray (type, size);
[+] 	return tryAllocateArray(type, size);
[-] GcHeap::allocateBuffer (size_t size)
[+] GcHeap::allocateBuffer(size_t size)
[-] 	ct::Module* module = m_runtime->getModule ();
[+] 	ct::Module* module = m_runtime->getModule();
[-] 	ASSERT (module);
[+] 	ASSERT(module);
[-] 	ct::Type* type = module->m_typeMgr.getPrimitiveType (TypeKind_Char);
[+] 	ct::Type* type = module->m_typeMgr.getPrimitiveType(TypeKind_Char);
[-] 	return allocateArray (type, size);
[+] 	return allocateArray(type, size);
[-] GcHeap::createDataPtrValidator (
[+] GcHeap::createDataPtrValidator(
[-] 	ASSERT (GcDef_DataPtrValidatorPoolSize >= 1);
[+] 	ASSERT(GcDef_DataPtrValidatorPoolSize >= 1);
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread && !thread->m_waitRegionLevel);
[+] 	ASSERT(thread && !thread->m_waitRegionLevel);
[-] 		size_t size = sizeof (DataPtrValidator) * GcDef_DataPtrValidatorPoolSize;
[+] 		size_t size = sizeof(DataPtrValidator)* GcDef_DataPtrValidatorPoolSize;
[-] 		DynamicArrayBox* box = AXL_MEM_NEW_EXTRA (DynamicArrayBox, size);
[+] 		DynamicArrayBox* box = AXL_MEM_NEW_EXTRA(DynamicArrayBox, size);
[-] 			Runtime::dynamicThrow ();
[+] 			Runtime::dynamicThrow();
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		box->m_box.m_type = (jnc::Type*) m_runtime->getModule ()->m_typeMgr.getStdType (StdType_DataPtrValidator);
[+] 		box->m_box.m_type = (jnc::Type*)m_runtime->getModule()->m_typeMgr.getStdType(StdType_DataPtrValidator);
[-] 		incrementAllocSizeAndLock (size);
[+] 		incrementAllocSizeAndLock(size);
[-] 		m_allocBoxArray.append ((Box*) box);
[+] 		m_allocBoxArray.append((Box*)box);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		validator->m_validatorBox = (Box*) box;
[+] 		validator->m_validatorBox = (Box*)box;
[-] 			thread->m_dataPtrValidatorPoolBegin->m_validatorBox = (Box*) box;
[+] 			thread->m_dataPtrValidatorPoolBegin->m_validatorBox = (Box*)box;
[-] 	validator->m_rangeEnd = (char*) rangeBegin + rangeLength;
[+] 	validator->m_rangeEnd = (char*)rangeBegin + rangeLength;
[-] GcHeap::getDynamicLayout (Box* box)
[+] GcHeap::getDynamicLayout(Box* box)
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	sl::HashTableIterator <Box*, IfaceHdr*> it = m_dynamicLayoutMap.find (box);
[+] 	sl::HashTableIterator<Box*, IfaceHdr*> it = m_dynamicLayoutMap.find(box);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	JNC_BEGIN_CALL_SITE (m_runtime)
[+] 	JNC_BEGIN_CALL_SITE(m_runtime)
[-] 	dynamicLayout = createClass <rtl::DynamicLayout> (m_runtime);
[+] 	dynamicLayout = createClass<rtl::DynamicLayout> (m_runtime);
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	sl::HashTableIterator <Box*, IfaceHdr*> it = m_dynamicLayoutMap.visit (box);
[+] 	sl::HashTableIterator<Box*, IfaceHdr*> it = m_dynamicLayoutMap.visit(box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] GcHeap::resetDynamicLayout (Box* box)
[+] GcHeap::resetDynamicLayout(Box* box)
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	m_dynamicLayoutMap.eraseKey (box);
[+] 	m_dynamicLayoutMap.eraseKey(box);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::beginShutdown ()
[+] GcHeap::beginShutdown()
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (!isMutatorThread);
[+] 	ASSERT(!isMutatorThread);
[-] 	m_staticRootArray.clear (); // drop static roots
[+] 	m_staticRootArray.clear(); // drop static roots
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::finalizeShutdown ()
[+] GcHeap::finalizeShutdown()
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (!isMutatorThread && (m_flags & Flag_ShuttingDown));
[+] 	ASSERT(!isMutatorThread && (m_flags & Flag_ShuttingDown));
[-] 	m_destructEvent.signal ();
[+] 	m_destructEvent.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_destructThread.waitAndClose ();
[+] 	m_destructThread.waitAndClose();
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	m_staticRootArray.clear (); // drop static roots one more time
[+] 	m_staticRootArray.clear(); // drop static roots one more time
[-] 	collect_l (false);
[+] 	collect_l(false);
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	sl::Array <Box*> postponeFreeBoxArray = m_postponeFreeBoxArray;
[+] 	sl::Array<Box*> postponeFreeBoxArray = m_postponeFreeBoxArray;
[-] 	m_postponeFreeBoxArray.clear ();
[+] 	m_postponeFreeBoxArray.clear();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	size_t count = postponeFreeBoxArray.getCount ();
[+] 	size_t count = postponeFreeBoxArray.getCount();
[-] 		AXL_MEM_FREE (postponeFreeBoxArray [i]);
[+] 		AXL_MEM_FREE(postponeFreeBoxArray[i]);
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		m_staticDestructorList.isEmpty () &&
[+] 		m_staticDestructorList.isEmpty() &&
[-] 		m_dynamicDestructArray.isEmpty () &&
[+] 		m_dynamicDestructArray.isEmpty() &&
[-] 		m_allocBoxArray.isEmpty () &&
[+] 		m_allocBoxArray.isEmpty() &&
[-] 		m_classBoxArray.isEmpty () &&
[+] 		m_classBoxArray.isEmpty() &&
[-] 		m_dynamicLayoutMap.isEmpty ()
[+] 		m_dynamicLayoutMap.isEmpty()
[-] 	m_staticDestructorList.clear ();
[+] 	m_staticDestructorList.clear();
[-] 	m_dynamicDestructArray.clear ();
[+] 	m_dynamicDestructArray.clear();
[-] 	m_allocBoxArray.clear ();
[+] 	m_allocBoxArray.clear();
[-] 	m_classBoxArray.clear ();
[+] 	m_classBoxArray.clear();
[-] 	m_destructibleClassBoxArray.clear ();
[+] 	m_destructibleClassBoxArray.clear();
[-] 	m_dynamicLayoutMap.clear ();
[+] 	m_dynamicLayoutMap.clear();
[-] GcHeap::addStaticRootVariables (
[+] GcHeap::addStaticRootVariables(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <Root> rootArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<Root> rootArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	rootArray.setCount (count);
[+] 	rootArray.setCount(count);
[-] 		ct::Variable* variable = variableArray [i];
[+] 		ct::Variable* variable = variableArray[i];
[-] 		rootArray [i].m_p = variable->getStaticData ();
[+] 		rootArray[i].m_p = variable->getStaticData();
[-] 		rootArray [i].m_type = variable->getType ();
[+] 		rootArray[i].m_type = variable->getType();
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	m_staticRootArray.append (rootArray);
[+] 	m_staticRootArray.append(rootArray);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::addStaticRoot (
[+] GcHeap::addStaticRoot(
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	m_staticRootArray.append (root);
[+] 	m_staticRootArray.append(root);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::addStaticDestructor (StaticDestructFunc* func)
[+] GcHeap::addStaticDestructor(StaticDestructFunc* func)
[-] 	StaticDestructor* destruct = AXL_MEM_NEW (StaticDestructor);
[+] 	StaticDestructor* destruct = AXL_MEM_NEW(StaticDestructor);
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	m_staticDestructorList.insertTail (destruct);
[+] 	m_staticDestructorList.insertTail(destruct);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::addStaticClassDestructor (
[+] GcHeap::addStaticClassDestructor(
[-] 	waitIdleAndLock ();
[+] 	waitIdleAndLock();
[-] 	addStaticClassDestructor_l (func, iface);
[+] 	addStaticClassDestructor_l(func, iface);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::registerMutatorThread (GcMutatorThread* thread)
[+] GcHeap::registerMutatorThread(GcMutatorThread* thread)
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (!isMutatorThread); // we are in the process of registering this thread
[+] 	ASSERT(!isMutatorThread); // we are in the process of registering this thread
[-] 	thread->m_threadId = sys::getCurrentThreadId ();
[+] 	thread->m_threadId = sys::getCurrentThreadId();
[-] 	m_mutatorThreadList.insertTail (thread);
[+] 	m_mutatorThreadList.insertTail(thread);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::unregisterMutatorThread (GcMutatorThread* thread)
[+] GcHeap::unregisterMutatorThread(GcMutatorThread* thread)
[-] 	ASSERT (thread->m_threadId == sys::getCurrentThreadId ());
[+] 	ASSERT(thread->m_threadId == sys::getCurrentThreadId());
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (isMutatorThread);
[+] 	ASSERT(isMutatorThread);
[-] 	m_mutatorThreadList.remove (thread);
[+] 	m_mutatorThreadList.remove(thread);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::enterWaitRegion ()
[+] GcHeap::enterWaitRegion()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread);
[+] 	ASSERT(thread);
[-] 		TRACE ("-- WARNING: GcHeap::enterWaitRegion () in no-collect-region (no collections until wait completes)\n");
[+] 		TRACE("-- WARNING: GcHeap::enterWaitRegion () in no-collect-region (no collections until wait completes)\n");
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (isMutatorThread);
[+] 	ASSERT(isMutatorThread);
[-] 	ASSERT (m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount ());
[+] 	ASSERT(m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount());
[-] 	JNC_TRACE_GC_REGION ("GcHeap::enterWaitRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[+] 	JNC_TRACE_GC_REGION("GcHeap::enterWaitRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::leaveWaitRegion ()
[+] GcHeap::leaveWaitRegion()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread && thread->m_waitRegionLevel);
[+] 	ASSERT(thread && thread->m_waitRegionLevel);
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (!isMutatorThread);
[+] 	ASSERT(!isMutatorThread);
[-] 	JNC_TRACE_GC_REGION ("GcHeap::leaveWaitRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[+] 	JNC_TRACE_GC_REGION("GcHeap::leaveWaitRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 		abortThrow ();
[+] 		abortThrow();
[-] GcHeap::enterNoCollectRegion ()
[+] GcHeap::enterNoCollectRegion()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread && !thread->m_waitRegionLevel);
[+] 	ASSERT(thread && !thread->m_waitRegionLevel);
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (isMutatorThread);
[+] 	ASSERT(isMutatorThread);
[-] 	ASSERT (m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount ());
[+] 	ASSERT(m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount());
[-] 	JNC_TRACE_GC_REGION ("GcHeap::enterNoCollectRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[+] 	JNC_TRACE_GC_REGION("GcHeap::enterNoCollectRegion () (tid = %x)\n", (uint_t) sys::getCurrentThreadId ());
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::leaveNoCollectRegion (bool canCollectNow)
[+] GcHeap::leaveNoCollectRegion(bool canCollectNow)
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread && !thread->m_waitRegionLevel && thread->m_noCollectRegionLevel);
[+] 	ASSERT(thread && !thread->m_waitRegionLevel && thread->m_noCollectRegionLevel);
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 	ASSERT (isMutatorThread);
[+] 	ASSERT(isMutatorThread);
[-] 	JNC_TRACE_GC_REGION ("GcHeap::leaveNoCollectRegion (%d) (tid = %x)\n", canCollectNow, (uint_t) sys::getCurrentThreadId ());
[+] 	JNC_TRACE_GC_REGION("GcHeap::leaveNoCollectRegion (%d) (tid = %x)\n", canCollectNow, (uint_t) sys::getCurrentThreadId ());
[-] 	if (canCollectNow && isCollectionTriggered_l ())
[+] 	if (canCollectNow && isCollectionTriggered_l())
[-] 		collect_l (isMutatorThread);
[+] 		collect_l(isMutatorThread);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] GcHeap::safePoint ()
[+] GcHeap::safePoint()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread && thread->m_waitRegionLevel == 0); // otherwise we may finish handshake prematurely
[+] 	ASSERT(thread && thread->m_waitRegionLevel == 0); // otherwise we may finish handshake prematurely
[-] 		sys::atomicXchg ((volatile int32_t*) m_guardPage.p (), 0); // we need a fence, hence atomicXchg
[+] 		sys::atomicXchg((volatile int32_t*) m_guardPage.p(), 0); // we need a fence, hence atomicXchg
[-] 		parkAtSafePoint (); // parkAtSafePoint will force a fence with atomicDec
[+] 		parkAtSafePoint(); // parkAtSafePoint will force a fence with atomicDec
[-] GcHeap::weakMark (Box* box)
[+] GcHeap::weakMark(Box* box)
[-] 		Box* root = (Box*) ((char*) box - box->m_rootOffset);
[+] 		Box* root = (Box*)((char*)box - box->m_rootOffset);
[-] GcHeap::markData (Box* box)
[+] GcHeap::markData(Box* box)
[-] 	weakMark (box);
[+] 	weakMark(box);
[-] 	if (!(box->m_type->getFlags () & TypeFlag_GcRoot))
[+] 	if (!(box->m_type->getFlags() & TypeFlag_GcRoot))
[-] 	ASSERT (!(box->m_flags & BoxFlag_StaticData));
[+] 	ASSERT(!(box->m_flags & BoxFlag_StaticData));
[-] 	if (box->m_type->getTypeKind () == TypeKind_Class)
[+] 	if (box->m_type->getTypeKind() == TypeKind_Class)
[-] 		addRoot (box, box->m_type);
[+] 		addRoot(box, box->m_type);
[-] 		addRoot ((DataBox*) box + 1, box->m_type);
[+] 		addRoot((DataBox*)box + 1, box->m_type);
[-] 		DynamicArrayBox* arrayBox = (DynamicArrayBox*) box;
[+] 		DynamicArrayBox* arrayBox = (DynamicArrayBox*)box;
[-] 		addRootArray (arrayBox + 1, arrayBox->m_box.m_type, arrayBox->m_count);
[+] 		addRootArray(arrayBox + 1, arrayBox->m_box.m_type, arrayBox->m_count);
[-] GcHeap::markClass (Box* box)
[+] GcHeap::markClass(Box* box)
[-] 	weakMark (box);
[+] 	weakMark(box);
[-] 	markClassFields (box);
[+] 	markClassFields(box);
[-] 	if (box->m_type->getFlags () & TypeFlag_GcRoot)
[+] 	if (box->m_type->getFlags() & TypeFlag_GcRoot)
[-] 		addRoot (box, box->m_type);
[+] 		addRoot(box, box->m_type);
[-] GcHeap::markClassFields (Box* box)
[+] GcHeap::markClassFields(Box* box)
[-] 	ASSERT (box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(box->m_type->getTypeKind() == TypeKind_Class);
[-] 	char* p0 = (char*) (box + 1);
[+] 	char* p0 = (char*)(box + 1);
[-] 	ct::ClassType* classType = (ct::ClassType*) box->m_type;
[+] 	ct::ClassType* classType = (ct::ClassType*)box->m_type;
[-] 	sl::Array <ct::StructField*> classMemberFieldArray = classType->getClassMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> classMemberFieldArray = classType->getClassMemberFieldArray();
[-] 	size_t count = classMemberFieldArray.getCount ();
[+] 	size_t count = classMemberFieldArray.getCount();
[-] 		ct::StructField* field = classMemberFieldArray [i];
[+] 		ct::StructField* field = classMemberFieldArray[i];
[-] 		Box* fieldBox = (Box*) (p0 + field->getOffset ());
[+] 		Box* fieldBox = (Box*)(p0 + field->getOffset());
[-] 		ASSERT (fieldBox->m_type == field->getType ());
[+] 		ASSERT(fieldBox->m_type == field->getType());
[-] 		markClassFields (fieldBox);
[+] 		markClassFields(fieldBox);
[-] GcHeap::weakMarkClosureClass (Box* box)
[+] GcHeap::weakMarkClosureClass(Box* box)
[-] 	ASSERT (!box->m_rootOffset && box->m_type->getTypeKind () == TypeKind_Class);
[+] 	ASSERT(!box->m_rootOffset && box->m_type->getTypeKind() == TypeKind_Class);
[-] 	ASSERT (isClosureClassType (box->m_type));
[+] 	ASSERT(isClosureClassType(box->m_type));
[-] 	ct::ClosureClassType* closureClassType = (ct::ClosureClassType*) box->m_type;
[+] 	ct::ClosureClassType* closureClassType = (ct::ClosureClassType*)box->m_type;
[-] 	size_t thisArgFieldIdx = closureClassType->getThisArgFieldIdx ();
[+] 	size_t thisArgFieldIdx = closureClassType->getThisArgFieldIdx();
[-] 		markClass (box);
[+] 		markClass(box);
[-] 	weakMark (box);
[+] 	weakMark(box);
[-] 	char* p0 = (char*) (box + 1);
[+] 	char* p0 = (char*)(box + 1);
[-] 	ct::StructField* thisArgField = closureClassType->getFieldByIndex (thisArgFieldIdx);
[+] 	ct::StructField* thisArgField = closureClassType->getFieldByIndex(thisArgFieldIdx);
[-] 	ASSERT (thisArgField && thisArgField->getType ()->getTypeKind () == TypeKind_ClassPtr);
[+] 	ASSERT(thisArgField && thisArgField->getType()->getTypeKind() == TypeKind_ClassPtr);
[-] 	ct::ClassPtrType* weakPtrType = ((ct::ClassPtrType*) (thisArgField->getType ()))->getWeakPtrType ();
[+] 	ct::ClassPtrType* weakPtrType = ((ct::ClassPtrType*)(thisArgField->getType()))->getWeakPtrType();
[-] 	addRoot (p0 + thisArgField->getOffset (), weakPtrType);
[+] 	addRoot(p0 + thisArgField->getOffset(), weakPtrType);
[-] 	sl::Array <ct::StructField*> gcRootFieldArray = closureClassType->getGcRootMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> gcRootFieldArray = closureClassType->getGcRootMemberFieldArray();
[-] 	size_t count = gcRootFieldArray.getCount ();
[+] 	size_t count = gcRootFieldArray.getCount();
[-] 		ct::StructField* field = gcRootFieldArray [i];
[+] 		ct::StructField* field = gcRootFieldArray[i];
[-] 			addRoot (p0 + field->getOffset (), field->getType ());
[+] 			addRoot(p0 + field->getOffset(), field->getType());
[-] GcHeap::addRoot (
[+] GcHeap::addRoot(
[-] 	ASSERT (m_state == State_Mark && p);
[+] 	ASSERT(m_state == State_Mark && p);
[-] 	if (type->getFlags () & TypeFlag_GcRoot)
[+] 	if (type->getFlags() & TypeFlag_GcRoot)
[-] 		m_markRootArray [m_currentMarkRootArrayIdx].append (root);
[+] 		m_markRootArray[m_currentMarkRootArrayIdx].append(root);
[-] 		ASSERT (isDataPtrType (type, DataPtrTypeKind_Thin));
[+] 		ASSERT(isDataPtrType(type, DataPtrTypeKind_Thin));
[-] 		ct::Type* targetType = ((ct::DataPtrType*) type)->getTargetType ();
[+] 		ct::Type* targetType = ((ct::DataPtrType*)type)->getTargetType();
[-] 		if (targetType->getStdType () == StdType_DataPtrValidator)
[+] 		if (targetType->getStdType() == StdType_DataPtrValidator)
[-] 			DataPtrValidator* validator = (DataPtrValidator*) p;
[+] 			DataPtrValidator* validator = (DataPtrValidator*)p;
[-] 			ASSERT (validator->m_validatorBox->m_type == targetType);
[+] 			ASSERT(validator->m_validatorBox->m_type == targetType);
[-] 			weakMark (validator->m_validatorBox);
[+] 			weakMark(validator->m_validatorBox);
[-] 		else if (targetType->getTypeKind () == TypeKind_Class)
[+] 		else if (targetType->getTypeKind() == TypeKind_Class)
[-] 			Box* box = ((Box*) p) - 1;
[+] 			Box* box = ((Box*)p) - 1;
[-] 			ASSERT (box->m_type == targetType);
[+] 			ASSERT(box->m_type == targetType);
[-] 			markClass (box);
[+] 			markClass(box);
[-] 			DataBox* box = ((DataBox*) p) - 1;
[+] 			DataBox* box = ((DataBox*)p) - 1;
[-] 			ASSERT (box->m_box.m_type == targetType);
[+] 			ASSERT(box->m_box.m_type == targetType);
[-] 			markData ((Box*) box);
[+] 			markData((Box*)box);
[-] GcHeap::addRootArray (
[+] GcHeap::addRootArray(
[-] 	ASSERT (type->getTypeKind () != TypeKind_Class && (type->getFlags () & TypeFlag_GcRoot));
[+] 	ASSERT(type->getTypeKind() != TypeKind_Class && (type->getFlags() & TypeFlag_GcRoot));
[-] 	sl::Array <Root>* markRootArray = &m_markRootArray [m_currentMarkRootArrayIdx];
[+] 	sl::Array<Root>* markRootArray = &m_markRootArray[m_currentMarkRootArrayIdx];
[-] 	size_t baseCount = markRootArray->getCount ();
[+] 	size_t baseCount = markRootArray->getCount();
[-] 	markRootArray->setCount (baseCount + count);
[+] 	markRootArray->setCount(baseCount + count);
[-] 		p += type->getSize ();
[+] 		p += type->getSize();
[-] GcHeap::setFrameMap (
[+] GcHeap::setFrameMap(
[-] 	switch (op)
[+] 	switch(op)
[-] 		count = map->getGcRootCount ();
[+] 		count = map->getGcRootCount();
[-] 		ASSERT (map && count);
[+] 		ASSERT(map && count);
[-] 		indexArray = map->getGcRootIndexArray ();
[+] 		indexArray = map->getGcRootIndexArray();
[-] 			size_t j = indexArray [i];
[+] 			size_t j = indexArray[i];
[-] 			frame->m_gcRootArray [j] = NULL;
[+] 			frame->m_gcRootArray[j] = NULL;
[-] 		ASSERT (frame->m_map == map); // this assert helps catch wrongly sequenced closeScope & jumps
[+] 		ASSERT(frame->m_map == map); // this assert helps catch wrongly sequenced closeScope & jumps
[-] 		frame->m_map = map->getPrev ();
[+] 		frame->m_map = map->getPrev();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] GcHeap::collect ()
[+] GcHeap::collect()
[-] 	bool isMutatorThread = waitIdleAndLock ();
[+] 	bool isMutatorThread = waitIdleAndLock();
[-] 		collect_l (isMutatorThread);
[+] 		collect_l(isMutatorThread);
[-] 		m_lock.unlock (); // not now
[+] 		m_lock.unlock(); // not now
[-] GcHeap::stopTheWorld_l (bool isMutatorThread)
[+] GcHeap::stopTheWorld_l(bool isMutatorThread)
[-] 	size_t handshakeCount = m_mutatorThreadList.getCount () - m_waitingMutatorThreadCount;
[+] 	size_t handshakeCount = m_mutatorThreadList.getCount() - m_waitingMutatorThreadCount;
[-] 		ASSERT (handshakeCount);
[+] 		ASSERT(handshakeCount);
[-] 	JNC_TRACE_GC_COLLECT (
[+] 	JNC_TRACE_GC_COLLECT(
[-] 		(uint_t) sys::getCurrentThreadId (),
[+] 		(uint_t)sys::getCurrentThreadId(),
[-] 		m_mutatorThreadList.getCount (),
[+] 		m_mutatorThreadList.getCount(),
[-] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead ();
[+] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead();
[-] 		JNC_TRACE_GC_COLLECT ("   *** mutator (tid = %x; wait = %d)\n",
[+] 		JNC_TRACE_GC_COLLECT("   *** mutator (tid = %x; wait = %d)\n",
[-] 			(uint_t) threadIt->m_threadId,
[+] 			(uint_t)threadIt->m_threadId,
[-] 		m_idleEvent.reset ();
[+] 		m_idleEvent.reset();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_resumeEvent.reset ();
[+] 		m_resumeEvent.reset();
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 		m_idleEvent.reset ();
[+] 		m_idleEvent.reset();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 		m_resumeEvent.reset ();
[+] 		m_resumeEvent.reset();
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 		m_idleEvent.reset ();
[+] 		m_idleEvent.reset();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_guardPage.protect (PAGE_NOACCESS);
[+] 		m_guardPage.protect(PAGE_NOACCESS);
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 		m_idleEvent.reset ();
[+] 		m_idleEvent.reset();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		m_guardPage.protect (PROT_NONE);
[+] 		m_guardPage.protect(PROT_NONE);
[-] 		m_handshakeSem.wait ();
[+] 		m_handshakeSem.wait();
[-] GcHeap::resumeTheWorld (size_t handshakeCount)
[+] GcHeap::resumeTheWorld(size_t handshakeCount)
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 		m_resumeEvent.signal ();
[+] 		m_resumeEvent.signal();
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 		m_guardPage.protect (PAGE_READWRITE);
[+] 		m_guardPage.protect(PAGE_READWRITE);
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 		m_resumeEvent.signal ();
[+] 		m_resumeEvent.signal();
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 		m_guardPage.protect (PROT_READ | PROT_WRITE);
[+] 		m_guardPage.protect(PROT_READ | PROT_WRITE);
[-] 		sys::atomicXchg (&m_handshakeCount, handshakeCount);
[+] 		sys::atomicXchg(&m_handshakeCount, handshakeCount);
[-] 			MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead ();
[+] 			MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead();
[-] 					::pthread_kill ((pthread_t) threadIt->m_threadId, SIGUSR1); // resume
[+] 					::pthread_kill((pthread_t)threadIt->m_threadId, SIGUSR1); // resume
[-] 			result = m_handshakeSem.wait (200); // wait just a bit and retry sending signal
[+] 			result = m_handshakeSem.wait(200); // wait just a bit and retry sending signal
[-] GcHeap::collect_l (bool isMutatorThread)
[+] GcHeap::collect_l(bool isMutatorThread)
[-] 	ASSERT (!m_noCollectMutatorThreadCount && m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount ());
[+] 	ASSERT(!m_noCollectMutatorThreadCount && m_waitingMutatorThreadCount <= m_mutatorThreadList.getCount());
[-] 	m_stats.m_lastCollectTime = sys::getTimestamp ();
[+] 	m_stats.m_lastCollectTime = sys::getTimestamp();
[-] 	size_t handshakeCount = stopTheWorld_l (isMutatorThread);
[+] 	size_t handshakeCount = stopTheWorld_l(isMutatorThread);
[-] 	JNC_TRACE_GC_COLLECT ("   ... GcHeap::collect_l () -- the world is stopped\n");
[+] 	JNC_TRACE_GC_COLLECT("   ... GcHeap::collect_l () -- the world is stopped\n");
[-] 	m_markRootArray [0].clear ();
[+] 	m_markRootArray[0].clear();
[-] 	size_t count = m_allocBoxArray.getCount ();
[+] 	size_t count = m_allocBoxArray.getCount();
[-] 		m_allocBoxArray [i]->m_flags &= ~BoxFlag_MarkMask;
[+] 		m_allocBoxArray[i]->m_flags &= ~BoxFlag_MarkMask;
[-] 	count = m_classBoxArray.getCount ();
[+] 	count = m_classBoxArray.getCount();
[-] 		m_classBoxArray [i]->m_flags &= ~BoxFlag_MarkMask;
[+] 		m_classBoxArray[i]->m_flags &= ~BoxFlag_MarkMask;
[-] 	count = m_staticRootArray.getCount ();
[+] 	count = m_staticRootArray.getCount();
[-] 		ASSERT (m_staticRootArray [i].m_type->getFlags () & TypeFlag_GcRoot);
[+] 		ASSERT(m_staticRootArray[i].m_type->getFlags() & TypeFlag_GcRoot);
[-] 		addRoot (
[+] 		addRoot(
[-] 			m_staticRootArray [i].m_p,
[+] 			m_staticRootArray[i].m_p,
[-] 			m_staticRootArray [i].m_type
[+] 			m_staticRootArray[i].m_type
[-] 	ct::StructType* tlsType = m_runtime->getModule ()->m_variableMgr.getTlsStructType ();
[+] 	ct::StructType* tlsType = m_runtime->getModule()->m_variableMgr.getTlsStructType();
[-] 	sl::Array <ct::StructField*> tlsRootFieldArray = tlsType->getGcRootMemberFieldArray ();
[+] 	sl::Array<ct::StructField*> tlsRootFieldArray = tlsType->getGcRootMemberFieldArray();
[-] 	size_t tlsRootFieldCount = tlsRootFieldArray.getCount ();
[+] 	size_t tlsRootFieldCount = tlsRootFieldArray.getCount();
[-] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead ();
[+] 	MutatorThreadList::Iterator threadIt = m_mutatorThreadList.getHead();
[-] 		TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (thread + 1);
[+] 		TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(thread + 1);
[-] 			addShadowStackFrame (frame);
[+] 			addShadowStackFrame(frame);
[-] 			ct::StructField* field = tlsRootFieldArray [i];
[+] 			ct::StructField* field = tlsRootFieldArray[i];
[-] 			addRoot ((char*) tlsVariableTable + field->getOffset (), field->getType ());
[+] 			addRoot((char*)tlsVariableTable + field->getOffset(), field->getType());
[-] 			weakMark (thread->m_dataPtrValidatorPoolBegin->m_validatorBox);
[+] 			weakMark(thread->m_dataPtrValidatorPoolBegin->m_validatorBox);
[-] 	runMarkCycle ();
[+] 	runMarkCycle();
[-] 	sl::HashTableIterator <Box*, IfaceHdr*> it = m_dynamicLayoutMap.getHead ();
[+] 	sl::HashTableIterator<Box*, IfaceHdr*> it = m_dynamicLayoutMap.getHead();
[-] 	sl::HashTableIterator <Box*, IfaceHdr*> nextIt;
[+] 	sl::HashTableIterator<Box*, IfaceHdr*> nextIt;
[-] 		nextIt = it.getNext ();
[+] 		nextIt = it.getNext();
[-] 		if (it->getKey ()->m_flags & BoxFlag_WeakMark)
[+] 		if (it->getKey()->m_flags & BoxFlag_WeakMark)
[-] 			markClass (it->m_value->m_box); // simple mark is enough -- DynamicLayout is a primitive opaque class
[+] 			markClass(it->m_value->m_box); // simple mark is enough -- DynamicLayout is a primitive opaque class
[-] 			m_dynamicLayoutMap.erase (it);
[+] 			m_dynamicLayoutMap.erase(it);
[-] 	JNC_TRACE_GC_COLLECT ("   ... GcHeap::collect_l () -- mark complete\n");
[+] 	JNC_TRACE_GC_COLLECT("   ... GcHeap::collect_l () -- mark complete\n");
[-] 	sl::Array <IfaceHdr*> destructArray;
[+] 	sl::Array<IfaceHdr*> destructArray;
[-] 	count = m_destructibleClassBoxArray.getCount ();
[+] 	count = m_destructibleClassBoxArray.getCount();
[-] 		Box* box = m_destructibleClassBoxArray [i];
[+] 		Box* box = m_destructibleClassBoxArray[i];
[-] 		ASSERT (!(box->m_flags & BoxFlag_Zombie) && ((ct::ClassType*) box->m_type)->getDestructor ());
[+] 		ASSERT(!(box->m_flags & BoxFlag_Zombie) && ((ct::ClassType*)box->m_type)->getDestructor());
[-] 			m_destructibleClassBoxArray [dstIdx++] = box;
[+] 			m_destructibleClassBoxArray[dstIdx++] = box;
[-] 			IfaceHdr* iface = (IfaceHdr*) (box + 1);
[+] 			IfaceHdr* iface = (IfaceHdr*)(box + 1);
[-] 			ASSERT (iface->m_box == box);
[+] 			ASSERT(iface->m_box == box);
[-] 			destructArray.append (iface);
[+] 			destructArray.append(iface);
[-] 	m_destructibleClassBoxArray.setCount (dstIdx);
[+] 	m_destructibleClassBoxArray.setCount(dstIdx);
[-] 	if (!destructArray.isEmpty ())
[+] 	if (!destructArray.isEmpty())
[-] 		m_dynamicDestructArray.append (destructArray);
[+] 		m_dynamicDestructArray.append(destructArray);
[-] 	if (!m_dynamicDestructArray.isEmpty ())
[+] 	if (!m_dynamicDestructArray.isEmpty())
[-] 		size_t count = m_dynamicDestructArray.getCount ();
[+] 		size_t count = m_dynamicDestructArray.getCount();
[-] 			ct::ClassType* classType = (ct::ClassType*) (*iface)->m_box->m_type;
[+] 			ct::ClassType* classType = (ct::ClassType*)(*iface)->m_box->m_type;
[-] 			addRoot (iface, classType->getClassPtrType ());
[+] 			addRoot(iface, classType->getClassPtrType());
[-] 		runMarkCycle ();
[+] 		runMarkCycle();
[-] 	count = m_classBoxArray.getCount ();
[+] 	count = m_classBoxArray.getCount();
[-] 		Box* box = m_classBoxArray [i];
[+] 		Box* box = m_classBoxArray[i];
[-] 			m_classBoxArray [dstIdx++] = box;
[+] 			m_classBoxArray[dstIdx++] = box;
[-] 	m_classBoxArray.setCount (dstIdx);
[+] 	m_classBoxArray.setCount(dstIdx);
[-] 	count = m_allocBoxArray.getCount ();
[+] 	count = m_allocBoxArray.getCount();
[-] 		Box* box = m_allocBoxArray [i];
[+] 		Box* box = m_allocBoxArray[i];
[-] 			m_allocBoxArray [dstIdx] = box;
[+] 			m_allocBoxArray[dstIdx] = box;
[-] 			size_t size = box->m_type->getSize ();
[+] 			size_t size = box->m_type->getSize();
[-] 				size *= ((DynamicArrayBox*) box)->m_count;
[+] 				size *= ((DynamicArrayBox*)box)->m_count;
[-] 				m_postponeFreeBoxArray.append (box);
[+] 				m_postponeFreeBoxArray.append(box);
[-] 				AXL_MEM_FREE (box);
[+] 				AXL_MEM_FREE(box);
[-] 	m_allocBoxArray.setCount (dstIdx);
[+] 	m_allocBoxArray.setCount(dstIdx);
[-] 	JNC_TRACE_GC_COLLECT ("   ... GcHeap::collect_l () -- sweep complete\n");
[+] 	JNC_TRACE_GC_COLLECT("   ... GcHeap::collect_l () -- sweep complete\n");
[-] 	resumeTheWorld (handshakeCount);
[+] 	resumeTheWorld(handshakeCount);
[-] 	JNC_TRACE_GC_COLLECT ("   ... GcHeap::collect_l () -- the world is resumed\n");
[+] 	JNC_TRACE_GC_COLLECT("   ... GcHeap::collect_l () -- the world is resumed\n");
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_stats.m_lastCollectTimeTaken = sys::getTimestamp () - m_stats.m_lastCollectTime;
[+] 	m_stats.m_lastCollectTimeTaken = sys::getTimestamp() - m_stats.m_lastCollectTime;
[-] 	m_idleEvent.signal ();
[+] 	m_idleEvent.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	JNC_TRACE_GC_COLLECT ("--- GcHeap::collect_l ()\n");
[+] 	JNC_TRACE_GC_COLLECT("--- GcHeap::collect_l ()\n");
[-] GcHeap::addShadowStackFrame (GcShadowStackFrame* frame)
[+] GcHeap::addShadowStackFrame(GcShadowStackFrame* frame)
[-] 	for (; frameMap; frameMap = frameMap->getPrev ())
[+] 	for (; frameMap; frameMap = frameMap->getPrev())
[-] 		size_t gcRootCount = frameMap->getGcRootCount ();
[+] 		size_t gcRootCount = frameMap->getGcRootCount();
[-] 		ct::GcShadowStackFrameMapKind mapKind = frameMap->getMapKind ();
[+] 		ct::GcShadowStackFrameMapKind mapKind = frameMap->getMapKind();
[-] 			Box* const* boxArray = frameMap->getBoxArray ();
[+] 			Box* const* boxArray = frameMap->getBoxArray();
[-] 				Box* box = boxArray [i];
[+] 				Box* box = boxArray[i];
[-] 				if (box->m_type->getTypeKind () == TypeKind_Class)
[+] 				if (box->m_type->getTypeKind() == TypeKind_Class)
[-] 					markClass (box);
[+] 					markClass(box);
[-] 					markData (box);
[+] 					markData(box);
[-] 			ASSERT (mapKind == ct::GcShadowStackFrameMapKind_Static);
[+] 			ASSERT(mapKind == ct::GcShadowStackFrameMapKind_Static);
[-] 			Type* const* typeArray = frameMap->getGcRootTypeArray ();
[+] 			Type* const* typeArray = frameMap->getGcRootTypeArray();
[-] 			const size_t* indexArray = frameMap->getGcRootIndexArray ();
[+] 			const size_t* indexArray = frameMap->getGcRootIndexArray();
[-] 				size_t j = indexArray [i];
[+] 				size_t j = indexArray[i];
[-] 				void* p = frame->m_gcRootArray [j];
[+] 				void* p = frame->m_gcRootArray[j];
[-] 					addRoot (p, typeArray [i]);
[+] 					addRoot(p, typeArray[i]);
[-] GcHeap::runMarkCycle ()
[+] GcHeap::runMarkCycle()
[-] 	while (!m_markRootArray [m_currentMarkRootArrayIdx].isEmpty ())
[+] 	while (!m_markRootArray[m_currentMarkRootArrayIdx].isEmpty())
[-] 		m_markRootArray [m_currentMarkRootArrayIdx].clear ();
[+] 		m_markRootArray[m_currentMarkRootArrayIdx].clear();
[-] 		size_t count = m_markRootArray [prevGcRootArrayIdx].getCount ();
[+] 		size_t count = m_markRootArray[prevGcRootArrayIdx].getCount();
[-] 			const Root* root = &m_markRootArray [prevGcRootArrayIdx] [i];
[+] 			const Root* root = &m_markRootArray[prevGcRootArrayIdx] [i];
[-] 			root->m_type->markGcRoots (root->m_p, this);
[+] 			root->m_type->markGcRoots(root->m_p, this);
[-] GcHeap::runDestructCycle_l ()
[+] GcHeap::runDestructCycle_l()
[-] 	while (!m_dynamicDestructArray.isEmpty ())
[+] 	while (!m_dynamicDestructArray.isEmpty())
[-] 		size_t i = m_dynamicDestructArray.getCount () - 1;
[+] 		size_t i = m_dynamicDestructArray.getCount() - 1;
[-] 		IfaceHdr* iface = m_dynamicDestructArray [i];
[+] 		IfaceHdr* iface = m_dynamicDestructArray[i];
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		ct::ClassType* classType = (ct::ClassType*) iface->m_box->m_type;
[+] 		ct::ClassType* classType = (ct::ClassType*)iface->m_box->m_type;
[-] 		ct::Function* destructor = classType->getDestructor ();
[+] 		ct::Function* destructor = classType->getDestructor();
[-] 		ASSERT (destructor);
[+] 		ASSERT(destructor);
[-] 		bool result = callVoidFunction (m_runtime, destructor, iface);
[+] 		bool result = callVoidFunction(m_runtime, destructor, iface);
[-] 			TRACE (
[+] 			TRACE(
[-] 				classType->m_tag.sz (),
[+] 				classType->m_tag.sz(),
[-] 				err::getLastErrorDescription ().sz ()
[+] 				err::getLastErrorDescription().sz()
[-] 		waitIdleAndLock ();
[+] 		waitIdleAndLock();
[-] 		m_dynamicDestructArray.remove (i);
[+] 		m_dynamicDestructArray.remove(i);
[-] GcHeap::destructThreadFunc ()
[+] GcHeap::destructThreadFunc()
[-] 		m_destructEvent.wait ();
[+] 		m_destructEvent.wait();
[-] 		waitIdleAndLock ();
[+] 		waitIdleAndLock();
[-] 		runDestructCycle_l ();
[+] 		runDestructCycle_l();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 		runDestructCycle_l ();
[+] 		runDestructCycle_l();
[-] 		while (!m_staticDestructorList.isEmpty ())
[+] 		while (!m_staticDestructorList.isEmpty())
[-] 			StaticDestructor* destructor = m_staticDestructorList.removeTail ();
[+] 			StaticDestructor* destructor = m_staticDestructorList.removeTail();
[-] 			m_lock.unlock ();
[+] 			m_lock.unlock();
[-] 				callFunctionImpl_s (m_runtime, (void*) destructor->m_destructFunc, &retVal, destructor->m_iface) :
[+] 				callFunctionImpl_s(m_runtime, (void*)destructor->m_destructFunc, &retVal, destructor->m_iface) :
[-] 				callFunctionImpl_s (m_runtime, (void*) destructor->m_staticDestructFunc, &retVal);
[+] 				callFunctionImpl_s(m_runtime, (void*)destructor->m_staticDestructFunc, &retVal);
[-] 			AXL_MEM_DELETE (destructor);
[+] 			AXL_MEM_DELETE(destructor);
[-] 			waitIdleAndLock ();
[+] 			waitIdleAndLock();
[-] 		m_staticRootArray.clear (); // drop roots before every collect
[+] 		m_staticRootArray.clear(); // drop roots before every collect
[-] 		collect_l (false);
[+] 		collect_l(false);
[-] 		waitIdleAndLock ();
[+] 		waitIdleAndLock();
[-] 		if (m_allocBoxArray.isEmpty ())
[+] 		if (m_allocBoxArray.isEmpty())
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] GcHeap::parkAtSafePoint ()
[+] GcHeap::parkAtSafePoint()
[-] 	GcMutatorThread* thread = getCurrentGcMutatorThread ();
[+] 	GcMutatorThread* thread = getCurrentGcMutatorThread();
[-] 	ASSERT (thread);
[+] 	ASSERT(thread);
[-] 	parkAtSafePoint (thread);
[+] 	parkAtSafePoint(thread);
[-] GcHeap::parkAtSafePoint (GcMutatorThread* thread)
[+] GcHeap::parkAtSafePoint(GcMutatorThread* thread)
[-] 	ASSERT (m_state == State_StopTheWorld); // shouldn't be here otherwise
[+] 	ASSERT(m_state == State_StopTheWorld); // shouldn't be here otherwise
[-] 	ASSERT (!thread->m_waitRegionLevel && !thread->m_isSafePoint);
[+] 	ASSERT(!thread->m_waitRegionLevel && !thread->m_isSafePoint);
[-] 	intptr_t count = sys::atomicDec (&m_handshakeCount);
[+] 	intptr_t count = sys::atomicDec(&m_handshakeCount);
[-] 	ASSERT (count >= 0);
[+] 	ASSERT(count >= 0);
[-] 		m_handshakeEvent.signal ();
[+] 		m_handshakeEvent.signal();
[-] 	m_resumeEvent.wait ();
[+] 	m_resumeEvent.wait();
[-] 	ASSERT (m_state == State_ResumeTheWorld);
[+] 	ASSERT(m_state == State_ResumeTheWorld);
[-] 	count = sys::atomicDec (&m_handshakeCount);
[+] 	count = sys::atomicDec(&m_handshakeCount);
[-] 	ASSERT (count >= 0);
[+] 	ASSERT(count >= 0);
[-] 		m_handshakeEvent.signal ();
[+] 		m_handshakeEvent.signal();
[-] 		abortThrow ();
[+] 		abortThrow();
[-] GcHeap::abortThrow ()
[+] GcHeap::abortThrow()
[-] 	err::setError ("Jancy script execution forcibly interrupted");
[+] 	err::setError("Jancy script execution forcibly interrupted");
[-] 	Runtime::dynamicThrow ();
[+] 	Runtime::dynamicThrow();
[-] 	ASSERT (false);
[+] 	ASSERT(false);
[-] GcHeap::handleGuardPageHit (GcMutatorThread* thread)
[+] GcHeap::handleGuardPageHit(GcMutatorThread* thread)
[-] 	parkAtSafePoint (thread);
[+] 	parkAtSafePoint(thread);
[-] GcHeap::handleGuardPageHit (GcMutatorThread* thread)
[+] GcHeap::handleGuardPageHit(GcMutatorThread* thread)
[-] 	ASSERT (m_state == State_StopTheWorld); // shouldn't be here otherwise
[+] 	ASSERT(m_state == State_StopTheWorld); // shouldn't be here otherwise
[-] 	ASSERT (!thread->m_waitRegionLevel && !thread->m_isSafePoint);
[+] 	ASSERT(!thread->m_waitRegionLevel && !thread->m_isSafePoint);
[-] 	intptr_t count = sys::atomicDec (&m_handshakeCount);
[+] 	intptr_t count = sys::atomicDec(&m_handshakeCount);
[-] 	ASSERT (count >= 0);
[+] 	ASSERT(count >= 0);
[-] 		m_handshakeSem.signal ();
[+] 		m_handshakeSem.signal();
[-] 		sigsuspend (&signalWaitMask);
[+] 		sigsuspend(&signalWaitMask);
[-] 	count = sys::atomicDec (&m_handshakeCount);
[+] 	count = sys::atomicDec(&m_handshakeCount);
[-] 	ASSERT (count >= 0);
[+] 	ASSERT(count >= 0);
[-] 		m_handshakeSem.signal ();
[+] 		m_handshakeSem.signal();
[-] 		abortThrow ();
[+] 		abortThrow();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_Runtime.cpp
----------------------
[-] Runtime::Runtime ()
[+] Runtime::Runtime()
[-] 	m_noThreadEvent.signal ();
[+] 	m_noThreadEvent.signal();
[-] Runtime::setStackSizeLimit (size_t sizeLimit)
[+] Runtime::setStackSizeLimit(size_t sizeLimit)
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] Runtime::startup (ct::Module* module)
[+] Runtime::startup(ct::Module* module)
[-] 	shutdown ();
[+] 	shutdown();
[-] 	m_tlsSize = module->m_variableMgr.getTlsStructType ()->getSize ();
[+] 	m_tlsSize = module->m_variableMgr.getTlsStructType()->getSize();
[-] 	m_noThreadEvent.signal ();
[+] 	m_noThreadEvent.signal();
[-] 	ct::Function* constructor = module->getConstructor ();
[+] 	ct::Function* constructor = module->getConstructor();
[-] 	ASSERT (constructor);
[+] 	ASSERT(constructor);
[-] 		m_gcHeap.startup (module) &&
[+] 		m_gcHeap.startup(module) &&
[-] 		callVoidFunction (this, constructor);
[+] 		callVoidFunction(this, constructor);
[-] Runtime::shutdown ()
[+] Runtime::shutdown()
[-] 	ASSERT (!sys::getTlsPtrSlotValue <Tls> ());
[+] 	ASSERT(!sys::getTlsPtrSlotValue<Tls> ());
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	ASSERT (m_state != State_ShuttingDown); // concurrent shutdowns?
[+] 	ASSERT(m_state != State_ShuttingDown); // concurrent shutdowns?
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_gcHeap.beginShutdown ();
[+] 	m_gcHeap.beginShutdown();
[-] 		m_gcHeap.collect ();
[+] 		m_gcHeap.collect();
[-] 		bool result = m_noThreadEvent.wait (Shutdown_WaitThreadTimeout); // wait for other threads
[+] 		bool result = m_noThreadEvent.wait(Shutdown_WaitThreadTimeout); // wait for other threads
[-] 	ASSERT (m_tlsList.isEmpty ());
[+] 	ASSERT(m_tlsList.isEmpty());
[-] 	m_gcHeap.finalizeShutdown ();
[+] 	m_gcHeap.finalizeShutdown();
[-] Runtime::abort ()
[+] Runtime::abort()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_gcHeap.abort ();
[+] 	m_gcHeap.abort();
[-] Runtime::initializeCallSite (jnc_CallSite* callSite)
[+] Runtime::initializeCallSite(jnc_CallSite* callSite)
[-] 	memset (callSite, 0, sizeof (jnc_CallSite));
[+] 	memset(callSite, 0, sizeof(jnc_CallSite));
[-] 	ASSERT (sizeof (GcShadowStackFrameMapBuffer) >= sizeof (GcShadowStackFrameMap));
[+] 	ASSERT(sizeof(GcShadowStackFrameMapBuffer) >= sizeof(GcShadowStackFrameMap));
[-] 	new (&callSite->m_gcShadowStackDynamicFrameMap) GcShadowStackFrameMap;
[+] 	new(&callSite->m_gcShadowStackDynamicFrameMap) GcShadowStackFrameMap;
[-] 	Tls* prevTls = sys::getTlsPtrSlotValue <Tls> ();
[+] 	Tls* prevTls = sys::getTlsPtrSlotValue<Tls> ();
[-] 			TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 			TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 			ASSERT (tlsVariableTable->m_gcShadowStackTop > &callSite->m_gcShadowStackDynamicFrame);
[+] 			ASSERT(tlsVariableTable->m_gcShadowStackTop > &callSite->m_gcShadowStackDynamicFrame);
[-] 			if (tlsVariableTable->m_gcShadowStackTop->m_map->getMapKind () != ct::GcShadowStackFrameMapKind_Dynamic)
[+] 			if (tlsVariableTable->m_gcShadowStackTop->m_map->getMapKind() != ct::GcShadowStackFrameMapKind_Dynamic)
[-] 	Tls* tls = AXL_MEM_NEW_EXTRA (Tls, m_tlsSize);
[+] 	Tls* tls = AXL_MEM_NEW_EXTRA(Tls, m_tlsSize);
[-] 	m_gcHeap.registerMutatorThread (&tls->m_gcMutatorThread); // register with GC heap first
[+] 	m_gcHeap.registerMutatorThread(&tls->m_gcMutatorThread); // register with GC heap first
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 	sys::setTlsPtrSlotValue <Tls> (tls);
[+] 	sys::setTlsPtrSlotValue<Tls> (tls);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	if (m_tlsList.isEmpty ())
[+] 	if (m_tlsList.isEmpty())
[-] 		m_noThreadEvent.reset ();
[+] 		m_noThreadEvent.reset();
[-] 	m_tlsList.insertTail (tls);
[+] 	m_tlsList.insertTail(tls);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Runtime::uninitializeCallSite (jnc_CallSite* callSite)
[+] Runtime::uninitializeCallSite(jnc_CallSite* callSite)
[-] 	Tls* tls = sys::getTlsPtrSlotValue <Tls> ();
[+] 	Tls* tls = sys::getTlsPtrSlotValue<Tls> ();
[-] 	ASSERT (tls && tls->m_runtime == this);
[+] 	ASSERT(tls && tls->m_runtime == this);
[-] 	ASSERT (
[+] 	ASSERT(
[-] 	ASSERT (
[+] 	ASSERT(
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		prevGcShadowStackTop->m_map->getMapKind () == ct::GcShadowStackFrameMapKind_Dynamic ||
[+] 		prevGcShadowStackTop->m_map->getMapKind() == ct::GcShadowStackFrameMapKind_Dynamic ||
[-] 	((GcShadowStackFrameMap*) &callSite->m_gcShadowStackDynamicFrameMap)->~GcShadowStackFrameMap ();
[+] 	((GcShadowStackFrameMap*) &callSite->m_gcShadowStackDynamicFrameMap)->~GcShadowStackFrameMap();
[-] 		m_gcHeap.safePoint ();
[+] 		m_gcHeap.safePoint();
[-] 	ASSERT (
[+] 	ASSERT(
[-] 	m_gcHeap.unregisterMutatorThread (&tls->m_gcMutatorThread);
[+] 	m_gcHeap.unregisterMutatorThread(&tls->m_gcMutatorThread);
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_tlsList.remove (tls);
[+] 	m_tlsList.remove(tls);
[-] 	if (m_tlsList.isEmpty ())
[+] 	if (m_tlsList.isEmpty())
[-] 		m_noThreadEvent.signal ();
[+] 		m_noThreadEvent.signal();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	sys::setTlsPtrSlotValue <Tls> (tls->m_prevTls);
[+] 	sys::setTlsPtrSlotValue<Tls> (tls->m_prevTls);
[-] 	AXL_MEM_DELETE (tls);
[+] 	AXL_MEM_DELETE(tls);
[-] Runtime::checkStackOverflow ()
[+] Runtime::checkStackOverflow()
[-] 	Tls* tls = sys::getTlsPtrSlotValue <Tls> ();
[+] 	Tls* tls = sys::getTlsPtrSlotValue<Tls> ();
[-] 	ASSERT (tls && tls->m_runtime == this);
[+] 	ASSERT(tls && tls->m_runtime == this);
[-] 	char* p = (char*) _alloca (1);
[+] 	char* p = (char*)_alloca(1);
[-] 	ASSERT ((char*) tls->m_stackEpoch >= p);
[+] 	ASSERT((char*)tls->m_stackEpoch >= p);
[-] 	size_t stackSize = (char*) tls->m_stackEpoch - p;
[+] 	size_t stackSize = (char*)tls->m_stackEpoch - p;
[-] 		err::setFormatStringError ("stack overflow (%dB)", stackSize);
[+] 		err::setFormatStringError("stack overflow (%dB)", stackSize);
[-] 		dynamicThrow ();
[+] 		dynamicThrow();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Runtime::setSjljFrame (SjljFrame* frame)
[+] Runtime::setSjljFrame(SjljFrame* frame)
[-] 	Tls* tls = rt::getCurrentThreadTls ();
[+] 	Tls* tls = rt::getCurrentThreadTls();
[-] 		TRACE ("-- WARNING: set external SJLJ frame: %p\n", frame);
[+] 		TRACE("-- WARNING: set external SJLJ frame: %p\n", frame);
[-] 		return sys::setTlsPtrSlotValue <SjljFrame> (frame);
[+] 		return sys::setTlsPtrSlotValue<SjljFrame> (frame);
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 	ASSERT (tls);
[+] 	ASSERT(tls);
[-] Runtime::dynamicThrow ()
[+] Runtime::dynamicThrow()
[-] 	Tls* tls = rt::getCurrentThreadTls ();
[+] 	Tls* tls = rt::getCurrentThreadTls();
[-] 	ASSERT (tls);
[+] 	ASSERT(tls);
[-] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*) (tls + 1);
[+] 	TlsVariableTable* tlsVariableTable = (TlsVariableTable*)(tls + 1);
[-] 		_JUMP_BUFFER* pBuffer = (_JUMP_BUFFER*) tlsVariableTable->m_sjljFrame->m_jmpBuf;
[+] 		_JUMP_BUFFER* pBuffer = (_JUMP_BUFFER*)tlsVariableTable->m_sjljFrame->m_jmpBuf;
[-] 		longjmp (tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[+] 		longjmp(tlsVariableTable->m_sjljFrame->m_jmpBuf, -1);
[-] 		SjljFrame* frame = sys::getTlsPtrSlotValue <SjljFrame> ();
[+] 		SjljFrame* frame = sys::getTlsPtrSlotValue<SjljFrame> ();
[-] 		TRACE ("-- WARNING: jump to external SJLJ frame: %p\n", frame);
[+] 		TRACE("-- WARNING: jump to external SJLJ frame: %p\n", frame);
[-] 		ASSERT (frame);
[+] 		ASSERT(frame);
[-] 		longjmp (frame->m_jmpBuf, -1);
[+] 		longjmp(frame->m_jmpBuf, -1);
[-] 	ASSERT (false);
[+] 	ASSERT(false);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_ExceptionMgr.h
----------------------
[-] 	struct sigaction m_prevSigActionTable [32]; // we will get a compile-time error if not enough
[+] 	struct sigaction m_prevSigActionTable[32]; // we will get a compile-time error if not enough
[-] 	ExceptionMgr ()
[+] 	ExceptionMgr()
[-] 		memset (m_prevSigActionTable, 0, sizeof (m_prevSigActionTable));
[+] 		memset(m_prevSigActionTable, 0, sizeof(m_prevSigActionTable));
[-] 	install ();
[+] 	install();
[-] 	signalHandler (
[+] 	signalHandler(
[-] 	signalHandler_SIGUSR (
[+] 	signalHandler_SIGUSR(
[-] 	invokePrevSignalHandler (
[+] 	invokePrevSignalHandler(
[-] 	install ();
[+] 	install();
[-] 	vectoredExceptionHandler (EXCEPTION_POINTERS* exceptionPointers);
[+] 	vectoredExceptionHandler(EXCEPTION_POINTERS* exceptionPointers);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_GcHeap.h
----------------------
[-] 	class DestructThread: public axl::sys::ThreadImpl <DestructThread>
[+] 	class DestructThread: public axl::sys::ThreadImpl<DestructThread>
[-] 		threadFunc ()
[+] 		threadFunc()
[-] 			containerof (this, GcHeap, m_destructThread)->destructThreadFunc ();
[+] 			containerof(this, GcHeap, m_destructThread)->destructThreadFunc();
[-] 	typedef sl::AuxList <GcMutatorThread, GetGcMutatorThreadLink> MutatorThreadList;
[+] 	typedef sl::AuxList<GcMutatorThread, GetGcMutatorThreadLink> MutatorThreadList;
[-] 	sl::List <StaticDestructor> m_staticDestructorList;
[+] 	sl::List<StaticDestructor> m_staticDestructorList;
[-] 	sl::Array <IfaceHdr*> m_dynamicDestructArray;
[+] 	sl::Array<IfaceHdr*> m_dynamicDestructArray;
[-] 	sl::Array <Box*> m_allocBoxArray;
[+] 	sl::Array<Box*> m_allocBoxArray;
[-] 	sl::Array <Box*> m_classBoxArray;
[+] 	sl::Array<Box*> m_classBoxArray;
[-] 	sl::Array <Box*> m_destructibleClassBoxArray;
[+] 	sl::Array<Box*> m_destructibleClassBoxArray;
[-] 	sl::Array <Box*> m_postponeFreeBoxArray;
[+] 	sl::Array<Box*> m_postponeFreeBoxArray;
[-] 	sl::Array <Root> m_staticRootArray;
[+] 	sl::Array<Root> m_staticRootArray;
[-] 	sl::Array <Root> m_markRootArray [2];
[+] 	sl::Array<Root> m_markRootArray[2];
[-] 	sl::HashTable <Box*, IfaceHdr*, sl::HashId <Box*> > m_dynamicLayoutMap;
[+] 	sl::HashTable<Box*, IfaceHdr*, sl::HashId<Box*> > m_dynamicLayoutMap;
[-] 	GcHeap ();
[+] 	GcHeap();
[-] 	~GcHeap ()
[+] 	~GcHeap()
[-] 		ASSERT (isEmpty ()); // should be collected during runtime shutdown
[+] 		ASSERT(isEmpty()); // should be collected during runtime shutdown
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_allocBoxArray.isEmpty ();
[+] 		return m_allocBoxArray.isEmpty();
[-] 	isAborted ()
[+] 	isAborted()
[-] 	getRuntime ()
[+] 	getRuntime()
[-] 	getGuardPage ()
[+] 	getGuardPage()
[-] 	tryAllocateClass (ct::ClassType* type);
[+] 	tryAllocateClass(ct::ClassType* type);
[-] 	allocateClass (ct::ClassType* type);
[+] 	allocateClass(ct::ClassType* type);
[-] 	tryAllocateData (ct::Type* type);
[+] 	tryAllocateData(ct::Type* type);
[-] 	allocateData (ct::Type* type);
[+] 	allocateData(ct::Type* type);
[-] 	tryAllocateArray (
[+] 	tryAllocateArray(
[-] 	allocateArray (
[+] 	allocateArray(
[-] 	tryAllocateBuffer (size_t size);
[+] 	tryAllocateBuffer(size_t size);
[-] 	allocateBuffer (size_t size);
[+] 	allocateBuffer(size_t size);
[-] 	createDataPtrValidator (
[+] 	createDataPtrValidator(
[-] 	getDynamicLayout (Box* box);
[+] 	getDynamicLayout(Box* box);
[-] 	resetDynamicLayout (Box* box);
[+] 	resetDynamicLayout(Box* box);
[-] 	getStats (GcStats* stats);
[+] 	getStats(GcStats* stats);
[-] 	getSizeTriggers (GcSizeTriggers* triggers)
[+] 	getSizeTriggers(GcSizeTriggers* triggers)
[-] 	setSizeTriggers (
[+] 	setSizeTriggers(
[-] 	setSizeTriggers (const GcSizeTriggers& triggers)
[+] 	setSizeTriggers(const GcSizeTriggers& triggers)
[-] 		setSizeTriggers (triggers.m_allocSizeTrigger, triggers.m_periodSizeTrigger);
[+] 		setSizeTriggers(triggers.m_allocSizeTrigger, triggers.m_periodSizeTrigger);
[-] 	startup (ct::Module* module);
[+] 	startup(ct::Module* module);
[-] 	abort ();
[+] 	abort();
[-] 	beginShutdown ();
[+] 	beginShutdown();
[-] 	finalizeShutdown ();
[+] 	finalizeShutdown();
[-] 	registerMutatorThread (GcMutatorThread* thread);
[+] 	registerMutatorThread(GcMutatorThread* thread);
[-] 	unregisterMutatorThread (GcMutatorThread* thread);
[+] 	unregisterMutatorThread(GcMutatorThread* thread);
[-] 	addStaticRootVariables (
[+] 	addStaticRootVariables(
[-] 	addStaticRootVariables (const sl::Array <ct::Variable*>& variableArray)
[+] 	addStaticRootVariables(const sl::Array<ct::Variable*>& variableArray)
[-] 		addStaticRootVariables (variableArray, variableArray.getCount ());
[+] 		addStaticRootVariables(variableArray, variableArray.getCount());
[-] 	addStaticRoot (
[+] 	addStaticRoot(
[-] 	addStaticDestructor (StaticDestructFunc* destructFunc);
[+] 	addStaticDestructor(StaticDestructFunc* destructFunc);
[-] 	addStaticClassDestructor (
[+] 	addStaticClassDestructor(
[-] 	enterWaitRegion ();
[+] 	enterWaitRegion();
[-] 	leaveWaitRegion ();
[+] 	leaveWaitRegion();
[-] 	enterNoCollectRegion ();
[+] 	enterNoCollectRegion();
[-] 	leaveNoCollectRegion (bool canCollectNow);
[+] 	leaveNoCollectRegion(bool canCollectNow);
[-] 	safePoint ();
[+] 	safePoint();
[-] 	collect ();
[+] 	collect();
[-] 	setFrameMap (
[+] 	setFrameMap(
[-] 	weakMark (Box* box);
[+] 	weakMark(Box* box);
[-] 	markData (Box* box);
[+] 	markData(Box* box);
[-] 	markClass (Box* box);
[+] 	markClass(Box* box);
[-] 	weakMarkClosureClass (Box* box);
[+] 	weakMarkClosureClass(Box* box);
[-] 	addRoot (
[+] 	addRoot(
[-] 	addRootArray (
[+] 	addRootArray(
[-] 	handleGuardPageHit (GcMutatorThread* thread);
[+] 	handleGuardPageHit(GcMutatorThread* thread);
[-] 	addBoxIfDynamicFrame (Box* box);
[+] 	addBoxIfDynamicFrame(Box* box);
[-] 	addShadowStackFrame (GcShadowStackFrame* frame);
[+] 	addShadowStackFrame(GcShadowStackFrame* frame);
[-] 	destructThreadFunc ();
[+] 	destructThreadFunc();
[-] 	getCurrentGcMutatorThread ();
[+] 	getCurrentGcMutatorThread();
[-] 	isCollectionTriggered_l ();
[+] 	isCollectionTriggered_l();
[-] 	waitIdleAndLock (); // return true if this thread is registered mutator thread
[+] 	waitIdleAndLock(); // return true if this thread is registered mutator thread
[-] 	incrementAllocSizeAndLock (size_t size);
[+] 	incrementAllocSizeAndLock(size_t size);
[-] 	incrementAllocSize_l (size_t size);
[+] 	incrementAllocSize_l(size_t size);
[-] 	stopTheWorld_l (bool isMutatorThread);
[+] 	stopTheWorld_l(bool isMutatorThread);
[-] 	resumeTheWorld (size_t handshakeCount);
[+] 	resumeTheWorld(size_t handshakeCount);
[-] 	collect_l (bool isMutatorThread);
[+] 	collect_l(bool isMutatorThread);
[-] 	addClassBox_l (Box* box);
[+] 	addClassBox_l(Box* box);
[-] 	addBaseTypeClassFieldBoxes_l (
[+] 	addBaseTypeClassFieldBoxes_l(
[-] 	addClassFieldBoxes_l (
[+] 	addClassFieldBoxes_l(
[-] 	addStaticClassDestructor_l (
[+] 	addStaticClassDestructor_l(
[-] 	addStaticBaseTypeClassFieldDestructors_l (
[+] 	addStaticBaseTypeClassFieldDestructors_l(
[-] 	addStaticClassFieldDestructors_l (
[+] 	addStaticClassFieldDestructors_l(
[-] 	markClassFields (Box* box);
[+] 	markClassFields(Box* box);
[-] 	runMarkCycle ();
[+] 	runMarkCycle();
[-] 	runDestructCycle_l ();
[+] 	runDestructCycle_l();
[-] 	parkAtSafePoint (GcMutatorThread* thread);
[+] 	parkAtSafePoint(GcMutatorThread* thread);
[-] 	parkAtSafePoint ();
[+] 	parkAtSafePoint();
[-] 	abortThrow ();
[+] 	abortThrow();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_rt\jnc_rt_Runtime.h
----------------------
[-] 	sl::List <Tls, GetTlsLink> m_tlsList;
[+] 	sl::List<Tls, GetTlsLink> m_tlsList;
[-] 	Runtime ();
[+] 	Runtime();
[-] 	~Runtime ()
[+] 	~Runtime()
[-] 		shutdown ();
[+] 		shutdown();
[-] 	getModule ()
[+] 	getModule()
[-] 	getGcHeap ()
[+] 	getGcHeap()
[-] 	isAborted ()
[+] 	isAborted()
[-] 		return m_gcHeap.isAborted ();
[+] 		return m_gcHeap.isAborted();
[-] 	getStackSizeLimit ()
[+] 	getStackSizeLimit()
[-] 	setStackSizeLimit (size_t sizeLimit);
[+] 	setStackSizeLimit(size_t sizeLimit);
[-] 	startup (ct::Module* module);
[+] 	startup(ct::Module* module);
[-] 	shutdown ();
[+] 	shutdown();
[-] 	abort ();
[+] 	abort();
[-] 	initializeCallSite (jnc_CallSite* callSite);
[+] 	initializeCallSite(jnc_CallSite* callSite);
[-] 	uninitializeCallSite (jnc_CallSite* callSite);
[+] 	uninitializeCallSite(jnc_CallSite* callSite);
[-] 	checkStackOverflow ();
[+] 	checkStackOverflow();
[-] 	setSjljFrame (SjljFrame* frame);
[+] 	setSjljFrame(SjljFrame* frame);
[-] 	dynamicThrow ();
[+] 	dynamicThrow();
[-] getCurrentThreadTls ()
[+] getCurrentThreadTls()
[-] 	return sys::getTlsPtrSlotValue <Tls> ();
[+] 	return sys::getTlsPtrSlotValue<Tls> ();
[-] getCurrentThreadRuntime ()
[+] getCurrentThreadRuntime()
[-] 	Tls* tls = getCurrentThreadTls ();
[+] 	Tls* tls = getCurrentThreadTls();
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc_test_abi\main.cpp
----------------------
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	printf ("Initializing...\n");
[+] 	printf("Initializing...\n");
[-] 		printf ("usage: jnc_test_abi <script.jnc>\n");
[+] 		printf("usage: jnc_test_abi <script.jnc>\n");
[-] 	sl::String sourceFileName = argv [1]; // utf16 -> utf8
[+] 	sl::String sourceFileName = argv[1]; // utf16 -> utf8
[-] 	const char* sourceFileName = argv [1];
[+] 	const char* sourceFileName = argv[1];
[-] 	g::getModule ()->setTag ("jnc_test_abi");
[+] 	g::getModule()->setTag("jnc_test_abi");
[-] 	jnc::initialize ("jnc_dll:jnc_test_abi");
[+] 	jnc::initialize("jnc_dll:jnc_test_abi");
[-] 	jnc::setErrorRouter (err::getErrorMgr ());
[+] 	jnc::setErrorRouter(err::getErrorMgr());
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	srand ((int) sys::getTimestamp ());
[+] 	srand((int)sys::getTimestamp());
[-] 	module->initialize ("jnc_module");
[+] 	module->initialize("jnc_module");
[-] 	module->addStaticLib (jnc::StdLib_getLib ());
[+] 	module->addStaticLib(jnc::StdLib_getLib());
[-] 	module->addStaticLib (TestLib_getLib ());
[+] 	module->addStaticLib(TestLib_getLib());
[-] 	printf ("Compiling...\n");
[+] 	printf("Compiling...\n");
[-] 		module->parseFile (sourceFileName) &&
[+] 		module->parseFile(sourceFileName) &&
[-] 		module->parseImports () &&
[+] 		module->parseImports() &&
[-] 		module->compile () &&
[+] 		module->compile() &&
[-] 		module->jit ();
[+] 		module->jit();
[-] 		printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Starting up runtime...\n");
[+] 	printf("Starting up runtime...\n");
[-] 	result = runtime->startup (module);
[+] 	result = runtime->startup(module);
[-] 		printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	c2jnc::testInt32 (module);
[+] 	c2jnc::testInt32(module);
[-] 	c2jnc::testInt64 (module);
[+] 	c2jnc::testInt64(module);
[-] 	c2jnc::testStruct32 (module);
[+] 	c2jnc::testStruct32(module);
[-] 	c2jnc::testStruct64 (module);
[+] 	c2jnc::testStruct64(module);
[-] 	c2jnc::testStruct128 (module);
[+] 	c2jnc::testStruct128(module);
[-] 	c2jnc::testVariant (module);
[+] 	c2jnc::testVariant(module);
[-] 	c2jnc::testFloat (module);
[+] 	c2jnc::testFloat(module);
[-] 	c2jnc::testDouble (module);
[+] 	c2jnc::testDouble(module);
[-] 	jnc2c::test (module, "jnc2c.testInt32");
[+] 	jnc2c::test(module, "jnc2c.testInt32");
[-] 	jnc2c::test (module, "jnc2c.testInt64");
[+] 	jnc2c::test(module, "jnc2c.testInt64");
[-] 	jnc2c::test (module, "jnc2c.testStruct32");
[+] 	jnc2c::test(module, "jnc2c.testStruct32");
[-] 	jnc2c::test (module, "jnc2c.testStruct64");
[+] 	jnc2c::test(module, "jnc2c.testStruct64");
[-] 	jnc2c::test (module, "jnc2c.testStruct128");
[+] 	jnc2c::test(module, "jnc2c.testStruct128");
[-] 	jnc2c::test (module, "jnc2c.testVariant");
[+] 	jnc2c::test(module, "jnc2c.testVariant");
[-] 	jnc2c::test (module, "jnc2c.testPtr");
[+] 	jnc2c::test(module, "jnc2c.testPtr");
[-] 	jnc2c::test (module, "jnc2c.testFloat");
[+] 	jnc2c::test(module, "jnc2c.testFloat");
[-] 	jnc2c::test (module, "jnc2c.testDouble");
[+] 	jnc2c::test(module, "jnc2c.testDouble");
[-] 	JNC_CALL_SITE_CATCH ()
[+] 	JNC_CALL_SITE_CATCH()
[-] 	printf ("Runtime exception caught: %s\n", err::getLastErrorDescription ().sz ());
[+] 	printf("Runtime exception caught: %s\n", err::getLastErrorDescription ().sz ());
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] 	printf ("Shutting down...\n");
[+] 	printf("Shutting down...\n");
[-] 	runtime->shutdown ();
[+] 	runtime->shutdown();
[-] 	printf ("Done.\n");
[+] 	printf("Done.\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc_test_abi\test.cpp
----------------------
[-] testInt32 (jnc::Module* module)
[+] testInt32(jnc::Module* module)
[-] 	printf ("Running c2jnc.testInt32...\n");
[+] 	printf("Running c2jnc.testInt32...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcInt32");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcInt32");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncInt32* funcPtr = (FuncInt32*) jncFunc->getMachineCode ();
[+] 	FuncInt32* funcPtr = (FuncInt32*)jncFunc->getMachineCode();
[-] 	int32_t retval = funcPtr (-1, -2, -3, -4, -5, -6, -7, -8);
[+] 	int32_t retval = funcPtr(-1, -2, -3, -4, -5, -6, -7, -8);
[-] 	ASSERT (retval == -36);
[+] 	ASSERT(retval == -36);
[-] testInt64 (jnc::Module* module)
[+] testInt64(jnc::Module* module)
[-] 	printf ("Running c2jnc.testInt64...\n");
[+] 	printf("Running c2jnc.testInt64...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcInt64");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcInt64");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncInt64* funcPtr = (FuncInt64*) jncFunc->getMachineCode ();
[+] 	FuncInt64* funcPtr = (FuncInt64*)jncFunc->getMachineCode();
[-] 	int64_t retval = funcPtr (-1, -2, -3, -4, -5, -6, -7, -8);
[+] 	int64_t retval = funcPtr(-1, -2, -3, -4, -5, -6, -7, -8);
[-] 	ASSERT (retval == -36);
[+] 	ASSERT(retval == -36);
[-] testStruct32 (jnc::Module* module)
[+] testStruct32(jnc::Module* module)
[-] 	printf ("Running c2jnc.testStruct32...\n");
[+] 	printf("Running c2jnc.testStruct32...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcStruct32");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcStruct32");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncStruct32* funcPtr = (FuncStruct32*) jncFunc->getMachineCode ();
[+] 	FuncStruct32* funcPtr = (FuncStruct32*)jncFunc->getMachineCode();
[-] 	ASSERT (retval.m_a == -36);
[+] 	ASSERT(retval.m_a == -36);
[-] testStruct64 (jnc::Module* module)
[+] testStruct64(jnc::Module* module)
[-] 	printf ("Running c2jnc.testStruct64...\n");
[+] 	printf("Running c2jnc.testStruct64...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcStruct64");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcStruct64");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncStruct64* funcPtr = (FuncStruct64*) jncFunc->getMachineCode ();
[+] 	FuncStruct64* funcPtr = (FuncStruct64*)jncFunc->getMachineCode();
[-] 	struct64 retval = funcPtr (s1, s2, s3, s4, s5, s6, s7, s8);
[+] 	struct64 retval = funcPtr(s1, s2, s3, s4, s5, s6, s7, s8);
[-] 	ASSERT (retval.m_a == -36);
[+] 	ASSERT(retval.m_a == -36);
[-] testStruct128 (jnc::Module* module)
[+] testStruct128(jnc::Module* module)
[-] 	printf ("Running c2jnc.testStruct128...\n");
[+] 	printf("Running c2jnc.testStruct128...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcStruct128");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcStruct128");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncStruct128* funcPtr = (FuncStruct128*) jncFunc->getMachineCode ();
[+] 	FuncStruct128* funcPtr = (FuncStruct128*)jncFunc->getMachineCode();
[-] 	struct128 retval = funcPtr (s1, s2, s3, s4);
[+] 	struct128 retval = funcPtr(s1, s2, s3, s4);
[-] 	ASSERT (retval.m_a == -16 && retval.m_b == -20);
[+] 	ASSERT(retval.m_a == -16 && retval.m_b == -20);
[-] testVariant (jnc::Module* module)
[+] testVariant(jnc::Module* module)
[-] 	printf ("Running c2jnc.testVariant...\n");
[+] 	printf("Running c2jnc.testVariant...\n");
[-] 	jnc::Type* type = module->getPrimitiveType (jnc::TypeKind_Int);
[+] 	jnc::Type* type = module->getPrimitiveType(jnc::TypeKind_Int);
[-] 	jnc::Variant v [4] = { 0 };
[+] 	jnc::Variant v[4] = { 0 };
[-] 	v [0].m_type = type;
[+] 	v[0].m_type = type;
[-] 	v [0].m_int32 = -1;
[+] 	v[0].m_int32 = -1;
[-] 	v [1].m_type = type;
[+] 	v[1].m_type = type;
[-] 	v [1].m_int32 = -2;
[+] 	v[1].m_int32 = -2;
[-] 	v [2].m_type = type;
[+] 	v[2].m_type = type;
[-] 	v [2].m_int32 = -3;
[+] 	v[2].m_int32 = -3;
[-] 	v [3].m_type = type;
[+] 	v[3].m_type = type;
[-] 	v [3].m_int32 = -4;
[+] 	v[3].m_int32 = -4;
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcVariant");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcVariant");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncVariant* funcPtr = (FuncVariant*) jncFunc->getMachineCode ();
[+] 	FuncVariant* funcPtr = (FuncVariant*)jncFunc->getMachineCode();
[-] 	jnc::Variant retval = funcPtr (v [0], v [1], v [2], v [3]);
[+] 	jnc::Variant retval = funcPtr(v[0], v[1], v[2], v[3]);
[-] 	ASSERT (retval.m_type->getTypeKind () == jnc::TypeKind_Int && retval.m_int32 == -10);
[+] 	ASSERT(retval.m_type->getTypeKind() == jnc::TypeKind_Int && retval.m_int32 == -10);
[-] testFloat (jnc::Module* module)
[+] testFloat(jnc::Module* module)
[-] 	printf ("Running c2jnc.testFloat...\n");
[+] 	printf("Running c2jnc.testFloat...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcFloat");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcFloat");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncFloat* funcPtr = (FuncFloat*) jncFunc->getMachineCode ();
[+] 	FuncFloat* funcPtr = (FuncFloat*)jncFunc->getMachineCode();
[-] 	float retval = funcPtr (3.1415f, 2.7182f);
[+] 	float retval = funcPtr(3.1415f, 2.7182f);
[-] 	ASSERT (retval > 2.7182f && retval < 3.1415f);
[+] 	ASSERT(retval > 2.7182f && retval < 3.1415f);
[-] testDouble (jnc::Module* module)
[+] testDouble(jnc::Module* module)
[-] 	printf ("Running c2jnc.testDouble...\n");
[+] 	printf("Running c2jnc.testDouble...\n");
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction ("c2jnc.funcDouble");
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction("c2jnc.funcDouble");
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	FuncDouble* funcPtr = (FuncDouble*) jncFunc->getMachineCode ();
[+] 	FuncDouble* funcPtr = (FuncDouble*)jncFunc->getMachineCode();
[-] 	double retval = funcPtr (3.1415, 2.7182);
[+] 	double retval = funcPtr(3.1415, 2.7182);
[-] 	ASSERT (retval > 2.7182 && retval < 3.1415);
[+] 	ASSERT(retval > 2.7182 && retval < 3.1415);
[-] funcInt32 (
[+] funcInt32(
[-] 	ASSERT (a1 == -1);
[+] 	ASSERT(a1 == -1);
[-] 	ASSERT (a2 == -2);
[+] 	ASSERT(a2 == -2);
[-] 	ASSERT (a3 == -3);
[+] 	ASSERT(a3 == -3);
[-] 	ASSERT (a4 == -4);
[+] 	ASSERT(a4 == -4);
[-] 	ASSERT (a5 == -5);
[+] 	ASSERT(a5 == -5);
[-] 	ASSERT (a6 == -6);
[+] 	ASSERT(a6 == -6);
[-] 	ASSERT (a7 == -7);
[+] 	ASSERT(a7 == -7);
[-] 	ASSERT (a8 == -8);
[+] 	ASSERT(a8 == -8);
[-] funcInt64 (
[+] funcInt64(
[-] 	ASSERT (a1 == -1);
[+] 	ASSERT(a1 == -1);
[-] 	ASSERT (a2 == -2);
[+] 	ASSERT(a2 == -2);
[-] 	ASSERT (a3 == -3);
[+] 	ASSERT(a3 == -3);
[-] 	ASSERT (a4 == -4);
[+] 	ASSERT(a4 == -4);
[-] 	ASSERT (a5 == -5);
[+] 	ASSERT(a5 == -5);
[-] 	ASSERT (a6 == -6);
[+] 	ASSERT(a6 == -6);
[-] 	ASSERT (a7 == -7);
[+] 	ASSERT(a7 == -7);
[-] 	ASSERT (a8 == -8);
[+] 	ASSERT(a8 == -8);
[-] funcStruct32 (
[+] funcStruct32(
[-] 	ASSERT (s1.m_a == -1);
[+] 	ASSERT(s1.m_a == -1);
[-] 	ASSERT (s2.m_a == -2);
[+] 	ASSERT(s2.m_a == -2);
[-] 	ASSERT (s3.m_a == -3);
[+] 	ASSERT(s3.m_a == -3);
[-] 	ASSERT (s4.m_a == -4);
[+] 	ASSERT(s4.m_a == -4);
[-] 	ASSERT (s5.m_a == -5);
[+] 	ASSERT(s5.m_a == -5);
[-] 	ASSERT (s6.m_a == -6);
[+] 	ASSERT(s6.m_a == -6);
[-] 	ASSERT (s7.m_a == -7);
[+] 	ASSERT(s7.m_a == -7);
[-] 	ASSERT (s8.m_a == -8);
[+] 	ASSERT(s8.m_a == -8);
[-] funcStruct64 (
[+] funcStruct64(
[-] 	ASSERT (s1.m_a == -1);
[+] 	ASSERT(s1.m_a == -1);
[-] 	ASSERT (s2.m_a == -2);
[+] 	ASSERT(s2.m_a == -2);
[-] 	ASSERT (s3.m_a == -3);
[+] 	ASSERT(s3.m_a == -3);
[-] 	ASSERT (s4.m_a == -4);
[+] 	ASSERT(s4.m_a == -4);
[-] 	ASSERT (s5.m_a == -5);
[+] 	ASSERT(s5.m_a == -5);
[-] 	ASSERT (s6.m_a == -6);
[+] 	ASSERT(s6.m_a == -6);
[-] 	ASSERT (s7.m_a == -7);
[+] 	ASSERT(s7.m_a == -7);
[-] 	ASSERT (s8.m_a == -8);
[+] 	ASSERT(s8.m_a == -8);
[-] funcStruct128 (
[+] funcStruct128(
[-] 	ASSERT (s1.m_a == -1);
[+] 	ASSERT(s1.m_a == -1);
[-] 	ASSERT (s1.m_b == -2);
[+] 	ASSERT(s1.m_b == -2);
[-] 	ASSERT (s2.m_a == -3);
[+] 	ASSERT(s2.m_a == -3);
[-] 	ASSERT (s2.m_b == -4);
[+] 	ASSERT(s2.m_b == -4);
[-] 	ASSERT (s3.m_a == -5);
[+] 	ASSERT(s3.m_a == -5);
[-] 	ASSERT (s3.m_b == -6);
[+] 	ASSERT(s3.m_b == -6);
[-] 	ASSERT (s4.m_a == -7);
[+] 	ASSERT(s4.m_a == -7);
[-] 	ASSERT (s4.m_b == -8);
[+] 	ASSERT(s4.m_b == -8);
[-] funcVariant (
[+] funcVariant(
[-] 	ASSERT (v1.m_type->getTypeKind () == jnc::TypeKind_Int && v1.m_int32 == -1);
[+] 	ASSERT(v1.m_type->getTypeKind() == jnc::TypeKind_Int && v1.m_int32 == -1);
[-] 	ASSERT (v2.m_type->getTypeKind () == jnc::TypeKind_Int && v2.m_int32 == -2);
[+] 	ASSERT(v2.m_type->getTypeKind() == jnc::TypeKind_Int && v2.m_int32 == -2);
[-] 	ASSERT (v3.m_type->getTypeKind () == jnc::TypeKind_Int && v3.m_int32 == -3);
[+] 	ASSERT(v3.m_type->getTypeKind() == jnc::TypeKind_Int && v3.m_int32 == -3);
[-] 	ASSERT (v4.m_type->getTypeKind () == jnc::TypeKind_Int && v4.m_int32 == -4);
[+] 	ASSERT(v4.m_type->getTypeKind() == jnc::TypeKind_Int && v4.m_int32 == -4);
[-] funcPtr (
[+] funcPtr(
[-] 	ASSERT (strcmp ((char*) p1.m_p, "abc") == 0);
[+] 	ASSERT(strcmp((char*)p1.m_p, "abc") == 0);
[-] 	ASSERT (strcmp (p2, "def") == 0);
[+] 	ASSERT(strcmp(p2, "def") == 0);
[-] funcFloat (
[+] funcFloat(
[-] 	ASSERT (x > 3.1414 && x < 3.1416);
[+] 	ASSERT(x > 3.1414 && x < 3.1416);
[-] 	ASSERT (y > 2.7181 && y < 2.7183);
[+] 	ASSERT(y > 2.7181 && y < 2.7183);
[-] funcDouble (
[+] funcDouble(
[-] 	ASSERT (x > 3.1414 && x < 3.1416);
[+] 	ASSERT(x > 3.1414 && x < 3.1416);
[-] 	ASSERT (y > 2.7181 && y < 2.7183);
[+] 	ASSERT(y > 2.7181 && y < 2.7183);
[-] test (
[+] test(
[-] 	printf ("Running %s...\n", funcName);
[+] 	printf("Running %s...\n", funcName);
[-] 	jnc::Function* jncFunc = module->getGlobalNamespace ()->getNamespace ()->findFunction (funcName);
[+] 	jnc::Function* jncFunc = module->getGlobalNamespace()->getNamespace()->findFunction(funcName);
[-] 	ASSERT (jncFunc);
[+] 	ASSERT(jncFunc);
[-] 	TestFunc* funcPtr = (TestFunc*) jncFunc->getMachineCode ();
[+] 	TestFunc* funcPtr = (TestFunc*)jncFunc->getMachineCode();
[-] 	funcPtr ();
[+] 	funcPtr();
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_FUNCTION_MAP (TestLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(TestLib)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcInt32",     &jnc2c::funcInt32)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcInt32",     &jnc2c::funcInt32)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcInt64",     &jnc2c::funcInt64)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcInt64",     &jnc2c::funcInt64)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcStruct32",  &jnc2c::funcStruct32)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcStruct32",  &jnc2c::funcStruct32)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcStruct64",  &jnc2c::funcStruct64)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcStruct64",  &jnc2c::funcStruct64)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcStruct128", &jnc2c::funcStruct128)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcStruct128", &jnc2c::funcStruct128)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcVariant",   &jnc2c::funcVariant)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcVariant",   &jnc2c::funcVariant)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcPtr",       &jnc2c::funcPtr)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcPtr",       &jnc2c::funcPtr)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcFloat",     &jnc2c::funcFloat)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcFloat",     &jnc2c::funcFloat)
[-] 	JNC_MAP_FUNCTION ("jnc2c.funcDouble",    &jnc2c::funcDouble)
[+] 	JNC_MAP_FUNCTION("jnc2c.funcDouble",    &jnc2c::funcDouble)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (TestLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(TestLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (TestLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(TestLib)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc_test_abi\test.h
----------------------
[-] FuncInt32 (
[+] FuncInt32(
[-] FuncInt64 (
[+] FuncInt64(
[-] FuncStruct32 (
[+] FuncStruct32(
[-] FuncStruct64 (
[+] FuncStruct64(
[-] FuncStruct128 (
[+] FuncStruct128(
[-] FuncVariant (
[+] FuncVariant(
[-] FuncPtr (
[+] FuncPtr(
[-] FuncFloat (
[+] FuncFloat(
[-] FuncDouble (
[+] FuncDouble(
[-] TestFunc ();
[+] TestFunc();
[-] testInt32 (jnc::Module* module);
[+] testInt32(jnc::Module* module);
[-] testInt64 (jnc::Module* module);
[+] testInt64(jnc::Module* module);
[-] testStruct32 (jnc::Module* module);
[+] testStruct32(jnc::Module* module);
[-] testStruct64 (jnc::Module* module);
[+] testStruct64(jnc::Module* module);
[-] testStruct128 (jnc::Module* module);
[+] testStruct128(jnc::Module* module);
[-] testVariant (jnc::Module* module);
[+] testVariant(jnc::Module* module);
[-] testFloat (jnc::Module* module);
[+] testFloat(jnc::Module* module);
[-] testDouble (jnc::Module* module);
[+] testDouble(jnc::Module* module);
[-] test (
[+] test(
[-] JNC_DECLARE_LIB (TestLib)
[+] JNC_DECLARE_LIB(TestLib)
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\AstDoc.cpp
----------------------
[-] StdLib_printf (
[+] StdLib_printf(
[-] 	AXL_VA_DECL (va, pFormat);
[+] 	AXL_VA_DECL(va, pFormat);
[-] 	Text.Format_va (pFormat, va);
[+] 	Text.Format_va(pFormat, va);
[-] 	CMainFrame* pMainFrame = GetMainFrame ();
[+] 	CMainFrame* pMainFrame = GetMainFrame();
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace_0 (Text);
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace_0(Text);
[-] 	return Text.GetLength ();
[+] 	return Text.GetLength();
[-] 	Compile ();
[+] 	Compile();
[-] void CAstDoc::OnFileRun ()
[+] void CAstDoc::OnFileRun()
[-] 	Run ();
[+] 	Run();
[-] CAstDoc::Compile ()
[+] CAstDoc::Compile()
[-] 	DoFileSave ();
[+] 	DoFileSave();
[-] 	CMainFrame* pMainFrame = GetMainFrame ();
[+] 	CMainFrame* pMainFrame = GetMainFrame();
[-] 	rtl::CString FilePath = GetPathName ();
[+] 	rtl::CString FilePath = GetPathName();
[-] 	llvm::Module* pLlvmModule = new llvm::Module (FilePath.cc (), *pLlvmContext);
[+] 	llvm::Module* pLlvmModule = new llvm::Module(FilePath.cc(), *pLlvmContext);
[-] 	m_Module.Create (FilePath, pLlvmModule);
[+] 	m_Module.Create(FilePath, pLlvmModule);
[-] 	llvm::EngineBuilder EngineBuilder (pLlvmModule);
[+] 	llvm::EngineBuilder EngineBuilder(pLlvmModule);
[-] 	EngineBuilder.setErrorStr (&ErrorString);
[+] 	EngineBuilder.setErrorStr(&ErrorString);
[-] 	m_pLlvmExecutionEngine = EngineBuilder.create ();
[+] 	m_pLlvmExecutionEngine = EngineBuilder.create();
[-] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Error creating a JITter (%s)\n", ErrorString.c_str ());
[+] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace("Error creating a JITter (%s)\n", ErrorString.c_str ());
[-] 	jnc::CScopeThreadModule ScopeModule (&m_Module);
[+] 	jnc::CScopeThreadModule ScopeModule(&m_Module);
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Parsing...\n");
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("Parsing...\n");
[-] 	pMainFrame->m_GlobalAstPane.Clear ();
[+] 	pMainFrame->m_GlobalAstPane.Clear();
[-] 	pMainFrame->m_ModulePane.Clear ();
[+] 	pMainFrame->m_ModulePane.Clear();
[-] 	pMainFrame->m_LlvmIrPane.Clear ();
[+] 	pMainFrame->m_LlvmIrPane.Clear();
[-] 	pMainFrame->m_DasmPane.Clear ();
[+] 	pMainFrame->m_DasmPane.Clear();
[-] 	GetView ()->GetWindowTextW (SourceText_w);
[+] 	GetView()->GetWindowTextW(SourceText_w);
[-] 	Lexer.Create (
[+] 	Lexer.Create(
[-] 		SourceText.GetLength ()
[+] 		SourceText.GetLength()
[-] 	Parser.Create (jnc::CParser::StartSymbol, true);
[+] 	Parser.Create(jnc::CParser::StartSymbol, true);
[-] 		const jnc::CToken* pToken = Lexer.GetToken ();
[+] 		const jnc::CToken* pToken = Lexer.GetToken();
[-] 		Result = Parser.ParseToken (pToken);
[+] 		Result = Parser.ParseToken(pToken);
[-] 			rtl::CString Text = err::GetError ()->GetDescription ();
[+] 			rtl::CString Text = err::GetError()->GetDescription();
[-] 			pMainFrame->m_OutputPane.m_LogCtrl.Trace (
[+] 			pMainFrame->m_OutputPane.m_LogCtrl.Trace(
[-] 		Lexer.NextToken ();
[+] 		Lexer.NextToken();
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Compiling...\n");
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("Compiling...\n");
[-] 	Result = m_Module.Compile ();
[+] 	Result = m_Module.Compile();
[-] 	pMainFrame->m_GlobalAstPane.Build (Parser.GetAst ());
[+] 	pMainFrame->m_GlobalAstPane.Build(Parser.GetAst());
[-] 	pMainFrame->m_ModulePane.Build (&m_Module);
[+] 	pMainFrame->m_ModulePane.Build(&m_Module);
[-] 	pMainFrame->m_LlvmIrPane.Build (&m_Module);
[+] 	pMainFrame->m_LlvmIrPane.Build(&m_Module);
[-] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace ("%s\n", err::GetError ()->GetDescription ());
[+] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace("%s\n", err::GetError ()->GetDescription ());
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("JITting...\n");
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("JITting...\n");
[-] 	jnc::CStdLib::Export (&m_Module, m_pLlvmExecutionEngine);
[+] 	jnc::CStdLib::Export(&m_Module, m_pLlvmExecutionEngine);
[-] 	m_Module.SetFunctionPointer (m_pLlvmExecutionEngine, "printf", (void*) StdLib_printf);
[+] 	m_Module.SetFunctionPointer(m_pLlvmExecutionEngine, "printf", (void*) StdLib_printf);
[-] 	Result = m_Module.m_FunctionMgr.JitFunctions (m_pLlvmExecutionEngine);
[+] 	Result = m_Module.m_FunctionMgr.JitFunctions(m_pLlvmExecutionEngine);
[-] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace ("%s\n", err::GetError ()->GetDescription ());
[+] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace("%s\n", err::GetError ()->GetDescription ());
[-] 	pMainFrame->m_DasmPane.Build (&m_Module);
[+] 	pMainFrame->m_DasmPane.Build(&m_Module);
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Done.\n");
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("Done.\n");
[-] CAstDoc::RunFunction (
[+] CAstDoc::RunFunction(
[-] 	typedef int (*FFunction) ();
[+] 	typedef int(*FFunction) ();
[-] 	FFunction pf = (FFunction) pFunction->GetMachineCode ();
[+] 	FFunction pf = (FFunction)pFunction->GetMachineCode();
[-] 	ASSERT (pf);
[+] 	ASSERT(pf);
[-] 		int ReturnValue = pf ();
[+] 		int ReturnValue = pf();
[-] 	catch (err::CError Error)
[+] 	catch(err::CError Error)
[-] 		GetMainFrame ()->m_OutputPane.m_LogCtrl.Trace ("ERROR: %s\n", Error.GetDescription ());
[+] 		GetMainFrame()->m_OutputPane.m_LogCtrl.Trace("ERROR: %s\n", Error.GetDescription ());
[-] 	catch (...)
[+] 	catch(...)
[-] 		GetMainFrame ()->m_OutputPane.m_LogCtrl.Trace ("UNKNOWN EXCEPTION\n");
[+] 		GetMainFrame()->m_OutputPane.m_LogCtrl.Trace("UNKNOWN EXCEPTION\n");
[-] CAstDoc::Run ()
[+] CAstDoc::Run()
[-] 	CMainFrame* pMainFrame = GetMainFrame ();
[+] 	CMainFrame* pMainFrame = GetMainFrame();
[-] 	if (IsModified ())
[+] 	if (IsModified())
[-] 		Result = Compile ();
[+] 		Result = Compile();
[-] 	jnc::CFunction* pMainFunction = FindGlobalFunction ("main");
[+] 	jnc::CFunction* pMainFunction = FindGlobalFunction("main");
[-] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace ("'main' is not found or not a function\n");
[+] 		pMainFrame->m_OutputPane.m_LogCtrl.Trace("'main' is not found or not a function\n");
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Running...\n");
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("Running...\n");
[-] 	jnc::CScopeThreadRuntime ScopeRuntime (&m_Runtime);
[+] 	jnc::CScopeThreadRuntime ScopeRuntime(&m_Runtime);
[-] 	m_Runtime.Startup ();
[+] 	m_Runtime.Startup();
[-] 	jnc::CFunction* pConstructor = m_Module.GetConstructor ();
[+] 	jnc::CFunction* pConstructor = m_Module.GetConstructor();
[-] 		Result = RunFunction (pConstructor);
[+] 		Result = RunFunction(pConstructor);
[-] 	Result = RunFunction (pMainFunction);
[+] 	Result = RunFunction(pMainFunction);
[-] 	jnc::CFunction* pDestructor = m_Module.GetDestructor ();
[+] 	jnc::CFunction* pDestructor = m_Module.GetDestructor();
[-] 		Result = RunFunction (pDestructor);
[+] 		Result = RunFunction(pDestructor);
[-] 	m_Runtime.Shutdown ();
[+] 	m_Runtime.Shutdown();
[-] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace ("Done (retval = %d).\n", Result);
[+] 	pMainFrame->m_OutputPane.m_LogCtrl.Trace("Done (retval = %d).\n", Result);
[-] CAstDoc::FindGlobalFunction (const char* pName)
[+] CAstDoc::FindGlobalFunction(const char* pName)
[-] 	jnc::CModuleItem* pItem = m_Module.m_NamespaceMgr.GetGlobalNamespace ()->FindItem (pName);
[+] 	jnc::CModuleItem* pItem = m_Module.m_NamespaceMgr.GetGlobalNamespace()->FindItem(pName);
[-] 	if (pItem->GetItemKind () != jnc::EModuleItem_Function)
[+] 	if (pItem->GetItemKind() != jnc::EModuleItem_Function)
[-] 	return (jnc::CFunction*) pItem;
[+] 	return (jnc::CFunction*)pItem;
[-] 	GetView ()->SetFont (&theApp.m_Font);
[+] 	GetView()->SetFont(&theApp.m_Font);
[-] 	BOOL Result = File.Open (lpszPathName, CFile::modeRead | CFile::shareDenyWrite);
[+] 	BOOL Result = File.Open(lpszPathName, CFile::modeRead | CFile::shareDenyWrite);
[-] 	size_t Size = (size_t) File.GetLength ();
[+] 	size_t Size = (size_t)File.GetLength();
[-] 	rtl::CArrayT <char> Buffer;
[+] 	rtl::CArrayT<char> Buffer;
[-] 	Buffer.SetCount (Size + 1);
[+] 	Buffer.SetCount(Size + 1);
[-] 	Buffer [Size] = 0;
[+] 	Buffer[Size] = 0;
[-] 	File.Read (Buffer, Size);
[+] 	File.Read(Buffer, Size);
[-] 	GetView ()->SetWindowText (rtl::CString_w (Buffer));
[+] 	GetView()->SetWindowText(rtl::CString_w(Buffer));
[-] 	Compile ();
[+] 	Compile();
[-] 	BOOL Result = File.Open (lpszPathName, CFile::modeWrite | CFile::shareDenyWrite);
[+] 	BOOL Result = File.Open(lpszPathName, CFile::modeWrite | CFile::shareDenyWrite);
[-] 	GetView ()->GetWindowText (String_w);
[+] 	GetView()->GetWindowText(String_w);
[-] 	size_t Length = String.GetLength ();
[+] 	size_t Length = String.GetLength();
[-] 	File.Write (String, Length);
[+] 	File.Write(String, Length);
[-] 	File.SetLength (Length);
[+] 	File.SetLength(Length);
[-] 	CFont* pDefaultGUIFont = CFont::FromHandle((HFONT) GetStockObject(DEFAULT_GUI_FONT));
[+] 	CFont* pDefaultGUIFont = CFont::FromHandle((HFONT)GetStockObject(DEFAULT_GUI_FONT));
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\AstPane.cpp
----------------------
[-] CAstPane::Build (ref::CBufT <jnc::CParser::CAst> Ast)
[+] CAstPane::Build(ref::CBufT<jnc::CParser::CAst> Ast)
[-] 	Clear ();
[+] 	Clear();
[-] 	AddAst (NULL, Ast->GetRoot ());
[+] 	AddAst(NULL, Ast->GetRoot());
[-] CAstPane::AddAst (
[+] CAstPane::AddAst(
[-] 	rtl::CString_w SymbolName = jnc::CParser::GetSymbolName (pAstNode->m_Kind);
[+] 	rtl::CString_w SymbolName = jnc::CParser::GetSymbolName(pAstNode->m_Kind);
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (SymbolName, hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(SymbolName, hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) pAstNode);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)pAstNode);
[-] 	size_t Count = pAstNode->m_Children.GetCount ();
[+] 	size_t Count = pAstNode->m_Children.GetCount();
[-] 		jnc::CParser::CAstNode* pChild = pAstNode->m_Children [i];
[+] 		jnc::CParser::CAstNode* pChild = pAstNode->m_Children[i];
[-] 		AddAst (hItem, pChild);
[+] 		AddAst(hItem, pChild);
[-] 	m_TreeCtrl.Expand (hItem, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hItem, TVE_EXPAND);
[-] CAstPane::Clear ()
[+] CAstPane::Clear()
[-] 	m_TreeCtrl.DeleteAllItems ();
[+] 	m_TreeCtrl.DeleteAllItems();
[-] 	m_Ast.Release ();
[+] 	m_Ast.Release();
[-] 	HTREEITEM hItem = m_TreeCtrl.GetSelectedItem ();
[+] 	HTREEITEM hItem = m_TreeCtrl.GetSelectedItem();
[-] 	jnc::CParser::CAstNode* pAstNode = (jnc::CParser::CAstNode*) m_TreeCtrl.GetItemData (hItem);
[+] 	jnc::CParser::CAstNode* pAstNode = (jnc::CParser::CAstNode*)m_TreeCtrl.GetItemData(hItem);
[-] 	CEditView* pView = GetMainFrame ()->GetDocument ()->GetView ();
[+] 	CEditView* pView = GetMainFrame()->GetDocument()->GetView();
[-] 	pView->GetEditCtrl ().SetSel (
[+] 	pView->GetEditCtrl().SetSel(
[-] 		(int) pAstNode->m_FirstToken.m_Pos.m_Offset,
[+] 		(int)pAstNode->m_FirstToken.m_Pos.m_Offset,
[-] 		(int) pAstNode->m_LastToken.m_Pos.m_Offset + pAstNode->m_LastToken.m_Pos.m_Length
[+] 		(int)pAstNode->m_LastToken.m_Pos.m_Offset + pAstNode->m_LastToken.m_Pos.m_Length
[-] 	NMTVGETINFOTIP* pInfoTip = (NMTVGETINFOTIP*) pNMHDR;
[+] 	NMTVGETINFOTIP* pInfoTip = (NMTVGETINFOTIP*)pNMHDR;
[-] 	jnc::CParser::CAstNode* pAstNode = (jnc::CParser::CAstNode*) pInfoTip->lParam;
[+] 	jnc::CParser::CAstNode* pAstNode = (jnc::CParser::CAstNode*)pInfoTip->lParam;
[-] 	rtl::CString_w NodeText (
[+] 	rtl::CString_w NodeText(
[-] 	size_t CopyLength = NodeText.GetLength ();
[+] 	size_t CopyLength = NodeText.GetLength();
[-] 	if (CopyLength > (size_t) pInfoTip->cchTextMax)
[+] 	if (CopyLength > (size_t)pInfoTip->cchTextMax)
[-] 	wcsncpy (
[+] 	wcsncpy(
[-] 	pInfoTip->pszText [CopyLength] = 0;
[+] 	pInfoTip->pszText[CopyLength] = 0;
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\DasmPane.cpp
----------------------
[-] 	m_LogCtrl.SetFont (&theApp.m_Font);
[+] 	m_LogCtrl.SetFont(&theApp.m_Font);
[-] CDasmPane::Build (jnc::CModule* pModule)
[+] CDasmPane::Build(jnc::CModule* pModule)
[-] 	rtl::CIteratorT <jnc::CFunction> Function = pModule->m_FunctionMgr.GetFunctionList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CFunction> Function = pModule->m_FunctionMgr.GetFunctionList().GetHead();
[-] 		jnc::CFunctionType* pFunctionType = Function->GetType ();
[+] 		jnc::CFunctionType* pFunctionType = Function->GetType();
[-] 		m_LogCtrl.Trace (
[+] 		m_LogCtrl.Trace(
[-] 			pFunctionType->GetReturnType ()->GetTypeString (),
[+] 			pFunctionType->GetReturnType()->GetTypeString(),
[-] 			pFunctionType->GetCallConv ()->GetCallConvString (),
[+] 			pFunctionType->GetCallConv()->GetCallConvString(),
[-] 			pFunctionType->GetArgString ()
[+] 			pFunctionType->GetArgString()
[-] 		void* pf = Function->GetMachineCode ();
[+] 		void* pf = Function->GetMachineCode();
[-] 		size_t Size = Function->GetMachineCodeSize ();
[+] 		size_t Size = Function->GetMachineCodeSize();
[-] 			rtl::CString s = Dasm.Disassemble (pf, Size).cc ();
[+] 			rtl::CString s = Dasm.Disassemble(pf, Size).cc();
[-] 			m_LogCtrl.Trace ("\r\n%s", s);
[+] 			m_LogCtrl.Trace("\r\n%s", s);
[-] 		m_LogCtrl.Trace ("\r\n........................................\r\n\r\n");
[+] 		m_LogCtrl.Trace("\r\n........................................\r\n\r\n");
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\LlvmIrPane.cpp
----------------------
[-] 	m_LogCtrl.SetFont (&theApp.m_Font);
[+] 	m_LogCtrl.SetFont(&theApp.m_Font);
[-] CLlvmIrPane::Build (jnc::CModule* pModule)
[+] CLlvmIrPane::Build(jnc::CModule* pModule)
[-] 	Clear ();
[+] 	Clear();
[-] 	uint_t CommentMdKind = pModule->m_LlvmBuilder.GetCommentMdKind ();
[+] 	uint_t CommentMdKind = pModule->m_LlvmBuilder.GetCommentMdKind();
[-] 	rtl::CIteratorT <jnc::CFunction> Function = pModule->m_FunctionMgr.GetFunctionList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CFunction> Function = pModule->m_FunctionMgr.GetFunctionList().GetHead();
[-] 		jnc::CFunctionType* pFunctionType = Function->GetType ();
[+] 		jnc::CFunctionType* pFunctionType = Function->GetType();
[-] 		m_LogCtrl.Trace (
[+] 		m_LogCtrl.Trace(
[-] 			pFunctionType->GetReturnType ()->GetTypeString (),
[+] 			pFunctionType->GetReturnType()->GetTypeString(),
[-] 			pFunctionType->GetCallConv ()->GetCallConvString (),
[+] 			pFunctionType->GetCallConv()->GetCallConvString(),
[-] 			pFunctionType->GetArgString ()
[+] 			pFunctionType->GetArgString()
[-] 		llvm::Function* pLlvmFunction = Function->GetLlvmFunction ();
[+] 		llvm::Function* pLlvmFunction = Function->GetLlvmFunction();
[-] 		llvm::Function::BasicBlockListType& BlockList = pLlvmFunction->getBasicBlockList ();
[+] 		llvm::Function::BasicBlockListType& BlockList = pLlvmFunction->getBasicBlockList();
[-] 		llvm::Function::BasicBlockListType::iterator Block = BlockList.begin ();
[+] 		llvm::Function::BasicBlockListType::iterator Block = BlockList.begin();
[-] 		for (; Block != BlockList.end (); Block++)
[+] 		for (; Block != BlockList.end(); Block++)
[-] 			std::string Name = Block->getName ();
[+] 			std::string Name = Block->getName();
[-] 			m_LogCtrl.Trace ("%s\r\n", Name.c_str ());
[+] 			m_LogCtrl.Trace("%s\r\n", Name.c_str ());
[-] 			llvm::BasicBlock::InstListType& InstList = Block->getInstList ();
[+] 			llvm::BasicBlock::InstListType& InstList = Block->getInstList();
[-] 			llvm::BasicBlock::InstListType::iterator Inst = InstList.begin ();
[+] 			llvm::BasicBlock::InstListType::iterator Inst = InstList.begin();
[-] 			for (; Inst != InstList.end (); Inst++)
[+] 			for (; Inst != InstList.end(); Inst++)
[-] 				llvm::raw_string_ostream Stream (String);
[+] 				llvm::raw_string_ostream Stream(String);
[-] 				llvm::MDNode* pMdComment = pInst->getMetadata (CommentMdKind);
[+] 				llvm::MDNode* pMdComment = pInst->getMetadata(CommentMdKind);
[-] 					pInst->setMetadata (CommentMdKind, NULL); // remove before print
[+] 					pInst->setMetadata(CommentMdKind, NULL); // remove before print
[-] 				pInst->print (Stream);
[+] 				pInst->print(Stream);
[-] 				m_LogCtrl.Trace ("%s\r\n", String.c_str ());
[+] 				m_LogCtrl.Trace("%s\r\n", String.c_str ());
[-] 					pInst->setMetadata (CommentMdKind, pMdComment); // restore
[+] 					pInst->setMetadata(CommentMdKind, pMdComment); // restore
[-] 					llvm::MDString* pMdString = (llvm::MDString*) pMdComment->getOperand (0);
[+] 					llvm::MDString* pMdString = (llvm::MDString*)pMdComment->getOperand(0);
[-] 					m_LogCtrl.Trace ("\r\n; %s\r\n", pMdString->getString ().data ());
[+] 					m_LogCtrl.Trace("\r\n; %s\r\n", pMdString->getString ().data ());
[-] 		m_LogCtrl.Trace ("\r\n........................................\r\n\r\n");
[+] 		m_LogCtrl.Trace("\r\n........................................\r\n\r\n");
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\LogCtrl.cpp
----------------------
[-] CLogCtrl::Trace_va (
[+] CLogCtrl::Trace_va(
[-] 	Text.Format_va (pFormat, va);
[+] 	Text.Format_va(pFormat, va);
[-] 	Trace_0 (Text);
[+] 	Trace_0(Text);
[-] CLogCtrl::Trace_0 (const char* pText)
[+] CLogCtrl::Trace_0(const char* pText)
[-] 			Text.Append (p0, p - p0);
[+] 			Text.Append(p0, p - p0);
[-] 			Text.Append (L"\r\n");
[+] 			Text.Append(L"\r\n");
[-] 	Text.Append (p0, p - p0);
[+] 	Text.Append(p0, p - p0);
[-] 	size_t Length = GetWindowTextLength ();
[+] 	size_t Length = GetWindowTextLength();
[-] 	SetSel ((int) Length, (int) Length);
[+] 	SetSel((int)Length, (int)Length);
[-] 	ReplaceSel (Text);
[+] 	ReplaceSel(Text);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\MainFrm.cpp
----------------------
[-] 	m_GlobalAstPane.Create (L"Global AST", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_GLOBALASTPANE, Style | CBRS_LEFT);
[+] 	m_GlobalAstPane.Create(L"Global AST", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_GLOBALASTPANE, Style | CBRS_LEFT);
[-] 	m_ModulePane.Create (L"Module", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_MODULEPANE, Style | CBRS_LEFT);
[+] 	m_ModulePane.Create(L"Module", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_MODULEPANE, Style | CBRS_LEFT);
[-] 	m_LlvmIrPane.Create (L"LLVM IR", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_LLVMIRPANE, Style | CBRS_LEFT);
[+] 	m_LlvmIrPane.Create(L"LLVM IR", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_LLVMIRPANE, Style | CBRS_LEFT);
[-] 	m_DasmPane.Create (L"Disassembly", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_DASMPANE, Style | CBRS_LEFT);
[+] 	m_DasmPane.Create(L"Disassembly", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_DASMPANE, Style | CBRS_LEFT);
[-] 	m_OutputPane.Create (L"Output", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_OUTPUTPANE, Style | CBRS_LEFT);
[+] 	m_OutputPane.Create(L"Output", this, CRect (0, 0, 300, 300), TRUE, ID_VIEW_OUTPUTPANE, Style | CBRS_LEFT);
[-] 	DockPane (&m_OutputPane, AFX_IDW_DOCKBAR_BOTTOM);
[+] 	DockPane(&m_OutputPane, AFX_IDW_DOCKBAR_BOTTOM);
[-] 	DockPane (&m_GlobalAstPane, AFX_IDW_DOCKBAR_LEFT);
[+] 	DockPane(&m_GlobalAstPane, AFX_IDW_DOCKBAR_LEFT);
[-] 	DockPane (&m_ModulePane, AFX_IDW_DOCKBAR_RIGHT);
[+] 	DockPane(&m_ModulePane, AFX_IDW_DOCKBAR_RIGHT);
[-] 	m_LlvmIrPane.DockToWindow (&m_ModulePane, CBRS_ALIGN_BOTTOM);
[+] 	m_LlvmIrPane.DockToWindow(&m_ModulePane, CBRS_ALIGN_BOTTOM);
[-] 	m_DasmPane.AttachToTabWnd (&m_LlvmIrPane, DM_SHOW, FALSE);
[+] 	m_DasmPane.AttachToTabWnd(&m_LlvmIrPane, DM_SHOW, FALSE);
[-] 	switch (theApp.m_nAppLook)
[+] 	switch(theApp.m_nAppLook)
[-] 		switch (theApp.m_nAppLook)
[+] 		switch(theApp.m_nAppLook)
[-] 	m_OutputPane.m_LogCtrl.Clear ();
[+] 	m_OutputPane.m_LogCtrl.Clear();
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\ModulePane.cpp
----------------------
[-] CModulePane::Build (jnc::CModule* pModule)
[+] CModulePane::Build(jnc::CModule* pModule)
[-] 	Clear ();
[+] 	Clear();
[-] 	jnc::CGlobalNamespace* pGlobalNamespace = pModule->m_NamespaceMgr.GetGlobalNamespace ();
[+] 	jnc::CGlobalNamespace* pGlobalNamespace = pModule->m_NamespaceMgr.GetGlobalNamespace();
[-] 	AddNamespace (NULL, pGlobalNamespace);
[+] 	AddNamespace(NULL, pGlobalNamespace);
[-] CModulePane::Clear ()
[+] CModulePane::Clear()
[-] 	m_TreeCtrl.DeleteAllItems ();
[+] 	m_TreeCtrl.DeleteAllItems();
[-] CModulePane::AddItemAttributes (
[+] CModulePane::AddItemAttributes(
[-] 	jnc::CModuleItemDecl* pDecl = pItem->GetItemDecl ();
[+] 	jnc::CModuleItemDecl* pDecl = pItem->GetItemDecl();
[-] 	jnc::CAttributeBlock* pAttributeBlock = pDecl->GetAttributeBlock ();
[+] 	jnc::CAttributeBlock* pAttributeBlock = pDecl->GetAttributeBlock();
[-] 	HTREEITEM hAttributes = m_TreeCtrl.InsertItem (L"attributes", hParent);
[+] 	HTREEITEM hAttributes = m_TreeCtrl.InsertItem(L"attributes", hParent);
[-] 	rtl::CIteratorT <jnc::CAttribute> Attribute = pAttributeBlock->GetAttributeList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CAttribute> Attribute = pAttributeBlock->GetAttributeList().GetHead();
[-] 		jnc::CValue* pValue = Attribute->GetValue ();
[+] 		jnc::CValue* pValue = Attribute->GetValue();
[-] 		ItemName = Attribute->GetName ();
[+] 		ItemName = Attribute->GetName();
[-] 		HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName, hAttributes);
[+] 		HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName, hAttributes);
[-] 		m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) *Attribute);
[+] 		m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)*Attribute);
[-] 	m_TreeCtrl.Expand (hAttributes, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hAttributes, TVE_EXPAND);
[-] CModulePane::AddNamespace (
[+] CModulePane::AddNamespace(
[-] 	jnc::EModuleItem ItemKind = pNamespace->GetItemKind ();
[+] 	jnc::EModuleItem ItemKind = pNamespace->GetItemKind();
[-] 		hItem = m_TreeCtrl.InsertItem (L"scope", hParent);
[+] 		hItem = m_TreeCtrl.InsertItem(L"scope", hParent);
[-] 	else if (!pNamespace->GetParentNamespace ())
[+] 	else if (!pNamespace->GetParentNamespace())
[-] 		hItem = m_TreeCtrl.InsertItem (L"global", hParent);
[+] 		hItem = m_TreeCtrl.InsertItem(L"global", hParent);
[-] 		rtl::CString Name = rtl::CString::Format_s ("namespace %s", pNamespace->GetName ());
[+] 		rtl::CString Name = rtl::CString::Format_s("namespace %s", pNamespace->GetName ());
[-] 		hItem = m_TreeCtrl.InsertItem (Name.cc2 (), hParent);
[+] 		hItem = m_TreeCtrl.InsertItem(Name.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pNamespace);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pNamespace);
[-] 	size_t Count = pNamespace->GetItemCount ();
[+] 	size_t Count = pNamespace->GetItemCount();
[-] 		jnc::CModuleItem* pItem = pNamespace->GetItem (i);
[+] 		jnc::CModuleItem* pItem = pNamespace->GetItem(i);
[-] 		AddItem (hItem, pItem);
[+] 		AddItem(hItem, pItem);
[-] 	m_TreeCtrl.Expand (hItem, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hItem, TVE_EXPAND);
[-] CModulePane::AddItem (
[+] CModulePane::AddItem(
[-] 	jnc::EModuleItem ItemKind = pItem->GetItemKind ();
[+] 	jnc::EModuleItem ItemKind = pItem->GetItemKind();
[-] 	switch (ItemKind)
[+] 	switch(ItemKind)
[-] 		AddNamespace (hParent, (jnc::CGlobalNamespace*) pItem);
[+] 		AddNamespace(hParent, (jnc::CGlobalNamespace*)pItem);
[-] 		AddType (hParent, (jnc::CType*) pItem);
[+] 		AddType(hParent, (jnc::CType*)pItem);
[-] 		AddTypedef (hParent, (jnc::CTypedef*) pItem);
[+] 		AddTypedef(hParent, (jnc::CTypedef*)pItem);
[-] 		AddVariable (hParent, (jnc::CVariable*) pItem);
[+] 		AddVariable(hParent, (jnc::CVariable*)pItem);
[-] 		AddFunction (hParent, (jnc::CFunction*) pItem);
[+] 		AddFunction(hParent, (jnc::CFunction*)pItem);
[-] 		AddProperty (hParent, (jnc::CProperty*) pItem);
[+] 		AddProperty(hParent, (jnc::CProperty*)pItem);
[-] 		AddEnumConst (hParent, (jnc::CEnumConst*) pItem);
[+] 		AddEnumConst(hParent, (jnc::CEnumConst*)pItem);
[-] 		AddStructField (hParent, (jnc::CStructField*) pItem);
[+] 		AddStructField(hParent, (jnc::CStructField*)pItem);
[-] 		Name.Format ("item %x of kind %d", pItem, ItemKind);
[+] 		Name.Format("item %x of kind %d", pItem, ItemKind);
[-] 		HTREEITEM hItem = m_TreeCtrl.InsertItem (Name.cc2 (), hParent);
[+] 		HTREEITEM hItem = m_TreeCtrl.InsertItem(Name.cc2(), hParent);
[-] 		m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pItem);
[+] 		m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pItem);
[-] CModulePane::AddType (
[+] CModulePane::AddType(
[-] 	rtl::CString ItemName = pType->GetTypeString ();
[+] 	rtl::CString ItemName = pType->GetTypeString();
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pType);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pType);
[-] 	AddItemAttributes (hItem, pType);
[+] 	AddItemAttributes(hItem, pType);
[-] 	jnc::EType TypeKind = pType->GetTypeKind ();
[+] 	jnc::EType TypeKind = pType->GetTypeKind();
[-] 	switch (TypeKind)
[+] 	switch(TypeKind)
[-] 		AddEnumTypeMembers (hItem, (jnc::CEnumType*) pType);
[+] 		AddEnumTypeMembers(hItem, (jnc::CEnumType*)pType);
[-] 		AddStructTypeMembers (hItem, (jnc::CStructType*) pType);
[+] 		AddStructTypeMembers(hItem, (jnc::CStructType*)pType);
[-] 		AddUnionTypeMembers (hItem, (jnc::CUnionType*) pType);
[+] 		AddUnionTypeMembers(hItem, (jnc::CUnionType*)pType);
[-] 		AddClassTypeMembers (hItem, (jnc::CClassType*) pType);
[+] 		AddClassTypeMembers(hItem, (jnc::CClassType*)pType);
[-] 		AddPropertyTypeMembers (hItem, (jnc::CPropertyType*) pType);
[+] 		AddPropertyTypeMembers(hItem, (jnc::CPropertyType*)pType);
[-] CModulePane::AddEnumConst (
[+] CModulePane::AddEnumConst(
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (pMember->GetName ().cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(pMember->GetName().cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pMember);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pMember);
[-] CModulePane::AddValue (
[+] CModulePane::AddValue(
[-] 	ItemName.Format (
[+] 	ItemName.Format(
[-] 		pType->GetTypeString (),
[+] 		pType->GetTypeString(),
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pItem);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pItem);
[-] CModulePane::AddEnumTypeMembers (
[+] CModulePane::AddEnumTypeMembers(
[-] 	rtl::CIteratorT <jnc::CEnumConst> Member = pType->GetConstList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CEnumConst> Member = pType->GetConstList().GetHead();
[-] 		AddEnumConst (hParent, *Member);
[+] 		AddEnumConst(hParent, *Member);
[-] 	m_TreeCtrl.Expand (hParent, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hParent, TVE_EXPAND);
[-] CModulePane::AddStructClassTypeMembers (
[+] CModulePane::AddStructClassTypeMembers(
[-] 	size_t Count = pType->GetBaseTypeCount ();
[+] 	size_t Count = pType->GetBaseTypeCount();
[-] 		HTREEITEM hInheritanceItem = m_TreeCtrl.InsertItem ("Inheritance", hParent);
[+] 		HTREEITEM hInheritanceItem = m_TreeCtrl.InsertItem("Inheritance", hParent);
[-] 			jnc::CType* pBaseType = pType->GetBaseType (i);
[+] 			jnc::CType* pBaseType = pType->GetBaseType(i);
[-] 			ItemName = pBaseType->GetTypeString ();
[+] 			ItemName = pBaseType->GetTypeString();
[-] 			HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName, hInheritanceItem);
[+] 			HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName, hInheritanceItem);
[-] 			m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pBaseType);
[+] 			m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pBaseType);
[-] 	Count = pType->GetGenericArgumentCount ();
[+] 	Count = pType->GetGenericArgumentCount();
[-] 		HTREEITEM hGenericItem = m_TreeCtrl.InsertItem ("Generic", hParent);
[+] 		HTREEITEM hGenericItem = m_TreeCtrl.InsertItem("Generic", hParent);
[-] 			jnc::CImportType* pBaseType = pType->GetGenericArgument (i);
[+] 			jnc::CImportType* pBaseType = pType->GetGenericArgument(i);
[-] 			ItemName = pBaseType->GetTypeString ();
[+] 			ItemName = pBaseType->GetTypeString();
[-] 			HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName, hGenericItem);
[+] 			HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName, hGenericItem);
[-] 			m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pBaseType);
[+] 			m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pBaseType);
[-] CModulePane::AddStructTypeMembers (
[+] CModulePane::AddStructTypeMembers(
[-] 	rtl::CIteratorT <jnc::CStructField> Member = pType->GetFieldList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CStructField> Member = pType->GetFieldList().GetHead();
[-] 		AddStructField (hParent, *Member);
[+] 		AddStructField(hParent, *Member);
[-] 	m_TreeCtrl.Expand (hParent, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hParent, TVE_EXPAND);
[-] CModulePane::AddUnionTypeMembers (
[+] CModulePane::AddUnionTypeMembers(
[-] 	rtl::CIteratorT <jnc::CStructField> Member = pType->GetFieldList ().GetHead ();
[+] 	rtl::CIteratorT<jnc::CStructField> Member = pType->GetFieldList().GetHead();
[-] 		AddStructField (hParent, *Member);
[+] 		AddStructField(hParent, *Member);
[-] 	m_TreeCtrl.Expand (hParent, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hParent, TVE_EXPAND);
[-] CModulePane::AddClassTypeMembers (
[+] CModulePane::AddClassTypeMembers(
[-] 	size_t Count = pType->GetItemCount ();
[+] 	size_t Count = pType->GetItemCount();
[-] 		jnc::CModuleItem* pMember = pType->GetItem (i);
[+] 		jnc::CModuleItem* pMember = pType->GetItem(i);
[-] 		AddItem (hParent, pMember);
[+] 		AddItem(hParent, pMember);
[-] 	m_TreeCtrl.Expand (hParent, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hParent, TVE_EXPAND);
[-] CModulePane::AddPropertyTypeMembers (
[+] CModulePane::AddPropertyTypeMembers(
[-] 	rtl::CString ItemName = pType->GetTypeString ();
[+] 	rtl::CString ItemName = pType->GetTypeString();
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pType);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pType);
[-] 	jnc::CFunctionType* pGetterType = pType->GetGetterType ();
[+] 	jnc::CFunctionType* pGetterType = pType->GetGetterType();
[-] 	jnc::CFunctionTypeOverload* pSetterType = pType->GetSetterType ();
[+] 	jnc::CFunctionTypeOverload* pSetterType = pType->GetSetterType();
[-] 	AddType (hItem, pGetterType);
[+] 	AddType(hItem, pGetterType);
[-] 	size_t SetterOverloadCount = pSetterType->GetOverloadCount ();
[+] 	size_t SetterOverloadCount = pSetterType->GetOverloadCount();
[-] 		jnc::CFunctionType* pOverload = pSetterType->GetOverload (i);
[+] 		jnc::CFunctionType* pOverload = pSetterType->GetOverload(i);
[-] 		AddType (hItem, pOverload);
[+] 		AddType(hItem, pOverload);
[-] 	m_TreeCtrl.Expand (hItem, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hItem, TVE_EXPAND);
[-] CModulePane::AddTypedef (
[+] CModulePane::AddTypedef(
[-] 	ItemName.Format (
[+] 	ItemName.Format(
[-] 		pTypedef->GetType ()->GetTypeString (),
[+] 		pTypedef->GetType()->GetTypeString(),
[-] 		pTypedef->GetName ()
[+] 		pTypedef->GetName()
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pTypedef);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pTypedef);
[-] CModulePane::AddVariable (
[+] CModulePane::AddVariable(
[-] 	ItemName.Format (
[+] 	ItemName.Format(
[-] 		pVariable->GetType ()->GetTypeString (),
[+] 		pVariable->GetType()->GetTypeString(),
[-] 		pVariable->GetName ()
[+] 		pVariable->GetName()
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pVariable);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pVariable);
[-] CModulePane::AddFunction (
[+] CModulePane::AddFunction(
[-] 	if (!pFunction->IsOverloaded ())
[+] 	if (!pFunction->IsOverloaded())
[-] 		AddFunctionImpl (hParent, pFunction);
[+] 		AddFunctionImpl(hParent, pFunction);
[-] 		size_t Count = pFunction->GetOverloadCount ();
[+] 		size_t Count = pFunction->GetOverloadCount();
[-] 		ItemName.Format (
[+] 		ItemName.Format(
[-] 		HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 		HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 			jnc::CFunction* pOverload = pFunction->GetOverload (i);
[+] 			jnc::CFunction* pOverload = pFunction->GetOverload(i);
[-] 			AddFunctionImpl (hItem, pOverload);
[+] 			AddFunctionImpl(hItem, pOverload);
[-] 		m_TreeCtrl.Expand (hItem, TVE_EXPAND);
[+] 		m_TreeCtrl.Expand(hItem, TVE_EXPAND);
[-] CModulePane::AddFunctionImpl (
[+] CModulePane::AddFunctionImpl(
[-] 	jnc::CFunctionType* pType = pFunction->GetType ();
[+] 	jnc::CFunctionType* pType = pFunction->GetType();
[-] 	rtl::CString Name = pFunction->GetFunctionKind () == jnc::EFunction_Named ?
[+] 	rtl::CString Name = pFunction->GetFunctionKind() == jnc::EFunction_Named ?
[-] 		pFunction->GetName () :
[+] 		pFunction->GetName() :
[-] 		jnc::GetFunctionKindString (pFunction->GetFunctionKind ());
[+] 		jnc::GetFunctionKindString(pFunction->GetFunctionKind());
[-] 	ItemName.Format (
[+] 	ItemName.Format(
[-] 		pType->GetReturnType ()->GetTypeString (),
[+] 		pType->GetReturnType()->GetTypeString(),
[-] 		pFunction->GetType ()->GetArgString ()
[+] 		pFunction->GetType()->GetArgString()
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (ItemName.cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(ItemName.cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pFunction);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pFunction);
[-] CModulePane::AddProperty (
[+] CModulePane::AddProperty(
[-] 	HTREEITEM hItem = m_TreeCtrl.InsertItem (pProperty->GetName ().cc2 (), hParent);
[+] 	HTREEITEM hItem = m_TreeCtrl.InsertItem(pProperty->GetName().cc2(), hParent);
[-] 	m_TreeCtrl.SetItemData (hItem, (DWORD_PTR) (jnc::CModuleItem*) pProperty);
[+] 	m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)(jnc::CModuleItem*)pProperty);
[-] 	jnc::CFunction* pGetter = pProperty->GetGetter ();
[+] 	jnc::CFunction* pGetter = pProperty->GetGetter();
[-] 	jnc::CFunction* pSetter = pProperty->GetSetter ();
[+] 	jnc::CFunction* pSetter = pProperty->GetSetter();
[-] 	AddFunction (hItem, pGetter);
[+] 	AddFunction(hItem, pGetter);
[-] 		AddFunction (hItem, pSetter);
[+] 		AddFunction(hItem, pSetter);
[-] 	m_TreeCtrl.Expand (hItem, TVE_EXPAND);
[+] 	m_TreeCtrl.Expand(hItem, TVE_EXPAND);
[-] GetNamespaceTip (jnc::CGlobalNamespace* pNamespace)
[+] GetNamespaceTip(jnc::CGlobalNamespace* pNamespace)
[-] 	return rtl::CString::Format_s ("namespace %s", pNamespace->GetQualifiedName ());
[+] 	return rtl::CString::Format_s("namespace %s", pNamespace->GetQualifiedName ());
[-] GetVariableTip (jnc::CVariable* pVariable)
[+] GetVariableTip(jnc::CVariable* pVariable)
[-] 	jnc::CType* pType = pVariable->GetType ();
[+] 	jnc::CType* pType = pVariable->GetType();
[-] 	return rtl::CString::Format_s (
[+] 	return rtl::CString::Format_s(
[-] 		pType->GetTypeString (),
[+] 		pType->GetTypeString(),
[-] 		pVariable->GetQualifiedName (),
[+] 		pVariable->GetQualifiedName(),
[-] 		pType->GetSize ()
[+] 		pType->GetSize()
[-] GetFunctionTip (jnc::CFunction* pFunction)
[+] GetFunctionTip(jnc::CFunction* pFunction)
[-] 	jnc::CFunctionType* pType = pFunction->GetType ();
[+] 	jnc::CFunctionType* pType = pFunction->GetType();
[-] 	TipText.Format (
[+] 	TipText.Format(
[-] 		pType->GetReturnType ()->GetTypeString (),
[+] 		pType->GetReturnType()->GetTypeString(),
[-] 		pFunction->GetType ()->GetArgString ()
[+] 		pFunction->GetType()->GetArgString()
[-] 	jnc::CScope* pScope = pFunction->GetScope ();
[+] 	jnc::CScope* pScope = pFunction->GetScope();
[-] 	jnc::CToken::CPos Pos = *pScope->GetBeginPos ();
[+] 	jnc::CToken::CPos Pos = *pScope->GetBeginPos();
[-] 	jnc::CToken::CPos PosEnd = *pScope->GetEndPos ();
[+] 	jnc::CToken::CPos PosEnd = *pScope->GetEndPos();
[-] 	TipText.Append ("\n");
[+] 	TipText.Append("\n");
[-] 	TipText.Append (
[+] 	TipText.Append(
[-] GetPropertyTip (jnc::CProperty* pProperty)
[+] GetPropertyTip(jnc::CProperty* pProperty)
[-] 	jnc::CPropertyType* pType = pProperty->GetType ();
[+] 	jnc::CPropertyType* pType = pProperty->GetType();
[-] 	TipText.Format (
[+] 	TipText.Format(
[-] 		pType->GetReturnType ()->GetTypeString (),
[+] 		pType->GetReturnType()->GetTypeString(),
[-] 		pProperty->GetName ()
[+] 		pProperty->GetName()
[-] GetStructFieldTip (jnc::CStructField* pMember)
[+] GetStructFieldTip(jnc::CStructField* pMember)
[-] 	jnc::CType* pType = pMember->GetType ();
[+] 	jnc::CType* pType = pMember->GetType();
[-] 	return rtl::CString::Format_s (
[+] 	return rtl::CString::Format_s(
[-] 		pType->GetTypeString (),
[+] 		pType->GetTypeString(),
[-] 		pMember->GetParentNamespace ()->GetQualifiedName (),
[+] 		pMember->GetParentNamespace()->GetQualifiedName(),
[-] 		pMember->GetName (),
[+] 		pMember->GetName(),
[-] 		pType->GetSize ()
[+] 		pType->GetSize()
[-] GetEnumConstTip (jnc::CEnumConst* pMember)
[+] GetEnumConstTip(jnc::CEnumConst* pMember)
[-] 	rtl::CString TipText = pMember->GetName ();
[+] 	rtl::CString TipText = pMember->GetName();
[-] 	rtl::CConstBoxListT <jnc::CToken> Initializer = pMember->GetInitializer ();
[+] 	rtl::CConstBoxListT<jnc::CToken> Initializer = pMember->GetInitializer();
[-] 	if (Initializer.IsEmpty ())
[+] 	if (Initializer.IsEmpty())
[-] 	rtl::CBoxIteratorT <jnc::CToken> First = Initializer.GetHead ();
[+] 	rtl::CBoxIteratorT<jnc::CToken> First = Initializer.GetHead();
[-] 	rtl::CBoxIteratorT <jnc::CToken> Last = Initializer.GetTail ();
[+] 	rtl::CBoxIteratorT<jnc::CToken> Last = Initializer.GetTail();
[-] 	TipText.Append (" = ");
[+] 	TipText.Append(" = ");
[-] 	TipText.Append (
[+] 	TipText.Append(
[-] CModulePane::GetItemTip (jnc::CModuleItem* pItem)
[+] CModulePane::GetItemTip(jnc::CModuleItem* pItem)
[-] 	jnc::CProperty* pProperty = (jnc::CProperty*) pItem;
[+] 	jnc::CProperty* pProperty = (jnc::CProperty*)pItem;
[-] 	jnc::EModuleItem ItemKind = pItem->GetItemKind ();
[+] 	jnc::EModuleItem ItemKind = pItem->GetItemKind();
[-] 	switch (ItemKind)
[+] 	switch(ItemKind)
[-] 		return GetNamespaceTip ((jnc::CGlobalNamespace*) pItem);
[+] 		return GetNamespaceTip((jnc::CGlobalNamespace*)pItem);
[-] 		return GetVariableTip ((jnc::CVariable*) pItem);
[+] 		return GetVariableTip((jnc::CVariable*)pItem);
[-] 		return GetFunctionTip ((jnc::CFunction*) pItem);
[+] 		return GetFunctionTip((jnc::CFunction*)pItem);
[-] 		return GetPropertyTip ((jnc::CProperty*) pItem);
[+] 		return GetPropertyTip((jnc::CProperty*)pItem);
[-] 		return ((jnc::CType*) pItem)->GetTypeString ();
[+] 		return ((jnc::CType*)pItem)->GetTypeString();
[-] 		return ((jnc::CTypedef*) pItem)->GetQualifiedName ();
[+] 		return ((jnc::CTypedef*)pItem)->GetQualifiedName();
[-] 		return GetStructFieldTip ((jnc::CStructField*) pItem);
[+] 		return GetStructFieldTip((jnc::CStructField*)pItem);
[-] 		return GetEnumConstTip ((jnc::CEnumConst*) pItem);
[+] 		return GetEnumConstTip((jnc::CEnumConst*)pItem);
[-] 		return rtl::CString::Format_s ("item %x of kind %d", pItem, ItemKind);
[+] 		return rtl::CString::Format_s("item %x of kind %d", pItem, ItemKind);
[-] CModulePane::OnDblClk (NMHDR* pNMHDR, LRESULT* pResult)
[+] CModulePane::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
[-] 	HTREEITEM hItem = m_TreeCtrl.GetSelectedItem ();
[+] 	HTREEITEM hItem = m_TreeCtrl.GetSelectedItem();
[-] 	jnc::CModuleItem* pItem = (jnc::CModuleItem*) m_TreeCtrl.GetItemData (hItem);
[+] 	jnc::CModuleItem* pItem = (jnc::CModuleItem*)m_TreeCtrl.GetItemData(hItem);
[-] 	jnc::CModuleItemDecl* pDecl = pItem->GetItemDecl ();
[+] 	jnc::CModuleItemDecl* pDecl = pItem->GetItemDecl();
[-] 	CEditView* pView = GetMainFrame ()->GetDocument ()->GetView ();
[+] 	CEditView* pView = GetMainFrame()->GetDocument()->GetView();
[-] 	int Offset1 = pView->GetEditCtrl ().LineIndex (pDecl->GetPos ()->m_Line);
[+] 	int Offset1 = pView->GetEditCtrl().LineIndex(pDecl->GetPos()->m_Line);
[-] 	int Offset2 = pView->GetEditCtrl ().LineIndex (pDecl->GetPos ()->m_Line + 1);
[+] 	int Offset2 = pView->GetEditCtrl().LineIndex(pDecl->GetPos()->m_Line + 1);
[-] 	pView->GetEditCtrl ().SetSel (Offset1, Offset1);
[+] 	pView->GetEditCtrl().SetSel(Offset1, Offset1);
[-] 	pView->GetEditCtrl ().SetSel (Offset1, Offset2);
[+] 	pView->GetEditCtrl().SetSel(Offset1, Offset2);
[-] 	NMTVGETINFOTIP* pInfoTip = (NMTVGETINFOTIP*) pNMHDR;
[+] 	NMTVGETINFOTIP* pInfoTip = (NMTVGETINFOTIP*)pNMHDR;
[-] 	jnc::CModuleItem* pItem = (jnc::CModuleItem*) pInfoTip->lParam;
[+] 	jnc::CModuleItem* pItem = (jnc::CModuleItem*)pInfoTip->lParam;
[-] 	rtl::CString_w Tip = GetItemTip (pItem);
[+] 	rtl::CString_w Tip = GetItemTip(pItem);
[-] 	size_t CopyLength = Tip.GetLength ();
[+] 	size_t CopyLength = Tip.GetLength();
[-] 	if (CopyLength > (size_t) pInfoTip->cchTextMax)
[+] 	if (CopyLength > (size_t)pInfoTip->cchTextMax)
[-] 	wcsncpy (
[+] 	wcsncpy(
[-] 	pInfoTip->pszText [CopyLength] = 0;
[+] 	pInfoTip->pszText[CopyLength] = 0;
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\OutputPane.cpp
----------------------
[-] ParseFileLineString (
[+] ParseFileLineString(
[-] 	*pstrFile = CString(buffer, (int) (pLeft - buffer));
[+] 	*pstrFile = CString(buffer, (int)(pLeft - buffer));
[-] 	CString strLine(pLeft + 1, (int) (pRight - pLeft - 1));
[+] 	CString strLine(pLeft + 1, (int)(pRight - pLeft - 1));
[-] 	if (pEnd == (LPCTSTR) strLine)
[+] 	if (pEnd == (LPCTSTR)strLine)
[-] 	m_LogCtrl.SetFont (&theApp.m_Font);
[+] 	m_LogCtrl.SetFont(&theApp.m_Font);
[-] BOOL COutputPane::PreTranslateMessage (MSG* pMsg)
[+] BOOL COutputPane::PreTranslateMessage(MSG* pMsg)
[-] 	switch (pMsg->message)
[+] 	switch(pMsg->message)
[-] 		return OnLButtonDblClk ();
[+] 		return OnLButtonDblClk();
[-] 	return CDockablePane::PreTranslateMessage (pMsg);
[+] 	return CDockablePane::PreTranslateMessage(pMsg);
[-] BOOL COutputPane::OnLButtonDblClk ()
[+] BOOL COutputPane::OnLButtonDblClk()
[-] 	m_LogCtrl.GetSel (StartChar, StopChar);
[+] 	m_LogCtrl.GetSel(StartChar, StopChar);
[-] 	int Line = m_LogCtrl.LineFromChar (StartChar);
[+] 	int Line = m_LogCtrl.LineFromChar(StartChar);
[-] 	TCHAR Buffer [1024] = { 0 };
[+] 	TCHAR Buffer[1024] = { 0 };
[-] 	m_LogCtrl.GetLine (Line, Buffer, sizeof (Buffer) - 1);
[+] 	m_LogCtrl.GetLine(Line, Buffer, sizeof(Buffer) - 1);
[-] 	BOOL Result = ParseFileLineString (Buffer, &FilePath, &Line);
[+] 	BOOL Result = ParseFileLineString(Buffer, &FilePath, &Line);
[-] 	CEdit* pEditCtrl = &GetMainFrame ()->GetDocument ()->GetView ()->GetEditCtrl ();
[+] 	CEdit* pEditCtrl = &GetMainFrame()->GetDocument()->GetView()->GetEditCtrl();
[-] 	StartChar = pEditCtrl->LineIndex (Line - 1);
[+] 	StartChar = pEditCtrl->LineIndex(Line - 1);
[-] 	int Length = pEditCtrl->LineLength (StartChar);
[+] 	int Length = pEditCtrl->LineLength(StartChar);
[-] 	pEditCtrl->SetSel (StartChar, StopChar);
[+] 	pEditCtrl->SetSel(StartChar, StopChar);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\test_ast.cpp
----------------------
[-] 	m_Font.CreatePointFont (80, L"Lucida Console");
[+] 	m_Font.CreatePointFont(80, L"Lucida Console");
[-] 	g::getModule ()->setTag ("jnc_test_mfc");
[+] 	g::getModule()->setTag("jnc_test_mfc");
[-] 	llvm::InitializeNativeTarget ();
[+] 	llvm::InitializeNativeTarget();
[-] 	llvm::InitializeNativeTargetAsmParser ();
[+] 	llvm::InitializeNativeTargetAsmParser();
[-] 	llvm::InitializeNativeTargetAsmPrinter ();
[+] 	llvm::InitializeNativeTargetAsmPrinter();
[-] 	llvm::InitializeNativeTargetDisassembler ();
[+] 	llvm::InitializeNativeTargetDisassembler();
[-] 	err::CParseErrorProvider::Register ();
[+] 	err::CParseErrorProvider::Register();
[-] 	GetMainFrame ()->m_hAccelTable = LoadAccelerators (m_hInstance, MAKEINTRESOURCE (IDR_MAINFRAME));
[+] 	GetMainFrame()->m_hAccelTable = LoadAccelerators(m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\AstDoc.h
----------------------
[-] 	CEditView* GetView ()
[+] 	CEditView* GetView()
[-] 		POSITION Pos = GetFirstViewPosition ();
[+] 		POSITION Pos = GetFirstViewPosition();
[-] 		return (CEditView*) GetNextView (Pos);
[+] 		return (CEditView*)GetNextView(Pos);
[-] 	Compile ();
[+] 	Compile();
[-] 	Run ();
[+] 	Run();
[-] 	RunFunction (
[+] 	RunFunction(
[-] 	FindGlobalFunction (const char* pName);
[+] 	FindGlobalFunction(const char* pName);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\AstPane.h
----------------------
[-] 	ref::CBufT <jnc::CParser::CAst> m_Ast;
[+] 	ref::CBufT<jnc::CParser::CAst> m_Ast;
[-] 	Build (ref::CBufT <jnc::CParser::CAst> Ast);
[+] 	Build(ref::CBufT<jnc::CParser::CAst> Ast);
[-] 	Clear ();
[+] 	Clear();
[-] 	AddAst (
[+] 	AddAst(
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\DasmPane.h
----------------------
[-] 	Build (jnc::CModule* pModule);
[+] 	Build(jnc::CModule* pModule);
[-] 	Clear ()
[+] 	Clear()
[-] 		m_LogCtrl.Clear ();
[+] 		m_LogCtrl.Clear();
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\LlvmIrPane.h
----------------------
[-] 	Build (jnc::CModule* pModule);
[+] 	Build(jnc::CModule* pModule);
[-] 	Clear ()
[+] 	Clear()
[-] 		m_LogCtrl.Clear ();
[+] 		m_LogCtrl.Clear();
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\LogCtrl.h
----------------------
[-] 	Trace_0 (const char* pText);
[+] 	Trace_0(const char* pText);
[-] 	Trace (
[+] 	Trace(
[-] 		AXL_VA_DECL (va, pFormat);
[+] 		AXL_VA_DECL(va, pFormat);
[-] 		Trace_va (pFormat, va);
[+] 		Trace_va(pFormat, va);
[-] 	Trace_va (
[+] 	Trace_va(
[-] 	Clear ()
[+] 	Clear()
[-] 		SetWindowText (NULL);
[+] 		SetWindowText(NULL);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\MainFrm.h
----------------------
[-] 	CAstDoc* GetDocument ()
[+] 	CAstDoc* GetDocument()
[-] 		return (CAstDoc*) GetActiveDocument ();
[+] 		return (CAstDoc*)GetActiveDocument();
[-] GetMainFrame ()
[+] GetMainFrame()
[-] 	return (CMainFrame*) AfxGetApp ()->GetMainWnd ();
[+] 	return (CMainFrame*)AfxGetApp()->GetMainWnd();
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\ModulePane.h
----------------------
[-] 	Build (jnc::CModule* pModule);
[+] 	Build(jnc::CModule* pModule);
[-] 	Clear ();
[+] 	Clear();
[-] 	AddItemAttributes (
[+] 	AddItemAttributes(
[-] 	AddNamespace (
[+] 	AddNamespace(
[-] 	AddItem (
[+] 	AddItem(
[-] 	AddType (
[+] 	AddType(
[-] 	AddTypedef (
[+] 	AddTypedef(
[-] 	AddVariable (
[+] 	AddVariable(
[-] 	AddEnumConst (
[+] 	AddEnumConst(
[-] 	AddValue (
[+] 	AddValue(
[-] 	AddFunction (
[+] 	AddFunction(
[-] 	AddFunctionImpl (
[+] 	AddFunctionImpl(
[-] 	AddProperty (
[+] 	AddProperty(
[-] 	AddEnumTypeMembers (
[+] 	AddEnumTypeMembers(
[-] 	AddStructTypeMembers (
[+] 	AddStructTypeMembers(
[-] 	AddStructField (
[+] 	AddStructField(
[-] 		AddValue (hParent, pMember->GetName (), pMember->GetType (), pMember);
[+] 		AddValue(hParent, pMember->GetName(), pMember->GetType(), pMember);
[-] 	AddUnionTypeMembers (
[+] 	AddUnionTypeMembers(
[-] 	AddClassTypeMembers (
[+] 	AddClassTypeMembers(
[-] 	AddPropertyTypeMembers (
[+] 	AddPropertyTypeMembers(
[-] 	GetItemTip (jnc::CModuleItem* pItem);
[+] 	GetItemTip(jnc::CModuleItem* pItem);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\OutputPane.h
----------------------
[-] 	PreTranslateMessage (MSG* pMsg);
[+] 	PreTranslateMessage(MSG* pMsg);
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_mfc\pch.h
----------------------
[-] #pragma warning (disable : 4005)
[+] #pragma warning(disable : 4005)
[-] #pragma warning (default : 4005)
[+] #pragma warning(default : 4005)
[-] #pragma warning (disable: 4146)
[+] #pragma warning(disable: 4146)
[-] #pragma warning (disable: 4355)
[+] #pragma warning(disable: 4355)
[-] #pragma warning (disable: 4800)
[+] #pragma warning(disable: 4800)
[-] #pragma warning (disable: 4244)
[+] #pragma warning(disable: 4244)
[-] #pragma warning (default: 4146)
[+] #pragma warning(default: 4146)
[-] #pragma warning (default: 4355)
[+] #pragma warning(default: 4355)
[-] #pragma warning (default: 4800)
[+] #pragma warning(default: 4800)
[-] #pragma warning (default: 4244)
[+] #pragma warning(default: 4244)
[-] __declspec (selectany)
[+] __declspec(selectany)
[-] 	CClearTypeInfoCache ()
[+] 	CClearTypeInfoCache()
[-] 		atexit (ClearTypeInfoCache);
[+] 		atexit(ClearTypeInfoCache);
[-] 	ClearTypeInfoCache ()
[+] 	ClearTypeInfoCache()
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\editor.cpp
----------------------
[-] 	QFont font ("Menlo", 11);
[+] 	QFont font("Menlo", 11);
[-] 	QFont font ("Monospace", 9);
[+] 	QFont font("Monospace", 9);
[-] 	font.setFixedPitch (true);
[+] 	font.setFixedPitch(true);
[-] 	font.setKerning (false);
[+] 	font.setKerning(false);
[-] 	font.setStyleHint (
[+] 	font.setStyleHint(
[-] 		(QFont::StyleStrategy) (QFont::NoFontMerging | QFont::ForceIntegerMetrics)
[+] 		(QFont::StyleStrategy)(QFont::NoFontMerging | QFont::ForceIntegerMetrics)
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\llvmir.cpp
----------------------
[-] 	setLineWrapMode (QPlainTextEdit::NoWrap);
[+] 	setLineWrapMode(QPlainTextEdit::NoWrap);
[-] 	clear ();
[+] 	clear();
[-] 	appendText (module->getLlvmIrString_v ());
[+] 	appendText(module->getLlvmIrString_v());
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\main.cpp
----------------------
[-] int main (int argc, char* argv [])
[+] int main(int argc, char* argv[])
[-] 	WSAStartup (0x0202, &WsaData);
[+] 	WSAStartup(0x0202, &WsaData);
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	g::getModule ()->setTag ("jnc_app");
[+] 	g::getModule()->setTag("jnc_app");
[-] 	jnc::initialize ("jnc_dll:jnc_test_qt");
[+] 	jnc::initialize("jnc_dll:jnc_test_qt");
[-] 	jnc::setErrorRouter (err::getErrorMgr ());
[+] 	jnc::setErrorRouter(err::getErrorMgr());
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	io::registerUsbErrorProvider ();
[+] 	io::registerUsbErrorProvider();
[-] 	srand ((int) sys::getTimestamp ());
[+] 	srand((int)sys::getTimestamp());
[-] 	QApplication app (argc, argv);
[+] 	QApplication app(argc, argv);
[-] 	QCoreApplication::setOrganizationName ("Tibbo");
[+] 	QCoreApplication::setOrganizationName("Tibbo");
[-] 	QCoreApplication::setOrganizationDomain ("tibbo.com");
[+] 	QCoreApplication::setOrganizationDomain("tibbo.com");
[-] 	QCoreApplication::setApplicationName ("JancyEdit");
[+] 	QCoreApplication::setApplicationName("JancyEdit");
[-] 	return app.exec ();
[+] 	return app.exec();
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\mainwindow.cpp
----------------------
[-] printToOutput (
[+] printToOutput(
[-] 	fwrite (p, length, 1, stdout);
[+] 	fwrite(p, length, 1, stdout);
[-] 	return (int) getMainWindow ()->writeOutputDirect (QString::fromUtf8 ((const char*) p, length));
[+] 	return (int)getMainWindow()->writeOutputDirect(QString::fromUtf8((const char*) p, length));
[-] 	ASSERT (!g_mainWindow);
[+] 	ASSERT(!g_mainWindow);
[-] 	createMdiArea ();
[+] 	createMdiArea();
[-] 	setCentralWidget (m_mdiArea);
[+] 	setCentralWidget(m_mdiArea);
[-] 	createActions ();
[+] 	createActions();
[-] 	createMenu ();
[+] 	createMenu();
[-] 	createToolBars ();
[+] 	createToolBars();
[-] 	createPanes ();
[+] 	createPanes();
[-] 	createStatusBar ();
[+] 	createStatusBar();
[-] 	readSettings ();
[+] 	readSettings();
[-] 	connect (
[+] 	connect(
[-] 		this, SIGNAL (outputSignal ()),
[+] 		this, SIGNAL(outputSignal()),
[-] 		this, SLOT (outputSlot ()),
[+] 		this, SLOT(outputSlot()),
[-] 	jnc::StdLib_setStdIo (NULL, printToOutput, printToOutput);
[+] 	jnc::StdLib_setStdIo(NULL, printToOutput, printToOutput);
[-] 	writeSettings ();
[+] 	writeSettings();
[-] 	m_mdiArea->closeAllSubWindows ();
[+] 	m_mdiArea->closeAllSubWindows();
[-] 	if (m_mdiArea->currentSubWindow ())
[+] 	if (m_mdiArea->currentSubWindow())
[-] 	m_lastDir = QFileInfo (filePath).dir ().absolutePath ();
[+] 	m_lastDir = QFileInfo(filePath).dir().absolutePath();
[-] size_t MainWindow::writeOutputDirect (const QString& string)
[+] size_t MainWindow::writeOutputDirect(const QString& string)
[-] 	if (QApplication::instance()->thread () == QThread::currentThread () && m_outputQueue.empty ())
[+] 	if (QApplication::instance()->thread() == QThread::currentThread() && m_outputQueue.empty())
[-] 		m_output->appendString (string);
[+] 		m_output->appendString(string);
[-] 		m_output->repaint ();
[+] 		m_output->repaint();
[-] 		m_outputMutex.lock ();
[+] 		m_outputMutex.lock();
[-] 		m_outputQueue.append (string);
[+] 		m_outputQueue.append(string);
[-] 		m_outputMutex.unlock ();
[+] 		m_outputMutex.unlock();
[-] 		emit outputSignal ();
[+] 		emit outputSignal();
[-] 	return string.length ();
[+] 	return string.length();
[-] 	text.vsprintf (format, va);
[+] 	text.vsprintf(format, va);
[-] 	return writeOutputDirect (text);
[+] 	return writeOutputDirect(text);
[-] size_t MainWindow::writeOutput (const char* format, ...)
[+] size_t MainWindow::writeOutput(const char* format, ...)
[-] 	va_start (va, format);
[+] 	va_start(va, format);
[-] 	return writeOutput_va (format, va);
[+] 	return writeOutput_va(format, va);
[-] void MainWindow::outputSlot ()
[+] void MainWindow::outputSlot()
[-] 	m_outputMutex.lock ();
[+] 	m_outputMutex.lock();
[-] 	while (!m_outputQueue.empty ())
[+] 	while (!m_outputQueue.empty())
[-] 		QString string = m_outputQueue.takeFirst ();
[+] 		QString string = m_outputQueue.takeFirst();
[-] 		m_outputMutex.unlock ();
[+] 		m_outputMutex.unlock();
[-] 		m_output->appendString (string);
[+] 		m_output->appendString(string);
[-] 		m_output->repaint ();
[+] 		m_output->repaint();
[-] 		m_outputMutex.lock ();
[+] 		m_outputMutex.lock();
[-] 	m_outputMutex.unlock ();
[+] 	m_outputMutex.unlock();
[-] 	m_lastDir = s.value ("lastDir").toString ();
[+] 	m_lastDir = s.value("lastDir").toString ();
[-] 	foreach (QString file, files)
[+] 	foreach(QString file, files)
[-] 	foreach (QMdiSubWindow* subWindow, m_mdiArea->subWindowList())
[+] 	foreach(QMdiSubWindow* subWindow, m_mdiArea->subWindowList())
[-] 	s.setValue ("filesOpened", files);
[+] 	s.setValue("filesOpened", files);
[-] 	s.setValue ("lastDir", m_lastDir);
[+] 	s.setValue("lastDir", m_lastDir);
[-] 	return m_module->getGlobalNamespace()->getNamespace ()->findFunction (nameBytes.data());
[+] 	return m_module->getGlobalNamespace()->getNamespace()->findFunction(nameBytes.data());
[-] bool MainWindow::compile ()
[+] bool MainWindow::compile()
[-] 	qApp->setCursorFlashTime (0);
[+] 	qApp->setCursorFlashTime(0);
[-] 	QByteArray sourceFilePath = child->file().toUtf8 ();
[+] 	QByteArray sourceFilePath = child->file().toUtf8();
[-] 	QByteArray appDir = qApp->applicationDirPath ().toUtf8 ();
[+] 	QByteArray appDir = qApp->applicationDirPath().toUtf8();
[-] 	m_module->initialize (sourceFilePath.data(), compileFlags);
[+] 	m_module->initialize(sourceFilePath.data(), compileFlags);
[-] 	m_module->addStaticLib (jnc::StdLib_getLib ());
[+] 	m_module->addStaticLib(jnc::StdLib_getLib());
[-] 	m_module->addStaticLib (jnc::SysLib_getLib ());
[+] 	m_module->addStaticLib(jnc::SysLib_getLib());
[-] 	m_module->addStaticLib (TestLib_getLib ());
[+] 	m_module->addStaticLib(TestLib_getLib());
[-] 	m_module->addImportDir (appDir.constData ());
[+] 	m_module->addImportDir(appDir.constData());
[-] 	QString libDir = qApp->applicationDirPath () + "/../../lib/Debug";
[+] 	QString libDir = qApp->applicationDirPath() + "/../../lib/Debug";
[-] 	QString libDir = qApp->applicationDirPath () + "/../../lib/Release";
[+] 	QString libDir = qApp->applicationDirPath() + "/../../lib/Release";
[-] 	m_module->addImportDir (libDir.toUtf8 ().constData ());
[+] 	m_module->addImportDir(libDir.toUtf8().constData());
[-] 	m_modulePane->clear ();
[+] 	m_modulePane->clear();
[-] 	m_llvmIr->clear ();
[+] 	m_llvmIr->clear();
[-] 	result = m_module->parse (
[+] 	result = m_module->parse(
[-] 		sourceFilePath.constData (),
[+] 		sourceFilePath.constData(),
[-] 		source.constData (),
[+] 		source.constData(),
[-] 		source.size ()
[+] 		source.size()
[-] 		m_module->parseImports ();
[+] 		m_module->parseImports();
[-] 	result = m_module->compile ();
[+] 	result = m_module->compile();
[-] 	m_modulePane->build (m_module, child);
[+] 	m_modulePane->build(m_module, child);
[-] 	m_llvmIr->build (m_module);
[+] 	m_llvmIr->build(m_module);
[-] 	result = m_module->jit ();
[+] 	result = m_module->jit();
[-] 	writeOutput ("Done.\n");
[+] 	writeOutput("Done.\n");
[-] 	child->setCompilationNeeded (false);
[+] 	child->setCompilationNeeded(false);
[-] MainWindow::run ()
[+] MainWindow::run()
[-] 	 MdiChild* mdiChild = activeMdiChild ();
[+] 	 MdiChild* mdiChild = activeMdiChild();
[-] 	if (mdiChild->isCompilationNeeded ())
[+] 	if (mdiChild->isCompilationNeeded())
[-] 		result = compile ();
[+] 		result = compile();
[-] 	jnc::Function* mainFunction = findGlobalFunction ("main");
[+] 	jnc::Function* mainFunction = findGlobalFunction("main");
[-] 		writeOutput ("'main' is not found or not a function\n");
[+] 		writeOutput("'main' is not found or not a function\n");
[-] 	writeOutput ("Running...\n");
[+] 	writeOutput("Running...\n");
[-] 	m_runtime->getGcHeap ()->setSizeTriggers (&triggers);
[+] 	m_runtime->getGcHeap()->setSizeTriggers(&triggers);
[-] 	result = m_runtime->startup (m_module);
[+] 	result = m_runtime->startup(m_module);
[-] 		writeOutput ("Cannot startup Jancy runtime: %s\n", err::getLastErrorDescription ().sz ());
[+] 		writeOutput("Cannot startup Jancy runtime: %s\n", err::getLastErrorDescription ().sz ());
[-] 	result = jnc::callFunction (m_runtime, mainFunction, &returnValue);
[+] 	result = jnc::callFunction(m_runtime, mainFunction, &returnValue);
[-] 		writeOutput ("'main' returned %d.\n", returnValue);
[+] 		writeOutput("'main' returned %d.\n", returnValue);
[-] 		writeOutput ("Runtime error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		writeOutput("Runtime error: %s\n", err::getLastErrorDescription ().sz ());
[-] 		writeOutput ("Staying resident...\n");
[+] 		writeOutput("Staying resident...\n");
[-] 	writeOutput ("Shutting down...\n");
[+] 	writeOutput("Shutting down...\n");
[-] 	m_runtime->shutdown ();
[+] 	m_runtime->shutdown();
[-] 	writeOutput ("Done.\n");
[+] 	writeOutput("Done.\n");
[-] MdiChild* MainWindow::createMdiChild ()
[+] MdiChild* MainWindow::createMdiChild()
[-] MdiChild* MainWindow::activeMdiChild ()
[+] MdiChild* MainWindow::activeMdiChild()
[-] QMdiSubWindow* MainWindow::findMdiSubWindow (const QString& filePath)
[+] QMdiSubWindow* MainWindow::findMdiSubWindow(const QString& filePath)
[-] 	foreach (QMdiSubWindow* subWindow, m_mdiArea->subWindowList()) {
[+] 	foreach(QMdiSubWindow* subWindow, m_mdiArea->subWindowList()) {
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\mdichild.cpp
----------------------
[-] 	QByteArray data = file.readAll ();
[+] 	QByteArray data = file.readAll();
[-] 	setPlainText (QString::fromUtf8 (data));
[+] 	setPlainText(QString::fromUtf8(data));
[-] 	QByteArray data = toPlainText ().toUtf8 ();
[+] 	QByteArray data = toPlainText().toUtf8();
[-] 	file.write (data);
[+] 	file.write(data);
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\modulepane.cpp
----------------------
[-] bool ModulePane::build (jnc::Module* module, MdiChild* document)
[+] bool ModulePane::build(jnc::Module* module, MdiChild* document)
[-] 	jnc::ModuleItemDecl* decl = (jnc::ModuleItemDecl*) variant.value <void*> ();
[+] 	jnc::ModuleItemDecl* decl = (jnc::ModuleItemDecl*)variant.value<void*> ();
[-] 	document->selectLine(decl->getLine (), true);
[+] 	document->selectLine(decl->getLine(), true);
[-] 	size_t count = attributeBlock->getAttributeCount ();
[+] 	size_t count = attributeBlock->getAttributeCount();
[-] 		jnc::Attribute* attribute = attributeBlock->getAttribute (i);
[+] 		jnc::Attribute* attribute = attributeBlock->getAttribute(i);
[-] 		jnc::ModuleItemDecl* decl = attribute->getDecl ();
[+] 		jnc::ModuleItemDecl* decl = attribute->getDecl();
[-] 		QTreeWidgetItem *item = insertItem (decl->getName (), attributes);
[+] 		QTreeWidgetItem *item = insertItem(decl->getName(), attributes);
[-] 		item->setData(0, Qt::UserRole, qVariantFromValue((void*) decl));
[+] 		item->setData(0, Qt::UserRole, qVariantFromValue((void*)decl));
[-] 	else if (!globalNamespace->getDecl ()->getParentNamespace())
[+] 	else if (!globalNamespace->getDecl()->getParentNamespace())
[-] 			(const char *)globalNamespace->getDecl ()->getName());
[+] 			(const char *)globalNamespace->getDecl()->getName());
[-] 	treeItem->setData(0, Qt::UserRole, qVariantFromValue((void*) globalNamespace->getDecl ()));
[+] 	treeItem->setData(0, Qt::UserRole, qVariantFromValue((void*)globalNamespace->getDecl()));
[-] 	jnc::Namespace* nspace = globalNamespace->getNamespace ();
[+] 	jnc::Namespace* nspace = globalNamespace->getNamespace();
[-] 		jnc::ModuleItem *child = nspace->getItem (i);
[+] 		jnc::ModuleItem *child = nspace->getItem(i);
[-] 	switch (itemKind)
[+] 	switch(itemKind)
[-] 		addNamespace (parent, (jnc::GlobalNamespace*) item);
[+] 		addNamespace(parent, (jnc::GlobalNamespace*)item);
[-] 		addType (parent, (jnc::Type*) item);
[+] 		addType(parent, (jnc::Type*)item);
[-] 		addTypedef (parent, (jnc::Typedef*) item);
[+] 		addTypedef(parent, (jnc::Typedef*)item);
[-] 		addVariable (parent, (jnc::Variable*) item);
[+] 		addVariable(parent, (jnc::Variable*)item);
[-] 		addFunction (parent, (jnc::Function*) item);
[+] 		addFunction(parent, (jnc::Function*)item);
[-] 		addProperty (parent, (jnc::Property*) item);
[+] 		addProperty(parent, (jnc::Property*)item);
[-] 		addEnumConst (parent, (jnc::EnumConst*) item);
[+] 		addEnumConst(parent, (jnc::EnumConst*)item);
[-] 		addStructField (parent, (jnc::StructField*) item);
[+] 		addStructField(parent, (jnc::StructField*)item);
[-] 		addAlias (parent, (jnc::Alias*) item);
[+] 		addAlias(parent, (jnc::Alias*)item);
[-] 	QString toolTip = QString ("%1 (sizeof = %2)").arg (type->getTypeString ()).arg (type->getSize ());
[+] 	QString toolTip = QString("%1 (sizeof = %2)").arg (type->getTypeString ()).arg (type->getSize ());
[-] 	item->setToolTip (0, toolTip);
[+] 	item->setToolTip(0, toolTip);
[-] 	switch (typeKind)
[+] 	switch(typeKind)
[-] 		decl = ((jnc::EnumType *)type)->getDecl ();
[+] 		decl = ((jnc::EnumType *)type)->getDecl();
[-] 		addItemAttributes (item, decl);
[+] 		addItemAttributes(item, decl);
[-] 		decl = ((jnc::DerivableType *)type)->getDecl ();
[+] 		decl = ((jnc::DerivableType *)type)->getDecl();
[-] 		addItemAttributes (item, decl);
[+] 		addItemAttributes(item, decl);
[-] 	item->setData(0, Qt::UserRole, qVariantFromValue ((void*) decl));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)decl));
[-] void ModulePane::addTypedef (QTreeWidgetItem *parent, jnc::Typedef* tdef)
[+] void ModulePane::addTypedef(QTreeWidgetItem *parent, jnc::Typedef* tdef)
[-] 	name.sprintf ("typedef %s %s %s",
[+] 	name.sprintf("typedef %s %s %s",
[-] 		tdef->getType ()->getTypeStringPrefix(),
[+] 		tdef->getType()->getTypeStringPrefix(),
[-] 		tdef->getDecl ()->getName (),
[+] 		tdef->getDecl()->getName(),
[-] 		tdef->getType ()->getTypeStringSuffix()
[+] 		tdef->getType()->getTypeStringSuffix()
[-] 	QTreeWidgetItem *item = insertItem (name, parent);
[+] 	QTreeWidgetItem *item = insertItem(name, parent);
[-] 	item->setData (0, Qt::UserRole, qVariantFromValue((void*) tdef->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)tdef->getDecl()));
[-] 	addValue (parent, variable->getDecl ()->getName(), variable->getType(), variable);
[+] 	addValue(parent, variable->getDecl()->getName(), variable->getType(), variable);
[-] 	QTreeWidgetItem *item = insertItem((const char*) member->getDecl ()->getName(), parent);
[+] 	QTreeWidgetItem *item = insertItem((const char*) member->getDecl()->getName(), parent);
[-] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*) member->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)member->getDecl()));
[-] void ModulePane::addValue (QTreeWidgetItem *parent, const QString& name, jnc::Type* type, jnc::ModuleItem* moduleItem)
[+] void ModulePane::addValue(QTreeWidgetItem *parent, const QString& name, jnc::Type* type, jnc::ModuleItem* moduleItem)
[-] 	QString itemName = QString ("%1 %2 %3").arg (type->getTypeStringPrefix ()).arg (name).arg (type->getTypeStringSuffix ());
[+] 	QString itemName = QString("%1 %2 %3").arg (type->getTypeStringPrefix ()).arg (name).arg (type->getTypeStringSuffix ());
[-] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*) moduleItem->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)moduleItem->getDecl()));
[-] 	if (jnc::isClassType (type, jnc::ClassTypeKind_Reactor))
[+] 	if (jnc::isClassType(type, jnc::ClassTypeKind_Reactor))
[-] 		addDerivableTypeMembers (item, (jnc::ClassType*) type);
[+] 		addDerivableTypeMembers(item, (jnc::ClassType*)type);
[-] void ModulePane::addEnumTypeMembers (QTreeWidgetItem *parent, jnc::EnumType* type)
[+] void ModulePane::addEnumTypeMembers(QTreeWidgetItem *parent, jnc::EnumType* type)
[-] 	size_t count = type->getConstCount ();
[+] 	size_t count = type->getConstCount();
[-] 		jnc::EnumConst* member = type->getConst (i);
[+] 		jnc::EnumConst* member = type->getConst(i);
[-] 		addEnumConst (parent, member);
[+] 		addEnumConst(parent, member);
[-] 	expandItem (parent);
[+] 	expandItem(parent);
[-] 	size_t count = type->getMemberFieldCount ();
[+] 	size_t count = type->getMemberFieldCount();
[-] 		jnc::StructField* field = type->getMemberField (i);
[+] 		jnc::StructField* field = type->getMemberField(i);
[-] 		addStructField (parent, field);
[+] 		addStructField(parent, field);
[-] 	if (type->getStaticConstructor ())
[+] 	if (type->getStaticConstructor())
[-] 		addItem (parent, type->getStaticConstructor ());
[+] 		addItem(parent, type->getStaticConstructor());
[-] 	if (type->getStaticDestructor ())
[+] 	if (type->getStaticDestructor())
[-] 		addItem (parent, type->getStaticDestructor ());
[+] 		addItem(parent, type->getStaticDestructor());
[-] 	if (type->getPreConstructor ())
[+] 	if (type->getPreConstructor())
[-] 		addItem (parent, type->getPreConstructor ());
[+] 		addItem(parent, type->getPreConstructor());
[-] 	if (type->getConstructor ())
[+] 	if (type->getConstructor())
[-] 		addItem (parent, type->getConstructor ());
[+] 		addItem(parent, type->getConstructor());
[-] 	if (type->getDestructor ())
[+] 	if (type->getDestructor())
[-] 		addItem (parent, type->getDestructor ());
[+] 		addItem(parent, type->getDestructor());
[-] 	count = type->getMemberPropertyCount ();
[+] 	count = type->getMemberPropertyCount();
[-] 		jnc::Property* prop = type->getMemberProperty (i);
[+] 		jnc::Property* prop = type->getMemberProperty(i);
[-] 		addProperty (parent, prop);
[+] 		addProperty(parent, prop);
[-] 	count = type->getMemberMethodCount ();
[+] 	count = type->getMemberMethodCount();
[-] 		jnc::Function* function = type->getMemberMethod (i);
[+] 		jnc::Function* function = type->getMemberMethod(i);
[-] 		addFunction (parent, function);
[+] 		addFunction(parent, function);
[-] 	expandItem (parent);
[+] 	expandItem(parent);
[-] void ModulePane::addFunction (QTreeWidgetItem *parent, jnc::Function* function)
[+] void ModulePane::addFunction(QTreeWidgetItem *parent, jnc::Function* function)
[-] 	if (!function->isOverloaded ())
[+] 	if (!function->isOverloaded())
[-] 		addFunctionImpl (parent, function);
[+] 		addFunctionImpl(parent, function);
[-] 		size_t count = function->getOverloadCount ();
[+] 		size_t count = function->getOverloadCount();
[-] 		itemName.sprintf (
[+] 		itemName.sprintf(
[-] 			function->getDecl ()->getName (),
[+] 			function->getDecl()->getName(),
[-] 		QTreeWidgetItem *item = insertItem (itemName, parent);
[+] 		QTreeWidgetItem *item = insertItem(itemName, parent);
[-] 			jnc::Function* pOverload = function->getOverload (i);
[+] 			jnc::Function* pOverload = function->getOverload(i);
[-] 			addFunctionImpl (item, pOverload);
[+] 			addFunctionImpl(item, pOverload);
[-] 		expandItem (item);
[+] 		expandItem(item);
[-] void ModulePane::addFunctionImpl (QTreeWidgetItem *parent, jnc::Function* function)
[+] void ModulePane::addFunctionImpl(QTreeWidgetItem *parent, jnc::Function* function)
[-] 	jnc::FunctionType* type = function->getType ();
[+] 	jnc::FunctionType* type = function->getType();
[-] 	const char* name = function->getFunctionKind () == jnc::FunctionKind_Normal ?
[+] 	const char* name = function->getFunctionKind() == jnc::FunctionKind_Normal ?
[-] 		function->getDecl ()->getName () :
[+] 		function->getDecl()->getName() :
[-] 		jnc::getFunctionKindString (function->getFunctionKind ());
[+] 		jnc::getFunctionKindString(function->getFunctionKind());
[-] 	QString itemName = QString ("%1 %2 %3").arg (type->getTypeStringPrefix (), name, type->getTypeStringSuffix ());
[+] 	QString itemName = QString("%1 %2 %3").arg (type->getTypeStringPrefix (), name, type->getTypeStringSuffix ());
[-] 	QTreeWidgetItem *item = insertItem (itemName, parent);
[+] 	QTreeWidgetItem *item = insertItem(itemName, parent);
[-] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*) function->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)function->getDecl()));
[-] void ModulePane::addProperty (QTreeWidgetItem *parent, jnc::Property* prop)
[+] void ModulePane::addProperty(QTreeWidgetItem *parent, jnc::Property* prop)
[-] 	QTreeWidgetItem *item = insertItem (prop->getDecl ()->getName (), parent);
[+] 	QTreeWidgetItem *item = insertItem(prop->getDecl()->getName(), parent);
[-] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*) prop->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)prop->getDecl()));
[-] 	jnc::Function* getter = prop->getGetter ();
[+] 	jnc::Function* getter = prop->getGetter();
[-] 	jnc::Function* setter = prop->getSetter ();
[+] 	jnc::Function* setter = prop->getSetter();
[-] 	addFunction (item, getter);
[+] 	addFunction(item, getter);
[-] 		addFunction (item, setter);
[+] 		addFunction(item, setter);
[-] 	expandItem (item);
[+] 	expandItem(item);
[-] 	name.sprintf (
[+] 	name.sprintf(
[-] 		alias->getDecl ()->getName (),
[+] 		alias->getDecl()->getName(),
[-] 		alias->getTargetItem ()->getDecl ()->getQualifiedName ()
[+] 		alias->getTargetItem()->getDecl()->getQualifiedName()
[-] 	QTreeWidgetItem *item = insertItem (name, parent);
[+] 	QTreeWidgetItem *item = insertItem(name, parent);
[-] 	item->setData (0, Qt::UserRole, qVariantFromValue((void*) alias->getDecl ()));
[+] 	item->setData(0, Qt::UserRole, qVariantFromValue((void*)alias->getDecl()));
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\output.cpp
----------------------
[-] 	setLineWrapMode (QPlainTextEdit::NoWrap);
[+] 	setLineWrapMode(QPlainTextEdit::NoWrap);
[-] 	QString lineNumber = regexp.capturedTexts ().at (1);
[+] 	QString lineNumber = regexp.capturedTexts().at(1);
[-] 	QString colNumber = regexp.capturedTexts ().at (2);
[+] 	QString colNumber = regexp.capturedTexts().at(2);
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\testlib.cpp
----------------------
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_DEFINE_TYPE (
[+] JNC_DEFINE_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestClassA)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestClassA)
[-] 	JNC_MAP_FUNCTION ("foo", &TestClassA::foo)
[+] 	JNC_MAP_FUNCTION("foo", &TestClassA::foo)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_OPAQUE_CLASS_TYPE (
[+] JNC_DEFINE_OPAQUE_CLASS_TYPE(
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestClassB)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestClassB)
[-] 	JNC_MAP_FUNCTION ("bar", &TestClassB::bar)
[+] 	JNC_MAP_FUNCTION("bar", &TestClassB::bar)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] JNC_DEFINE_TYPE (TestStruct, "TestStruct", g_testLibGuid, TestLibCacheSlot_TestStruct)
[+] JNC_DEFINE_TYPE(TestStruct, "TestStruct", g_testLibGuid, TestLibCacheSlot_TestStruct)
[-] JNC_BEGIN_TYPE_FUNCTION_MAP (TestStruct)
[+] JNC_BEGIN_TYPE_FUNCTION_MAP(TestStruct)
[-] 	JNC_MAP_CONSTRUCTOR (&TestStruct::construct_0)
[+] 	JNC_MAP_CONSTRUCTOR(&TestStruct::construct_0)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::construct_1)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::construct_1)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::construct_2)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::construct_2)
[-] 	JNC_MAP_FUNCTION ("foo", &TestStruct::foo_0)
[+] 	JNC_MAP_FUNCTION("foo", &TestStruct::foo_0)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::foo_1)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::foo_1)
[-] 	JNC_MAP_OVERLOAD (&TestStruct::foo_2)
[+] 	JNC_MAP_OVERLOAD(&TestStruct::foo_2)
[-] JNC_END_TYPE_FUNCTION_MAP ()
[+] JNC_END_TYPE_FUNCTION_MAP()
[-] TestClassA::foo (int x)
[+] TestClassA::foo(int x)
[-] 	printf ("TestClassA::foo (%d)\n", x);
[+] 	printf("TestClassA::foo (%d)\n", x);
[-] TestClassB::markOpaqueGcRoots (jnc::GcHeap* gcHeap)
[+] TestClassB::markOpaqueGcRoots(jnc::GcHeap* gcHeap)
[-] TestClassB::bar (
[+] TestClassB::bar(
[-] 	printf ("TestClassB::bar ()\n");
[+] 	printf("TestClassB::bar ()\n");
[-] TestStruct::construct_0 (jnc::DataPtr selfPtr)
[+] TestStruct::construct_0(jnc::DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::construct () { m_x = %d, m_y = %f }\n", self->m_x, self->m_y);
[+] 	printf("TestStruct::construct () { m_x = %d, m_y = %f }\n", self->m_x, self->m_y);
[-] TestStruct::construct_1 (jnc::DataPtr selfPtr, int x)
[+] TestStruct::construct_1(jnc::DataPtr selfPtr, int x)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::construct (int x = %d) { m_x = %d, m_y = %f }\n", x, self->m_x, self->m_y);
[+] 	printf("TestStruct::construct (int x = %d) { m_x = %d, m_y = %f }\n", x, self->m_x, self->m_y);
[-] TestStruct::construct_2 (jnc::DataPtr selfPtr, double y)
[+] TestStruct::construct_2(jnc::DataPtr selfPtr, double y)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::construct (double y = %f) { m_x = %d, m_y = %f }\n", y, self->m_x, self->m_y);
[+] 	printf("TestStruct::construct (double y = %f) { m_x = %d, m_y = %f }\n", y, self->m_x, self->m_y);
[-] TestStruct::foo_0 (jnc::DataPtr selfPtr)
[+] TestStruct::foo_0(jnc::DataPtr selfPtr)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::foo () { m_x = %d, m_y = %f }\n", self->m_x, self->m_y);
[+] 	printf("TestStruct::foo () { m_x = %d, m_y = %f }\n", self->m_x, self->m_y);
[-] TestStruct::foo_1 (jnc::DataPtr selfPtr, int x)
[+] TestStruct::foo_1(jnc::DataPtr selfPtr, int x)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::foo (int x = %d) { m_x = %d, m_y = %f }\n", x, self->m_x, self->m_y);
[+] 	printf("TestStruct::foo (int x = %d) { m_x = %d, m_y = %f }\n", x, self->m_x, self->m_y);
[-] TestStruct::foo_2 (jnc::DataPtr selfPtr, double y)
[+] TestStruct::foo_2(jnc::DataPtr selfPtr, double y)
[-] 	TestStruct* self = (TestStruct*) selfPtr.m_p;
[+] 	TestStruct* self = (TestStruct*)selfPtr.m_p;
[-] 	printf ("TestStruct::foo (double y = %f) { m_x = %d, m_y = %f }\n", y, self->m_x, self->m_y);
[+] 	printf("TestStruct::foo (double y = %f) { m_x = %d, m_y = %f }\n", y, self->m_x, self->m_y);
[-] testPtr (
[+] testPtr(
[-] 	printf ("TestLib::testPtr\n");
[+] 	printf("TestLib::testPtr\n");
[-] 	((axl::io::SockAddr*) ptr.m_p)->parse ((const char*) ptr2.m_p);
[+] 	((axl::io::SockAddr*)ptr.m_p)->parse((const char*) ptr2.m_p);
[-] testVariant (jnc::Variant variant)
[+] testVariant(jnc::Variant variant)
[-] 	printf ("TestLib::testVariant\n");
[+] 	printf("TestLib::testVariant\n");
[-] qtWait (uint_t msTime)
[+] qtWait(uint_t msTime)
[-] 	uint64_t start = sys::getTimestamp ();
[+] 	uint64_t start = sys::getTimestamp();
[-] 		uint_t now = sys::getTimestamp ();
[+] 		uint_t now = sys::getTimestamp();
[-] 		eventLoop.processEvents (QEventLoop::AllEvents, 100);
[+] 		eventLoop.processEvents(QEventLoop::AllEvents, 100);
[-] testAlloc ()
[+] testAlloc()
[-] 	jnc::Runtime* runtime = jnc::getCurrentThreadRuntime ();
[+] 	jnc::Runtime* runtime = jnc::getCurrentThreadRuntime();
[-] 	ASSERT (runtime);
[+] 	ASSERT(runtime);
[-] 	jnc::GcHeap* gcHeap = runtime->getGcHeap ();
[+] 	jnc::GcHeap* gcHeap = runtime->getGcHeap();
[-] 	JNC_BEGIN_CALL_SITE (runtime)
[+] 	JNC_BEGIN_CALL_SITE(runtime)
[-] 	ptr1 = gcHeap->allocateBuffer (100);
[+] 	ptr1 = gcHeap->allocateBuffer(100);
[-] 	memset (ptr1.m_p, 0xaa, 100);
[+] 	memset(ptr1.m_p, 0xaa, 100);
[-] 	ptr2 = gcHeap->allocateBuffer (100);
[+] 	ptr2 = gcHeap->allocateBuffer(100);
[-] 	memset (ptr2.m_p, 0xbb, 100);
[+] 	memset(ptr2.m_p, 0xbb, 100);
[-] 	ptr3 = gcHeap->allocateBuffer (100);
[+] 	ptr3 = gcHeap->allocateBuffer(100);
[-] 	memset (ptr3.m_p, 0xcc, 100);
[+] 	memset(ptr3.m_p, 0xcc, 100);
[-] 	JNC_END_CALL_SITE ()
[+] 	JNC_END_CALL_SITE()
[-] 	gcHeap->collect ();
[+] 	gcHeap->collect();
[-] 	printf ("done\n");
[+] 	printf("done\n");
[-] JNC_DEFINE_LIB (
[+] JNC_DEFINE_LIB(
[-] JNC_BEGIN_LIB_SOURCE_FILE_TABLE (TestLib)
[+] JNC_BEGIN_LIB_SOURCE_FILE_TABLE(TestLib)
[-] JNC_END_LIB_SOURCE_FILE_TABLE ()
[+] JNC_END_LIB_SOURCE_FILE_TABLE()
[-] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE (TestLib)
[+] JNC_BEGIN_LIB_OPAQUE_CLASS_TYPE_TABLE(TestLib)
[-] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY (TestClassB)
[+] 	JNC_LIB_OPAQUE_CLASS_TYPE_TABLE_ENTRY(TestClassB)
[-] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE ()
[+] JNC_END_LIB_OPAQUE_CLASS_TYPE_TABLE()
[-] JNC_BEGIN_LIB_FUNCTION_MAP (TestLib)
[+] JNC_BEGIN_LIB_FUNCTION_MAP(TestLib)
[-] JNC_END_LIB_FUNCTION_MAP ()
[+] JNC_END_LIB_FUNCTION_MAP()
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\editor.h
----------------------
[-] 	void appendString (const QString &string)
[+] 	void appendString(const QString &string)
[-] 		moveCursor (QTextCursor::End);
[+] 		moveCursor(QTextCursor::End);
[-] 		insertPlainText (string);
[+] 		insertPlainText(string);
[-] 	void appendText (const sl::StringRef& text)
[+] 	void appendText(const sl::StringRef& text)
[-] 		appendString (QString::fromUtf8 (text.cp (), text.getLength ()));
[+] 		appendString(QString::fromUtf8(text.cp(), text.getLength()));
[-] 	void appendFormat_va (const char* format, va_list va)
[+] 	void appendFormat_va(const char* format, va_list va)
[-] 		string.vsprintf (format, va);
[+] 		string.vsprintf(format, va);
[-] 		appendString (string);
[+] 		appendString(string);
[-] 	void appendFormat (const char* format, ...)
[+] 	void appendFormat(const char* format, ...)
[-] 		va_start (va, format);
[+] 		va_start(va, format);
[-] 		appendFormat_va (format, va);
[+] 		appendFormat_va(format, va);
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\llvmir.h
----------------------
[-] 	bool build (jnc::Module* module);
[+] 	bool build(jnc::Module* module);
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\mainwindow.h
----------------------
[-] 	void outputSlot ();
[+] 	void outputSlot();
[-] 	void outputSignal ();
[+] 	void outputSignal();
[-] JNC_INLINE MainWindow* getMainWindow ()
[+] JNC_INLINE MainWindow* getMainWindow()
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\mdichild.h
----------------------
[-] 	bool isCompilationNeeded ()
[+] 	bool isCompilationNeeded()
[-] 	void setCompilationNeeded (bool isNeeded = true)
[+] 	void setCompilationNeeded(bool isNeeded = true)
[-] 	LineNumberMargin(MdiChild *editor) : QWidget (editor)
[+] 	LineNumberMargin(MdiChild *editor) : QWidget(editor)
[-] 		{ return QSize (editor->lineNumberMarginWidth, 0); }
[+] 		{ return QSize(editor->lineNumberMarginWidth, 0); }
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\modulepane.h
----------------------
[-] 		addValue (parent, field->getDecl ()->getName (), field->getType (), field);
[+] 		addValue(parent, field->getDecl()->getName(), field->getType(), field);
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\pch.h
----------------------
[-] #			define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
[+] #			define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__)
----------------------
27/02/2019 18:02:34 - C:\Projects\repos\ioninja\jancy\test\jnc_test_qt\testlib.h
----------------------
[-] JNC_DEFINE_GUID (
[+] JNC_DEFINE_GUID(
[-] 	destruct ();
[+] 	destruct();
[-] 	foo (int x);
[+] 	foo(int x);
[-] 	char m_data [256];
[+] 	char m_data[256];
[-] 	markOpaqueGcRoots (jnc::GcHeap* gcHeap);
[+] 	markOpaqueGcRoots(jnc::GcHeap* gcHeap);
[-] 	bar (
[+] 	bar(
[-] 	construct_0 (jnc::DataPtr selfPtr);
[+] 	construct_0(jnc::DataPtr selfPtr);
[-] 	construct_1 (
[+] 	construct_1(
[-] 	construct_2 (
[+] 	construct_2(
[-] 	foo_0 (jnc::DataPtr selfPtr);
[+] 	foo_0(jnc::DataPtr selfPtr);
[-] 	foo_1 (
[+] 	foo_1(
[-] 	foo_2 (
[+] 	foo_2(
[-] JNC_DECLARE_LIB (TestLib)
[+] JNC_DECLARE_LIB(TestLib)
