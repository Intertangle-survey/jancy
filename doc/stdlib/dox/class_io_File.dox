/*!

\class io.File

	\ingroup file

	\brief This class provides a standard synchronous interface for reading from and writing to files or devices.

	All the methods of this class are mapped directly to underlying Operating System API (not to the C-runtime library). A typical sequence of steps when working with a file looks something like this:

	* Open a file with ``open`` method;
	* Read from the file using ``read`` method;
	* Write to the file using ``write`` method;
	* Close the file with ``close`` method.

	If an instance of ``io.File`` class is being abandoned without calling ``close``, it will be closed automatically in ``io.File.destruct`` -- which will happen whenever the Jancy Garbage Collector decides to sweep unused objects.

	However, leaving this at Garbage Collector' discretion is undesirable, as it leads to undeterministic resource release -- file will be kept open for unknown period of time.

	An easy way for overcoming this problem is to always work with files using Jancy ``disposable`` storage specifier, like this:

	.. ref-code-block:: jnc

		foo ()
		{
			// ...

			disposable io.File file;
			file.open ();

			// work with file...
		} // <-- file.close () is guaranteed to be called upon exiting the scope


	\field m_isOpen

		Holds the open status for the file, i.e. ``true`` if opened; ``false`` otherwise.

	\property m_size

		This property is used for getting and setting file size.

		Reading from this property returns current size of the file; writing to it sets new size. If setting new size fails, IO error supplied by operating system is set; then dynamic exception is thrown.

	\property m_position

		This property is used for getting and setting current file position, i.e. the offset at which file contents will be accessed by ``read`` and ``write`` methods.

		Reading from this property returns current read/write position in the file; writing to it sets new position. Behaviour of this property sequential devices (which do not support access at random-offset) is determined by the underlying operating system. If getting or setting position fails, IO error supplied by operating system is set; then dynamic exception is thrown.

	\fn open

		Opens or creates a file or device.

		The function accepts two arguments. The first one, ``name`` specifies the name of the file/device. The second one, ``flags``, can be used to specify open options. Check `io.FileOpenFlags` for the complete list of options.

		If file or device could not be opened, IO error supplied by operating system is set and then the function returns ``false``. Since this is an ``errorcode`` function, you can use exception semantics to handle the error.

	\fn close

		Closes a previously opened file, does nothing if the file is not opened. This function always succeeds.

	\fn read

		Attempts to read up to ``size`` bytes from file into the buffer pointed to by ``p``.

		Returns the actual amount of bytes read or ``-1`` if error occurs.

		If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1``. Since this is an ``errorcode`` function, you can use exception semantics to handle the error.

		If this function is called when there is no incoming data on the opened device, it blocks until either the data arrives, or the file is closed.

	\fn write

		Attempts to write ``size`` bytes from the buffer pointed to by ``p`` into the file.

		Returns the actual amount of bytes written or ``-1`` if error occurs.

		If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1``. Since this is an ``errorcode`` function, you can use exception semantics to handle the error.

*/