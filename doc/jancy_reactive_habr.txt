<img src="http://tibbo.com/images/ninja/habrahabr/rocket-2.jpg" alt="rocket" align="right"/>Что такое реактивное программирование? <a href = "https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Статья в Википедии</a> учит, что это -- парадигма программирования, <b>ориентированная на потоки данных и распространение изменений</b>. Это определение, хоть и технически корректно (ещё бы!), даёт крайне размытое представление о том, что же за всем этим скрывается на самом деле. Между тем, концепция реактивности проста и естественна, и объяснять её лучше всего на следующем примере.

Все мы когда-нибудь пользовались электронными таблицами типа Microsoft Excel. В ячейке таблицы пользователь может написать формулу, которая ссылается на другие ячейки. Если значение любой из них изменится -- формула будет пересчитана, и наша ячейка автоматически обновится. При этом, если наша ячейка участвует в других формулах -- то и они будут автоматически пересчитаны, и так далее, и так далее -- процесс, напоминающий развитие цепной реакции. Так вот, это и есть главная идея реактивного программирования!

На хабре было уже немало статей на тему реактивного программирования (<a href="http://habrahabr.ru/post/198656/">раз</a>, <a href="http://habrahabr.ru/post/140719/">два</a>,  <a href="http://habrahabr.ru/company/2gis/blog/228125/">три</a>, <a href="http://habrahabr.ru/post/254569/">четыре</a> и другие) - в основном в них описывается реактивность в своей <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">FRP</a>-ипостаси в виде библиотек навроде <a href="https://baconjs.github.io/">bacon.js</a> для JavaScript, <a href="https://github.com/ReactiveX/RxJava">JavaRx</a> для Java и т.д. В данной статье пойдёт речь о реализации и применении реактивного программирования в языке <a href="http://tibbo.com/jancy/">Jancy</a>. Материал будет интересен к прочтению даже если вы никогда не слышали о языке Jancy и не собираетесь на нём ничего писать -- потому что далее мы продемонстрируем достаточно необычный подход к реактивности из императивного языка.
<habracut>
Какую бы из существующих реактивных библиотек мы не взяли, ключевым в реализации будет паттерн <b>"Observable"</b>. Действительно, ведь для того, чтобы "распространять" изменения, нам как минимум надо получить о них уведомления. Observable-сущности обычно подразделяются на два примитива (называются они в разных библиотеках по-разному):
<ul>
	<li>Поток событий (EventStream/Observable/Event/Stream);</li>
	<li>Свойства (Property/Behavior/Attribute) -- значение, меняющееся со временем.</li>
</ul>
В FRP всё это настаивается на элементах <b>функционального программирования</b>: для построения сложных конструкций из таких примитивов применяются функции высшего порядка типа map, reduce, filter, combine и т.д. которые порождают вторичные потоки и события (вместо того, чтобы "модифициорвать" исходные). Получившийся компот из observables и функциональщины не столь труден для понимания и освоения и при этом позволяет выражать зависимости между компонентами в <b>декларативной форме</b>. Это замечательно подходит для программирования запутанных пользовательских интерфейсов и распределённых асинхронных систем. Так есть ли что улучшать?

<h1>Проблемы</h1>
Первая проблема такова. Если реактивность реализуется на уровне библиотек, без поддержки observables в компиляторе, то <b>автоматически-пересчитываемые формулы а-ля Excel</b> остаются недостижимым идеалом. Вместо этого придётся вручную сделать несколько map и combine над нашими observables -- тем больше, чем сложнее логика нашей формулы, а потом ещё onValue/assign для записи полученного значения в нужное место.

Пожалуй, ближе всего к Excel-подобным формулам подобрался <a href="http://flapjax-lang.org/">Flapjax</a> -- опенсорсный компилятор в JavaScript (если существуют другие проекты подобного рода, пожалуйста, напишите про них в комментариях). Observables 2-го типа, которые в Flapjax называются Behavor, можно произвольным образом комбинировать в выражениях и получать на выходе новые Behavor.

<img src="http://tibbo.com/images/ninja/habrahabr/magic-pot.jpg" alt="magic-pot" align="left"/>Но имеется ещё одна фундаментальная проблема, которая присуща как реактивным библиотекам, так и Flapjax -- это проблема <b>"горшочек не вари"</b>. После того, как мы создали нашу инфраструктуру из потоков событий, свойств и взаимных подписок друг на друга, она начинает жить своей жизнью. Данные текут и преобразуются, как мы их попросили, необходимые действия выполняются во всеразличных onValue и onCompleted, всё здорово. Так, а как теперь это остановить? Пробежаться по всем корневым observables и останавить эмиссию событий вручную? Уже не очень красиво. А что если надо остановить не всё, а лишь часть нашего реактивного графа зависимостей? При том, что львиная доля наших observables существует в виде неявных результатов map/combine/filter?

Если переформулировать несколько по-другому, то одна из проблем с существующими реактивными библиотеками -- это то, что (во многом в силу своей функциональной ориентированности) они порождают одноуровневую структуру observable объектов!

Впрочем, критиковать всегда легче, чем предложить какую-то альтернативу. Итак, чем же в плане реактивности может похвастать Jancy?
<ol>
	<li>Excel-подобный <b>автоматический пересчёт формул</b> с observables -- причём только там, где выберет программист;</li>
	<li>Возможность группировать <b>кластеры зависимостей</b> между observables -- и потом запускать и останавливать все подписки в кластере разом.</li>
</ol>
Выглядит это вот так:
<source lang="cpp">
reactor TcpConnectionSession.m_uiReactor ()
{
	m_title = $"TCP $(m_addressCombo.m_editText)";
	m_isTransmitEnabled = m_state == State.Connected;
	m_adapterProp.m_isEnabled = m_useLocalAddressProp.m_value;
	m_localPortProp.m_isEnabled = m_useLocalAddressProp.m_value;
	m_actionTable [ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
	m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? 
		IconId.Disconnect : 
		IconId.Connect];
	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? 
		m_remoteAddress.getString () : 
		"<peer-address>";
	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
}
</source>
Это выжимка из исходников сессии TCP Connection терминала <a href="http://tibbo.com/ioninja/">IO Ninja</a>. Как легко догадаться, данный код занимается обновлением UI при изменениях статуса, текста в комбобоксе и т.д.

А теперь про то, как это работает.

<h1>Общим планом</h1>
Прежде всего, дабы избежать путаницы, договоримся о терминологии. 

<b>Свойство</b> (property) в Jancy имеет общепринятое (не реактивное) определение -- это некая штуковина, которая выглядит, как переменная/поле, но при этом позволяет выполнять действия в функциях-аксессорах. 

<b>Мультикасты</b> (multicast) и <b>события</b> (event) служат для накопления указателей на функции и вызова их всех разом (о различиях между мультикастами и событиями чуть попозже).

В Jancy только один вид observable на уровне компилятора -- <b>"связываемое свойство"</b> (bindable property), т.е. свойство, способное оповещать о своём изменении через событие onChanged.

В отличие от аналогов, реактивность в Jancy не пытается быть "слишком умной" и лезть всюду, где используются observables -- с побочными эффектами типа автоматической подписки, неявного порождения новых observables и т.д. Она стоит в уголке и есть не просит. Доступ к связываемым свойствам в императивном стиле не дороже доступа к обычной переменной. 

Как это сочетается с заявленным выше реактивным пересчётом а-ля Excel? Бесконфликтное сосуществование реактивного и императивного начал в Jancy возможно потому, что предусмотрены <b>специальные зоны реактивного кода</b> -- т.н. <b>реакторы</b> (reactors). Вместо последовательности инструкций, реакторы состоят из  Excel-подобных формул -- выражений, каждое из которых должно использовать связываемые свойства. Вот внутри реакторов связываемые свойства ведут себя "по-реактивному".

Итак, основными кирпичиками, из которых строится реактивное программирование в Jancy, являются <b>события</b>, <b>связываемые свойства</b> и <b>реакторы</b>. Рассмотрим эти кирпичики поближе.

<h1>Мультикасты и события</h1>
<b>Мультикаст</b> (multicast) в Jancy -- это генерируемый компилятором специальный класс, позволяющий аккумулировать указатели на функции и затем вызывать их все сразу. Объявление мультикаста очень похоже на объявление функции, что неудивительно -- ведь оно должно однозначно определять, указатели на функции какого типа будут храниться в данном мультикасте:
<source lang="cpp">
foo (int x);

bar (
    int x, 
    int y   
    );

baz ()
{
    multicast m (int); // normal (fat) multicast
    
    intptr fooCookie = m.add (foo); 
    m += bar ~(, 200); // capture the 2nd argument
    m (100);  // <-- foo (100); bar (100, 200);

    m -= fooCookie;
    m (300); // <-- bar (300, 200);
    m.clear ();
}
</source>
<spoiler title="Подробнее про методы класса-мультикаста">Для примера, определим простой мультикаст:
<source lang="cpp"> 
multicast m (int);
</source>
Класс мультикаста, сгенерированный в примере выше, будет иметь следующие методы:
<source lang="cpp">
void clear ();
intptr set (function* (int)); // returns cookie
intptr add (function* (int)); // returns cookie
function* remove (intptr cookie) (int);
function* getSnapshot () (int);
void call (int);
</source>
Методы set и add возвращают некий целочисленный cookie, который может быть использован в методе remove для эффективного удаления указателя из мультикаста.

Некоторые из методов имеют также псевдонимы в виде операторов:
<source lang="cpp">
multicast m ();
m = foo;     // same as m.set (foo);
m += bar;    // same as m.add (bar);
m -= cookie; // same as m.remove (cookie);
m = null;    // same as m.clear ();
m (10);      // same as m.call (10);
</source>
Мультикаст можно привести к указателю на функцию, которая вызовет все накопленные в мультикасте указатели. Но тут имеется неоднозначность, а именно: должно ли подобное приведение быть "живым" (live) или же снимком (snapshot)? Другими словами, если после создания указателя на функцию мы модифицируем исходный мультикаст, должен ли этот указатель видеть изменения?

Для разрешения неоднозначности мультикасты предоставляют метод getSnapshot, возвращающий снимок. В то же время оператор приведения даёт "живой" указатель:
<source lang="cpp">
foo ();
bar ();

baz ()
{
	multicast m ();
	m += foo;

    function* f1 () = m.getSnapshot ();
    function* f2 () = m; 

    m += bar;

    f1 (45); // <-- foo ();
    f2 (55); // <-- foo (); bar ();

    return 0;
}
</source>
</spoiler>
<b>События</b> (event) в Jancy представляют собой специальные <b>указатели</b> на мультикасты <b>с ограничением доступа</b>: можно делать только add и remove:
<source lang="cpp">
foo ()
{
    multicast m (int);

    event* p (int) = m;
    p += bar;    // OK
    p (100);     // <-- error, 'call' is inaccessible
}
</source>
Объявление переменной или поля типа "событие" создаёт <b>дуальный тип</b>: для "своих" этот тип ведёт себя так, как если бы был использован модификатор multicast, а для "чужих" -- это event с запрещением вызова всех методов, кроме add и remove.
<spoiler title="Подробнее про дуальные типы в Jancy">Основным отличием модели доступа в Jancy от большинства других объектно-ориентированных языков является сокращение количества спецификаторов доступа до двух -- <b>public</b> и <b>protected</b>. 

С одной стороны, это предоставляет разработчикам значительно меньшую гибкость в определении того, кто и к чему имеет доступ. С другой стороны, данная упрощённая модель позволяет чётко делить всех на <b>"свой-чужой"</b>, а это, свою очередь, открывает возможность <b>дуальных модификаторов</b>, т.е. модификаторов, имеющих разное значение для "своих" и "чужих", и создаваемых с их помощью <b>дуальных типов</b>.

Итак, в Jancy для каждого отдельно взятого пространства имён A весь остальной мир распадается на две категории: "свои" и "чужие". Помимо самого пространства имён A, к "своим" относятся:
<ul>
    <li>Пространства имён классов или структур, унаследованных от A;</li>
    <li>Пространства имён, объявленные как дружественные (friend);</li>
    <li>Дочерние по отношению к A пространства имён;</li>
    <li>Расширения (extension namespaces) A.</li>
</ul>
Все остальные являются "чужими". "Свои" имеют доступ и к публичным (public), и к защищённым (protected) членам пространства имён, в то время как "чужие" -- только к публичным членам. Помимо этого, принадлежность к группе "своих" или "чужих" меняет смысл дуальных модификаторов Jancy.

Дуальный модификатор <b>readonly</b> может быть использован для элегантной организации доступа только на чтение. Вместо написания тривиальных геттеров, единственным назначением которых был бы контроль доступа, разработчик на Jancy может объявлять поля с модификатором readonly. Для "своих" модификатор readonly как бы невидим, для "чужих" readonly трактуется как <b>const</b>: 
<source lang="cpp">
class C1
{
    int readonly m_progress;

    foo ()
    {
        m_progress += 25; // OK
        // ...
    }
}

bar (C1* c)
{
    c.m_progress = 100; // <-- error, cannot write to 'const' location
}
</source>
Главное преимущество данного подхода -- это то, что он делает код короче и естественнее; как побочный положительный эффект можно назвать упрощение, а значит и ускорение работы оптимизатора, которому не нужно анализировать и выкидывать геттеры-пустышки.

Второй дуальный модификатор в Jancy -- это <b>event</b>. Владелец события должен иметь над ним полный контроль, включая возможность вызвать всех подписчиков или очистить их список. Клиент события должен иметь возможность только добавить или удалить подписчика. Для "своих" поле с модификатором event работает так же, как и мультикаст с соответствующей сигнатурой аргументов. Для "чужих" такое поле ограничивает доступ к методам мультикаста: разрешены только вызовы add и removе; запрещены call, set, clear, getSnapshot и приведение к указателю-на-функцию:
<source lang="cpp">
class C1
{
    event m_onCompleted (); // dual type

    bool work ()
    {
        // ...
        m_onCompleted (); // OK, friends have multicast-access to m_onComplete
        return true;
    }
}

foo ()
{
    C1 c;
    c.m_onCompleted += completionFunc; // ok, aliens have event-access to m_onComplete
    c.m_onCompleted ();                // <-- error, 'call' is inaccessible
    c.m_onCompleted.clear ();          // <-- error, 'clear' is inaccessible
}
</source>
</spoiler>
<h1>Свойства</h1>
В контексте языков программирования <b>свойство</b> (property) -- это нечто, выглядящее и ведущее себя как данные, но при этом позволяющее выполнять некие дополнительные действия при считывании и записи. Без ложной скромности, Jancy предоставляет самую полную на сегодняшний день реализацию свойств любых форм, цветов и размеров.
<spoiler title="Подробнее и с примерами"><h3>Определения</h3>
Функции, выполняющие действия при чтении и записи, называются <b>аксессорами</b> (accessors): аксессор чтения свойства называется геттером (getter), записи – сеттером (setter). 

Каждое свойство в Jancy обладает одним <b>геттером</b> и опционально -- одним или несколькими (перегруженными) <b>сеттерами</b> (т.е. write-only свойств в Jancy нет). Если сеттер перегружен, то выбор конкретного сеттера будет произведён во время присвоения значения свойству по тем же правилам, по которым производится выбор перегруженной функции.

Если свойство не имеет сеттера, то оно называется <b>константным</b> (const-property). В других языках программирования свойства без сеттеров обычно называются "только-для-чтения" (read-only), но так как в Jancy понятия <b>const</b> и <b>readonly</b> сосуществуют (readonly -- дуальный модификатор), то переопределить устоявшиеся определения пришлось бы так или иначе. Итак, в Jancy свойство без сеттера -- это const-свойство.

<h3>Простые свойства</h3>
Для простых свойств без перегруженных сеттеров (к которым сводится большинство практических задач) предлагается наиболее естественная форма объявления:
<source lang="cpp">
int property g_simpleProp;
int const property g_simpleConstProp;
</source>
Данная форма идеально подходит для объявления интерфейсов, или же если разработчик предпочитает принятый в C++ стиль разнесения объявления и реализации методов:
<source lang="cpp">
int g_simpleProp.get ()
{
    // ...
}

g_simpleProp.set (int x)
{
    // ...
}

int g_simpleConstProp.get ()
{
    // ...
}
</source>
<h3>Полная форма объявления</h3>
Для свойств произвольной сложности (т.е. свойств с перегруженными сеттерами, полями данных, вспомогательными методами и т.д.) имеется полная форма объявления:
<source lang="cpp">
property g_prop
{
    int m_x = 5; // member field with in-place initializer

    int get ()
    {
        return m_x;
    }

    set (int x) 
    {
        m_x = x;
        update ();
    }   
        
    set (double x); // overloaded setter
    update ();      // helper method
}
</source>
<h3>Индексируемые свойства</h3>
Jancy также поддерживает индексируемые свойства, т.е. свойства с семантикой массивов. Аксессоры таких свойств принимают дополнительные индексные аргументы. Однако в отличие от настоящих массивов, индексные аргументы свойств не обязаны быть целочисленными, и, строго говоря, не обязаны вообще иметь смысл "индекса" -- их использование полностью определяется разработчиком: 
<source lang="cpp">
int indexed property g_simpleProp (size_t i);

property g_prop
{
    int get (
        size_t i,
        size_t j
        );

    set (
        size_t i,
        size_t j,
        int x
        );

    set (
        size_t i,
        size_t j,
        double x
        );
}

foo ()
{
    int x = g_simpleProp [10];
    g_prop [x] [20] = 100;
}
</source>
<h3>Autoget-свойства</h3>
В подавляющем большинстве случаев геттер просто должен возвращать значение некоей переменной или поля, где хранится текущее значение свойства, а собственно логика поведения свойства воплощается в сеттере. Очевидно, что создание таких тривиальных геттеров можно переложить на компилятор -- что и сделано в Jancy. Для autoget-свойств компилятор автоматически создаёт геттер и поле для хранения данных. Более того, компилятор генерирует прямой доступ к полю в обход геттера везде, где это возможно:
<source lang="cpp">
int autoget property g_simpleProp;

g_simpleProp.set (int x)
{
    m_value = x; // the name of a compiler-generated field is 'm_value'
}

property g_prop
{
    int autoget m_x; // declaring an autoget field makes the whole property autoget

    set (int x);
    set (double x);
}
</source>
Обратная ситуация, когда специальная логика поведения свойства заложена в геттере, а сеттер-пустышка должен просто класть данные в ячейку памяти, встречается редко и не заслуживает создания специального синтаксиса. 
</spoiler>
В применении к реактивному программирования наибольший интерес представляют <b>связываемые свойства</b>, т.е. свойства, которые могут оповещать подписчиков о своих изменениях. Как можно догадаться, для реализации связываемых свойств в Jancy используется механизм <b>мультикастов/событий</b>:
<source lang="cpp">
int autoget bindable property g_simpleProp;

g_simpleProp.set (int x)
{   
    if (x == m_value)
        return;

    m_value = x;
    m_onChanged (); // the name of a compiler-generated bindable event is 'm_onChanged'
}

property g_prop
{
    autoget int m_x;
    bindable event m_e (); // declaring a bindable event makes the whole property bindable

    set (int x);
    set (double x);
}
</source>
Для доступа к событиям, оповещающим об изменениях связываемого свойств, применяется оператор <b>bindingof</b>:
<source lang="cpp">
onSimplePropChanged ()
{
    // ...
}

foo ()
{
    bindingof (g_simpleProp) += onSimplePropChanged;
    g_simpleProp = 100; // bindable event is going to get fired
}
</source>
Jancy также поддерживает связываемые свойства с полностью сгенерированными компилятором аксессорами -- и геттером, и сеттером. Эти в некотором роде дегенеративные свойства называются <b>связываемые данные</b> (bindable data). Они служат единственной цели -- отлавливать момент изменения -- и могут выступать в роли простых observable-переменных/полей:
<source lang="cpp">
int bindable g_data;

onDataChanged ()
{
    // ...
}

foo ()
{
    bindingof (g_data) += onDataChanged;
    g_data = 100; // onDataChanged will get called
    g_data = 100; // onDataChanged will NOT get called
}
</source>
<h1>Реакторы</h1>
<b>Реактор</b> в Jancy -- это зона реактивного кода. Все реактивные зависимости и неявные подписки локализованы внутри реакторов.

Внешне реактор выглядит как обычная функция, разве что в объявлении указан модификатор reactor. В отличие от функций каждый реактор создаёт переменную или поле особого <b>реакторного класса</b> с двумя публичными методами: start и stop, позволяющими запустить и остановить реактор. Вместо инструкций (statements), из которых состоит тело обычной функции, тело реактора состоит из последовательности выражений, каждое из которые должно использовать в своей правой части связываемые свойства:

<source lang="cpp">
State bindable m_state;

reactor m_uiReactor ()
{
    m_isTransmitEnabled = m_state == State.Connected;
    m_actionTable [ActionId.Disconnect].m_isEnabled = m_state != State.Closed;
    // ...
}
</source>
При старте реактор строит граф зависимостей и подписывается на все связываемые события всех "управляющих" свойств. При изменении любого из них все зависимые выражения пересчитываются (что, естественно, может вызвать лавинообразное изменение других свойств).
<spoiler title="А что делать с циклическими зависимостями?">В настоящий момент циклические обновления зависимостей просто игнорируются -- то есть, если какое-либо из управляющих свойств P изменилось и вызвало пересчёт выражений в реакторе, которые в свою очередь поменяли значение этого свойства P, то это повторное изменение не вызовет рекурсивного запуска вычислений в реакторе.

В дальнешем, скорее всего, у реакторов появятся настройки допустимой глубины рекурсии и стратегии восстановления, если глубина оказалась-таки превышена (игнорировать/останавливать реактор с ошибкой/вызывать некий callback/и т.д.)
</spoiler>
Помимо реактивных выражений, в реакторах можно в интуитивно-понятном синтаксисе увязывать произвольные события и код их обработки. Для этого предусмотрена конструкция <b>onevent</b>. Данный подход позволяет использовать традиционный событийный подход к UI и в то же время избавляет от необходимости подписываться на события вручную:
<source lang="cpp">
reactor m_uiReactor ()
{
    onevent m_startButton.m_onClicked ()
    {
        // handle start button click...
    }

    onevent (bindingof (m_userEdit.m_text), bindingof (m_passwordEdit.m_text)) ()
    {
        // handle login change...
    }

    // ...
}
</source>
При останове реактор отписывается от всех событий, на которые подписан (если реактор является членом класса, то останов автоматически происходит в момент разрушения родительского объекта). Таким образом, разработчик имеет возможность детально определять и <b>где</b> использовать реактивный подход (зоны реакторов), и <b>когда</b> (старт/стоп). Все неявные подписки собраны воедино и сделать сакраментальное <b>"горшочек не вари"</b> очень легко:
<source lang="cpp">
m_uiReactor.stop ();
</source>
При этом, разумеется, может быть несколько реакторов, использующих одни и те же связываемые свойства и другие события -- если это требуется для логической группировки зависимостей в некие кластеры.

<h1>Сводим всё воедино</h1>
Итак, у нас есть все кубики для того, чтобы собирать из них красивые фреймворки пользовательского интерфейса и использовать их в реактивном стиле:
<spoiler title="Несколько UI-классов"><source lang="cpp">
class Widget
{
    bitflag enum SizePolicyFlag
    {
        Grow,
        Expand,
        Shrink,
        Ignore,
    }

    enum SizePolicy
    {
        Fixed = 0,
        Minimum = SizePolicyFlag.Grow,
        Maximum = SizePolicyFlag.Shrink,
        Preferred = SizePolicyFlag.Grow | SizePolicyFlag.Shrink,
        MinimumExpanding = SizePolicyFlag.Grow | SizePolicyFlag.Expand,
        Expanding = SizePolicyFlag.Grow| SizePolicyFlag.Shrink | SizePolicyFlag.Expand,
        Ignored = SizePolicyFlag.Shrink | SizePolicyFlag.Grow | SizePolicyFlag.Ignore
    }

    protected intptr m_handle;
    
    SizePolicy readonly m_hsizePolicy;
    SizePolicy readonly m_vsizePolicy;

    setSizePolicy (
        SizePolicy hpolicy,
        SizePolicy vpolicy
        );
    
    bool autoget property m_isVisible;
    bool autoget property m_isEnabled;
}

opaque class Label: Widget
{
    bitflag enum Alignment
    {
        Left,
        Right,
        HCenter,
        Justify,
        Absolute,
        Top,
        Bottom,
        VCenter,
    }

    char const* autoget property m_text;
    int autoget property m_color;
    int autoget property m_backColor;
    Alignment autoget property m_alignment;

    Label* operator new (char const* text);
}

opaque class Button: Widget
{
    char const* autoget property m_text;
    event m_onClicked ();

    Button* operator new (char const* text);
}

opaque class CheckBox: Widget
{
    char const* autoget property m_text;
    bool bindable property m_isChecked;

    CheckBox* operator new (char const* text);
}

opaque class TextEdit: Widget
{
    char const* property m_text;

    TextEdit* operator new ();
}

opaque class Slider: Widget
{
    int autoget property m_minimum;
    int autoget property m_maximum;
    int bindable property m_value;

    Slider* operator new (
        int minimum = 0,
        int maximum = 100
        );
}
</source></spoiler>
<spoiler title="И их использование из реактора"><source lang="cpp">
Slider* g_redSlider;
Slider* g_greenSlider;
Slider* g_blueSlider;

int bindable g_color;

Label* g_colorLabel;

CheckBox* g_enablePrintCheckBox;
TextEdit* g_textEdit;
Button* g_printButton;

int calcColorVolume (int color)
{
    return 
        (color & 0xff) + 
        ((color >> 8) & 0xff) + 
        ((color >> 16) & 0xff);
}

reactor g_uiReactor ()
{
    g_color = 
        (g_redSlider.m_value << 16) |
        (g_greenSlider.m_value << 8) |
        (g_blueSlider.m_value);

    g_colorLabel.m_text = $"#$(g_color;06x)";       
    g_colorLabel.m_backColor = g_color;
    g_colorLabel.m_color = calcColorVolume (g_color) > 0x180 ? 0x000000 : 0xffffff;

    g_textEdit.m_isEnabled = g_enablePrintCheckBox.m_isChecked;
    g_printButton.m_isEnabled = g_enablePrintCheckBox.m_isChecked;

    onevent g_printButton.m_onClicked ()
    {
        printf ($"> $(g_textEdit.m_text)\n");
    }
}
</source></spoiler>
Уважаемые хабровчане приглашаются на <a href="http://tibbo.com/jancy/live_demo.html">живую страничку</a> нашего компилятора, чтобы опробовать реактивные возможности Jancy без необходимости что-либо скачивать, устанавливать или собирать. 

Желающие таки скачать и cобрать/просто покопаться в исходниках Jancy, могут сделать это со <a href="http://tibbo.com/jancy/downloads.html">странички скачивания</a>. Кстати, в папке samples/02_dialog лежит приведённый чуть выше пример навешивания реактивности на QT-виджеты.

А на реальное применение Jancy и его реактивных возможностей можно посмотреть в нашем программируемом терминале/сниффере <a href="http://tibbo.com/ioninja/">IO Ninja</a>.
