.. include:: def.rst
.. index:: pair: group; Core RTL
.. _doxid-group_rtl_core:

Core RTL
========

.. toctree::
	:hidden:

	class_jnc_DynamicLib.rst
	class_jnc_Scheduler.rst

Overview
~~~~~~~~

This section describes the core RTL types and facilities. :ref:`More...<details-group_rtl_core>`


.. ref-code-block:: jancy
	:class: doxyrest-overview-code-block

	
	// classes

	class :ref:`jnc.DynamicLib<doxid-type_jnc_dynamiclib>`;
	class :ref:`jnc.Scheduler<doxid-type_jnc_scheduler>`;

	// global functions

	void* :target:`jnc.createDataPtr<doxid-function_jnc_createdataptr>`(
		void thin* p,
		:ref:`size_t<doxid-typedef_size_t>` length = - 1
		);

	void const* :target:`jnc.createDataPtr<doxid-function_jnc_createdataptr_2>`(
		void const thin* p,
		:ref:`size_t<doxid-typedef_size_t>` length = - 1
		);

	void :ref:`jnc.resetDynamicLayout<doxid-function_jnc_resetdynamiclayout>`(void const* p);

.. _details-group_rtl_core:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

This section describes the core RTL types and facilities.

Global Functions
----------------

.. index:: pair: function; resetDynamicLayout
.. _doxid-function_jnc_resetdynamiclayout:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void jnc.resetDynamicLayout(void const* p)

Clears the cache of dynamically calculated offsets inside a
``dynamic struct``.

Jancy runtime optimizes access to dynamic structures by caching the
calucated offsets of dynamic fields. The cache is stored inside a buffer
itself(as part of jnc.Box, not as part of a dynamic pointer). Therefore,
it's necessary to drop this cache if you are about to re-use the same buffer
by re-writing it with another block of memory and analyzing it agani with
dynamic structures.

Note that dropping the cache is not required if you just want to analyze the
same buffer with other ``dynamic struct`` pointers -- the cache is smart
enough to distinguish between multiple dynamic structure types.

.. rubric:: Sample code:

.. ref-code-block::

	dynamic struct HeaderA
	{
		// ...
	};

	dynamic struct HeaderB
	{
		// ...
	};

	char buffer[1024];

	file.read(buffer, sizeof(buffer));

	HeaderA const* a = (HeaderA const*) buffer;

	// access the buffer via dynamic struct A...

	file.read(buffer, sizeof(buffer));

	// we need to drop the previous cache -- otherwise,
	// Jancy runtime will re-use pre-calculated offsets.
	// that, obviously, will yield wrong resultts (the data is different)

	jnc.resetDynamicLayout(buffer);

	HeaderA const* a = (HeaderA const*) buffer;

	// access the buffer via dynamic struct A...

	// no need to drop cache before accessing the same
	// buffer with a different dynamic struct pointer

	HeaderB const* b = (HeaderB const*) buffer;

