<md>

# Compiler Overview

The Jancy compiler uses a lexical analyzer generated by [Ragel](http://www.complang.org/ragel/) (a universal finite state machine compiler). It is perfectly suited for building lexers due to the convenience and expressiveness of its input language and, even more importantly, the unbeatable performance of the output code. 

On the backend, Jancy uses [LLVM](http://llvm.org), which offers a reliable optimizer and native code generator for a wide variety of platforms. LLVM also significantly simplifies the process of ensuring ABI compatibility with C/C++.

As for the syntax analyzer we use our own <s>wheel</s> generator of table-driven top-down LL parsers called Bulldozer. Read the [Bulldozer page](compiler_architecture/bulldozer.html) for some thoughts on why we settled on this approach.

The output of the parser is LLVM IR without intermediate generation of an AST: Unlike with bottom-up parsers, in top-down parsers it is rather convenient to perform semantic analysis and generate IR in parallel while parsing, i.e. while the parser is matching the grammar rules.

Jancy grammar belongs to context-sensitive LL(2). 

Syntactic/semantic analysis is performed in multiple passes (mostly two, with some rules requiring three passes). This, however, does not mean that the source is re-tokenized multiple times. The second pass is needed to allow the usage of global entities (namespaces, types, variables, functions and properties) before their declaration, which might be "below" or even reside in a separate compilation unit. The third pass is necessary for the preliminary calculation of reactor class layouts.

---
Proceed to [Bulldozer page](compiler_architecture/bulldozer.html)

</md>
