<md>

# Formatting Literals

Jancy has three kinds of literals.

The first kind is the good old C-style literal. It defines a statically allocated const char array.

<div class='new_frame snippet'>
<code name="jancy">

char a [] = "hello world";

</code>
</div>

<br>
The second kind is the hex literal. This kind of literals allows for a nice and clean way of defining in-program const binary data blocks (i.e. icons, public keys etc) Just like C-literals, hex literals define a statically allocated const char array.

<div class='new_frame snippet'>
<code name="jancy">

char b [] = 0x"61 62 63 20 64 65 66 00";  
// same as: char b [] = { 0x61, 0x62, 0x63, 0x20, 0x64, 0x65, 0x66, 0x00  }

</code>
</div>

<br>
Literals of the third kind bring Perl-style formatting into our C-family language. This type of literals produces a dynamically allocated char array on the GC heap.

<div class='new_frame snippet'>
<code name="jancy">

int i = 100;	

char const* c = $"i = $i";

</code>
</div>

<br>
Jancy allows the use of expressions and printf-style formatting:

<div class='new_frame snippet'>
<code name="jancy">

int i = 100;	
char a [] = "hello world";
uint_t h = 0xbeef;

char const* c = $"i = $i; a [6] = $(a [6], c); h = 0x$(h, 08x)";

</code>
</div>

<br>
All literal types can be concatenated and combined.
If the combination does not include formatting literals, then the result is a statically allocated const char array. If the combination includes formatting literals then it will produce a dynamically allocated char array on the GC heap:

<div class='new_frame snippet'>
<code name="jancy">

int i = 100;	
char a [] = "hello world";

char const* c = 
	0x"61 62 63" 
	" ...concatenated to... " 
	$"i = $i; a = $a; " 
	0x"64 65 66" 
	" ...end."
	);	

</code>
</div>

---
Proceed to Jancy [flag enums](fenums.html)
</md>
