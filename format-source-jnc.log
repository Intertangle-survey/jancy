----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\00_HelloWorld.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("hello world!\n");
[+] 	printf("hello world!\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\01_Classes.jnc
----------------------
[-] 	static int m_table [10];
[+] 	static int m_table[10];
[-] 	static construct ();
[+] 	static construct();
[-] 	preconstruct ()
[+] 	preconstruct()
[-] 		printf ("C1.preconstruct ()\n");
[+] 		printf("C1.preconstruct ()\n");
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	construct (
[+] 	construct(
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] C1.static construct ()
[+] C1.static construct()
[-] 	printf ("C1.static construct ()\n");
[+] 	printf("C1.static construct ()\n");
[-] 	for (int i = 0; i < countof (m_table); i++)
[+] 	for (int i = 0; i < countof(m_table); i++)
[-] 		m_table [i] = i;
[+] 		m_table[i] = i;
[-] C1.construct (
[+] C1.construct(
[-] 	printf ("C1.construct (%d, %d)\n", x, y);
[+] 	printf("C1.construct (%d, %d)\n", x, y);
[-] 	printf ("C1.operator += (%d)\n", d);
[+] 	printf("C1.operator += (%d)\n", d);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	C1 c (100, 200);
[+] 	C1 c(100, 200);
[-] 	printf ("c = { %d, %d }\n", c.m_x, c.m_y);
[+] 	printf("c = { %d, %d }\n", c.m_x, c.m_y);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\02_Inheritance.jnc
----------------------
[-] 	abstract foo ();
[+] 	abstract foo();
[-] 	construct (int a)
[+] 	construct(int a)
[-] 		printf ("C1.construct (%d)\n", a);
[+] 		printf("C1.construct (%d)\n", a);
[-] 	override foo ()
[+] 	override foo()
[-] 		printf ("C1.foo ()\n");
[+] 		printf("C1.foo ()\n");
[-] 	abstract bar ();
[+] 	abstract bar();
[-] 	abstract baz (
[+] 	abstract baz(
[-] 	construct (int a)
[+] 	construct(int a)
[-] 		printf ("C2.construct (%d)\n", a);
[+] 		printf("C2.construct (%d)\n", a);
[-] 	override bar ()
[+] 	override bar()
[-] 		printf ("C2.bar ()\n");
[+] 		printf("C2.bar ()\n");
[-] 	override baz (
[+] 	override baz(
[-] 		printf ("C2.baz (%d, %d)\n", x, y);
[+] 		printf("C2.baz (%d, %d)\n", x, y);
[-] 	construct (int a);
[+] 	construct(int a);
[-] 	override baz (
[+] 	override baz(
[-] C3.construct (int a)
[+] C3.construct(int a)
[-] 	basetype1.construct (a * 10);
[+] 	basetype1.construct(a * 10);
[-] 	C2.construct (a * 100);
[+] 	C2.construct(a * 100);
[-] 	printf ("C3.construct (%d)\n", a);
[+] 	printf("C3.construct (%d)\n", a);
[-] override C3.baz (
[+] override C3.baz(
[-] 	printf ("C3.baz (%d, %d)\n", x, y);
[+] 	printf("C3.baz (%d, %d)\n", x, y);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	C3 c (7);
[+] 	C3 c(7);
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.bar ();
[+] 	c.bar();
[-] 	c.baz (20, 30);
[+] 	c.baz(20, 30);
[-] 	printf ("c = { %d, %d }\n", c.m_x, c.m_y);
[+] 	printf("c = { %d, %d }\n", c.m_x, c.m_y);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\03_Storage.jnc
----------------------
[-] 	construct (int x)
[+] 	construct(int x)
[-] 		printf ("C1.construct (%d)\n", x);
[+] 		printf("C1.construct (%d)\n", x);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct (%d)\n", m_memberField);
[+] 		printf("C1.destruct (%d)\n", m_memberField);
[-] 	construct (int x)
[+] 	construct(int x)
[-] 		m_classField.construct (x);
[+] 		m_classField.construct(x);
[-] 		printf ("C2.construct (%d)\n", x);
[+] 		printf("C2.construct (%d)\n", x);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C2.destruct (%d)\n", m_classField.m_memberField);
[+] 		printf("C2.destruct (%d)\n", m_classField.m_memberField);
[-] C1 g_classGlobal construct (10);
[+] C1 g_classGlobal construct(10);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	C2 c1 (1000);
[+] 	C2 c1(1000);
[-] 	static C2 c2 (2000);
[+] 	static C2 c2(2000);
[-] 	C2* c4 = new C2 (4000);
[+] 	C2* c4 = new C2(4000);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\05_WeakClassPtr.jnc
----------------------
[-] 	construct (int x)
[+] 	construct(int x)
[-] 		printf ("C1.construct (%d)\n", x);
[+] 		printf("C1.construct (%d)\n", x);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	C1* c = new C1 (10);
[+] 	C1* c = new C1(10);
[-] 	printf ("gc run...\n");
[+] 	printf("gc run...\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
[-] 		printf ("object survived the GC run\n");
[+] 		printf("object survived the GC run\n");
[-] 		printf ("object was collected during the GC run\n");
[+] 		printf("object was collected during the GC run\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\10_DataPtrRange.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int a [] = { 10, 20, 30 }
[+] 	int a[] = { 10, 20, 30 }
[-] 	int* end = p + countof (a);
[+] 	int* end = p + countof(a);
[-] 		printf ("*p = %d\n", *p);
[+] 		printf("*p = %d\n", *p);
[-] 	for (i = 0; i < countof (a); i++)
[+] 	for (i = 0; i < countof(a); i++)
[-] 		printf ("a [%d] = %d\n", i, a [i]);
[+] 		printf("a [%d] = %d\n", i, a [i]);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\12_ConstCorrectness.jnc
----------------------
[-] transpose (
[+] transpose(
[-] 	printf ("transpose (%d, %d)\n", src.m_x, src.m_y);
[+] 	printf("transpose (%d, %d)\n", src.m_x, src.m_y);
[-] 	foo () const
[+] 	foo() const
[-] 		printf ("C1.foo () { m_field = %d }\n", m_field);
[+] 		printf("C1.foo () { m_field = %d }\n", m_field);
[-] 	bar (int x)
[+] 	bar(int x)
[-] 		printf ("C1.bar (%d)\n", x);
[+] 		printf("C1.bar (%d)\n", x);
[-] baz (C1 const* p)
[+] baz(C1 const* p)
[-] 	printf ("p.m_x = %d\n", p.m_field);
[+] 	printf("p.m_x = %d\n", p.m_field);
[-] 	p.foo ();
[+] 	p.foo();
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	transpose (&dstPoint, &srcPoint);
[+] 	transpose(&dstPoint, &srcPoint);
[-] 	c.bar (10);
[+] 	c.bar(10);
[-] 	baz (&c);
[+] 	baz(&c);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\13_DynamicCast.jnc
----------------------
[-] foo (TaggedTransform* taggedTransform)
[+] foo(TaggedTransform* taggedTransform)
[-] 	printf (
[+] 	printf(
[-] bar (Vector* vector)
[+] bar(Vector* vector)
[-] 	Transform* transform1 = (Transform*) vector;
[+] 	Transform* transform1 = (Transform*)vector;
[-] 	EulerAngles* angles1 = (EulerAngles*) vector;
[+] 	EulerAngles* angles1 = (EulerAngles*)vector;
[-] 	TaggedTransform* taggedTransform = dynamic (TaggedTransform*) vector;
[+] 	TaggedTransform* taggedTransform = dynamic(TaggedTransform*)vector;
[-] 	Transform* transform2 = dynamic (Transform*) vector;
[+] 	Transform* transform2 = dynamic(Transform*)vector;
[-] 	EulerAngles* angles2 = dynamic (EulerAngles*) vector;
[+] 	EulerAngles* angles2 = dynamic(EulerAngles*)vector;
[-] 	printf (
[+] 	printf(
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo (taggedTransform);
[+] 	foo(taggedTransform);
[-] 	bar (taggedTransform);
[+] 	bar(taggedTransform);
[-] 	bar (transform);
[+] 	bar(transform);
[-] 	bar (vector);
[+] 	bar(vector);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\14_DynamicSizeof.jnc
----------------------
[-] foo (char const* s)
[+] foo(char const* s)
[-] 	printf ("s = '%s'; length = %d\n", s, dynamic sizeof (s) - 1);
[+] 	printf("s = '%s'; length = %d\n", s, dynamic sizeof (s) - 1);
[-] int calcSum (int const* a)
[+] int calcSum(int const* a)
[-] 	size_t count = dynamic countof (a);
[+] 	size_t count = dynamic countof(a);
[-] 		result += a [i];
[+] 		result += a[i];
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo ("dynamic!");
[+] 	foo("dynamic!");
[-] 	int a [] = { 10, 20, 30 }
[+] 	int a[] = { 10, 20, 30 }
[-] 	int sum = calcSum (a);
[+] 	int sum = calcSum(a);
[-] 	printf ("sum = %d\n", sum);
[+] 	printf("sum = %d\n", sum);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\15_DynamicStructs.jnc
----------------------
[-] 	Section m_sectionTable [m_sectionCount];
[+] 	Section m_sectionTable[m_sectionCount];
[-] 	char m_authorName [strlen (m_authorName) + 1];
[+] 	char m_authorName[strlen(m_authorName) + 1];
[-] 	char m_authorEmail [strlen (m_authorEmail) + 1];
[+] 	char m_authorEmail[strlen(m_authorEmail) + 1];
[-] printFileHdr (FileHdr const* hdr)
[+] printFileHdr(FileHdr const* hdr)
[-] 	printf (
[+] 	printf(
[-] 		dynamic sizeof (*hdr)
[+] 		dynamic sizeof(*hdr)
[-] 		char const* section = data + hdr.m_sectionTable [i].m_offset;
[+] 		char const* section = data + hdr.m_sectionTable[i].m_offset;
[-] 		printf ("section [%d]: %s\n", i, section);
[+] 		printf("section [%d]: %s\n", i, section);
[-] int main ()
[+] int main()
[-] 	char buffer [] =
[+] 	char buffer[] =
[-] 	printf ("sizeof (buffer): %d\n", sizeof (buffer));
[+] 	printf("sizeof (buffer): %d\n", sizeof (buffer));
[-] 	printFileHdr ((FileHdr const*) buffer);
[+] 	printFileHdr((FileHdr const*) buffer);
[-] 	printf ("-----------------\n");
[+] 	printf("-----------------\n");
[-] 	std.resetDynamicLayout (buffer);
[+] 	std.resetDynamicLayout(buffer);
[-] 	FileHdr* hdr = (FileHdr*) buffer;
[+] 	FileHdr* hdr = (FileHdr*)buffer;
[-] 	strcpy (hdr.m_authorName, "Jane Doe");
[+] 	strcpy(hdr.m_authorName, "Jane Doe");
[-] 	strcpy (hdr.m_authorEmail, "jane.doe@gmail.com");
[+] 	strcpy(hdr.m_authorEmail, "jane.doe@gmail.com");
[-] 	strcpy ((char*) (hdr + 1), "SECTION-0");
[+] 	strcpy((char*)(hdr + 1), "SECTION-0");
[-] 	printFileHdr (hdr);
[+] 	printFileHdr(hdr);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\20_FunctionPtr.jnc
----------------------
[-] 	foo (
[+] 	foo(
[-] 		printf ("C1.foo (%d, %d, %d) { m_x = %d }\n", a, b, c, m_x);
[+] 		printf("C1.foo (%d, %d, %d) { m_x = %d }\n", a, b, c, m_x);
[-] bar (
[+] bar(
[-] 	printf ("bar (%d, %d)\n", a, b);
[+] 	printf("bar (%d, %d)\n", a, b);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	function thin* f1 (
[+] 	function thin* f1(
[-] 	f1 (10, 20);
[+] 	f1(10, 20);
[-] 	typedef function FpFunc (
[+] 	typedef function FpFunc(
[-] 	f2 (15.8, 7.1);
[+] 	f2(15.8, 7.1);
[-] 	function* f3 (
[+] 	function* f3(
[-] 	f3 (100, 200, 300);
[+] 	f3(100, 200, 300);
[-] 	function* f4 (int) = bar ~(5);
[+] 	function* f4(int) = bar ~(5);
[-] 	f4 (6);
[+] 	f4(6);
[-] 	function* f5 (
[+] 	function* f5(
[-] 	f5 (1, 2);
[+] 	f5(1, 2);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\21_WeakFunctionPtr.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] 	foo (
[+] 	foo(
[-] 		printf ("C1.foo (%d, %d, %d) { m_x = %d }\n", a, b, c, m_x);
[+] 		printf("C1.foo (%d, %d, %d) { m_x = %d }\n", a, b, c, m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	function weak* wf (int, int) = c.foo ~(,, 3);
[+] 	function weak* wf(int, int) = c.foo ~(,, 3);
[-] 	printf ("gc run...\n");
[+] 	printf("gc run...\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
[-] 	function* f (int, int) = wf;
[+] 	function* f(int, int) = wf;
[-] 		printf ("object survived the GC run\n");
[+] 		printf("object survived the GC run\n");
[-] 		f (1, 2);
[+] 		f(1, 2);
[-] 		printf ("object was collected during the GC run\n");
[+] 		printf("object was collected during the GC run\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\22_ScheduleOperator.jnc
----------------------
[-] 	override schedule (function* f ())
[+] 	override schedule(function* f())
[-] 		printf ("lock before call...\n");
[+] 		printf("lock before call...\n");
[-] 		f ();
[+] 		f();
[-] 		printf ("unlock after call...\n");
[+] 		printf("unlock after call...\n");
[-] foo (
[+] foo(
[-] 	function* completionFunc (
[+] 	function* completionFunc(
[-] 		printf ("working, %2d%%...\n", i);
[+] 		printf("working, %2d%%...\n", i);
[-] 	completionFunc (a, b);
[+] 	completionFunc(a, b);
[-] bar (int x)
[+] bar(int x)
[-] 	printf ("bar (%d)\n", x);
[+] 	printf("bar (%d)\n", x);
[-] onComplete (
[+] onComplete(
[-] 	printf ("onComplete (%d, %d)\n", a, b);
[+] 	printf("onComplete (%d, %d)\n", a, b);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	function* completionFunc (
[+] 	function* completionFunc(
[-] 	foo (10, 20, completionFunc);
[+] 	foo(10, 20, completionFunc);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\23_Multicasts.jnc
----------------------
[-] foo (int x)
[+] foo(int x)
[-] 	printf ("foo (%d)\n", x);
[+] 	printf("foo (%d)\n", x);
[-] bar (
[+] bar(
[-] 	printf ("bar (%d, %d)\n", x, y);
[+] 	printf("bar (%d, %d)\n", x, y);
[-] baz (int x)
[+] baz(int x)
[-] 	printf ("baz (%d)\n", x);
[+] 	printf("baz (%d)\n", x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	multicast m (int);
[+] 	multicast m(int);
[-] 	printf ("multicast call #1...\n");
[+] 	printf("multicast call #1...\n");
[-] 	m (5);
[+] 	m(5);
[-] 	event* e (int) = m;
[+] 	event* e(int) = m;
[-] 	printf ("multicast call #2...\n");
[+] 	printf("multicast call #2...\n");
[-] 	m (15);
[+] 	m(15);
[-] 	m.clear ();
[+] 	m.clear();
[-] 	intptr_t cookie1 = e.add (foo);
[+] 	intptr_t cookie1 = e.add(foo);
[-] 	intptr_t cookie2 = e.add (bar ~(, 2000));
[+] 	intptr_t cookie2 = e.add(bar ~(, 2000));
[-] 	printf ("multicast call #3...\n");
[+] 	printf("multicast call #3...\n");
[-] 	m (25);
[+] 	m(25);
[-] 	printf ("multicast call #4...\n");
[+] 	printf("multicast call #4...\n");
[-] 	m (35);
[+] 	m(35);
[-] 	function* f1 (int) = m.getSnapshot ();
[+] 	function* f1(int) = m.getSnapshot();
[-] 	function* f2 (int) = m;
[+] 	function* f2(int) = m;
[-] 	printf ("snapshot pointer call...\n");
[+] 	printf("snapshot pointer call...\n");
[-] 	f1 (45);
[+] 	f1(45);
[-] 	printf ("live pointer call...\n");
[+] 	printf("live pointer call...\n");
[-] 	f2 (55);
[+] 	f2(55);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\24_WeakMulticasts.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] 	foo ()
[+] 	foo()
[-] 		printf ("C1.foo () { m_x = %d }\n", m_x);
[+] 		printf("C1.foo () { m_x = %d }\n", m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	weak multicast wm ();
[+] 	weak multicast wm();
[-] 	printf ("gc run...\n");
[+] 	printf("gc run...\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
[-] 	printf ("calling weak multicast...\n");
[+] 	printf("calling weak multicast...\n");
[-] 	wm ();
[+] 	wm();
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\30_SimplePropertyDecl.jnc
----------------------
[-] int g_simpleProp.get ()
[+] int g_simpleProp.get()
[-] 	printf ("g_simpleProp.get ()\n");
[+] 	printf("g_simpleProp.get ()\n");
[-] 	return rand () % 3;
[+] 	return rand() % 3;
[-] g_simpleProp.set (int x)
[+] g_simpleProp.set(int x)
[-] 	printf ("g_simpleProp.set (%d)\n", x);
[+] 	printf("g_simpleProp.set (%d)\n", x);
[-] int g_simpleReadOnlyProp.get ()
[+] int g_simpleReadOnlyProp.get()
[-] 	printf ("g_simpleReadOnlyProp.get ()\n");
[+] 	printf("g_simpleReadOnlyProp.get ()\n");
[-] 	return rand () % 3;
[+] 	return rand() % 3;
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\31_FullPropertyDecl.jnc
----------------------
[-] 	int get ()
[+] 	int get()
[-] 		printf ("g_prop.get ()\n");
[+] 		printf("g_prop.get ()\n");
[-] 	set (int x);
[+] 	set(int x);
[-] 	set (double x);
[+] 	set(double x);
[-] 	update ()
[+] 	update()
[-] 		printf ("g_prop.update ()\n");
[+] 		printf("g_prop.update ()\n");
[-] g_prop.set (int x)
[+] g_prop.set(int x)
[-] 	printf ("g_prop.set (int %d)\n", x);
[+] 	printf("g_prop.set (int %d)\n", x);
[-] 	update ();
[+] 	update();
[-] g_prop.set (double x)
[+] g_prop.set(double x)
[-] 	printf ("g_prop.set (double %f)\n", x);
[+] 	printf("g_prop.set (double %f)\n", x);
[-] 	m_x = (int) x;
[+] 	m_x = (int)x;
[-] 	update ();
[+] 	update();
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\32_IndexedProperties.jnc
----------------------
[-] int property g_simpleProp (size_t i);
[+] int property g_simpleProp(size_t i);
[-] int g_simpleProp.get (size_t i)
[+] int g_simpleProp.get(size_t i)
[-] 	printf ("g_simpleProp.get (%d)\n", i);
[+] 	printf("g_simpleProp.get (%d)\n", i);
[-] 	return g_x [i];
[+] 	return g_x[i];
[-] g_simpleProp.set (
[+] g_simpleProp.set(
[-] 	printf ("g_simpleProp.set (%d, %d)\n", i, x);
[+] 	printf("g_simpleProp.set (%d, %d)\n", i, x);
[-] 	g_x [i] = x;
[+] 	g_x[i] = x;
[-] int g_x [2];
[+] int g_x[2];
[-] 	int m_x [2] [2];
[+] 	int m_x[2] [2];
[-] 	int get (
[+] 	int get(
[-] 		printf ("g_prop.get (%d, %d)\n", i, j);
[+] 		printf("g_prop.get (%d, %d)\n", i, j);
[-] 		return m_x [i] [j];
[+] 		return m_x[i] [j];
[-] 	set (
[+] 	set(
[-] 		printf ("g_prop.set (%d, %d, int %d)\n", i, j, x);
[+] 		printf("g_prop.set (%d, %d, int %d)\n", i, j, x);
[-] 		m_x [i] [j] = x;
[+] 		m_x[i] [j] = x;
[-] 	set (
[+] 	set(
[-] 		printf ("g_prop.set (%d, %d, double %f)\n", i, j, x);
[+] 		printf("g_prop.set (%d, %d, double %f)\n", i, j, x);
[-] 		m_x [i] [j] = (int) x;
[+] 		m_x[i] [j] = (int)x;
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int x = g_simpleProp [0];
[+] 	int x = g_simpleProp[0];
[-] 	g_simpleProp [0] = 100;
[+] 	g_simpleProp[0] = 100;
[-] 	g_simpleProp [1] = 200;
[+] 	g_simpleProp[1] = 200;
[-] 	x = g_prop [1] [1];
[+] 	x = g_prop[1] [1];
[-] 	g_prop [0] [1] = 500;
[+] 	g_prop[0] [1] = 500;
[-] 	g_prop [1] [0] = 1.5;
[+] 	g_prop[1] [0] = 1.5;
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\33_AutoGetProperties.jnc
----------------------
[-] g_simpleProp.set (int x)
[+] g_simpleProp.set(int x)
[-] 	printf ("g_simpleProp.set (%d)\n", x);
[+] 	printf("g_simpleProp.set (%d)\n", x);
[-] 	set (int x)
[+] 	set(int x)
[-] 		printf ("g_prop.set (int %d)\n", x);
[+] 		printf("g_prop.set (int %d)\n", x);
[-] 	set (double x)
[+] 	set(double x)
[-] 		printf ("g_prop.set (double %f)\n", x);
[+] 		printf("g_prop.set (double %f)\n", x);
[-] 		m_x = (int) x;
[+] 		m_x = (int)x;
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("x = %d\n", x);
[+] 	printf("x = %d\n", x);
[-] 	printf ("x = %d\n", x);
[+] 	printf("x = %d\n", x);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\34_BindableProperties.jnc
----------------------
[-] g_simpleProp.set (int x)
[+] g_simpleProp.set(int x)
[-] 	printf ("g_simpleProp.set (%d)\n", x);
[+] 	printf("g_simpleProp.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] 	bindable event m_e ();
[+] 	bindable event m_e();
[-] 	set (int x);
[+] 	set(int x);
[-] 	set (double x);
[+] 	set(double x);
[-] g_prop.set (int x)
[+] g_prop.set(int x)
[-] 	printf ("g_prop.set (int %d)\n", x);
[+] 	printf("g_prop.set (int %d)\n", x);
[-] 	m_e ();
[+] 	m_e();
[-] g_prop.set (double x)
[+] g_prop.set(double x)
[-] 	printf ("g_prop.set (double %f)\n", x);
[+] 	printf("g_prop.set (double %f)\n", x);
[-] 	if (m_x == (int) x)
[+] 	if (m_x == (int)x)
[-] 	m_x = (int) x;
[+] 	m_x = (int)x;
[-] 	m_e ();
[+] 	m_e();
[-] onSimplePropChanged ()
[+] onSimplePropChanged()
[-] 	printf ("g_simpleProp has changed (new value = %d)\n", g_simpleProp);
[+] 	printf("g_simpleProp has changed (new value = %d)\n", g_simpleProp);
[-] onPropChanged ()
[+] onPropChanged()
[-] 	printf ("g_prop has changed (new value = %d)\n", g_prop);
[+] 	printf("g_prop has changed (new value = %d)\n", g_prop);
[-] onDataChanged ()
[+] onDataChanged()
[-] 	printf ("g_data has changed (new value = %d)\n", g_data);
[+] 	printf("g_data has changed (new value = %d)\n", g_data);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	bindingof (g_simpleProp) += onSimplePropChanged;
[+] 	bindingof(g_simpleProp) += onSimplePropChanged;
[-] 	bindingof (g_prop) += onPropChanged;
[+] 	bindingof(g_prop) += onPropChanged;
[-] 	bindingof (g_data) += onDataChanged;
[+] 	bindingof(g_data) += onDataChanged;
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\35_PropertyPtr.jnc
----------------------
[-] g_foo.set (int x)
[+] g_foo.set(int x)
[-] 	printf ("g_foo.set (%d)\n", x);
[+] 	printf("g_foo.set (%d)\n", x);
[-] int property g_baz (
[+] int property g_baz(
[-] int g_baz.get (
[+] int g_baz.get(
[-] 	printf ("g_baz.get (%d, %d)\n", i, j);
[+] 	printf("g_baz.get (%d, %d)\n", i, j);
[-] 	return g_bazTable [i] [j];
[+] 	return g_bazTable[i] [j];
[-] g_baz.set (
[+] g_baz.set(
[-] 	printf ("g_baz.set (%d, %d, %d)\n", i, j, x);
[+] 	printf("g_baz.set (%d, %d, %d)\n", i, j, x);
[-] 	g_bazTable [i] [j] = x;
[+] 	g_bazTable[i] [j] = x;
[-] int g_bazTable [2] [2];
[+] int g_bazTable[2] [2];
[-] 	m_bar.set (int x)
[+] 	m_bar.set(int x)
[-] 		printf ("C1.m_bar.set (%d)\n", x);
[+] 		printf("C1.m_bar.set (%d)\n", x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int property* p4 = &(g_baz [0] [1]);
[+] 	int property* p4 = &(g_baz[0] [1]);
[-] 	int indexed property* p5 (size_t) = &(g_baz [] [0]);
[+] 	int indexed property* p5(size_t) = &(g_baz[] [0]);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\36_WeakPropertyPtr.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] 	m_foo.set (int x)
[+] 	m_foo.set(int x)
[-] 		printf ("C1.m_foo.set (%d)\n", x);
[+] 		printf("C1.m_foo.set (%d)\n", x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("gc run...\n");
[+] 	printf("gc run...\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
[-] 		printf ("object survived gc run\n");
[+] 		printf("object survived gc run\n");
[-] 		printf ("object was collected during gc run\n");
[+] 		printf("object was collected during gc run\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\40_Reactors.jnc
----------------------
[-] updatePurple (
[+] updatePurple(
[-] 	printf ("updatePurple (%x, %x, %x)\n", red, blue, alpha);
[+] 	printf("updatePurple (%x, %x, %x)\n", red, blue, alpha);
[-] updateYellow (
[+] updateYellow(
[-] 	printf ("updateYellow (%x, %x, %x)\n", red, green, alpha);
[+] 	printf("updateYellow (%x, %x, %x)\n", red, green, alpha);
[-] updateCyan (
[+] updateCyan(
[-] 	printf ("updateCyan (%x, %x, %x)\n", green, blue, alpha);
[+] 	printf("updateCyan (%x, %x, %x)\n", green, blue, alpha);
[-] 	updatePurple (g_red, g_blue, g_alpha);
[+] 	updatePurple(g_red, g_blue, g_alpha);
[-] 	updateYellow (g_red, g_green, g_alpha);
[+] 	updateYellow(g_red, g_green, g_alpha);
[-] 	updateCyan (g_green, g_blue, g_alpha);
[+] 	updateCyan(g_green, g_blue, g_alpha);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	g_colorReactor.start ();
[+] 	g_colorReactor.start();
[-] 	printf ("changing g_red...\n");
[+] 	printf("changing g_red...\n");
[-] 	printf ("changing g_green...\n");
[+] 	printf("changing g_green...\n");
[-] 	printf ("changing g_blue...\n");
[+] 	printf("changing g_blue...\n");
[-] 	printf ("changing g_alpha...\n");
[+] 	printf("changing g_alpha...\n");
[-] 	printf ("g_rgb = #%06x\n", g_rgb);
[+] 	printf("g_rgb = #%06x\n", g_rgb);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\41_OnEventStmt.jnc
----------------------
[-] event g_onApplyIpSettings ();
[+] event g_onApplyIpSettings();
[-] 	onevent bindingof (g_useDhcp) ()
[+] 	onevent bindingof(g_useDhcp)()
[-] 			printf ("using DHCP, disable IP-edit\n");
[+] 			printf("using DHCP, disable IP-edit\n");
[-] 			printf ("using manual IP configuration\n");
[+] 			printf("using manual IP configuration\n");
[-] 	onevent (bindingof (g_ip4), bindingof (g_routerIp4)) ()
[+] 	onevent(bindingof(g_ip4), bindingof(g_routerIp4)) ()
[-] 		printf ("IP or router IP has changed\n");
[+] 		printf("IP or router IP has changed\n");
[-] 	onevent g_onApplyIpSettings ()
[+] 	onevent g_onApplyIpSettings()
[-] 			printf ("applying %d%%...\n", i);
[+] 			printf("applying %d%%...\n", i);
[-] 		printf ("done!\n");
[+] 		printf("done!\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	g_ipReactor.start ();
[+] 	g_ipReactor.start();
[-] 	printf ("turning DHCP on...\n");
[+] 	printf("turning DHCP on...\n");
[-] 	printf ("changing IP...\n");
[+] 	printf("changing IP...\n");
[-] 	printf ("changing router IP...\n");
[+] 	printf("changing router IP...\n");
[-] 	printf ("applying IP settings...\n");
[+] 	printf("applying IP settings...\n");
[-] 	g_onApplyIpSettings ();
[+] 	g_onApplyIpSettings();
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\50_Exceptions.jnc
----------------------
[-] int errorcode foo (int a)
[+] int errorcode foo(int a)
[-] 	printf ("foo (%d)\n", a);
[+] 	printf("foo (%d)\n", a);
[-] 		printf ("argument too high\n");
[+] 		printf("argument too high\n");
[-] 		printf ("argument too low\n");
[+] 		printf("argument too low\n");
[-] int errorcode bar (
[+] int errorcode bar(
[-] 	printf ("bar (%d, %d)\n", a, b);
[+] 	printf("bar (%d, %d)\n", a, b);
[-] 	foo (a);
[+] 	foo(a);
[-] 	foo (b);
[+] 	foo(b);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int error = try bar (1, -150);
[+] 	int error = try bar(1, -150);
[-] 		printf ("bar returned error %d\n", error);
[+] 		printf("bar returned error %d\n", error);
[-] 	bar (2, 3);
[+] 	bar(2, 3);
[-] 	bar (5, 150);
[+] 	bar(5, 150);
[-] 	printf ("some of the throwing functions above returned an error\n");
[+] 	printf("some of the throwing functions above returned an error\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\51_Errors.jnc
----------------------
[-] bool errorcode foo (int a)
[+] bool errorcode foo(int a)
[-] 	printf ("foo (%d)\n", a);
[+] 	printf("foo (%d)\n", a);
[-] 		std.setErrno (1); // EPERM
[+] 		std.setErrno(1); // EPERM
[-] 		std.setError ("invalid argument");
[+] 		std.setError("invalid argument");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	bool result = try foo (-1);
[+] 	bool result = try foo(-1);
[-] 		printf ("foo failed (%s)\n", std.getLastError ().m_description);
[+] 		printf("foo failed (%s)\n", std.getLastError ().m_description);
[-] 	foo (150);
[+] 	foo(150);
[-] 	printf ("error caught (%s)\n", std.getLastError ().m_description);
[+] 	printf("error caught (%s)\n", std.getLastError ().m_description);
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\52_Finally.jnc
----------------------
[-] size_t foo (char const* s)
[+] size_t foo(char const* s)
[-] 	printf ("foo (%s)\n", s);
[+] 	printf("foo (%s)\n", s);
[-] 	size_t count = dynamic sizeof (s);
[+] 	size_t count = dynamic sizeof(s);
[-] 		int c = s [i];
[+] 		int c = s[i];
[-] 			printf ("TAB found at %d\n", i);
[+] 			printf("TAB found at %d\n", i);
[-] 	printf ("TAB not found\n");
[+] 	printf("TAB not found\n");
[-] 	printf ("foo () finalization\n");
[+] 	printf("foo () finalization\n");
[-] bool errorcode bar (int a)
[+] bool errorcode bar(int a)
[-] 	printf ("bar (%d)\n", a);
[+] 	printf("bar (%d)\n", a);
[-] 		std.setErrno (22); // EINVAL
[+] 		std.setErrno(22); // EINVAL
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		foo ("abc");
[+] 		foo("abc");
[-] 		foo ("def\tghi");
[+] 		foo("def\tghi");
[-] 		bar (10);
[+] 		bar(10);
[-] 		bar (-1);
[+] 		bar(-1);
[-] 		printf ("not supposed to get here\n");
[+] 		printf("not supposed to get here\n");
[-] 		printf ("error (%s)\n", std.getLastError ().m_description);
[+] 		printf("error (%s)\n", std.getLastError ().m_description);
[-] 		printf ("try-block finalization\n");
[+] 		printf("try-block finalization\n");
----------------------
27/02/2019 18:02:01 - C:\Projects\repos\ioninja\jancy\samples\jnc\53_Disposable.jnc
----------------------
[-] 	construct (int resource)
[+] 	construct(int resource)
[-] 			printf ("acquire resource #%d...\n", resource);
[+] 			printf("acquire resource #%d...\n", resource);
[-] 	destruct ()
[+] 	destruct()
[-] 		release ();
[+] 		release();
[-] 	release ()
[+] 	release()
[-] 		printf ("release resource #%d...\n", m_resource);
[+] 		printf("release resource #%d...\n", m_resource);
[-] foo ()
[+] foo()
[-] 	printf ("foo is about to throw...\n");
[+] 	printf("foo is about to throw...\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	disposable Resource resource1 (1);
[+] 	disposable Resource resource1(1);
[-] 	disposable Resource resource2 (2);
[+] 	disposable Resource resource2(2);
[-] 	Resource resource3 (3); // this resource will be released non-deterministically
[+] 	Resource resource3(3); // this resource will be released non-deterministically
[-] 	foo ();
[+] 	foo();
[-] 	printf ("exception caught in main\n");
[+] 	printf("exception caught in main\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\60_HexLiterals.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	char a [] = 0x"61 62 63 64 65 66 67 68 00";
[+] 	char a[] = 0x"61 62 63 64 65 66 67 68 00";
[-] 	printf ("a = %s\n", a);
[+] 	printf("a = %s\n", a);
[-] 	char b [] = 0x"696a 6b6c 6D6E 6F70 0000";
[+] 	char b[] = 0x"696a 6b6c 6D6E 6F70 0000";
[-] 	printf ("b = %s\n", b);
[+] 	printf("b = %s\n", b);
[-] 	char c [] = 0x"6a61 6e63 7920" "rocks!";
[+] 	char c[] = 0x"6a61 6e63 7920" "rocks!";
[-] 	printf ("c = %s\n", c);
[+] 	printf("c = %s\n", c);
[-] 	char d [] = "non-zero-terminated" 0x"";
[+] 	char d[] = "non-zero-terminated" 0x"";
[-] 	printf ("sizeof (d) = %d\n", sizeof (d));
[+] 	printf("sizeof (d) = %d\n", sizeof (d));
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\61_FormattingLiterals.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	static Color colorTable [] =
[+] 	static Color colorTable[] =
[-] 	for (size_t i = 0; i < countof (colorTable); i++)
[+] 	for (size_t i = 0; i < countof(colorTable); i++)
[-] 		char const* colorName = colorTable [i].m_name;
[+] 		char const* colorName = colorTable[i].m_name;
[-] 		printf ($"color $i = $colorName\n");
[+] 		printf($"color $i = $colorName\n");
[-] 	size_t i = rand () % countof (colorTable);
[+] 	size_t i = rand() % countof(colorTable);
[-] 	printf ($"random color = $(colorTable [i].m_name)\n");
[+] 	printf($"random color = $(colorTable [i].m_name)\n");
[-] 	printf ($"color value  = #$(colorTable [i].m_value; 06x)\n");
[+] 	printf($"color value  = #$(colorTable [i].m_value; 06x)\n");
[-] 	printf (
[+] 	printf(
[-] 			(colorTable [i].m_value & 0xff0000) >> 16,
[+] 			(colorTable[i].m_value & 0xff0000) >> 16,
[-] 			(colorTable [i].m_value & 0x00ff00) >> 8,
[+] 			(colorTable[i].m_value & 0x00ff00) >> 8,
[-] 			(colorTable [i].m_value & 0x0000ff)
[+] 			(colorTable[i].m_value & 0x0000ff)
[-] 	printf (
[+] 	printf(
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\70_RegExSwitch.jnc
----------------------
[-] bool errorcode fooBar (
[+] bool errorcode fooBar(
[-] 		length = strlen (p);
[+] 		length = strlen(p);
[-] 		reswitch (state, p, end - p)
[+] 		reswitch(state, p, end - p)
[-] 			printf ("lexeme found: foo\n");
[+] 			printf("lexeme found: foo\n");
[-] 			printf ("lexeme found: bar\n");
[+] 			printf("lexeme found: bar\n");
[-] 			printf ("lexeme found: dec '%s'\n", state.m_match.m_text);
[+] 			printf("lexeme found: dec '%s'\n", state.m_match.m_text);
[-] 			assert (state.m_isIncremental && state.m_consumedLength == end - p);
[+] 			assert(state.m_isIncremental && state.m_consumedLength == end - p);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	bool result = try fooBar (state, p);
[+] 	bool result = try fooBar(state, p);
[-] 		printf ("recognition error at: %s\n", p + state.m_currentOffset);
[+] 		printf("recognition error at: %s\n", p + state.m_currentOffset);
[-] 	state.reset ();
[+] 	state.reset();
[-] 		fooBar (state, " ba");
[+] 		fooBar(state, " ba");
[-] 		fooBar (state, "r f");
[+] 		fooBar(state, "r f");
[-] 		fooBar (state, "oo ");
[+] 		fooBar(state, "oo ");
[-] 		fooBar (state, "100");
[+] 		fooBar(state, "100");
[-] 		fooBar (state, "000");
[+] 		fooBar(state, "000");
[-] 		fooBar (state, null);
[+] 		fooBar(state, null);
[-] 		printf ("recognition error\n");
[+] 		printf("recognition error\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\71_MixedLanguageRecognition.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	char s [] = "foo 'bar \\' bar' foo";
[+] 	char s[] = "foo 'bar \\' bar' foo";
[-] 	char* end = p + countof (s) - 1;
[+] 	char* end = p + countof(s) - 1;
[-] 		switch (language)
[+] 		switch(language)
[-] 			reswitch (state, p, end - p)
[+] 			reswitch(state, p, end - p)
[-] 				printf ("lexeme found: foo\n");
[+] 				printf("lexeme found: foo\n");
[-] 			reswitch (state, p, end - p)
[+] 			reswitch(state, p, end - p)
[-] 				printf ("lexeme found: bar\n");
[+] 				printf("lexeme found: bar\n");
[-] 			assert (false);
[+] 			assert(false);
[-] 			printf ("recognition error\n");
[+] 			printf("recognition error\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\80_DualModifiers.jnc
----------------------
[-] 	event m_onCompleted ();
[+] 	event m_onCompleted();
[-] 	work ()
[+] 	work()
[-] 			m_onCompleted ();
[+] 			m_onCompleted();
[-] onCompleted ()
[+] onCompleted()
[-] 	printf ("onCompleted () -- work is finished\n");
[+] 	printf("onCompleted () -- work is finished\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		c.work ();
[+] 		c.work();
[-] 		printf ("progress = %d%%\n", c.m_progress);
[+] 		printf("progress = %d%%\n", c.m_progress);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\81_BitflagEnums.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("color = %d\n", color);
[+] 	printf("color = %d\n", color);
[-] 	printf ("state = %d\n", state);
[+] 	printf("state = %d\n", state);
[-] 	printf ("flags = 0x%x\n", flags);
[+] 	printf("flags = 0x%x\n", flags);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\82_Once.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 		m_x = rand () % 10;
[+] 		m_x = rand() % 10;
[-] int foo ()
[+] int foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] 	return rand () % 10;
[+] 	return rand() % 10;
[-] initSomethingElse ()
[+] initSomethingElse()
[-] 	printf ("initSomethingElse ()\n");
[+] 	printf("initSomethingElse ()\n");
[-] baz (int x)
[+] baz(int x)
[-] 	printf ("baz (%d)\n", x);
[+] 	printf("baz (%d)\n", x);
[-] bar ()
[+] bar()
[-] 	printf ("bar ()\n");
[+] 	printf("bar ()\n");
[-] 	static int x = foo ();
[+] 	static int x = foo();
[-] 	static int a [3];
[+] 	static int a[3];
[-] 		printf ("foo.static once\n");
[+] 		printf("foo.static once\n");
[-] 		for (size_t i = 0; i < countof (a); i++)
[+] 		for (size_t i = 0; i < countof(a); i++)
[-] 			a [i] = (int) i * 10;
[+] 			a[i] = (int)i * 10;
[-] 	once initSomethingElse ();
[+] 	once initSomethingElse();
[-] 	printf ("c.m_x = %d\n", c.m_x);
[+] 	printf("c.m_x = %d\n", c.m_x);
[-] 	printf ("x = %d\n", x);
[+] 	printf("x = %d\n", x);
[-] 	printf ("a = { ");
[+] 	printf("a = { ");
[-] 	for (size_t i = 0; i < countof (a); i++)
[+] 	for (size_t i = 0; i < countof(a); i++)
[-] 		printf ("%d, ", a [i]);
[+] 		printf("%d, ", a [i]);
[-] 	printf ("}\n");
[+] 	printf("}\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	bar ();
[+] 	bar();
[-] 	bar ();
[+] 	bar();
[-] 	bar ();
[+] 	bar();
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\83_BreakN.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int a [3] [4] =
[+] 	int a[3] [4] =
[-] 	for (i = 0; i < countof (a); i++)
[+] 	for (i = 0; i < countof(a); i++)
[-] 		for (j = 0; j < countof (a [0]); j++)
[+] 		for (j = 0; j < countof(a[0]); j++)
[-] 			if (a [i] [j] < 0)
[+] 			if (a[i] [j] < 0)
[-] 		printf ("negative item found at [%d] [%d]: %d\n", i, j, a [i] [j]);
[+] 		printf("negative item found at [%d] [%d]: %d\n", i, j, a [i] [j]);
[-] 		printf ("negative item not found\n");
[+] 		printf("negative item not found\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\84_CurlyInitializers.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int a [] = { 1, 2, 3 }
[+] 	int a[] = { 1, 2, 3 }
[-] 	printf ("a = { ");
[+] 	printf("a = { ");
[-] 	for (int i = 0; i < countof (a); i++)
[+] 	for (int i = 0; i < countof(a); i++)
[-] 		printf ("%d, ", a [i]);
[+] 		printf("%d, ", a [i]);
[-] 	printf ("}\n");
[+] 	printf("}\n");
[-] 	int b [10] = { ,, 3, 4,,, 7 }
[+] 	int b[10] = { ,, 3, 4,,, 7 }
[-] 	printf ("b = { ");
[+] 	printf("b = { ");
[-] 	for (int i = 0; i < countof (b); i++)
[+] 	for (int i = 0; i < countof(b); i++)
[-] 		printf ("%d, ", b [i]);
[+] 		printf("%d, ", b [i]);
[-] 	printf ("}\n");
[+] 	printf("}\n");
[-] 	printf ("point = { %d, %d, %d }\n", point.m_x, point.m_y, point.m_z);
[+] 	printf("point = { %d, %d, %d }\n", point.m_x, point.m_y, point.m_z);
[-] 	printf ("point = { %d, %d, %d }\n", point.m_x, point.m_y, point.m_z);
[+] 	printf("point = { %d, %d, %d }\n", point.m_x, point.m_y, point.m_z);
[-] 	printf ("point2 = { %d, %d, %d }\n", point2.m_x, point2.m_y, point2.m_z);
[+] 	printf("point2 = { %d, %d, %d }\n", point2.m_x, point2.m_y, point2.m_z);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\85_ScopesInSwitch.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int a = rand () % 3;
[+] 	int a = rand() % 3;
[-] 	switch (a)
[+] 	switch(a)
[-] 	printf ("a = %d, result = %d\n", a, result);
[+] 	printf("a = %d, result = %d\n", a, result);
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\86_ModuleConstructors.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] int g_x = foo ();
[+] int g_x = foo();
[-] int foo ()
[+] int foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] construct ()
[+] construct()
[-] 	printf ("module.construct ()\n");
[+] 	printf("module.construct ()\n");
[-] destruct ()
[+] destruct()
[-] 	printf ("module.destruct ()\n");
[+] 	printf("module.destruct ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc\87_ExtensionNamespaces.jnc
----------------------
[-] 	construct (int x)
[+] 	construct(int x)
[-] 		printf ("C1.construct (%d)\n", x);
[+] 		printf("C1.construct (%d)\n", x);
[-] 	foo ()
[+] 	foo()
[-] 		printf ("C1Ext.foo () { m_x = %d }\n", m_x);
[+] 		printf("C1Ext.foo () { m_x = %d }\n", m_x);
[-] 	bar (int x);
[+] 	bar(int x);
[-] 	static baz ()
[+] 	static baz()
[-] 		printf ("C1Ext.baz ()\n");
[+] 		printf("C1Ext.baz ()\n");
[-] C1Ext.bar (int x)
[+] C1Ext.bar(int x)
[-] 	printf ("C1Ext.bar (%d) { m_x = %d }\n", x, m_x);
[+] 	printf("C1Ext.bar (%d) { m_x = %d }\n", x, m_x);
[-] 	foo ();
[+] 	foo();
[-] int C1Ext.m_prop.get ()
[+] int C1Ext.m_prop.get()
[-] 	printf ("C1Ext.m_prop.get () { m_x = %d }\n", m_x);
[+] 	printf("C1Ext.m_prop.get () { m_x = %d }\n", m_x);
[-] C1Ext.m_prop.set (int x)
[+] C1Ext.m_prop.set(int x)
[-] 	printf ("C1Ext.m_prop.set (%d) { m_x = %d }\n", x, m_x);
[+] 	printf("C1Ext.m_prop.set (%d) { m_x = %d }\n", x, m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	C1 c (100);
[+] 	C1 c(100);
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.bar (200);
[+] 	c.bar(200);
[-] 	C1.baz ();
[+] 	C1.baz();
----------------------
27/02/2019 18:02:02 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_01_embed_c\script.jnc
----------------------
[-] foo (int);
[+] foo(int);
[-] foo (double);
[+] foo(double);
[-] foo (char const*);
[+] foo(char const*);
[-] 	char const* get ();
[+] 	char const* get();
[-] 	set (int);
[+] 	set(int);
[-] 	set (double);
[+] 	set(double);
[-] 	set (char const*);
[+] 	set(char const*);
[-] 	construct ();
[+] 	construct();
[-] 	construct (
[+] 	construct(
[-] 	foo ();
[+] 	foo();
[-] 	foo (
[+] 	foo(
[-] 	foo (TestStruct* src);
[+] 	foo(TestStruct* src);
[-] 	event m_onNegative ();
[+] 	event m_onNegative();
[-] 	construct (int value);
[+] 	construct(int value);
[-] 	destruct ();
[+] 	destruct();
[-] 	int foo ();
[+] 	int foo();
[-] 	int foo (int value);
[+] 	int foo(int value);
[-] 	int foo (TestClass* src);
[+] 	int foo(TestClass* src);
[-] onNegative ()
[+] onNegative()
[-] 	printf ("onNegative ()\n");
[+] 	printf("onNegative ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo (10);
[+] 	foo(10);
[-] 	foo (3.1415);
[+] 	foo(3.1415);
[-] 	foo ("bambarbia");
[+] 	foo("bambarbia");
[-] 	printf ("g_simpleProp = %d\n", g_simpleProp);
[+] 	printf("g_simpleProp = %d\n", g_simpleProp);
[-] 	printf ("g_prop = %s\n", g_prop);
[+] 	printf("g_prop = %s\n", g_prop);
[-] 	TestStruct s2 (100, 200);
[+] 	TestStruct s2(100, 200);
[-] 	s1.foo (&s2);
[+] 	s1.foo(&s2);
[-] 	s1.foo ();
[+] 	s1.foo();
[-] 	printf ("s1 = { %d, %d }\n", s1.m_x, s1.m_y);
[+] 	printf("s1 = { %d, %d }\n", s1.m_x, s1.m_y);
[-] 	TestClass* c = new TestClass (1000);
[+] 	TestClass* c = new TestClass(1000);
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.foo (-2000);
[+] 	c.foo(-2000);
[-] 	printf ("c.m_prop = %s\n", c.m_prop);
[+] 	printf("c.m_prop = %s\n", c.m_prop);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_02_embed_cpp\script.jnc
----------------------
[-] foo (int);
[+] foo(int);
[-] foo (double);
[+] foo(double);
[-] foo (char const*);
[+] foo(char const*);
[-] 	char const* get ();
[+] 	char const* get();
[-] 	set (int);
[+] 	set(int);
[-] 	set (double);
[+] 	set(double);
[-] 	set (char const*);
[+] 	set(char const*);
[-] 	construct ();
[+] 	construct();
[-] 	construct (
[+] 	construct(
[-] 	foo ();
[+] 	foo();
[-] 	foo (
[+] 	foo(
[-] 	foo (TestStruct* src);
[+] 	foo(TestStruct* src);
[-] 	event m_onNegative ();
[+] 	event m_onNegative();
[-] 	construct (int value);
[+] 	construct(int value);
[-] 	destruct ();
[+] 	destruct();
[-] 	int foo ();
[+] 	int foo();
[-] 	int foo (int value);
[+] 	int foo(int value);
[-] 	int foo (TestClass* src);
[+] 	int foo(TestClass* src);
[-] onNegative ()
[+] onNegative()
[-] 	printf ("onNegative ()\n");
[+] 	printf("onNegative ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo (10);
[+] 	foo(10);
[-] 	foo (3.1415);
[+] 	foo(3.1415);
[-] 	foo ("bambarbia");
[+] 	foo("bambarbia");
[-] 	printf ("g_simpleProp = %d\n", g_simpleProp);
[+] 	printf("g_simpleProp = %d\n", g_simpleProp);
[-] 	printf ("g_prop = %s\n", g_prop);
[+] 	printf("g_prop = %s\n", g_prop);
[-] 	TestStruct s2 (100, 200);
[+] 	TestStruct s2(100, 200);
[-] 	s1.foo (&s2);
[+] 	s1.foo(&s2);
[-] 	s1.foo ();
[+] 	s1.foo();
[-] 	printf ("s1 = { %d, %d }\n", s1.m_x, s1.m_y);
[+] 	printf("s1 = { %d, %d }\n", s1.m_x, s1.m_y);
[-] 	TestClass* c = new TestClass (1000);
[+] 	TestClass* c = new TestClass(1000);
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.foo (-2000);
[+] 	c.foo(-2000);
[-] 	printf ("c.m_prop = %s\n", c.m_prop);
[+] 	printf("c.m_prop = %s\n", c.m_prop);
----------------------
27/02/2019 18:02:03 - C:\Projects\repos\ioninja\jancy\samples\jnc_sample_03_dialog\script.jnc
----------------------
[-] 	setSizePolicy (
[+] 	setSizePolicy(
[-] 	addWidget (Widget* widget);
[+] 	addWidget(Widget* widget);
[-] 	addLayout (Layout* layout);
[+] 	addLayout(Layout* layout);
[-] 	addSpacer ();
[+] 	addSpacer();
[-] 	construct (Direction direction);
[+] 	construct(Direction direction);
[-] 	destruct ();
[+] 	destruct();
[-] 	construct (char const* text);
[+] 	construct(char const* text);
[-] 	destruct ();
[+] 	destruct();
[-] 	event m_onClicked ();
[+] 	event m_onClicked();
[-] 	construct (char const* text);
[+] 	construct(char const* text);
[-] 	destruct ();
[+] 	destruct();
[-] 	construct (char const* text);
[+] 	construct(char const* text);
[-] 	destruct ();
[+] 	destruct();
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	construct (
[+] 	construct(
[-] 	destruct ();
[+] 	destruct();
[-] int calcColorVolume (int color)
[+] int calcColorVolume(int color)
[-] 	g_colorLabel.m_color = calcColorVolume (g_color) > 0x180 ? 0x000000 : 0xffffff;
[+] 	g_colorLabel.m_color = calcColorVolume(g_color) > 0x180 ? 0x000000 : 0xffffff;
[-] 	onevent g_printButton.m_onClicked ()
[+] 	onevent g_printButton.m_onClicked()
[-] 		printf ("> %s\n", g_textEdit.m_text);
[+] 		printf("> %s\n", g_textEdit.m_text);
[-] int main (Layout* mainLayout)
[+] int main(Layout* mainLayout)
[-] 	printf ("Creating widgets...\n");
[+] 	printf("Creating widgets...\n");
[-] 	hlayout = new Layout (Layout.Direction.LeftToRight);
[+] 	hlayout = new Layout(Layout.Direction.LeftToRight);
[-] 	vlayout = new Layout (Layout.Direction.TopToBottom);
[+] 	vlayout = new Layout(Layout.Direction.TopToBottom);
[-] 	vlayout.addWidget (new Label ("Red:"));
[+] 	vlayout.addWidget(new Label("Red:"));
[-] 	vlayout.addWidget (new Label ("Green:"));
[+] 	vlayout.addWidget(new Label("Green:"));
[-] 	vlayout.addWidget (new Label ("Blue:"));
[+] 	vlayout.addWidget(new Label("Blue:"));
[-] 	hlayout.addLayout (vlayout);
[+] 	hlayout.addLayout(vlayout);
[-] 	vlayout = new Layout (Layout.Direction.TopToBottom);
[+] 	vlayout = new Layout(Layout.Direction.TopToBottom);
[-] 	vlayout.addWidget (g_redSlider = new Slider (0, 255));
[+] 	vlayout.addWidget(g_redSlider = new Slider(0, 255));
[-] 	vlayout.addWidget (g_greenSlider = new Slider (0, 255));
[+] 	vlayout.addWidget(g_greenSlider = new Slider(0, 255));
[-] 	vlayout.addWidget (g_blueSlider = new Slider (0, 255));
[+] 	vlayout.addWidget(g_blueSlider = new Slider(0, 255));
[-] 	hlayout.addLayout (vlayout);
[+] 	hlayout.addLayout(vlayout);
[-] 	mainLayout.addLayout (hlayout);
[+] 	mainLayout.addLayout(hlayout);
[-] 	g_colorLabel = new Label ("color-label");
[+] 	g_colorLabel = new Label("color-label");
[-] 	g_colorLabel.setSizePolicy (Widget.SizePolicy.Expanding, Widget.SizePolicy.Expanding);
[+] 	g_colorLabel.setSizePolicy(Widget.SizePolicy.Expanding, Widget.SizePolicy.Expanding);
[-] 	mainLayout.addWidget (g_colorLabel);
[+] 	mainLayout.addWidget(g_colorLabel);
[-] 	mainLayout.addWidget (g_enablePrintCheckBox = new CheckBox ("Enable printing to output"));
[+] 	mainLayout.addWidget(g_enablePrintCheckBox = new CheckBox("Enable printing to output"));
[-] 	hlayout = new Layout (Layout.Direction.LeftToRight);
[+] 	hlayout = new Layout(Layout.Direction.LeftToRight);
[-] 	hlayout.addWidget (new Label ("Text:"));
[+] 	hlayout.addWidget(new Label("Text:"));
[-] 	hlayout.addWidget (g_textEdit);
[+] 	hlayout.addWidget(g_textEdit);
[-] 	hlayout.addWidget (g_printButton = new Button ("Print"));
[+] 	hlayout.addWidget(g_printButton = new Button("Print"));
[-] 	mainLayout.addLayout (hlayout);
[+] 	mainLayout.addLayout(hlayout);
[-] 	printf ("Starting UI reactor...\n");
[+] 	printf("Starting UI reactor...\n");
[-] 	g_uiReactor.start ();
[+] 	g_uiReactor.start();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_File.jnc
----------------------
[-] 		mode (e.g., client mailslot files on Windows)
[+] 		mode(e.g., client mailslot files on Windows)
[-] 		empty file with such a name (which would be the default option).
[+] 		empty file with such a name(which would be the default option).
[-] 		handle to the file is allowed at the same time (subsequent attempts to
[+] 		handle to the file is allowed at the same time(subsequent attempts to
[-] 	System API (not to the C-runtime library). A typical sequence of steps when
[+] 	System API(not to the C-runtime library). A typical sequence of steps when
[-] 		foo (void const* data)
[+] 		foo(void const* data)
[-] 			file.open ("data.txt");
[+] 			file.open("data.txt");
[-] 			file.write (data, dynamic sizeof (data));
[+] 			file.write(data, dynamic sizeof(data));
[-] 		it sets new size [#f3]_.
[+] 		it sets new size[#f3]_.
[-] 		This property is used for getting and setting [#f3]_ current file
[+] 		This property is used for getting and setting[#f3]_ current file
[-] 		Accessing this property for sequential devices (which do not support
[+] 		Accessing this property for sequential devices(which do not support
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (
[+] 	bool errorcode open(
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.File`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.File`` a *disposable* class[#f2]_.
[-] 	bool errorcode setSize (uint64_t size);
[+] 	bool errorcode setSize(uint64_t size);
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	bool errorcode flush ();
[+] 	bool errorcode flush();
[-] char const* getSymbolicLinkTarget (char const* name);
[+] char const* getSymbolicLinkTarget(char const* name);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_FileStream.jnc
----------------------
[-] 	Currently, this functionality is only available on Windows (via the WinAPI
[+] 	Currently, this functionality is only available on Windows(via the WinAPI
[-] 	does not correspond to any known file stream kind (e.g. you have casted a
[+] 	does not correspond to any known file stream kind(e.g. you have casted a
[-] char const* getFileStreamKindString (FileStreamKind kind)
[+] char const* getFileStreamKindString(FileStreamKind kind)
[-] 	static char const* stringTable [] =
[+] 	static char const* stringTable[] =
[-] 	return kind < countof (stringTable) ?
[+] 	return kind < countof(stringTable) ?
[-] 		stringTable [kind] :
[+] 		stringTable[kind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 			open (char const* fileName);
[+] 			open(char const* fileName);
[-] 			close ();
[+] 			close();
[-] 			waitFileStreamEvents ();
[+] 			waitFileStreamEvents();
[-] 			onWriteButtonClicked ();
[+] 			onWriteButtonClicked();
[-] 			onFileStreamEvent (
[+] 			onFileStreamEvent(
[-] 		MyDialog.open (char const* fileName)
[+] 		MyDialog.open(char const* fileName)
[-] 			bool result = try m_fileStream.open (fileName);
[+] 			bool result = try m_fileStream.open(fileName);
[-] 				char const* errorString = std.getLastError ().m_description;
[+] 				char const* errorString = std.getLastError().m_description;
[-] 			waitFileStreamEvents ();
[+] 			waitFileStreamEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_fileStream.close ();
[+] 			m_fileStream.close();
[-] 		MyDialog.waitFileStreamEvent ()
[+] 		MyDialog.waitFileStreamEvent()
[-] 			m_fileStream.wait (eventMask, onFileStreamEvent ~(++m_syncId) @
[+] 			m_fileStream.wait(eventMask, onFileStreamEvent ~(++m_syncId) @
[-] 		MyDialog.onWriteButtonClicked ()
[+] 		MyDialog.onWriteButtonClicked()
[-] 			static char data [] = "a quick brown fox jumps over the lazy dog";
[+] 			static char data[] = "a quick brown fox jumps over the lazy dog";
[-] 			m_fileStream.write (data, sizeof (data));
[+] 			m_fileStream.write(data, sizeof(data));
[-] 		MyDialog.onFileStreamEvent (
[+] 		MyDialog.onFileStreamEvent(
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_fileStream.read (buffer, sizeof (buffer));
[+] 				size_t size = m_fileStream.read(buffer, sizeof(buffer));
[-] 			waitFileStreamEvents (); // restart wait
[+] 			waitFileStreamEvents(); // restart wait
[-] 		Specifies the type of the file stream (regular disk file, serial port
[+] 		Specifies the type of the file stream(regular disk file, serial port
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (
[+] 	bool errorcode open(
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.FileStream`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.FileStream`` a *disposable* class[#f2]_.
[-] 	bool errorcode clear ();
[+] 	bool errorcode clear();
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (FileStreamEvents triggeredEvents)
[+] 		function* handler(FileStreamEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	FileStreamEvents errorcode blockingWait (
[+] 	FileStreamEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_Mailslot.jnc
----------------------
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 			open (char const* fileName);
[+] 			open(char const* fileName);
[-] 			close ();
[+] 			close();
[-] 			waitMailslotEvents ();
[+] 			waitMailslotEvents();
[-] 			onMailslotEvent (
[+] 			onMailslotEvent(
[-] 		MyDialog.open (char const* fileName)
[+] 		MyDialog.open(char const* fileName)
[-] 			bool result = try m_mailslot.open (fileName);
[+] 			bool result = try m_mailslot.open(fileName);
[-] 				char const* errorString = std.getLastError ().m_description;
[+] 				char const* errorString = std.getLastError().m_description;
[-] 			waitMailslotEvents ();
[+] 			waitMailslotEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_mailslot.close ();
[+] 			m_mailslot.close();
[-] 		MyDialog.waitMailslotEvent ()
[+] 		MyDialog.waitMailslotEvent()
[-] 			m_mailslot.wait (eventMask, onMailslotEvent ~(++m_syncId) @
[+] 			m_mailslot.wait(eventMask, onMailslotEvent ~(++m_syncId) @
[-] 		MyDialog.onMailslotEvent (
[+] 		MyDialog.onMailslotEvent(
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_mailslot.read (buffer, sizeof (buffer));
[+] 				size_t size = m_mailslot.read(buffer, sizeof(buffer));
[-] 			waitMailslotEvents (); // restart wait
[+] 			waitMailslotEvents(); // restart wait
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (char const* name);
[+] 	bool errorcode open(char const* name);
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.Mailslot`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.Mailslot`` a *disposable* class[#f2]_.
[-] 		Returns the actual amount of bytes read or ``-1`` if error occurs [#f1]_.
[+] 		Returns the actual amount of bytes read or ``-1`` if error occurs[#f1]_.
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (MailslotEvents triggeredEvents)
[+] 		function* handler(MailslotEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	MailslotEvents errorcode blockingWait (
[+] 	MailslotEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_MappedFile.jnc
----------------------
[-] 	this region (or ``null`` if this could not be done). That's it! Actual
[+] 	this region(or ``null`` if this could not be done). That's it! Actual
[-] 	same time. Expiration queue is organized in FIFO (first-in-first-out)
[+] 	same time. Expiration queue is organized in FIFO(first-in-first-out)
[-] 	with ``view`` method (last accessed view is moved to the tail of the
[+] 	with ``view`` method(last accessed view is moved to the tail of the
[-] 		foo (char const* fileName)
[+] 		foo(char const* fileName)
[-] 			file.open (fileName, `io.FileOpenFlags.ReadOnly`);
[+] 			file.open(fileName, `io.FileOpenFlags.ReadOnly`);
[-] 			Hdr const* hdr = file.view (0, sizeof (Hdr), true);
[+] 			Hdr const* hdr = file.view(0, sizeof(Hdr), true);
[-] 			size_t offset = sizeof (Hdr);
[+] 			size_t offset = sizeof(Hdr);
[-] 				i++, offset += sizeof (SectionDesc)
[+] 				i++, offset += sizeof(SectionDesc)
[-] 				SectionDesc const* sectionDesc = file.view (
[+] 				SectionDesc const* sectionDesc = file.view(
[-] 					sizeof (SectionDesc)
[+] 					sizeof(SectionDesc)
[-] 				void const* section = file.view (
[+] 				void const* section = file.view(
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (
[+] 	bool errorcode open(
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.MappedFile`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.MappedFile`` a *disposable* class[#f2]_.
[-] 	bool errorcode setSize (uint64_t size);
[+] 	bool errorcode setSize(uint64_t size);
[-] 		operation failed [#f1]_.
[+] 		operation failed[#f1]_.
[-] 	void* errorcode view (
[+] 	void* errorcode view(
[-] 	void unmapAllViews ();
[+] 	void unmapAllViews();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_NamedPipe.jnc
----------------------
[-] 	used for IPC (Inter-Process Communications) between applications,
[+] 	used for IPC(Inter-Process Communications) between applications,
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (char const* name);
[+] 	bool errorcode open(char const* name);
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.NamedPipe`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.NamedPipe`` a *disposable* class[#f2]_.
[-] 		If method fails, ``null`` value is returned [#f1]_.
[+] 		If method fails, ``null`` value is returned[#f1]_.
[-] 	FileStream* accept ();
[+] 	FileStream* accept();
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (NamedPipeEvents triggeredEvents)
[+] 		function* handler(NamedPipeEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	NamedPipeEvents errorcode blockingWait (
[+] 	NamedPipeEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_NetworkAdapter.jnc
----------------------
[-] 			char const* getNetworkAdapterTypeString (io.NetworkAdapterType type)
[+] 			char const* getNetworkAdapterTypeString(io.NetworkAdapterType type)
[-] 				static char const stringTable [io.NetworkAdapterType._Count] =
[+] 				static char const stringTable[io.NetworkAdapterType._Count] =
[-] 				return stringTable [type];
[+] 				return stringTable[type];
[-] 		Holds the hardware Media Access Control (MAC) address of the network
[+] 		Holds the hardware Media Access Control(MAC)address of the network
[-] 	uint8_t m_mac [6];
[+] 	uint8_t m_mac[6];
[-] 			io.createNetworkAdapterDescList ();
[+] 			io.createNetworkAdapterDescList();
[-] NetworkAdapterDesc const* createNetworkAdapterDescList (
[+] NetworkAdapterDesc const* createNetworkAdapterDescList(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_Serial.jnc
----------------------
[-] 	property at any time (both pre-open and post-open modifications are
[+] 	property at any time(both pre-open and post-open modifications are
[-] 		``RTS/CTS`` flow control (sometimes called **hardware** flow control).
[+] 		``RTS/CTS`` flow control(sometimes called **hardware** flow control).
[-] 		``XON/XOFF`` flow control (sometimes called **software** flow control).
[+] 		``XON/XOFF`` flow control(sometimes called **software** flow control).
[-] 	Stop bits are auxillary (non-data) bits sent at the end of each character to
[+] 	Stop bits are auxillary(non-data) bits sent at the end of each character to
[-] 	time (both pre-open and post-open modifications are supported).
[+] 	time(both pre-open and post-open modifications are supported).
[-] 		A parity bit is sent; **odd** parity check is used (total number of
[+] 		A parity bit is sent; **odd** parity check is used(total number of
[-] 		A parity bit is sent; **even** parity check is used (total number of
[+] 		A parity bit is sent; **even** parity check is used(total number of
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 	* Configure serial port settings (``m_baudRate``, ``m_dataBits`` etc)
[+] 	* Configure serial port settings(``m_baudRate``, ``m_dataBits`` etc)
[-] 			open (
[+] 			open(
[-] 			close ();
[+] 			close();
[-] 			waitSerialEvents ();
[+] 			waitSerialEvents();
[-] 			onWriteButtonClicked ();
[+] 			onWriteButtonClicked();
[-] 			onSerialEvent (
[+] 			onSerialEvent(
[-] 		MyDialog.open (
[+] 		MyDialog.open(
[-] 			m_serial.open (portName);
[+] 			m_serial.open(portName);
[-] 			waitSerialEvents ();
[+] 			waitSerialEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_serial.close ();
[+] 			m_serial.close();
[-] 		MyDialog.waitSerialEvent ()
[+] 		MyDialog.waitSerialEvent()
[-] 			m_serial.wait (eventMask, onSerialEvent ~(++m_syncId) @
[+] 			m_serial.wait(eventMask, onSerialEvent ~(++m_syncId) @
[-] 		MyDialog.onWriteButtonClicked ()
[+] 		MyDialog.onWriteButtonClicked()
[-] 			static char data [] = "a quick brown fox jumps over the lazy dog";
[+] 			static char data[] = "a quick brown fox jumps over the lazy dog";
[-] 			m_serial.write (data, sizeof (data));
[+] 			m_serial.write(data, sizeof(data));
[-] 		MyDialog.onSerialEvent (
[+] 		MyDialog.onSerialEvent(
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_fileStream.read (buffer, sizeof (buffer));
[+] 				size_t size = m_fileStream.read(buffer, sizeof(buffer));
[-] 			waitSerialEvents (); // restart wait
[+] 			waitSerialEvents(); // restart wait
[-] 		This property is used for getting and setting [#f4]_ baud rate, i.e. the
[+] 		This property is used for getting and setting[#f4]_ baud rate, i.e. the
[-] 		This property is used for getting and setting [#f4]_ flow control, i.e.
[+] 		This property is used for getting and setting[#f4]_ flow control, i.e.
[-] 		This property is used for getting and setting [#f4]_ byte size, i.e. the
[+] 		This property is used for getting and setting[#f4]_ byte size, i.e. the
[-] 		This property is used for getting and setting [#f4]_ the number of
[+] 		This property is used for getting and setting[#f4]_ the number of
[-] 		serial stop bits, i.e. auxillary (non-data) bits sent at the end of each
[+] 		serial stop bits, i.e. auxillary(non-data) bits sent at the end of each
[-] 		This property is used for getting and setting [#f4]_ serial parity
[+] 		This property is used for getting and setting[#f4]_ serial parity
[-] 		enumeration members, showing which status lines are high (or ``0`` if
[+] 		enumeration members, showing which status lines are high(or ``0`` if
[-] 		This property is used for getting and setting [#f4]_ ``DTR``
[+] 		This property is used for getting and setting[#f4]_ ``DTR``
[-] 		This property is used for getting and setting [#f4]_ ``RTS``
[+] 		This property is used for getting and setting[#f4]_ ``RTS``
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (char const* name);
[+] 	bool errorcode open(char const* name);
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.Serial`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.Serial`` a *disposable* class[#f2]_.
[-] 	bool errorcode setupDevice (
[+] 	bool errorcode setupDevice(
[-] 	SerialLineErrors clearLineErrors ();
[+] 	SerialLineErrors clearLineErrors();
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (SerialEvents triggeredEvents)
[+] 		function* handler(SerialEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	SerialEvents errorcode blockingWait (
[+] 	SerialEvents errorcode blockingWait(
[-] 		`io.SerialPortDesc` const* portDesc = io.createSerialPortDescList ();
[+] 		`io.SerialPortDesc` const* portDesc = io.createSerialPortDescList();
[-] SerialPortDesc const* createSerialPortDescList (size_t* count = null);
[+] SerialPortDesc const* createSerialPortDescList(size_t* count = null);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_Socket.jnc
----------------------
[-] 		time. Note that if connection was terminated by the local node (using
[+] 		time. Note that if connection was terminated by the local node(using
[-] 		connection was terminated by the local node (using `io.Socket.close`),
[+] 		connection was terminated by the local node(using `io.Socket.close`),
[-] 	Sample code (client connection-oriented TCP socket):
[+] 	Sample code(client connection-oriented TCP socket):
[-] 			connect (char const* addrString);
[+] 			connect(char const* addrString);
[-] 			close ();
[+] 			close();
[-] 			waitSocketEvents ();
[+] 			waitSocketEvents();
[-] 			onWriteButtonClicked ();
[+] 			onWriteButtonClicked();
[-] 			onSocketEvent (
[+] 			onSocketEvent(
[-] 		MyDialog.connect (char const* addrString)
[+] 		MyDialog.connect(char const* addrString)
[-] 			sockAddr.parse (addrString);
[+] 			sockAddr.parse(addrString);
[-] 			m_socket.open (`io.Protocol.Tcp`);
[+] 			m_socket.open(`io.Protocol.Tcp`);
[-] 			m_socket.connect (sockAddr);
[+] 			m_socket.connect(sockAddr);
[-] 			waitSocketEvents ();
[+] 			waitSocketEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_socket.close ();
[+] 			m_socket.close();
[-] 		MyDialog.waitSocketEvent ()
[+] 		MyDialog.waitSocketEvent()
[-] 			m_socket.wait (eventMask, onSocketEvent ~(++m_syncId) @
[+] 			m_socket.wait(eventMask, onSocketEvent ~(++m_syncId) @
[-] 		MyDialog.onWriteButtonClicked ()
[+] 		MyDialog.onWriteButtonClicked()
[-] 			static char data [] = "a quick brown fox jumps over the lazy dog";
[+] 			static char data[] = "a quick brown fox jumps over the lazy dog";
[-] 			m_socket.write (data, sizeof (data));
[+] 			m_socket.write(data, sizeof(data));
[-] 		MyDialog.onSocketEvent (
[+] 		MyDialog.onSocketEvent(
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_socket.read (buffer, sizeof (buffer));
[+] 				size_t size = m_socket.read(buffer, sizeof(buffer));
[-] 			waitSocketEvents (); // restart wait
[+] 			waitSocketEvents(); // restart wait
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 		specifies the address family of the new socket (``IP4`` vs ``IP6``). The
[+] 		specifies the address family of the new socket(``IP4`` vs ``IP6``). The
[-] 	bool errorcode open (
[+] 	bool errorcode open(
[-] 		specifies the protocol of the new socket (datagram-oriented ``UDP``
[+] 		specifies the protocol of the new socket(datagram-oriented ``UDP``
[-] 	bool errorcode open (
[+] 	bool errorcode open(
[-] 	bool errorcode open (Protocol protocol)
[+] 	bool errorcode open(Protocol protocol)
[-] 		return open (AddressFamily.Ip4, protocol);
[+] 		return open(AddressFamily.Ip4, protocol);
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.Socket`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.Socket`` a *disposable* class[#f2]_.
[-] 	bool errorcode connect (SocketAddress const* address);
[+] 	bool errorcode connect(SocketAddress const* address);
[-] 	bool errorcode listen (size_t backlog = 0); // 0 -- default
[+] 	bool errorcode listen(size_t backlog = 0); // 0 -- default
[-] 		If method fails, ``null`` value is returned [#f1]_.
[+] 		If method fails, ``null`` value is returned[#f1]_.
[-] 	Socket* errorcode accept (SocketAddress* address = null);
[+] 	Socket* errorcode accept(SocketAddress* address = null);
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	size_t errorcode readDatagram (
[+] 	size_t errorcode readDatagram(
[-] 	size_t errorcode writeDatagram (
[+] 	size_t errorcode writeDatagram(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (SocketEvents triggeredEvents)
[+] 		function* handler(SocketEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	SocketEvents errorcode blockingWait (
[+] 	SocketEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_SocketAddress.jnc
----------------------
[-] 	protocol to use (all overloads of `io.Socket.open` methods require a
[+] 	protocol to use(all overloads of `io.Socket.open` methods require a
[-] 	uint8_t m_i8 [4];
[+] 	uint8_t m_i8[4];
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
[-] 	char const* getString () const;
[+] 	char const* getString() const;
[-] 	bigendian uint16_t m_i16 [8];
[+] 	bigendian uint16_t m_i16[8];
[-] 	uint8_t m_i8 [16];
[+] 	uint8_t m_i8[16];
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
[-] 	char const* getString () const;
[+] 	char const* getString() const;
[-] alignment (2);
[+] alignment(2);
[-] 	char m_padding [8];
[+] 	char m_padding[8];
[-] 	bool isEqual (SocketAddress_ip4 const* address);
[+] 	bool isEqual(SocketAddress_ip4 const* address);
[-] 	bool isMatch (SocketAddress_ip4 const* filterAddress);
[+] 	bool isMatch(SocketAddress_ip4 const* filterAddress);
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
[-] 	char const* getString () const;
[+] 	char const* getString() const;
[-] 	bool isEqual (SocketAddress_ip6 const* address);
[+] 	bool isEqual(SocketAddress_ip6 const* address);
[-] 	bool isMatch (SocketAddress_ip6 const* filterAddress);
[+] 	bool isMatch(SocketAddress_ip6 const* filterAddress);
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
[-] 	char const* getString () const;
[+] 	char const* getString() const;
[-] 	bool isEqual (SocketAddress const* addr);
[+] 	bool isEqual(SocketAddress const* addr);
[-] 	bool isMatch (SocketAddress const* filterAddress);
[+] 	bool isMatch(SocketAddress const* filterAddress);
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
[-] 	char const* getString () const;
[+] 	char const* getString() const;
[-] alignment (default);
[+] alignment(default);
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_SocketAddressResolver.jnc
----------------------
[-] 			resolve (char const* hostName);
[+] 			resolve(char const* hostName);
[-] 			onResolverEvent (
[+] 			onResolverEvent(
[-] 		MyDialog.resolve (char const* hostName)
[+] 		MyDialog.resolve(char const* hostName)
[-] 			bool result = try m_resolver.resolve (
[+] 			bool result = try m_resolver.resolve(
[-] 		MyDialog.onResolveCompleted (
[+] 		MyDialog.onResolveCompleted(
[-] 	typedef CompletionFunc (
[+] 	typedef CompletionFunc(
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	uintptr_t errorcode resolve (
[+] 	uintptr_t errorcode resolve(
[-] 	uintptr_t errorcode resolve (
[+] 	uintptr_t errorcode resolve(
[-] 		return resolve (name, AddressFamily.Undefined, completionFunc);
[+] 		return resolve(name, AddressFamily.Undefined, completionFunc);
[-] 	bool cancel (uintptr_t id);
[+] 	bool cancel(uintptr_t id);
[-] 	void cancelAll ();
[+] 	void cancelAll();
----------------------
27/02/2019 18:02:17 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_base\jnc\io_SocketOptions.jnc
----------------------
[-] 		datagram-oriented protocols (such as ``UDP``). When this option is set,
[+] 		datagram-oriented protocols(such as ``UDP``). When this option is set,
[-] 		provide ``IP`` header together with the rest of the packet (however,
[+] 		provide ``IP`` header together with the rest of the packet(however,
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_devmon\jnc\io_DeviceMonitor.jnc
----------------------
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	bool errorcode connect (char const* deviceName);
[+] 	bool errorcode connect(char const* deviceName);
[-] 	void close ();
[+] 	void close();
[-] 	void setIoctlDescTable (
[+] 	void setIoctlDescTable(
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (DeviceMonitorEvents triggeredEvents)
[+] 		function* handler(DeviceMonitorEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	DeviceMonitorEvents errorcode blockingWait (
[+] 	DeviceMonitorEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_pcap\jnc\io_Pcap.jnc
----------------------
[-] 		New packet(s) are available on the Pcap device or file; the next packet
[+] 		New packet(s)are available on the Pcap device or file; the next packet
[-] 	Pcap library (called WinPcap on Windows) is de-facto the standard tool for
[+] 	Pcap library(called WinPcap on Windows) is de-facto the standard tool for
[-] 	* Open a live capture using ``openDevice`` or a capture file (\*.pcap) using
[+] 	* Open a live capture using ``openDevice`` or a capture file(\*.pcap) using
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 			startCapture (
[+] 			startCapture(
[-] 			close ();
[+] 			close();
[-] 			waitPcapEvents ();
[+] 			waitPcapEvents();
[-] 			onPcapEvent (
[+] 			onPcapEvent(
[-] 		MyDialog.startCapture (
[+] 		MyDialog.startCapture(
[-] 			bool result = try m_pcap.openDevice (device, filter);
[+] 			bool result = try m_pcap.openDevice(device, filter);
[-] 			waitPcapEvents ();
[+] 			waitPcapEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_serial.close ();
[+] 			m_serial.close();
[-] 		MyDialog.waitPcapEvent ()
[+] 		MyDialog.waitPcapEvent()
[-] 			m_serial.wait (eventMask, onPcapEvent ~(++m_syncId) @
[+] 			m_serial.wait(eventMask, onPcapEvent ~(++m_syncId) @
[-] 		MyDialog.onPcapEvent (
[+] 		MyDialog.onPcapEvent(
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_pcap.read (buffer, sizeof (buffer));
[+] 				size_t size = m_pcap.read(buffer, sizeof(buffer));
[-] 			waitPcapEvents (); // restart wait
[+] 			waitPcapEvents(); // restart wait
[-] 		Holds currently specified capture filter [#f4]_.
[+] 		Holds currently specified capture filter[#f4]_.
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode openDevice (
[+] 	bool errorcode openDevice(
[-] 		``openDevice`` method [#f4]_.
[+] 		``openDevice`` method[#f4]_.
[-] 	bool errorcode openFile (
[+] 	bool errorcode openFile(
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.Pcap`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.Pcap`` a *disposable* class[#f2]_.
[-] 	bool errorcode setFilter (char const* filter);
[+] 	bool errorcode setFilter(char const* filter);
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (PcapEvents triggeredEvents)
[+] 		function* handler(PcapEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	PcapEvents errorcode blockingWait (
[+] 	PcapEvents errorcode blockingWait(
[-] 		`io.PcapDeviceDesc` const* deviceDesc = io.createPcapDeviceDescList ();
[+] 		`io.PcapDeviceDesc` const* deviceDesc = io.createPcapDeviceDescList();
[-] PcapDeviceDesc const* createPcapDeviceDescList (size_t* count = null);
[+] PcapDeviceDesc const* createPcapDeviceDescList(size_t* count = null);
----------------------
27/02/2019 18:02:18 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_ssh\jnc\io_Ssh.jnc
----------------------
[-] 		Socket receive buffer is full (data is arriving faster than the
[+] 		Socket receive buffer is full(data is arriving faster than the
[-] 		connection was terminated by the local node (using
[+] 		connection was terminated by the local node(using
[-] 		for a specific pseudo-terminal (such as ``xterm``) has been sent.
[+] 		for a specific pseudo-terminal(such as ``xterm``) has been sent.
[-] 		Request to the ``SSH`` server for a specific pseudo-terminal (such as
[+] 		Request to the ``SSH`` server for a specific pseudo-terminal(such as
[-] 		process (such as ``shell``) has been sent.
[+] 		process(such as ``shell``) has been sent.
[-] 		A remote process (such as ``shell``) has been started; the full ``SSH``
[+] 		A remote process(such as ``shell``) has been started; the full ``SSH``
[-] 	  environment (e.g., in a specific thread) and partially apply some
[+] 	  environment(e.g., in a specific thread) and partially apply some
[-] 			construct ();
[+] 			construct();
[-] 			open (
[+] 			open(
[-] 			close ();
[+] 			close();
[-] 			waitSshEvents ();
[+] 			waitSshEvents();
[-] 			onWriteButtonClicked ();
[+] 			onWriteButtonClicked();
[-] 			onSshEvent (
[+] 			onSshEvent(
[-] 		MyDialog.connect (
[+] 		MyDialog.connect(
[-] 			sockAddr.parse (addrString);
[+] 			sockAddr.parse(addrString);
[-] 			m_ssh.open ();
[+] 			m_ssh.open();
[-] 			m_ssh.connect (sockAddr, userName, password);
[+] 			m_ssh.connect(sockAddr, userName, password);
[-] 			waitSshEvents ();
[+] 			waitSshEvents();
[-] 		MyDialog.close ()
[+] 		MyDialog.close()
[-] 			m_serial.close ();
[+] 			m_serial.close();
[-] 		MyDialog.waitSshEvent ()
[+] 		MyDialog.waitSshEvent()
[-] 			m_ssh.wait (eventMask, onPcapEvent ~(++m_syncId) @
[+] 			m_ssh.wait(eventMask, onPcapEvent ~(++m_syncId) @
[-] 		MyDialog.onWriteButtonClicked ()
[+] 		MyDialog.onWriteButtonClicked()
[-] 			static char data [] = "a quick brown fox jumps over the lazy dog";
[+] 			static char data[] = "a quick brown fox jumps over the lazy dog";
[-] 			m_ssh.write (data, sizeof (data));
[+] 			m_ssh.write(data, sizeof(data));
[-] 		MyDialog.onSshEvent (
[+] 		MyDialog.onSshEvent(
[-] 				m_ssh.authenticate (userName, password);
[+] 				m_ssh.authenticate(userName, password);
[-] 				char buffer [256];
[+] 				char buffer[256];
[-] 				size_t size = m_ssh.read (buffer, sizeof (buffer));
[+] 				size_t size = m_ssh.read(buffer, sizeof(buffer));
[-] 			waitSshEvents (); // restart wait
[+] 			waitSshEvents(); // restart wait
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open (AddressFamily family);
[+] 	bool errorcode open(AddressFamily family);
[-] 	bool errorcode open (SocketAddress const* address);
[+] 	bool errorcode open(SocketAddress const* address);
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``io.SshChannel`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``io.SshChannel`` a *disposable* class[#f2]_.
[-] 		  side of this ``SSH`` channel (typically, ``shell``; can also be
[+] 		  side of this ``SSH`` channel(typically, ``shell``; can also be
[-] 		  run on the server side of this ``SSH`` channel (typically, ``xterm``;
[+] 		  run on the server side of this ``SSH`` channel(typically, ``xterm``;
[-] 	bool errorcode connect (
[+] 	bool errorcode connect(
[-] 	bool errorcode connect (SshConnectParams const* params);
[+] 	bool errorcode connect(SshConnectParams const* params);
[-] 	bool errorcode authenticate (
[+] 	bool errorcode authenticate(
[-] 	bool errorcode resizePty (
[+] 	bool errorcode resizePty(
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (SshEvents triggeredEvents)
[+] 		function* handler(SshEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	SshEvents errorcode blockingWait (
[+] 	SshEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc\io_UsbDevice.jnc
----------------------
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	void close ();
[+] 	void close();
[-] 	char const* errorcode getStringDesc (uint8_t stringId);
[+] 	char const* errorcode getStringDesc(uint8_t stringId);
[-] 	bool const property m_isKernelDriverActive (uint_t interfaceId);
[+] 	bool const property m_isKernelDriverActive(uint_t interfaceId);
[-] 	bool errorcode attachKernelDriver (uint_t interfaceId);
[+] 	bool errorcode attachKernelDriver(uint_t interfaceId);
[-] 	bool errorcode detachKernelDriver (uint_t interfaceId);
[+] 	bool errorcode detachKernelDriver(uint_t interfaceId);
[-] 	UsbInterface* errorcode claimInterface (
[+] 	UsbInterface* errorcode claimInterface(
[-] 	size_t errorcode controlTransfer (
[+] 	size_t errorcode controlTransfer(
[-] 	bool errorcode controlTransfer (
[+] 	bool errorcode controlTransfer(
[-] 		function* onCompleted (
[+] 		function* onCompleted(
[-] 	void cancelControlTransfers ();
[+] 	void cancelControlTransfers();
[-] UsbDevice* const* errorcode createUsbDeviceArray (size_t* count = null);
[+] UsbDevice* const* errorcode createUsbDeviceArray(size_t* count = null);
[-] UsbDevice* errorcode openUsbDevice (
[+] UsbDevice* errorcode openUsbDevice(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc\io_UsbEndpoint.jnc
----------------------
[-] getUsbTransferTypeString (UsbTransferType type);
[+] getUsbTransferTypeString(UsbTransferType type);
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	void close ();
[+] 	void close();
[-] 	size_t errorcode read (
[+] 	size_t errorcode read(
[-] 	size_t errorcode write (
[+] 	size_t errorcode write(
[-] 	intptr errorcode wait (
[+] 	intptr errorcode wait(
[-] 		function* handler (UsbEndpointEvents triggeredEvents)
[+] 		function* handler(UsbEndpointEvents triggeredEvents)
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	UsbEndpointEvents errorcode blockingWait (
[+] 	UsbEndpointEvents errorcode blockingWait(
----------------------
27/02/2019 18:02:19 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_io_usb\jnc\io_UsbInterface.jnc
----------------------
[-] getUsbClassString (UsbClass cls);
[+] getUsbClassString(UsbClass cls);
[-] getUsbSpeedString (UsbSpeed speed);
[+] getUsbSpeedString(UsbSpeed speed);
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	void release ();
[+] 	void release();
[-] 	UsbEndpoint* errorcode openEndpoint (uint8_t endpointId);
[+] 	UsbEndpoint* errorcode openEndpoint(uint8_t endpointId);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_DynamicLib.jnc
----------------------
[-] 	function names to pointers, (unsafely) cast these pointers to appropriate
[+] 	function names to pointers, (unsafely)cast these pointers to appropriate
[-] 		void foo ()
[+] 		void foo()
[-] 			lib.open ("libname"); // load library
[+] 			lib.open("libname"); // load library
[-] 			void thin* p = lib.getFunction ("foo"); // resolve function by name
[+] 			void thin* p = lib.getFunction("foo"); // resolve function by name
[-] 			typedef void stdcall FooFunc (int); // specify function type
[+] 			typedef void stdcall FooFunc(int); // specify function type
[-] 			foo (100); // call this function
[+] 			foo(100); // call this function
[-] 			void stdcall foo (int);
[+] 			void stdcall foo(int);
[-] 		void foo ()
[+] 		void foo()
[-] 			myLib.open ("libname"); // load library
[+] 			myLib.open("libname"); // load library
[-] 			myLib.lib.foo (100); // resolve, cache and call
[+] 			myLib.lib.foo(100); // resolve, cache and call
[-] 	Please note that when accessing functions from the dynamic library (``foo``
[+] 	Please note that when accessing functions from the dynamic library(``foo``
[-] 		This field holds the native handle of the dynamic library (``HMODULE``
[+] 		This field holds the native handle of the dynamic library(``HMODULE``
[-] 		bool get ()
[+] 		bool get()
[-] 	destruct ()
[+] 	destruct()
[-] 		close ();
[+] 		close();
[-] 		Opens (loads) a dynamic library.
[+] 		Opens(loads)a dynamic library.
[-] 	bool errorcode open (char const* fileName);
[+] 	bool errorcode open(char const* fileName);
[-] 		Closes (releases) a previously loaded dynamic library, does nothing if
[+] 		Closes(releases)a previously loaded dynamic library, does nothing if
[-] 	void close ();
[+] 	void close();
[-] 		Effectively makes ``jnc.DynamicLib`` a *disposable* class [#f2]_.
[+] 		Effectively makes ``jnc.DynamicLib`` a *disposable* class[#f2]_.
[-] 		Returns abstract pointer (``void thin*``), which then has to be cast
[+] 		Returns abstract pointer(``void thin*``), which then has to be cast
[-] 		to a ``thin`` function pointer of the proper type (e.g., ``void thin
[+] 		to a ``thin`` function pointer of the proper type(e.g., ``void thin
[-] 	void thin* errorcode getFunction (char const* fileName);
[+] 	void thin* errorcode getFunction(char const* fileName);
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_Promise.jnc
----------------------
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	intptr errorcode wait (function* handler ());
[+] 	intptr errorcode wait(function* handler());
[-] 	intptr errorcode wait (function* handler (std.Error const* error));
[+] 	intptr errorcode wait(function* handler(std.Error const* error));
[-] 	intptr errorcode wait (function* handler (
[+] 	intptr errorcode wait(function* handler(
[-] 	bool errorcode cancelWait (intptr handle);
[+] 	bool errorcode cancelWait(intptr handle);
[-] 	variant blockingWait ();
[+] 	variant blockingWait();
[-] 	variant async asyncWait ();
[+] 	variant async asyncWait();
[-] 	void complete ();
[+] 	void complete();
[-] 	void complete (std.Error const* error);
[+] 	void complete(std.Error const* error);
[-] 	void complete (
[+] 	void complete(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_Regex.jnc
----------------------
[-] 		reswitch (state, p, length)
[+] 		reswitch(state, p, length)
[-] 			print ($"bar id: $(state.m_subMatchArray [0].m_text)\n");
[+] 			print($"bar id: $(state.m_subMatchArray [0].m_text)\n");
[-] 		bool errorcode match (
[+] 		bool errorcode match(
[-] 				reswitch (state, p, end - p)
[+] 				reswitch(state, p, end - p)
[-] 					print ($"bar id: $(state.m_subMatchArray [0].m_text)\n");
[+] 					print($"bar id: $(state.m_subMatchArray [0].m_text)\n");
[-] 					assert (
[+] 					assert(
[-] 		jnc.RegexState state (true);  // turn on incremental matching
[+] 		jnc.RegexState state(true);  // turn on incremental matching
[-] 		size_t length = getNextPortionOfData (buffer);
[+] 		size_t length = getNextPortionOfData(buffer);
[-] 		match (state, buffer, length);
[+] 		match(state, buffer, length);
[-] 		match (state, null, 0);
[+] 		match(state, null, 0);
[-] 		``m_lexemeOffset`` will account for the initial offset (offset relative
[+] 		``m_lexemeOffset`` will account for the initial offset(offset relative
[-] 		sub-lexemes (if capturing regular expressions groups were used).
[+] 		sub-lexemes(if capturing regular expressions groups were used).
[-] 	construct (bool isIncremental = false);
[+] 	construct(bool isIncremental = false);
[-] 	reset ();
[+] 	reset();
[-] 	size_t exec (
[+] 	size_t exec(
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	clear ();
[+] 	clear();
[-] 	bool errorcode compile (
[+] 	bool errorcode compile(
[-] 		clear ();
[+] 		clear();
[-] 		return incrementalCompile (regexString, length) && finalize ();
[+] 		return incrementalCompile(regexString, length) && finalize();
[-] 	bool errorcode incrementalCompile (
[+] 	bool errorcode incrementalCompile(
[-] 	bool errorcode finalize ();
[+] 	bool errorcode finalize();
[-] 	size_t errorcode match (
[+] 	size_t errorcode match(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_Scheduler.jnc
----------------------
[-] 	function (e.g. IO completion routine or other event handler). A realistic
[+] 	function(e.g. IO completion routine or other event handler). A realistic
[-] 	2) use it to store IO completion event parameters (e.g. completion status,
[+] 	2) use it to store IO completion event parameters(e.g. completion status,
[-] 			override schedule (void function* f ())
[+] 			override schedule(void function* f())
[-] 				m_lock.lock ();
[+] 				m_lock.lock();
[-] 				f ();
[+] 				f();
[-] 				m_lock.unlock ();
[+] 				m_lock.unlock();
[-] 		typedef OnComplete (int x);
[+] 		typedef OnComplete(int x);
[-] 		work (OnComplete* onComplete)
[+] 		work(OnComplete* onComplete)
[-] 			onComplete (100);
[+] 			onComplete(100);
[-] 		bar (int a, int b, int c)
[+] 		bar(int a, int b, int c)
[-] 			printf ($"bar ($a, $b, $c) -- MUST be called under g_lock");
[+] 			printf($"bar ($a, $b, $c) -- MUST be called under g_lock");
[-] 		foo ()
[+] 		foo()
[-] 			work (bar ~(10, 20) @ scheduler); // pass as completion routine
[+] 			work(bar ~(10, 20) @ scheduler); // pass as completion routine
[-] 	abstract schedule (function* proc ());
[+] 	abstract schedule(function* proc());
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_StdFunctions.jnc
----------------------
[-] size_t dynamicSizeOf (void const* p);
[+] size_t dynamicSizeOf(void const* p);
[-] size_t dynamicCountOf (
[+] size_t dynamicCountOf(
[-] size_t dynamicTypeSizeOf (
[+] size_t dynamicTypeSizeOf(
[-] size_t dynamicFieldSizeOf (
[+] size_t dynamicFieldSizeOf(
[-] size_t dynamicFieldCountOf (
[+] size_t dynamicFieldCountOf(
[-] void* dynamicCastDataPtr (
[+] void* dynamicCastDataPtr(
[-] class* dynamicCastClassPtr (
[+] class* dynamicCastClassPtr(
[-] bool dynamicCastVariant (
[+] bool dynamicCastVariant(
[-] class* strengthenClassPtr (class weak* p);
[+] class* strengthenClassPtr(class weak* p);
[-] void assertionFailure (
[+] void assertionFailure(
[-] void addStaticDestructor (void thin* dtor);
[+] void addStaticDestructor(void thin* dtor);
[-] void addStaticClassDestructor (
[+] void addStaticClassDestructor(
[-] size_t appendFmtLiteral_a (
[+] size_t appendFmtLiteral_a(
[-] size_t appendFmtLiteral_p (
[+] size_t appendFmtLiteral_p(
[-] size_t appendFmtLiteral_i32 (
[+] size_t appendFmtLiteral_i32(
[-] size_t appendFmtLiteral_ui32 (
[+] size_t appendFmtLiteral_ui32(
[-] size_t appendFmtLiteral_i64 (
[+] size_t appendFmtLiteral_i64(
[-] size_t appendFmtLiteral_ui64 (
[+] size_t appendFmtLiteral_ui64(
[-] size_t appendFmtLiteral_f (
[+] size_t appendFmtLiteral_f(
[-] size_t appendFmtLiteral_v (
[+] size_t appendFmtLiteral_v(
[-] bool errorcode tryCheckDataPtrRangeDirect (
[+] bool errorcode tryCheckDataPtrRangeDirect(
[-] void checkDataPtrRangeDirect (
[+] void checkDataPtrRangeDirect(
[-] bool errorcode tryCheckNullPtr (
[+] bool errorcode tryCheckNullPtr(
[-] void checkNullPtr (
[+] void checkNullPtr(
[-] void checkStackOverflow ();
[+] void checkStackOverflow();
[-] void checkDivByZero_i32 (int32_t x);
[+] void checkDivByZero_i32(int32_t x);
[-] void checkDivByZero_i64 (int64_t x);
[+] void checkDivByZero_i64(int64_t x);
[-] void checkDivByZero_f32 (float x);
[+] void checkDivByZero_f32(float x);
[-] void checkDivByZero_f64 (double x);
[+] void checkDivByZero_f64(double x);
[-] void thin* errorcode tryLazyGetDynamicLibFunction (
[+] void thin* errorcode tryLazyGetDynamicLibFunction(
[-] void thin* lazyGetDynamicLibFunction (
[+] void thin* lazyGetDynamicLibFunction(
[-] void thin* getDynamicField (
[+] void thin* getDynamicField(
----------------------
27/02/2019 18:02:20 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_rtl\jnc\jnc_StdTypes.jnc
----------------------
[-] 	destruct ();
[+] 	destruct();
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_Array.jnc
----------------------
[-] 	variant get (size_t index)
[+] 	variant get(size_t index)
[-] 		boundsCheck (index);
[+] 		boundsCheck(index);
[-] 		return m_p [index];
[+] 		return m_p[index];
[-] 	set (
[+] 	set(
[-] 		boundsCheck (index);
[+] 		boundsCheck(index);
[-] 		m_p [index] = e;
[+] 		m_p[index] = e;
[-] 	clear ();
[+] 	clear();
[-] 	detach ()
[+] 	detach()
[-] 	bool errorcode setCount (size_t count);
[+] 	bool errorcode setCount(size_t count);
[-] 	bool errorcode reserve (size_t count);
[+] 	bool errorcode reserve(size_t count);
[-] 	size_t errorcode copy (
[+] 	size_t errorcode copy(
[-] 	size_t errorcode copy (variant e)
[+] 	size_t errorcode copy(variant e)
[-] 		return copy (&e, 1);
[+] 		return copy(&e, 1);
[-] 	size_t errorcode append (variant e)
[+] 	size_t errorcode append(variant e)
[-] 		return insert (-1, &e, 1);
[+] 		return insert(-1, &e, 1);
[-] 	size_t errorcode append (
[+] 	size_t errorcode append(
[-] 		return insert (-1, p, count);
[+] 		return insert(-1, p, count);
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 		return insert (index, &e, 1);
[+] 		return insert(index, &e, 1);
[-] 	size_t remove (
[+] 	size_t remove(
[-] 	boundsCheck (size_t index)
[+] 	boundsCheck(size_t index)
[-] 			std.setError ($"attempt to access out-of-bounds index $index (count: $m_count)");
[+] 			std.setError($"attempt to access out-of-bounds index $index (count: $m_count)");
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_Buffer.jnc
----------------------
[-] 	char get (size_t offset)
[+] 	char get(size_t offset)
[-] 		boundsCheck (offset);
[+] 		boundsCheck(offset);
[-] 		return m_p [offset];
[+] 		return m_p[offset];
[-] 	set (
[+] 	set(
[-] 		boundsCheck (offset);
[+] 		boundsCheck(offset);
[-] 		m_p [offset] = e;
[+] 		m_p[offset] = e;
[-] 	clear ();
[+] 	clear();
[-] 	detach ()
[+] 	detach()
[-] 	bool errorcode setSize (size_t size);
[+] 	bool errorcode setSize(size_t size);
[-] 	bool errorcode reserve (size_t size);
[+] 	bool errorcode reserve(size_t size);
[-] 	size_t errorcode copy (
[+] 	size_t errorcode copy(
[-] 	size_t errorcode append (
[+] 	size_t errorcode append(
[-] 		return insert (-1, p, size);
[+] 		return insert(-1, p, size);
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 	size_t errorcode remove (
[+] 	size_t errorcode remove(
[-] 	boundsCheck (size_t offset)
[+] 	boundsCheck(size_t offset)
[-] 			std.setError ($"attempt to access out-of-bounds offset $offset (size: $m_size)");
[+] 			std.setError($"attempt to access out-of-bounds offset $offset (size: $m_size)");
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_Error.jnc
----------------------
[-] 		``>= sizeof (std.Error)``.
[+] 		``>= sizeof(std.Error)``.
[-] 			printf ($"cannot open file: $!\n");
[+] 			printf($"cannot open file: $!\n");
[-] 			printf ($"cannot open file: $s\n");
[+] 			printf($"cannot open file: $s\n");
[-] 	future caching will be implemented (if ``AXL`` error has not changed since
[+] 	future caching will be implemented(if ``AXL`` error has not changed since
[-] Error const* getLastError ();
[+] Error const* getLastError();
[-] 		std.getLastError ().:ref:`m_description<cid-std.error.m_description>`
[+] 		std.getLastError().:ref:`m_description<cid-std.error.m_description>`
[-] char const* getLastErrorDescription ()
[+] char const* getLastErrorDescription()
[-] 	return getLastError ().m_description;
[+] 	return getLastError().m_description;
[-] setError (Error const* error);
[+] setError(Error const* error);
[-] setErrno (int errno);
[+] setErrno(int errno);
[-] setError (char const* string);
[+] setError(char const* string);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_globals.jnc
----------------------
[-] 		location ``p + dynamic sizeof (p)`` -- even if the actual byte at this
[+] 		location ``p + dynamic sizeof(p)`` -- even if the actual byte at this
[-] 		Note that this function uses ``C`` vararg calling convention (and
[+] 		Note that this function uses ``C`` vararg calling convention(and
[-] 	the beginning of the string ``p`` and the very first ``0`` byte [#f1]_.
[+] 	the beginning of the string ``p`` and the very first ``0`` byte[#f1]_.
[-] size_t strlen (char const* p);
[+] size_t strlen(char const* p);
[-] int strcmp (
[+] int strcmp(
[-] int strncmp (
[+] int strncmp(
[-] int stricmp (
[+] int stricmp(
[-] int strnicmp (
[+] int strnicmp(
[-] bool streq (
[+] bool streq(
[-] 	return strcmp (p1, p2) == 0;
[+] 	return strcmp(p1, p2) == 0;
[-] bool strneq (
[+] bool strneq(
[-] 	return strncmp (p1, p2, length) == 0;
[+] 	return strncmp(p1, p2, length) == 0;
[-] bool strieq (
[+] bool strieq(
[-] 	return stricmp (p1, p2) == 0;
[+] 	return stricmp(p1, p2) == 0;
[-] bool strnieq (
[+] bool strnieq(
[-] 	return strnicmp (p1, p2, length) == 0;
[+] 	return strnicmp(p1, p2, length) == 0;
[-] char const* strchr (
[+] char const* strchr(
[-] char const* strichr (
[+] char const* strichr(
[-] char const* strstr (
[+] char const* strstr(
[-] char const* stristr (
[+] char const* stristr(
[-] void strcpy (
[+] void strcpy(
[-] char const* errorcode strcat (
[+] char const* errorcode strcat(
[-] char const* errorcode strdup (
[+] char const* errorcode strdup(
[-] size_t strdjb2 (char const* p)
[+] size_t strdjb2(char const* p)
[-] 	return memdjb2 (p, strlen (p));
[+] 	return memdjb2(p, strlen(p));
[-] size_t stridjb2 (char const* p);
[+] size_t stridjb2(char const* p);
[-] int memcmp (
[+] int memcmp(
[-] void const* memchr (
[+] void const* memchr(
[-] void const* memmem (
[+] void const* memmem(
[-] void memcpy (
[+] void memcpy(
[-] 	Moves memory block ``src:size`` [#f2]_ to the (possibly overlapping) buffer
[+] 	Moves memory block ``src:size`` [#f2]_ to the(possibly overlapping) buffer
[-] void memmove (
[+] void memmove(
[-] void memset (
[+] void memset(
[-] void* errorcode memcat (
[+] void* errorcode memcat(
[-] void* errorcode memdup (
[+] void* errorcode memdup(
[-] size_t memdjb2 (
[+] size_t memdjb2(
[-] int rand ();
[+] int rand();
[-] uint32_t toupper (uint32_t c);
[+] uint32_t toupper(uint32_t c);
[-] uint32_t tolower (uint32_t c);
[+] uint32_t tolower(uint32_t c);
[-] int atoi (char const* p);
[+] int atoi(char const* p);
[-] long strtol (
[+] long strtol(
[-] 		char* s = gets ();
[+] 		char* s = gets();
[-] 		size_t length = dynamic sizeof (s) - 1;
[+] 		size_t length = dynamic sizeof(s) - 1;
[-] char* gets ();
[+] char* gets();
[-] size_t print (char const* text);
[+] size_t print(char const* text);
[-] size_t print_u (char const thin* text);
[+] size_t print_u(char const thin* text);
[-] size_t perror (char const* text);
[+] size_t perror(char const* text);
[-] 	Prints formatted output to the standard output stream [#f3]_.
[+] 	Prints formatted output to the standard output stream[#f3]_.
[-] intptr_t cdecl printf (
[+] intptr_t cdecl printf(
[-] 	printed, the content is stored in a memory buffer [#f3]_.
[+] 	printed, the content is stored in a memory buffer[#f3]_.
[-] char const* cdecl errorcode format (
[+] char const* cdecl errorcode format(
[-] 	itself (as part of jnc.Box, not as part of a dynamic pointer). Therefore,
[+] 	itself(as part of jnc.Box, not as part of a dynamic pointer). Therefore,
[-] 		char buffer [1024];
[+] 		char buffer[1024];
[-] 		file.read (buffer, sizeof (buffer));
[+] 		file.read(buffer, sizeof(buffer));
[-] 		file.read (buffer, sizeof (buffer));
[+] 		file.read(buffer, sizeof(buffer));
[-] 		std.resetDynamicLayout (buffer);
[+] 		std.resetDynamicLayout(buffer);
[-] void resetDynamicLayout (void const* p);
[+] void resetDynamicLayout(void const* p);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_Guid.jnc
----------------------
[-] 	\brief This struct describes a globally unique identifier (GUID).
[+] 	\brief This struct describes a globally unique identifier(GUID).
[-] 	uint8_t m_data4 [8];
[+] 	uint8_t m_data4[8];
[-] 	construct ()
[+] 	construct()
[-] 	construct (char const* string)
[+] 	construct(char const* string)
[-] 		parse (string);
[+] 		parse(string);
[-] 	bool isEqual (Guid const* op) const
[+] 	bool isEqual(Guid const* op) const
[-] 		return memcmp (this, op, sizeof (Guid)) == 0;
[+] 		return memcmp(this, op, sizeof(Guid)) == 0;
[-] 		return isEqual (op);
[+] 		return isEqual(op);
[-] 		return !isEqual (op);
[+] 		return !isEqual(op);
[-] 		parse (string);
[+] 		parse(string);
[-] 	char const* getString (GuidStringFlags flags = 0);
[+] 	char const* getString(GuidStringFlags flags = 0);
[-] 	bool errorcode parse (char const* string);
[+] 	bool errorcode parse(char const* string);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_HashTable.jnc
----------------------
[-] typedef size_t HashFunc (variant key);
[+] typedef size_t HashFunc(variant key);
[-] typedef bool IsEqualFunc (
[+] typedef bool IsEqualFunc(
[-] 	* Add ``(key; value)`` pairs using ``add`` method (or by accessing the
[+] 	* Add ``(key; value)`` pairs using ``add`` method(or by accessing the
[-] 	  method (or by accessing the *indexer* property).
[+] 	  method(or by accessing the *indexer* property).
[-] 		hashTable [State.Idle] = "idle";
[+] 		hashTable[State.Idle] = "idle";
[-] 		hashTable [State.Running] = "running";
[+] 		hashTable[State.Running] = "running";
[-] 		hashTable [State.Stopping] = "stopping";
[+] 		hashTable[State.Stopping] = "stopping";
[-] 		State state = (State) (rand () % State._Count);
[+] 		State state = (State)(rand() % State._Count);
[-] 		printf ($"state: $(hashTable [state])\n");
[+] 		printf($"state: $(hashTable [state])\n");
[-] 	construct (
[+] 	construct(
[-] 	destruct ();
[+] 	destruct();
[-] 	bool m_isEmpty.get ()
[+] 	bool m_isEmpty.get()
[-] 	variant get (variant key)
[+] 	variant get(variant key)
[-] 		return findValue (key, null);
[+] 		return findValue(key, null);
[-] 	set (
[+] 	set(
[-] 		add (key, value);
[+] 		add(key, value);
[-] 	clear ();
[+] 	clear();
[-] 	MapEntry* errorcode visit (variant key);
[+] 	MapEntry* errorcode visit(variant key);
[-] 	MapEntry cmut* find (variant key) const;
[+] 	MapEntry cmut* find(variant key) const;
[-] 	variant findValue (
[+] 	variant findValue(
[-] 		MapEntry* entry = find (key);
[+] 		MapEntry* entry = find(key);
[-] 	MapEntry* errorcode add (
[+] 	MapEntry* errorcode add(
[-] 		MapEntry* entry = visit (key);
[+] 		MapEntry* entry = visit(key);
[-] 	void remove (MapEntry* entry);
[+] 	void remove(MapEntry* entry);
[-] 	bool removeKey (variant key)
[+] 	bool removeKey(variant key)
[-] 		MapEntry* entry = find (key);
[+] 		MapEntry* entry = find(key);
[-] 		remove (entry);
[+] 		remove(entry);
[-] 	construct ()
[+] 	construct()
[-] 		basetype.construct (strdjb2, streq);
[+] 		basetype.construct(strdjb2, streq);
[-] 	construct ()
[+] 	construct()
[-] 		basetype.construct (stridjb2, strieq);
[+] 		basetype.construct(stridjb2, strieq);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_List.jnc
----------------------
[-] 		int a [] = { 10, 20, 30, 40, 50, }
[+] 		int a[] = { 10, 20, 30, 40, 50, }
[-] 		for (size_t i = 0; i < countof (a); i++)
[+] 		for (size_t i = 0; i < countof(a); i++)
[-] 			list.insertTail (a [i]);
[+] 			list.insertTail(a[i]);
[-] 	clear ();
[+] 	clear();
[-] 	takeOver (List* list);
[+] 	takeOver(List* list);
[-] 	ListEntry* errorcode add (variant data)
[+] 	ListEntry* errorcode add(variant data)
[-] 		return insertTail (data);
[+] 		return insertTail(data);
[-] 	ListEntry* errorcode insertHead (variant data);
[+] 	ListEntry* errorcode insertHead(variant data);
[-] 	ListEntry* errorcode insertTail (variant data);
[+] 	ListEntry* errorcode insertTail(variant data);
[-] 	ListEntry* errorcode insertBefore (
[+] 	ListEntry* errorcode insertBefore(
[-] 	ListEntry* errorcode insertAfter (
[+] 	ListEntry* errorcode insertAfter(
[-] 	moveToHead (ListEntry* entry);
[+] 	moveToHead(ListEntry* entry);
[-] 	moveToTail (ListEntry* entry);
[+] 	moveToTail(ListEntry* entry);
[-] 	moveBefore (
[+] 	moveBefore(
[-] 	moveAfter (
[+] 	moveAfter(
[-] 	variant removeHead ();
[+] 	variant removeHead();
[-] 	variant removeTail ();
[+] 	variant removeTail();
[-] 	variant remove (ListEntry* entry);
[+] 	variant remove(ListEntry* entry);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_RbTree.jnc
----------------------
[-] typedef int CmpFunc (
[+] typedef int CmpFunc(
[-] 	construct (CmpFunc thin* cmpFunc = null);
[+] 	construct(CmpFunc thin* cmpFunc = null);
[-] 	destruct ();
[+] 	destruct();
[-] 	bool m_isEmpty.get ()
[+] 	bool m_isEmpty.get()
[-] 	variant get (variant key)
[+] 	variant get(variant key)
[-] 		return findValue (key, null);
[+] 		return findValue(key, null);
[-] 	set (
[+] 	set(
[-] 		add (key, value);
[+] 		add(key, value);
[-] 	clear ();
[+] 	clear();
[-] 	MapEntry* errorcode visit (variant key);
[+] 	MapEntry* errorcode visit(variant key);
[-] 	MapEntry cmut* find (variant key) const;
[+] 	MapEntry cmut* find(variant key) const;
[-] 	MapEntry cmut* find (
[+] 	MapEntry cmut* find(
[-] 	variant findValue (
[+] 	variant findValue(
[-] 		MapEntry* entry = find (key);
[+] 		MapEntry* entry = find(key);
[-] 	variant findValue (
[+] 	variant findValue(
[-] 		MapEntry* entry = find (key, relOp);
[+] 		MapEntry* entry = find(key, relOp);
[-] 	MapEntry* errorcode add (
[+] 	MapEntry* errorcode add(
[-] 		MapEntry* entry = visit (key);
[+] 		MapEntry* entry = visit(key);
[-] 	void remove (MapEntry* entry);
[+] 	void remove(MapEntry* entry);
[-] 	bool removeKey (variant key)
[+] 	bool removeKey(variant key)
[-] 		MapEntry* entry = find (key);
[+] 		MapEntry* entry = find(key);
[-] 		remove (entry);
[+] 		remove(entry);
----------------------
27/02/2019 18:02:21 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_std\jnc\std_String.jnc
----------------------
[-] 		char const* get ()
[+] 		char const* get()
[-] 	char get (size_t offset)
[+] 	char get(size_t offset)
[-] 		boundsCheck (offset);
[+] 		boundsCheck(offset);
[-] 		return m_p [offset];
[+] 		return m_p[offset];
[-] 	set (
[+] 	set(
[-] 		boundsCheck (offset);
[+] 		boundsCheck(offset);
[-] 		m_p [offset] = e;
[+] 		m_p[offset] = e;
[-] 		return copy (p);
[+] 		return copy(p);
[-] 		return append (p);
[+] 		return append(p);
[-] 	clear ();
[+] 	clear();
[-] 	bool errorcode reserve (size_t length);
[+] 	bool errorcode reserve(size_t length);
[-] 	size_t errorcode copy (
[+] 	size_t errorcode copy(
[-] 	size_t errorcode copy (
[+] 	size_t errorcode copy(
[-] 	size_t errorcode copy (
[+] 	size_t errorcode copy(
[-] 	size_t errorcode copy (utf32_t c)
[+] 	size_t errorcode copy(utf32_t c)
[-] 		return copy (&c, 1);
[+] 		return copy(&c, 1);
[-] 	size_t errorcode append (
[+] 	size_t errorcode append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	size_t errorcode append (
[+] 	size_t errorcode append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	size_t errorcode append (
[+] 	size_t errorcode append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	size_t errorcode append (utf32_t c)
[+] 	size_t errorcode append(utf32_t c)
[-] 		return insert (-1, &c, 1);
[+] 		return insert(-1, &c, 1);
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 	size_t errorcode insert (
[+] 	size_t errorcode insert(
[-] 		return insert (offset, &c, 1);
[+] 		return insert(offset, &c, 1);
[-] 	size_t remove (
[+] 	size_t remove(
[-] 	char* errorcode detachString ();
[+] 	char* errorcode detachString();
[-] 	char* errorcode cloneString ();
[+] 	char* errorcode cloneString();
[-] 	boundsCheck (size_t offset)
[+] 	boundsCheck(size_t offset)
[-] 			std.setError ($"attempt to access out-of-bounds offset $offset (length: $m_length)");
[+] 			std.setError($"attempt to access out-of-bounds offset $offset (length: $m_length)");
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_Event.jnc
----------------------
[-] 		thread1 ()
[+] 		thread1()
[-] 			g_event.wait (); // thread sleeps here until event is signalled
[+] 			g_event.wait(); // thread sleeps here until event is signalled
[-] 		thread2 ()
[+] 		thread2()
[-] 			g_event.signal (); // thread1 wakes up and continues;
[+] 			g_event.signal(); // thread1 wakes up and continues;
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	signal ();
[+] 	signal();
[-] 	reset ();
[+] 	reset();
[-] 	bool wait (uint_t timeout = -1);
[+] 	bool wait(uint_t timeout = -1);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_globals.jnc
----------------------
[-] char const* property g_env (char const* name);
[+] char const* property g_env(char const* name);
[-] 	Returns the thread identifier (TID) of the current thread.
[+] 	Returns the thread identifier(TID)of the current thread.
[-] uintptr_t getCurrentThreadId ();
[+] uintptr_t getCurrentThreadId();
[-] 		myThreadFunc (
[+] 		myThreadFunc(
[-] 		sys.createThread (myThreadFunc ~(100, "string-context"));
[+] 		sys.createThread(myThreadFunc ~(100, "string-context"));
[-] bool createThread (function* threadFunc ());
[+] bool createThread(function* threadFunc());
[-] void sleep (uint32_t timeout);
[+] void sleep(uint32_t timeout);
[-] uint64_t getTimestamp ();
[+] uint64_t getTimestamp();
[-] uint64_t getPreciseTimestamp ();
[+] uint64_t getPreciseTimestamp();
[-] 	%h -- hour in 24-hour format (00..24)
[+] 	%h -- hour in 24-hour format(00..24)
[-] 	%H -- hour in 12-hour format (1..12)
[+] 	%H -- hour in 12-hour format(1..12)
[-] 	%m -- minutes (00..59)
[+] 	%m -- minutes(00..59)
[-] 	%s -- seconds (00..59)
[+] 	%s -- seconds(00..59)
[-] 	%l -- milliseconds (0..999)
[+] 	%l -- milliseconds(0..999)
[-] 	%c -- microseconds (0..999)
[+] 	%c -- microseconds(0..999)
[-] 	%p -- AM / PM designition lower case (a / p)
[+] 	%p -- AM / PM designition lower case(a / p)
[-] 	%p -- AM / PM designition upper case (A / P)
[+] 	%p -- AM / PM designition upper case(A / P)
[-] 	%y -- year, last 2-digit format (0..99)
[+] 	%y -- year, last 2-digit format(0..99)
[-] 	%D -- day of month, leading zero (01..31)
[+] 	%D -- day of month, leading zero(01..31)
[-] 	%d -- day of month, no leading zero (1..31)
[+] 	%d -- day of month, no leading zero(1..31)
[-] 	%M -- month index, leading zero (01..12)
[+] 	%M -- month index, leading zero(01..12)
[-] 	%o -- month index, no leading zero (1..12)
[+] 	%o -- month index, no leading zero(1..12)
[-] 	%n -- month short name (Jan..Dec)
[+] 	%n -- month short name(Jan..Dec)
[-] 	%N -- month full name (January..December)
[+] 	%N -- month full name(January..December)
[-] 	%w -- week day short name (Sun..Sat)
[+] 	%w -- week day short name(Sun..Sat)
[-] 	%W -- week day full name (Sunday..Saturday)
[+] 	%W -- week day full name(Sunday..Saturday)
[-] char const* formatTimestamp (
[+] char const* formatTimestamp(
[-] char const* formatTimestamp (
[+] char const* formatTimestamp(
[-] GcStats getGcStats ();
[+] GcStats getGcStats();
[-] void collectGarbage ();
[+] void collectGarbage();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_Lock.jnc
----------------------
[-] 		thread1 ()
[+] 		thread1()
[-] 			g_lock.lock ();   // acquire the lock
[+] 			g_lock.lock();   // acquire the lock
[-] 			g_lock.unlock (); // let others get access, too
[+] 			g_lock.unlock(); // let others get access, too
[-] 		thread2 ()
[+] 		thread2()
[-] 			g_lock.lock ();   // acquire the lock
[+] 			g_lock.lock();   // acquire the lock
[-] 			g_lock.unlock (); // let others get access, too
[+] 			g_lock.unlock(); // let others get access, too
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	lock ();
[+] 	lock();
[-] 	unlock ();
[+] 	unlock();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_NotificationEvent.jnc
----------------------
[-] 		thread1 ()
[+] 		thread1()
[-] 			g_event.wait (); // thread sleeps here until event is signalled
[+] 			g_event.wait(); // thread sleeps here until event is signalled
[-] 		thread2 ()
[+] 		thread2()
[-] 			g_event.wait (); // thread sleeps here until event is signalled
[+] 			g_event.wait(); // thread sleeps here until event is signalled
[-] 		thread3 ()
[+] 		thread3()
[-] 			g_event.signal (); // thread1 and thread2 wake up and continue;
[+] 			g_event.signal(); // thread1 and thread2 wake up and continue;
[-] 			g_event.reset (); // not signalled anymore
[+] 			g_event.reset(); // not signalled anymore
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	signal ();
[+] 	signal();
[-] 	reset ();
[+] 	reset();
[-] 	bool wait (uint_t timeout = -1);
[+] 	bool wait(uint_t timeout = -1);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_Thread.jnc
----------------------
[-] 		workerThread (
[+] 		workerThread(
[-] 		int main ()
[+] 		int main()
[-] 			thread1.start (workerThread ~(1, 2));
[+] 			thread1.start(workerThread ~(1, 2));
[-] 			thread2.start (workerThread ~(3, 4));
[+] 			thread2.start(workerThread ~(3, 4));
[-] 	protected function* m_threadFunc ();
[+] 	protected function* m_threadFunc();
[-] 		Holds native TID (thread identifier) of the thread controlled by
[+] 		Holds native TID(thread identifier) of the thread controlled by
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode start (function* func ());
[+] 	bool errorcode start(function* func());
[-] 	bool wait (uint_t timeout = -1);
[+] 	bool wait(uint_t timeout = -1);
[-] 	void waitAndClose (uint_t timeout = -1);
[+] 	void waitAndClose(uint_t timeout = -1);
[-] 	bool terminate ();
[+] 	bool terminate();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\src\jnc_ext\jnc_sys\jnc\sys_Timer.jnc
----------------------
[-] 	\brief This class provides facilities to manage both peridodic (repetitive)
[+] 	\brief This class provides facilities to manage both peridodic(repetitive)
[-] 	and non-periodic (single-shot) timers.
[+] 	and non-periodic(single-shot) timers.
[-] 	Each instance of ``sys.Timer`` manages a single timer (either periodic, or
[+] 	Each instance of ``sys.Timer`` manages a single timer(either periodic, or
[-] 	recommended to use *disposable* pattern [#f1]_.
[+] 	recommended to use *disposable* pattern[#f1]_.
[-] 		onTimer (int param)
[+] 		onTimer(int param)
[-] 		int main ()
[+] 		int main()
[-] 			timer.startPeriodic (onTimer ~(1, 2), 1000);
[+] 			timer.startPeriodic(onTimer ~(1, 2), 1000);
[-] 	protected function* m_timerFunc ();
[+] 	protected function* m_timerFunc();
[-] 	construct ();
[+] 	construct();
[-] 	destruct ();
[+] 	destruct();
[-] 	bool errorcode start (
[+] 	bool errorcode start(
[-] 		function* func (),
[+] 		function* func(),
[-] 		For local timers it is recommended to use *disposable* pattern [#f1]_.
[+] 		For local timers it is recommended to use *disposable* pattern[#f1]_.
[-] 	void stop ();
[+] 	void stop();
[-] 		Effectively makes ``sys.Timer`` a *disposable* class [#f1]_.
[+] 		Effectively makes ``sys.Timer`` a *disposable* class[#f1]_.
[-] 	bool errorcode startDueTimer (
[+] 	bool errorcode startDueTimer(
[-] 		function* func (),
[+] 		function* func(),
[-] 		return start (func, dueTime, 0);
[+] 		return start(func, dueTime, 0);
[-] 		argument calculated as ``sys.getTimestamp () + interval``.
[+] 		argument calculated as ``sys.getTimestamp() + interval``.
[-] 	bool errorcode startPeriodicTimer (
[+] 	bool errorcode startPeriodicTimer(
[-] 		function* func (),
[+] 		function* func(),
[-] 		uint64_t dueTime = sys.getTimestamp () + interval * 10000;
[+] 		uint64_t dueTime = sys.getTimestamp() + interval * 10000;
[-] 		return start (func, dueTime, interval);
[+] 		return start(func, dueTime, interval);
[-] 		``sys.getTimestamp () + interval`` and ``interval`` set to ``0``.
[+] 		``sys.getTimestamp() + interval`` and ``interval`` set to ``0``.
[-] 	bool errorcode startSingleShotTimer (
[+] 	bool errorcode startSingleShotTimer(
[-] 		function* func (),
[+] 		function* func(),
[-] 		uint64_t dueTime = sys.getTimestamp () + delay * 10000;
[+] 		uint64_t dueTime = sys.getTimestamp() + delay * 10000;
[-] 		return start (func, dueTime, 0);
[+] 		return start(func, dueTime, 0);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\doc_Layer.jnc
----------------------
[-] 	construct (PluginHost* host)
[+] 	construct(PluginHost* host)
[-] 		basetype.construct (host);
[+] 		basetype.construct(host);
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 		return transmitNext (p, size);
[+] 		return transmitNext(p, size);
[-] 	size_t transmitNext (
[+] 	size_t transmitNext(
[-] 	size_t transmitToNext (
[+] 	size_t transmitToNext(
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\doc_Plugin.jnc
----------------------
[-] 	construct (PluginHost* host)
[+] 	construct(PluginHost* host)
[-] 	virtual void load (Storage* storage)
[+] 	virtual void load(Storage* storage)
[-] 	virtual void save (Storage* storage)
[+] 	virtual void save(Storage* storage)
[-] 	virtual void updateProperties ()
[+] 	virtual void updateProperties()
[-] 	virtual bool errorcode applyProperties ()
[+] 	virtual bool errorcode applyProperties()
[-] 	virtual void restoreDefaultProperties ()
[+] 	virtual void restoreDefaultProperties()
[-] 	abstract size_t errorcode transmit (
[+] 	abstract size_t errorcode transmit(
[-] 	virtual size_t errorcode transmitTo (
[+] 	virtual size_t errorcode transmitTo(
[-] 		return transmit (p, size);
[+] 		return transmit(p, size);
[-] 	writeLog (
[+] 	writeLog(
[-] 		m_pluginHost.m_log.m_writer.write (recordCode, p, size);
[+] 		m_pluginHost.m_log.m_writer.write(recordCode, p, size);
[-] 	writeLog (uint64_t recordCode)
[+] 	writeLog(uint64_t recordCode)
[-] 		m_pluginHost.m_log.m_writer.write (recordCode, null, 0);
[+] 		m_pluginHost.m_log.m_writer.write(recordCode, null, 0);
[-] 	writeLogString (
[+] 	writeLogString(
[-] 		m_pluginHost.m_log.m_writer.write (recordCode, p, strlen (p));
[+] 		m_pluginHost.m_log.m_writer.write(recordCode, p, strlen(p));
[-] 	writeLogError (
[+] 	writeLogError(
[-] 		m_pluginHost.m_log.m_writer.write (recordCode, error, error.m_size);
[+] 		m_pluginHost.m_log.m_writer.write(recordCode, error, error.m_size);
[-] 	writeLogLastError (uint64_t recordCode)
[+] 	writeLogLastError(uint64_t recordCode)
[-] 		writeLogError (recordCode, std.getLastError ());
[+] 		writeLogError(recordCode, std.getLastError());
[-] 	gui.Action* createAction (
[+] 	gui.Action* createAction(
[-] 	gui.Action* createAction (
[+] 	gui.Action* createAction(
[-] 		return createAction (text, new gui.Icon (iconFileName), isCheckable, isChecked);
[+] 		return createAction(text, new gui.Icon(iconFileName), isCheckable, isChecked);
[-] gui.Action* Plugin.createAction (
[+] gui.Action* Plugin.createAction(
[-] 	gui.Action* action = new gui.Action (text, icon);
[+] 	gui.Action* action = new gui.Action(text, icon);
[-] 	m_pluginHost.m_menu.addAction (action);
[+] 	m_pluginHost.m_menu.addAction(action);
[-] 	m_pluginHost.m_toolBar.addAction (action);
[+] 	m_pluginHost.m_toolBar.addAction(action);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\doc_PluginHost.jnc
----------------------
[-] 	override schedule (function* f ());
[+] 	override schedule(function* f());
[-] 	destruct ();
[+] 	destruct();
[-] trace (char const* p);
[+] trace(char const* p);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\doc_Session.jnc
----------------------
[-] 	construct (PluginHost* host)
[+] 	construct(PluginHost* host)
[-] 		basetype.construct (host);
[+] 		basetype.construct(host);
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	startSession ()
[+] 	startSession()
[-] 		uint64_t timestamp = sys.getPreciseTimestamp ();
[+] 		uint64_t timestamp = sys.getPreciseTimestamp();
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, log.StdRecordCode.SessionStarted);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, log.StdRecordCode.SessionStarted);
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\doc_Storage.jnc
----------------------
[-] 	destruct ();
[+] 	destruct();
[-] 	void clear ();
[+] 	void clear();
[-] 	bool readBool (
[+] 	bool readBool(
[-] 		return readInt (name, defaultValue) != 0;
[+] 		return readInt(name, defaultValue) != 0;
[-] 	void writeBool (
[+] 	void writeBool(
[-] 		return writeInt (name, value);
[+] 		return writeInt(name, value);
[-] 	int readInt (
[+] 	int readInt(
[-] 	void writeInt (
[+] 	void writeInt(
[-] 	char const* readString (
[+] 	char const* readString(
[-] 	void writeString (
[+] 	void writeString(
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Action.jnc
----------------------
[-] 	construct (
[+] 	construct(
[-] 	event m_onTriggered ();
[+] 	event m_onTriggered();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Color.jnc
----------------------
[-] uint_t rgb (
[+] uint_t rgb(
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_ComboBox.jnc
----------------------
[-] 		set (char const* value);
[+] 		set(char const* value);
[-] 	destruct ();
[+] 	destruct();
[-] 	void adjustSizeToContents ();
[+] 	void adjustSizeToContents();
[-] 	size_t addItem (
[+] 	size_t addItem(
[-] 		return insertItem (-1, text, data);
[+] 		return insertItem(-1, text, data);
[-] 	size_t insertItem (
[+] 	size_t insertItem(
[-] 	bool removeItem (size_t index);
[+] 	bool removeItem(size_t index);
[-] 	void clear ();
[+] 	void clear();
[-] 	char const* property m_itemText (size_t index);
[+] 	char const* property m_itemText(size_t index);
[-] 	variant property m_itemData (size_t index);
[+] 	variant property m_itemData(size_t index);
[-] 		char const* get ();
[+] 		char const* get();
[-] 		variant get ();
[+] 		variant get();
[-] 		set (variant value);
[+] 		set(variant value);
[-] 	event m_onChanged ();
[+] 	event m_onChanged();
[-] 	event m_onEnter ();
[+] 	event m_onEnter();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Dialog.jnc
----------------------
[-] 	event m_onCompleted (StdDlgButton button);
[+] 	event m_onCompleted(StdDlgButton button);
[-] 	construct ();
[+] 	construct();
[-] 	show ();
[+] 	show();
[-] 	event m_onCompleted (StdDlgButton button);
[+] 	event m_onCompleted(StdDlgButton button);
[-] 	construct ();
[+] 	construct();
[-] 	show ();
[+] 	show();
[-] 	event m_onCompleted (StdDlgButton button);
[+] 	event m_onCompleted(StdDlgButton button);
[-] 	construct ();
[+] 	construct();
[-] 	show ();
[+] 	show();
[-] 	event m_onButtonClicked (StdDlgButton button);
[+] 	event m_onButtonClicked(StdDlgButton button);
[-] 	construct ();
[+] 	construct();
[-] 	show ();
[+] 	show();
[-] 	hide ();
[+] 	hide();
----------------------
27/02/2019 18:02:22 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Icon.jnc
----------------------
[-] 	construct (char const* fileName);
[+] 	construct(char const* fileName);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_InformationGrid.jnc
----------------------
[-] 	addChildItem (
[+] 	addChildItem(
[-] 	removeChildItem (InformationItem* item);
[+] 	removeChildItem(InformationItem* item);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	addItem (
[+] 	addItem(
[-] 	removeItem (InformationItem* item);
[+] 	removeItem(InformationItem* item);
[-] 	InformationGroup* createGroup (
[+] 	InformationGroup* createGroup(
[-] 	InformationGroup* createGroup (
[+] 	InformationGroup* createGroup(
[-] 		return createGroup (,, name, toolTipText);
[+] 		return createGroup(,, name, toolTipText);
[-] 	InformationValue* createValue (
[+] 	InformationValue* createValue(
[-] 	 InformationValue* createValue (
[+] 	 InformationValue* createValue(
[-] 		return createValue (,,, name, toolTipText);
[+] 		return createValue(,,, name, toolTipText);
[-] 	resizeNameColumnToContents ();
[+] 	resizeNameColumnToContents();
[-] InformationGroup* InformationGrid.createGroup (
[+] InformationGroup* InformationGrid.createGroup(
[-] 	InformationGroup* item = new InformationGroup (name);
[+] 	InformationGroup* item = new InformationGroup(name);
[-] 		parentItem.addChildItem (item, beforeItem) :
[+] 		parentItem.addChildItem(item, beforeItem) :
[-] 		addItem (item, beforeItem);
[+] 		addItem(item, beforeItem);
[-] InformationValue* InformationGrid.createValue (
[+] InformationValue* InformationGrid.createValue(
[-] 	InformationValue* item = new InformationValue (name);
[+] 	InformationValue* item = new InformationValue(name);
[-] 		parentItem.addChildItem (item, beforeItem) :
[+] 		parentItem.addChildItem(item, beforeItem) :
[-] 		addItem (item, beforeItem);
[+] 		addItem(item, beforeItem);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Menu.jnc
----------------------
[-] 	addAction (Action* action);
[+] 	addAction(Action* action);
[-] 	addSeparator ();
[+] 	addSeparator();
[-] 	destruct ();
[+] 	destruct();
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_PropertyGrid.jnc
----------------------
[-] 	addChildProperty (
[+] 	addChildProperty(
[-] 	removeChildProperty (Property* prop);
[+] 	removeChildProperty(Property* prop);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 		set (variant value);
[+] 		set(variant value);
[-] 		set (size_t value);
[+] 		set(size_t value);
[-] 		char const* get ();
[+] 		char const* get();
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	destruct ();
[+] 	destruct();
[-] 	setOptions (
[+] 	setOptions(
[-] 	event m_onChanged ();
[+] 	event m_onChanged();
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	destruct ();
[+] 	destruct();
[-] 	setOptions (
[+] 	setOptions(
[-] 	selectOption (size_t index);
[+] 	selectOption(size_t index);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	destruct ();
[+] 	destruct();
[-] 	setOptions (
[+] 	setOptions(
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	function* m_onAction ();
[+] 	function* m_onAction();
[-] 	construct (char const* name);
[+] 	construct(char const* name);
[-] 	addProperty (
[+] 	addProperty(
[-] 	removeProperty (Property* prop);
[+] 	removeProperty(Property* prop);
[-] 	GroupProperty* createGroupProperty (
[+] 	GroupProperty* createGroupProperty(
[-] 	GroupProperty* createGroupProperty (
[+] 	GroupProperty* createGroupProperty(
[-] 		return createGroupProperty (,, name, toolTipText);
[+] 		return createGroupProperty(,, name, toolTipText);
[-] 	BoolProperty* createBoolProperty (
[+] 	BoolProperty* createBoolProperty(
[-] 	BoolProperty* createBoolProperty (
[+] 	BoolProperty* createBoolProperty(
[-] 		return createBoolProperty (,, name, toolTipText);
[+] 		return createBoolProperty(,, name, toolTipText);
[-] 	IntProperty* createIntProperty (
[+] 	IntProperty* createIntProperty(
[-] 	IntProperty* createIntProperty (
[+] 	IntProperty* createIntProperty(
[-] 		return createIntProperty (,, name, toolTipText);
[+] 		return createIntProperty(,, name, toolTipText);
[-] 	StringProperty* createStringProperty (
[+] 	StringProperty* createStringProperty(
[-] 	StringProperty* createStringProperty (
[+] 	StringProperty* createStringProperty(
[-] 		return createStringProperty (,, name, toolTipText);
[+] 		return createStringProperty(,, name, toolTipText);
[-] 	EnumProperty* createEnumProperty (
[+] 	EnumProperty* createEnumProperty(
[-] 	EnumProperty* createEnumProperty (
[+] 	EnumProperty* createEnumProperty(
[-] 		return createEnumProperty (,, name, toolTipText, optionArray, count);
[+] 		return createEnumProperty(,, name, toolTipText, optionArray, count);
[-] 	ComboProperty* createComboProperty (
[+] 	ComboProperty* createComboProperty(
[-] 	ComboProperty* createComboProperty (
[+] 	ComboProperty* createComboProperty(
[-] 		return createComboProperty (,, name, toolTipText, optionArray, count);
[+] 		return createComboProperty(,, name, toolTipText, optionArray, count);
[-] 	FlagProperty* createFlagProperty (
[+] 	FlagProperty* createFlagProperty(
[-] 	FlagProperty* createFlagProperty (
[+] 	FlagProperty* createFlagProperty(
[-] 		return createFlagProperty (,, name, toolTipText, optionArray, count);
[+] 		return createFlagProperty(,, name, toolTipText, optionArray, count);
[-] 	ColorProperty* createColorProperty (
[+] 	ColorProperty* createColorProperty(
[-] 	ColorProperty* createColorProperty (
[+] 	ColorProperty* createColorProperty(
[-] 		return createColorProperty (,, name, toolTipText);
[+] 		return createColorProperty(,, name, toolTipText);
[-] 	ActionProperty* createActionProperty (
[+] 	ActionProperty* createActionProperty(
[-] 	ActionProperty* createActionProperty (
[+] 	ActionProperty* createActionProperty(
[-] 		return createActionProperty (,, name, toolTipText);
[+] 		return createActionProperty(,, name, toolTipText);
[-] 	FileProperty* createFileProperty (
[+] 	FileProperty* createFileProperty(
[-] 	FileProperty* createFileProperty (
[+] 	FileProperty* createFileProperty(
[-] 		return createFileProperty (,, name, toolTipText);
[+] 		return createFileProperty(,, name, toolTipText);
[-] GroupProperty* PropertyGrid.createGroupProperty (
[+] GroupProperty* PropertyGrid.createGroupProperty(
[-] 	GroupProperty* prop = new GroupProperty (name);
[+] 	GroupProperty* prop = new GroupProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] BoolProperty* PropertyGrid.createBoolProperty (
[+] BoolProperty* PropertyGrid.createBoolProperty(
[-] 	BoolProperty* prop = new BoolProperty (name);
[+] 	BoolProperty* prop = new BoolProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] IntProperty* PropertyGrid.createIntProperty (
[+] IntProperty* PropertyGrid.createIntProperty(
[-] 	IntProperty* prop = new IntProperty (name);
[+] 	IntProperty* prop = new IntProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] StringProperty* PropertyGrid.createStringProperty (
[+] StringProperty* PropertyGrid.createStringProperty(
[-] 	StringProperty* prop = new StringProperty (name);
[+] 	StringProperty* prop = new StringProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] EnumProperty* PropertyGrid.createEnumProperty (
[+] EnumProperty* PropertyGrid.createEnumProperty(
[-] 	EnumProperty* prop = new EnumProperty (name);
[+] 	EnumProperty* prop = new EnumProperty(name);
[-] 	prop.setOptions (optionArray, count);
[+] 	prop.setOptions(optionArray, count);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] ComboProperty* PropertyGrid.createComboProperty (
[+] ComboProperty* PropertyGrid.createComboProperty(
[-] 	ComboProperty* prop = new ComboProperty (name);
[+] 	ComboProperty* prop = new ComboProperty(name);
[-] 		prop.setOptions (optionArray, count);
[+] 		prop.setOptions(optionArray, count);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] FlagProperty* PropertyGrid.createFlagProperty (
[+] FlagProperty* PropertyGrid.createFlagProperty(
[-] 	FlagProperty* prop = new FlagProperty (name);
[+] 	FlagProperty* prop = new FlagProperty(name);
[-] 	prop.setOptions (optionArray, count);
[+] 	prop.setOptions(optionArray, count);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] ColorProperty* PropertyGrid.createColorProperty (
[+] ColorProperty* PropertyGrid.createColorProperty(
[-] 	ColorProperty* prop = new ColorProperty (name);
[+] 	ColorProperty* prop = new ColorProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] ActionProperty* PropertyGrid.createActionProperty (
[+] ActionProperty* PropertyGrid.createActionProperty(
[-] 	ActionProperty* prop = new ActionProperty (name);
[+] 	ActionProperty* prop = new ActionProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
[-] FileProperty* PropertyGrid.createFileProperty (
[+] FileProperty* PropertyGrid.createFileProperty(
[-] 	FileProperty* prop = new FileProperty (name);
[+] 	FileProperty* prop = new FileProperty(name);
[-] 		parentProp.addChildProperty (prop, beforeProp) :
[+] 		parentProp.addChildProperty(prop, beforeProp) :
[-] 		addProperty (prop, beforeProp);
[+] 		addProperty(prop, beforeProp);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_StatusBar.jnc
----------------------
[-] 	destruct ();
[+] 	destruct();
[-] 	displayMessage (
[+] 	displayMessage(
[-] 	StatusPane* const property m_pane (size_t index);
[+] 	StatusPane* const property m_pane(size_t index);
[-] 	StatusPane* addPane (
[+] 	StatusPane* addPane(
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_Terminal.jnc
----------------------
[-] 	event m_onConsoleSizeChanged ();
[+] 	event m_onConsoleSizeChanged();
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\gui_ToolBar.jnc
----------------------
[-] 	destruct ();
[+] 	destruct();
[-] 	addAction (Action* action);
[+] 	addAction(Action* action);
[-] 	addLabel (char const* pText);
[+] 	addLabel(char const* pText);
[-] 	ComboBox* addComboBox (uint_t width = 0);  // 0 = default, -1 = stretch
[+] 	ComboBox* addComboBox(uint_t width = 0);  // 0 = default, -1 = stretch
[-] 	ComboBox* addComboBox (
[+] 	ComboBox* addComboBox(
[-] 	addSeparator ();
[+] 	addSeparator();
[-] ComboBox* ToolBar.addComboBox (
[+] ComboBox* ToolBar.addComboBox(
[-] 	addLabel (labelText);
[+] 	addLabel(labelText);
[-] 	gui.ComboBox* comboBox = addComboBox ();
[+] 	gui.ComboBox* comboBox = addComboBox();
[-] 		comboBox.addItem (optionTable [i].m_text, optionTable [i].m_value);
[+] 		comboBox.addItem(optionTable[i].m_text, optionTable[i].m_value);
[-] 	comboBox.adjustSizeToContents ();
[+] 	comboBox.adjustSizeToContents();
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Converter.jnc
----------------------
[-] 	abstract bool convert (
[+] 	abstract bool convert(
[-] 	virtual reset ()
[+] 	virtual reset()
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Filter.jnc
----------------------
[-] 	abstract bool filter (
[+] 	abstract bool filter(
[-] 	virtual reset ()
[+] 	virtual reset()
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Listener.jnc
----------------------
[-] typedef ListenerFunc (
[+] typedef ListenerFunc(
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Log.jnc
----------------------
[-] 	gui.Icon* property m_iconTable (size_t i);
[+] 	gui.Icon* property m_iconTable(size_t i);
[-] 	destruct ();
[+] 	destruct();
[-] 	suspend ();
[+] 	suspend();
[-] 	resume ();
[+] 	resume();
[-] 	addConverter (
[+] 	addConverter(
[-] 	addConverter (Converter* converter)
[+] 	addConverter(Converter* converter)
[-] 		addConverter (converter, null, 0);
[+] 		addConverter(converter, null, 0);
[-] 	addConverter (
[+] 	addConverter(
[-] 		addConverter (converter, classGuid, 1);
[+] 		addConverter(converter, classGuid, 1);
[-] 	removeAllConverters ();
[+] 	removeAllConverters();
[-] 	addFilter (Filter* filter);
[+] 	addFilter(Filter* filter);
[-] 	removeAllFilters ();
[+] 	removeAllFilters();
[-] 	addListener (ListenerFunc* listenerFunc);
[+] 	addListener(ListenerFunc* listenerFunc);
[-] 	removeAllListeners ();
[+] 	removeAllListeners();
[-] 	addSelectionProcessor (RangeProcessorFactoryFunc* factoryFunc);
[+] 	addSelectionProcessor(RangeProcessorFactoryFunc* factoryFunc);
[-] 	removeAllSelectionProcessors ();
[+] 	removeAllSelectionProcessors();
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_RangeProcessor.jnc
----------------------
[-] 	virtual processNewZone ()
[+] 	virtual processNewZone()
[-] 	virtual processText (
[+] 	virtual processText(
[-] 	virtual processBin (
[+] 	virtual processBin(
[-] 	virtual processDualBin (
[+] 	virtual processDualBin(
[-] 	virtual processEndOfRange ()
[+] 	virtual processEndOfRange()
[-] typedef RangeProcessor* RangeProcessorFactoryFunc ();
[+] typedef RangeProcessor* RangeProcessorFactoryFunc();
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Representer.jnc
----------------------
[-] 	void addPart (
[+] 	void addPart(
[-] 	void retroColorize (
[+] 	void retroColorize(
[-] 	void addPlainText (
[+] 	void addPlainText(
[-] 		addPart (PartKind.PlainText, partCode, text, strlen (text));
[+] 		addPart(PartKind.PlainText, partCode, text, strlen(text));
[-] 	void addPlainText (char const* text)
[+] 	void addPlainText(char const* text)
[-] 		addPart (PartKind.PlainText, m_recordCode, text, strlen (text));
[+] 		addPart(PartKind.PlainText, m_recordCode, text, strlen(text));
[-] 	void addHyperText (
[+] 	void addHyperText(
[-] 		addPart (PartKind.HyperText, partCode, text, strlen (text));
[+] 		addPart(PartKind.HyperText, partCode, text, strlen(text));
[-] 	void addHyperText (char const* text)
[+] 	void addHyperText(char const* text)
[-] 		addPart (PartKind.HyperText, m_recordCode, text, strlen (text));
[+] 		addPart(PartKind.HyperText, m_recordCode, text, strlen(text));
[-] 	void addBin (
[+] 	void addBin(
[-] 		addPart (PartKind.Bin, partCode, p, size);
[+] 		addPart(PartKind.Bin, partCode, p, size);
[-] 	void addBin (
[+] 	void addBin(
[-] 		addPart (PartKind.Bin, m_recordCode, p, size);
[+] 		addPart(PartKind.Bin, m_recordCode, p, size);
[-] 	void addDualBin (
[+] 	void addDualBin(
[-] 		void const* p = memcat (p1, size, p2, size);
[+] 		void const* p = memcat(p1, size, p2, size);
[-] 		addPart (PartKind.DualBin, partCode, p, size * 2);
[+] 		addPart(PartKind.DualBin, partCode, p, size * 2);
[-] 	void addDualBin (
[+] 	void addDualBin(
[-] 		addDualBin (m_recordCode, p1, p2, size);
[+] 		addDualBin(m_recordCode, p1, p2, size);
[-] typedef bool RepresenterFunc (
[+] typedef bool RepresenterFunc(
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\log_Writer.jnc
----------------------
[-] 	write (
[+] 	write(
[-] 	write (
[+] 	write(
[-] 		write (sys.getPreciseTimestamp (), recordCode, p, size);
[+] 		write(sys.getPreciseTimestamp(), recordCode, p, size);
[-] 	writeString (
[+] 	writeString(
[-] 		write (timestamp, recordCode, p, strlen (p));
[+] 		write(timestamp, recordCode, p, strlen(p));
[-] 	writeString (
[+] 	writeString(
[-] 		writeString (sys.getPreciseTimestamp (), recordCode, p);
[+] 		writeString(sys.getPreciseTimestamp(), recordCode, p);
[-] 	writeError (
[+] 	writeError(
[-] 		write (timestamp, recordCode, error, error.m_size);
[+] 		write(timestamp, recordCode, error, error.m_size);
[-] 	writeError (
[+] 	writeError(
[-] 		writeError (sys.getPreciseTimestamp (), recordCode, error);
[+] 		writeError(sys.getPreciseTimestamp(), recordCode, error);
[-] 	writeLastError (
[+] 	writeLastError(
[-] 		writeError (timestamp, recordCode, std.getLastError ());
[+] 		writeError(timestamp, recordCode, std.getLastError());
[-] 	writeLastError (uint64_t recordCode)
[+] 	writeLastError(uint64_t recordCode)
[-] 		writeLastError (sys.getPreciseTimestamp (), recordCode);
[+] 		writeLastError(sys.getPreciseTimestamp(), recordCode);
[-] 	retroColorize (
[+] 	retroColorize(
[-] 		write (StdRecordCode.RetroColorize, &params, sizeof (params));
[+] 		write(StdRecordCode.RetroColorize, &params, sizeof(params));
[-] 	retroColorize (
[+] 	retroColorize(
[-] 		retroColorize (retroOffset, length, attr);
[+] 		retroColorize(retroOffset, length, attr);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\api\tx.jnc
----------------------
[-] void transmit (
[+] void transmit(
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\crc16.jnc
----------------------
[-] uint16_t crc16_ansi (
[+] uint16_t crc16_ansi(
[-] 	static uint16_t const crcTable [256] =
[+] 	static uint16_t const crcTable[256] =
[-] 		crc = (crc >> 8) ^ crcTable [j];
[+] 		crc = (crc >> 8) ^ crcTable[j];
[-] uint16_t crc16_ccitt (
[+] uint16_t crc16_ccitt(
[-] 	static uint16_t const crcTable [256] =
[+] 	static uint16_t const crcTable[256] =
[-] 		crc = (crc << 8) ^ crcTable [j];
[+] 		crc = (crc << 8) ^ crcTable[j];
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\crc32.jnc
----------------------
[-] uint32_t crc32 (
[+] uint32_t crc32(
[-] 	static uint32_t const crcTable [256] =
[+] 	static uint32_t const crcTable[256] =
[-] 		crc = (crc >> 8) ^ crcTable [j];
[+] 		crc = (crc >> 8) ^ crcTable[j];
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\escapeEncoding.jnc
----------------------
[-] char findEscapeReplaceChar (char x)
[+] char findEscapeReplaceChar(char x)
[-] 	switch (x)
[+] 	switch(x)
[-] size_t decodeEscapeString (
[+] size_t decodeEscapeString(
[-] 		length = strlen (source);
[+] 		length = strlen(source);
[-] 	string.clear ();
[+] 	string.clear();
[-] 	string.reserve (length / 2);
[+] 	string.reserve(length / 2);
[-] 	char hexCodeString [16];
[+] 	char hexCodeString[16];
[-] 		switch (state)
[+] 		switch(state)
[-] 				string.append (base, p - base);
[+] 				string.append(base, p - base);
[-] 			switch (*p)
[+] 			switch(*p)
[-] 				replace = findEscapeReplaceChar (*p);
[+] 				replace = findEscapeReplaceChar(*p);
[-] 					string.append (replace);
[+] 					string.append(replace);
[-] 				hexCodeString [hexCodeLen++] = c;
[+] 				hexCodeString[hexCodeLen++] = c;
[-] 				string.append ('?');
[+] 				string.append('?');
[-] 				hexCodeString [hexCodeLen] = 0;
[+] 				hexCodeString[hexCodeLen] = 0;
[-] 				hexCode = strtol (hexCodeString, null, 16);
[+] 				hexCode = strtol(hexCodeString, null, 16);
[-] 					string.append ((char const*) &hexCode, 1);
[+] 					string.append((char const*) &hexCode, 1);
[-] 					string.append (hexCode);
[+] 					string.append(hexCode);
[-] 	string.append (base, p - base);
[+] 	string.append(base, p - base);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\formatInteger.jnc
----------------------
[-] char* formatIntegerWithThousandSep (
[+] char* formatIntegerWithThousandSep(
[-] 		string.insert (i, sep);
[+] 		string.insert(i, sep);
[-] 	return string.detachString ();
[+] 	return string.detachString();
[-] char* formatFileSize (uint64_t size)
[+] char* formatFileSize(uint64_t size)
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\gui_History.jnc
----------------------
[-] 	addEditTextToHistory ();
[+] 	addEditTextToHistory();
[-] 	addToHistory (
[+] 	addToHistory(
[-] 	saveHistory (
[+] 	saveHistory(
[-] 	loadHistory (
[+] 	loadHistory(
[-] ComboBoxHistory.addEditTextToHistory ()
[+] ComboBoxHistory.addEditTextToHistory()
[-] 	return addToHistory (m_editText);
[+] 	return addToHistory(m_editText);
[-] ComboBoxHistory.addToHistory (
[+] ComboBoxHistory.addToHistory(
[-] 		if (strcmp (text, m_itemText [i]) == 0)
[+] 		if (strcmp(text, m_itemText[i]) == 0)
[-] 			removeItem (i);
[+] 			removeItem(i);
[-] 	insertItem (0, text);
[+] 	insertItem(0, text);
[-] 		removeItem (limit);
[+] 		removeItem(limit);
[-] ComboBoxHistory.saveHistory (
[+] ComboBoxHistory.saveHistory(
[-] 	storage.writeInt ("count", m_itemCount);
[+] 	storage.writeInt("count", m_itemCount);
[-] 		storage.writeString ($"item$i", m_itemText [i]);
[+] 		storage.writeString($"item$i", m_itemText [i]);
[-] ComboBoxHistory.loadHistory (
[+] ComboBoxHistory.loadHistory(
[-] 	clear ();
[+] 	clear();
[-] 	size_t count = storage.readInt ("count");
[+] 	size_t count = storage.readInt("count");
[-] 		addItem (storage.readString ($"item$i"));
[+] 		addItem(storage.readString($"item$i"));
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\gui_StdSessionInfo.jnc
----------------------
[-] 	createInformationValues (
[+] 	createInformationValues(
[-] 	addLogListener (log.Log* log)
[+] 	addLogListener(log.Log* log)
[-] 		log.addListener (onLogRecord);
[+] 		log.addListener(onLogRecord);
[-] 	startSession (jnc.Scheduler* mainThreadScheduler);
[+] 	startSession(jnc.Scheduler* mainThreadScheduler);
[-] 	endSession ();
[+] 	endSession();
[-] 	addData (
[+] 	addData(
[-] 	addTxData (size_t size)
[+] 	addTxData(size_t size)
[-] 		addData (size, 0);
[+] 		addData(size, 0);
[-] 	addRxData (size_t size)
[+] 	addRxData(size_t size)
[-] 		addData (0, size);
[+] 		addData(0, size);
[-] 	update (uint64_t timestamp = sys.getTimestamp ());
[+] 	update(uint64_t timestamp = sys.getTimestamp());
[-] 	initialUpdate ();
[+] 	initialUpdate();
[-] 	onTimer (uint_t syncId);
[+] 	onTimer(uint_t syncId);
[-] 	onLogRecord (
[+] 	onLogRecord(
[-] StdSessionInfoSet.createInformationValues (
[+] StdSessionInfoSet.createInformationValues(
[-] 		m_sessionTimeInfo = informationGrid.createValue (
[+] 		m_sessionTimeInfo = informationGrid.createValue(
[-] 		m_txTotalSizeInfo = informationGrid.createValue (
[+] 		m_txTotalSizeInfo = informationGrid.createValue(
[-] 		m_txThroughputInfo = informationGrid.createValue (
[+] 		m_txThroughputInfo = informationGrid.createValue(
[-] 		m_rxTotalSizeInfo = informationGrid.createValue (
[+] 		m_rxTotalSizeInfo = informationGrid.createValue(
[-] 		m_rxThroughputInfo = informationGrid.createValue (
[+] 		m_rxThroughputInfo = informationGrid.createValue(
[-] 		m_totalSizeInfo = informationGrid.createValue (
[+] 		m_totalSizeInfo = informationGrid.createValue(
[-] 		m_totalThroughputInfo = informationGrid.createValue (
[+] 		m_totalThroughputInfo = informationGrid.createValue(
[-] 	initialUpdate ();
[+] 	initialUpdate();
[-] StdSessionInfoSet.startSession (jnc.Scheduler* mainThreadScheduler)
[+] StdSessionInfoSet.startSession(jnc.Scheduler* mainThreadScheduler)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 	m_timer.startPeriodicTimer (onTimer ~(m_syncId) @ mainThreadScheduler, 500);
[+] 	m_timer.startPeriodicTimer(onTimer ~(m_syncId) @ mainThreadScheduler, 500);
[-] 	initialUpdate ();
[+] 	initialUpdate();
[-] StdSessionInfoSet.endSession ()
[+] StdSessionInfoSet.endSession()
[-] 	m_timer.stop ();
[+] 	m_timer.stop();
[-] 	update (); // final update
[+] 	update(); // final update
[-] StdSessionInfoSet.addData (
[+] StdSessionInfoSet.addData(
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] StdSessionInfoSet.onLogRecord (
[+] StdSessionInfoSet.onLogRecord(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		addTxData (size);
[+] 		addTxData(size);
[-] 		addRxData (size);
[+] 		addRxData(size);
[-] 		addData (size, size);
[+] 		addData(size, size);
[-] StdSessionInfoSet.onTimer (uint_t syncId)
[+] StdSessionInfoSet.onTimer(uint_t syncId)
[-] 		update ();
[+] 		update();
[-] StdSessionInfoSet.initialUpdate ()
[+] StdSessionInfoSet.initialUpdate()
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 	update (timestamp);
[+] 	update(timestamp);
[-] StdSessionInfoSet.update (uint64_t timestamp)
[+] StdSessionInfoSet.update(uint64_t timestamp)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] 		m_sessionTimeInfo.m_value = sys.formatTimestamp (timestamp - m_sessionTimestamp, 0, "%h:%m:%s");
[+] 		m_sessionTimeInfo.m_value = sys.formatTimestamp(timestamp - m_sessionTimestamp, 0, "%h:%m:%s");
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\hexEncoding.jnc
----------------------
[-] static bool isspace (char c) // we don't have these in the Jancy stdlib yet
[+] static bool isspace(char c) // we don't have these in the Jancy stdlib yet
[-] size_t decodeHexString (
[+] size_t decodeHexString(
[-] 		length = strlen (source);
[+] 		length = strlen(source);
[-] 	buffer.clear ();
[+] 	buffer.clear();
[-] 	buffer.setSize (length / 2); // enough to hold everything
[+] 	buffer.setSize(length / 2); // enough to hold everything
[-] 	char hexCodeString [4] = { 0 };
[+] 	char hexCodeString[4] = { 0 };
[-] 		bool isSpace = isspace (*p);
[+] 		bool isSpace = isspace(*p);
[-] 		switch (state)
[+] 		switch(state)
[-] 			hexCodeString [0] = *p;
[+] 			hexCodeString[0] = *p;
[-] 				hexCodeString [hexCodeLen++] = *p;
[+] 				hexCodeString[hexCodeLen++] = *p;
[-] 			hexCodeString [hexCodeLen] = 0;
[+] 			hexCodeString[hexCodeLen] = 0;
[-] 			x = (uchar_t) strtol (hexCodeString, &hexCodeEnd, 16);
[+] 			x = (uchar_t)strtol(hexCodeString, &hexCodeEnd, 16);
[-] 			if (hexCodeEnd == &hexCodeString [hexCodeLen])
[+] 			if (hexCodeEnd == &hexCodeString[hexCodeLen])
[-] 				buffer [size++] = x;
[+] 				buffer[size++] = x;
[-] 		hexCodeString [hexCodeLen] = 0;
[+] 		hexCodeString[hexCodeLen] = 0;
[-] 		x = (uchar_t) strtol (hexCodeString, &hexCodeEnd, 16);
[+] 		x = (uchar_t)strtol(hexCodeString, &hexCodeEnd, 16);
[-] 		if (hexCodeEnd == &hexCodeString [hexCodeLen])
[+] 		if (hexCodeEnd == &hexCodeString[hexCodeLen])
[-] 			buffer [size++] = x;
[+] 			buffer[size++] = x;
[-] 	buffer.setSize (size); // adjust size
[+] 	buffer.setSize(size); // adjust size
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_BufferUi.jnc
----------------------
[-] 	createProperties (
[+] 	createProperties(
[-] 	createPropertiesGrouped (
[+] 	createPropertiesGrouped(
[-] 	load (doc.Storage* storage);
[+] 	load(doc.Storage* storage);
[-] 	save (doc.Storage* storage);
[+] 	save(doc.Storage* storage);
[-] 	restoreDefaults ();
[+] 	restoreDefaults();
[-] BufferPropertySet.createProperties (
[+] BufferPropertySet.createProperties(
[-] 			m_readParallelismProp  = propertyGrid.createIntProperty (
[+] 			m_readParallelismProp  = propertyGrid.createIntProperty(
[-] 			m_readParallelismProp  = new gui.IntProperty (null);
[+] 			m_readParallelismProp  = new gui.IntProperty(null);
[-] 		m_readBlockSizeProp = propertyGrid.createIntProperty (
[+] 		m_readBlockSizeProp = propertyGrid.createIntProperty(
[-] 		m_readBufferSizeProp = propertyGrid.createIntProperty (
[+] 		m_readBufferSizeProp = propertyGrid.createIntProperty(
[-] 		m_writeBufferSizeProp = propertyGrid.createIntProperty (
[+] 		m_writeBufferSizeProp = propertyGrid.createIntProperty(
[-] 		m_keepReadBlockSizeProp = propertyGrid.createBoolProperty (
[+] 		m_keepReadBlockSizeProp = propertyGrid.createBoolProperty(
[-] 		m_keepWriteBlockSizeProp = propertyGrid.createBoolProperty (
[+] 		m_keepWriteBlockSizeProp = propertyGrid.createBoolProperty(
[-] 		m_notifyReadBufferFullProp = propertyGrid.createBoolProperty (
[+] 		m_notifyReadBufferFullProp = propertyGrid.createBoolProperty(
[-] BufferPropertySet.createPropertiesGrouped (
[+] BufferPropertySet.createPropertiesGrouped(
[-] 	gui.GroupProperty* subGroup = propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* subGroup = propertyGrid.createGroupProperty(
[-] 	createProperties (propertyGrid, subGroup,, mask);
[+] 	createProperties(propertyGrid, subGroup,, mask);
[-] BufferPropertySet.load (doc.Storage* storage)
[+] BufferPropertySet.load(doc.Storage* storage)
[-] 		m_readParallelismProp.m_value = storage.readInt ("readParallelism", Defaults.ReadParallelism);
[+] 		m_readParallelismProp.m_value = storage.readInt("readParallelism", Defaults.ReadParallelism);
[-] 		m_readBlockSizeProp.m_value = storage.readInt ("readBlockSize", Defaults.ReadBlockSize);
[+] 		m_readBlockSizeProp.m_value = storage.readInt("readBlockSize", Defaults.ReadBlockSize);
[-] 		m_readBufferSizeProp.m_value = storage.readInt ("readBufferSize", Defaults.ReadBufferSize);
[+] 		m_readBufferSizeProp.m_value = storage.readInt("readBufferSize", Defaults.ReadBufferSize);
[-] 		m_writeBufferSizeProp.m_value = storage.readInt ("writeBufferSize", Defaults.WriteBufferSize);
[+] 		m_writeBufferSizeProp.m_value = storage.readInt("writeBufferSize", Defaults.WriteBufferSize);
[-] 		m_keepReadBlockSizeProp.m_value = storage.readBool ("keepReadBlockSize", Defaults.KeepReadBlockSize);
[+] 		m_keepReadBlockSizeProp.m_value = storage.readBool("keepReadBlockSize", Defaults.KeepReadBlockSize);
[-] 		m_keepWriteBlockSizeProp.m_value = storage.readBool ("keepWriteBlockSize", Defaults.KeepWriteBlockSize);
[+] 		m_keepWriteBlockSizeProp.m_value = storage.readBool("keepWriteBlockSize", Defaults.KeepWriteBlockSize);
[-] 		m_notifyReadBufferFullProp.m_value = storage.readBool ("notifyReadBufferFull", Defaults.NotifyReadBufferFull);
[+] 		m_notifyReadBufferFullProp.m_value = storage.readBool("notifyReadBufferFull", Defaults.NotifyReadBufferFull);
[-] BufferPropertySet.save (doc.Storage* storage)
[+] BufferPropertySet.save(doc.Storage* storage)
[-] 		storage.writeInt ("readParallelism", m_readParallelismProp.m_value);
[+] 		storage.writeInt("readParallelism", m_readParallelismProp.m_value);
[-] 		storage.writeInt ("readBlockSize", m_readBlockSizeProp.m_value);
[+] 		storage.writeInt("readBlockSize", m_readBlockSizeProp.m_value);
[-] 		storage.writeInt ("readBufferSize", m_readBufferSizeProp.m_value);
[+] 		storage.writeInt("readBufferSize", m_readBufferSizeProp.m_value);
[-] 		storage.writeInt ("writeBufferSize", m_writeBufferSizeProp.m_value);
[+] 		storage.writeInt("writeBufferSize", m_writeBufferSizeProp.m_value);
[-] 		storage.writeBool ("keepReadBlockSize", m_keepReadBlockSizeProp.m_value);
[+] 		storage.writeBool("keepReadBlockSize", m_keepReadBlockSizeProp.m_value);
[-] 		storage.writeBool ("keepWriteBlockSize", m_keepWriteBlockSizeProp.m_value);
[+] 		storage.writeBool("keepWriteBlockSize", m_keepWriteBlockSizeProp.m_value);
[-] 		storage.writeBool ("notifyReadBufferFull", m_notifyReadBufferFullProp.m_value);
[+] 		storage.writeBool("notifyReadBufferFull", m_notifyReadBufferFullProp.m_value);
[-] BufferPropertySet.restoreDefaults ()
[+] BufferPropertySet.restoreDefaults()
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_FileIdMgr.jnc
----------------------
[-] 	reset ();
[+] 	reset();
[-] 	uint32_t getHiFileId (intptr_t loFileId);
[+] 	uint32_t getHiFileId(intptr_t loFileId);
[-] FileIdMgr.reset ()
[+] FileIdMgr.reset()
[-] 	m_fileIdMap.clear ();
[+] 	m_fileIdMap.clear();
[-] uint32_t FileIdMgr.getHiFileId (intptr_t loFileId)
[+] uint32_t FileIdMgr.getHiFileId(intptr_t loFileId)
[-] 	uint32_t hiFileId = m_fileIdMap.findValue (loFileId, 0);
[+] 	uint32_t hiFileId = m_fileIdMap.findValue(loFileId, 0);
[-] 		m_fileIdMap [loFileId] = hiFileId;
[+] 		m_fileIdMap[loFileId] = hiFileId;
[-] 	m_fileIdMap.removeKey (lowFileId);
[+] 	m_fileIdMap.removeKey(lowFileId);
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_I2cSignalDecoder.jnc
----------------------
[-] 	start ();
[+] 	start();
[-] 	I2cDecodeResult add (
[+] 	I2cDecodeResult add(
[-] I2cSignalDecoder.start ()
[+] I2cSignalDecoder.start()
[-] I2cDecodeResult I2cSignalDecoder.add (
[+] I2cDecodeResult I2cSignalDecoder.add(
[-] 	switch (m_bit)
[+] 	switch(m_bit)
----------------------
27/02/2019 18:02:23 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_IpDefragmenter.jnc
----------------------
[-] 	construct ();
[+] 	construct();
[-] 	reset ();
[+] 	reset();
[-] 	io.IpHdr const* defragment (
[+] 	io.IpHdr const* defragment(
[-] 	io.IpHdr const* assembleChain (Chain* chain);
[+] 	io.IpHdr const* assembleChain(Chain* chain);
[-] 	removeTimedOutChains ();
[+] 	removeTimedOutChains();
[-] IpDefragmenter.construct ()
[+] IpDefragmenter.construct()
[-] IpDefragmenter.reset ()
[+] IpDefragmenter.reset()
[-] 	m_chainHashTable.clear ();
[+] 	m_chainHashTable.clear();
[-] io.IpHdr const* IpDefragmenter.defragment (
[+] io.IpHdr const* IpDefragmenter.defragment(
[-] 	if (ipHdrSize < sizeof (io.IpHdr) ||
[+] 	if (ipHdrSize < sizeof(io.IpHdr) ||
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 	uint64_t key = (uint64_t) ipHdr.m_srcAddress | (ipHdr.m_identification << 32);
[+] 	uint64_t key = (uint64_t)ipHdr.m_srcAddress | (ipHdr.m_identification << 32);
[-] 	Chain* chain = m_chainHashTable [key];
[+] 	Chain* chain = m_chainHashTable[key];
[-] 		chain.m_listEntry = m_chainList.insertTail (chain);
[+] 		chain.m_listEntry = m_chainList.insertTail(chain);
[-] 		m_chainHashTable [key] = chain;
[+] 		m_chainHashTable[key] = chain;
[-] 		m_chainList.remove (chain.m_listEntry);
[+] 		m_chainList.remove(chain.m_listEntry);
[-] 		m_chainHashTable.removeKey (chain.m_key);
[+] 		m_chainHashTable.removeKey(chain.m_key);
[-] 	fragment.m_payload = new char [size];
[+] 	fragment.m_payload = new char[size];
[-] 	memcpy (fragment.m_payload, payload, size);
[+] 	memcpy(fragment.m_payload, payload, size);
[-] 	chain.m_fragmentList.insertBefore (fragment, it);
[+] 	chain.m_fragmentList.insertBefore(fragment, it);
[-] 		size_t bufferSize = sizeof (io.IpHdr) + payloadSize;
[+] 		size_t bufferSize = sizeof(io.IpHdr) + payloadSize;
[-] 		io.IpHdr* newIpHdr = (io.IpHdr*) new char [bufferSize];
[+] 		io.IpHdr* newIpHdr = (io.IpHdr*) new char[bufferSize];
[-] 		newIpHdr.m_headerLength = sizeof (io.IpHdr) / 4;
[+] 		newIpHdr.m_headerLength = sizeof(io.IpHdr) / 4;
[-] 	m_chainList.moveToTail (chain.m_listEntry);
[+] 	m_chainList.moveToTail(chain.m_listEntry);
[-] 	io.IpHdr const* result = chain.m_ipHdr ? assembleChain (chain) : null;
[+] 	io.IpHdr const* result = chain.m_ipHdr ? assembleChain(chain) : null;
[-] 	removeTimedOutChains ();
[+] 	removeTimedOutChains();
[-] io.IpHdr const* IpDefragmenter.assembleChain (IpDefragmenter.Chain* chain)
[+] io.IpHdr const* IpDefragmenter.assembleChain(IpDefragmenter.Chain* chain)
[-] 	char* p = (char*) (chain.m_ipHdr + 1) + chain.m_offset;
[+] 	char* p = (char*)(chain.m_ipHdr + 1) + chain.m_offset;
[-] 		chain.m_fragmentList.removeHead ();
[+] 		chain.m_fragmentList.removeHead();
[-] 		memcpy (p, fragment.m_payload, fragment.m_size);
[+] 		memcpy(p, fragment.m_payload, fragment.m_size);
[-] 	m_chainList.remove (chain.m_listEntry);
[+] 	m_chainList.remove(chain.m_listEntry);
[-] 	m_chainHashTable.removeKey (chain.m_key);
[+] 	m_chainHashTable.removeKey(chain.m_key);
[-] IpDefragmenter.removeTimedOutChains ()
[+] IpDefragmenter.removeTimedOutChains()
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 		m_chainList.remove (chain.m_listEntry);
[+] 		m_chainList.remove(chain.m_listEntry);
[-] 		m_chainHashTable.removeKey (chain.m_key);
[+] 		m_chainHashTable.removeKey(chain.m_key);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_Modbus.jnc
----------------------
[-] alignment (1);
[+] alignment(1);
[-] char const* getModbusFuncString (ModbusFunc func)
[+] char const* getModbusFuncString(ModbusFunc func)
[-] 	static char const* stringTable [] =
[+] 	static char const* stringTable[] =
[-] 		func < countof (stringTable) ?
[+] 		func < countof(stringTable) ?
[-] 			stringTable [func] :
[+] 			stringTable[func] :
[-] char const* getModbusExceptionString (ModbusException exception)
[+] char const* getModbusExceptionString(ModbusException exception)
[-] 	static char const* stringTable [] =
[+] 	static char const* stringTable[] =
[-] 	return exception < countof (stringTable) ? stringTable [exception] : "Unknown";
[+] 	return exception < countof(stringTable) ? stringTable[exception] : "Unknown";
[-] 	ModbusMaxPduSize = sizeof (ModbusWriteMultiplePdu) + 255,
[+] 	ModbusMaxPduSize = sizeof(ModbusWriteMultiplePdu) + 255,
[-] size_t errorcode getModbusPduSize (
[+] size_t errorcode getModbusPduSize(
[-] 	if (size < sizeof (ModbusPduHdr))
[+] 	if (size < sizeof(ModbusPduHdr))
[-] 		return sizeof (ModbusPduHdr);
[+] 		return sizeof(ModbusPduHdr);
[-] 	switch (pduHdr.m_func)
[+] 	switch(pduHdr.m_func)
[-] 			role == ModbusRole.Master ? sizeof (ModbusReadPdu) :
[+] 			role == ModbusRole.Master ? sizeof(ModbusReadPdu) :
[-] 			size < sizeof (ModbusReadReplyPdu) ? sizeof (ModbusReadReplyPdu) :
[+] 			size < sizeof(ModbusReadReplyPdu) ? sizeof(ModbusReadReplyPdu) :
[-] 			sizeof (ModbusReadReplyPdu) + ((ModbusReadReplyPdu const*) pduHdr).m_size;
[+] 			sizeof(ModbusReadReplyPdu) + ((ModbusReadReplyPdu const*) pduHdr).m_size;
[-] 		return sizeof (ModbusWritePdu);
[+] 		return sizeof(ModbusWritePdu);
[-] 			role == ModbusRole.Slave ? sizeof (ModbusWriteMultipleReplyPdu) :
[+] 			role == ModbusRole.Slave ? sizeof(ModbusWriteMultipleReplyPdu) :
[-] 			size < sizeof (ModbusWriteMultiplePdu) ? sizeof (ModbusWriteMultiplePdu) :
[+] 			size < sizeof(ModbusWriteMultiplePdu) ? sizeof(ModbusWriteMultiplePdu) :
[-] 			sizeof (ModbusWriteMultiplePdu) + ((ModbusWriteMultiplePdu const*) pduHdr).m_size;
[+] 			sizeof(ModbusWriteMultiplePdu) + ((ModbusWriteMultiplePdu const*) pduHdr).m_size;
[-] 		return sizeof (ModbusMaskWritePdu);
[+] 		return sizeof(ModbusMaskWritePdu);
[-] 		std.setError ("Unsupported Modbus function");
[+] 		std.setError("Unsupported Modbus function");
[-] 			return sizeof (ModbusExceptionPdu);
[+] 			return sizeof(ModbusExceptionPdu);
[-] 		std.setError ("Unknown Modbus function");
[+] 		std.setError("Unknown Modbus function");
[-] 	char m_deviceAddress [2];
[+] 	char m_deviceAddress[2];
[-] 	ModbusMaxRtuAduSize   = sizeof (ModbusRtuAduHdr) + ModbusMaxPduSize + 2,
[+] 	ModbusMaxRtuAduSize   = sizeof(ModbusRtuAduHdr) + ModbusMaxPduSize + 2,
[-] 	ModbusMaxAsciiAduSize = 1 + sizeof (ModbusAsciiAduHdr) + ModbusMaxPduSize * 2 + 4,
[+] 	ModbusMaxAsciiAduSize = 1 + sizeof(ModbusAsciiAduHdr) + ModbusMaxPduSize * 2 + 4,
[-] 	ModbusMaxTcpAduSize = sizeof (ModbusTcpAduHdr) + ModbusMaxPduSize,
[+] 	ModbusMaxTcpAduSize = sizeof(ModbusTcpAduHdr) + ModbusMaxPduSize,
[-] size_t errorcode getModbusRtuAduSize (
[+] size_t errorcode getModbusRtuAduSize(
[-] 	if (size < sizeof (ModbusRtuAduHdr))
[+] 	if (size < sizeof(ModbusRtuAduHdr))
[-] 		return sizeof (ModbusRtuAduHdr);
[+] 		return sizeof(ModbusRtuAduHdr);
[-] 	size_t pduSize = getModbusPduSize (role, pduHdr, size - sizeof (ModbusRtuAduHdr));
[+] 	size_t pduSize = getModbusPduSize(role, pduHdr, size - sizeof(ModbusRtuAduHdr));
[-] 	return pduSize + sizeof (uint8_t) + sizeof (uint16_t);
[+] 	return pduSize + sizeof(uint8_t) + sizeof(uint16_t);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_Monitor.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 	bool errorcode capture (
[+] 	bool errorcode capture(
[-] 	close ();
[+] 	close();
[-] 	bool errorcode setReadBufferSize (size_t size)
[+] 	bool errorcode setReadBufferSize(size_t size)
[-] 		return m_readBuffer.setSize (size);
[+] 		return m_readBuffer.setSize(size);
[-] 	bool errorcode applyProperties (
[+] 	bool errorcode applyProperties(
[-] 	onMonitorEvent (
[+] 	onMonitorEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitMonitorEvents ();
[+] 	waitMonitorEvents();
[-] 	bool addNotificationData (
[+] 	bool addNotificationData(
[-] 	abstract processNotification (DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	abstract processNotification(DeviceMonitorNotifyHdr const* notifyHdr);
[-] 	virtual processError (std.Error const* error);
[+] 	virtual processError(std.Error const* error);
[-] bool errorcode Monitor.capture (
[+] bool errorcode Monitor.capture(
[-] 	m_monitor.open ();
[+] 	m_monitor.open();
[-] 	m_monitor.connect (deviceName);
[+] 	m_monitor.connect(deviceName);
[-] 		m_monitor.setIoctlDescTable (ioctlDescTable, ioctlDescCount);
[+] 		m_monitor.setIoctlDescTable(ioctlDescTable, ioctlDescCount);
[-] 	m_notifyBuffer.clear ();
[+] 	m_notifyBuffer.clear();
[-] 	m_fileIdMgr.reset ();
[+] 	m_fileIdMgr.reset();
[-] 	waitMonitorEvents ();
[+] 	waitMonitorEvents();
[-] Monitor.close ()
[+] Monitor.close()
[-] 	m_monitor.close ();
[+] 	m_monitor.close();
[-] bool errorcode Monitor.applyProperties (
[+] bool errorcode Monitor.applyProperties(
[-] 	return m_readBuffer.setSize (bufferPropSet.m_readBufferSizeProp.m_value);
[+] 	return m_readBuffer.setSize(bufferPropSet.m_readBufferSizeProp.m_value);
[-] Monitor.waitMonitorEvents ()
[+] Monitor.waitMonitorEvents()
[-] 	m_monitor.wait (eventMask, onMonitorEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_monitor.wait(eventMask, onMonitorEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] Monitor.onMonitorEvent (
[+] Monitor.onMonitorEvent(
[-] 		processError (m_monitor.m_ioError);
[+] 		processError(m_monitor.m_ioError);
[-] 		m_pluginHost.m_log.m_writer.write (log.StdRecordCode.RxBufferFull);
[+] 		m_pluginHost.m_log.m_writer.write(log.StdRecordCode.RxBufferFull);
[-] 		size_t size = m_monitor.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t size = m_monitor.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			bool result = addNotificationData (m_readBuffer.m_p, size);
[+] 			bool result = addNotificationData(m_readBuffer.m_p, size);
[-] 	waitMonitorEvents ();
[+] 	waitMonitorEvents();
[-] bool Monitor.addNotificationData (
[+] bool Monitor.addNotificationData(
[-] 		if (m_notifyBuffer.m_size < sizeof (DeviceMonitorNotifyHdr))
[+] 		if (m_notifyBuffer.m_size < sizeof(DeviceMonitorNotifyHdr))
[-] 			size_t leftoverSize = sizeof (DeviceMonitorNotifyHdr) - m_notifyBuffer.m_size;
[+] 			size_t leftoverSize = sizeof(DeviceMonitorNotifyHdr) - m_notifyBuffer.m_size;
[-] 				m_notifyBuffer.append (p, size);
[+] 				m_notifyBuffer.append(p, size);
[-] 			m_notifyBuffer.append (p, leftoverSize);
[+] 			m_notifyBuffer.append(p, leftoverSize);
[-] 			std.setError ("invalid signature in notification header");
[+] 			std.setError("invalid signature in notification header");
[-] 			processError (std.getLastError ());
[+] 			processError(std.getLastError());
[-] 			m_pluginHost.m_log.m_writer.write (log.StdRecordCode.RxBufferFullLossy);
[+] 			m_pluginHost.m_log.m_writer.write(log.StdRecordCode.RxBufferFullLossy);
[-] 		size_t notifySize = sizeof (DeviceMonitorNotifyHdr) + notifyHdr.m_paramSize;
[+] 		size_t notifySize = sizeof(DeviceMonitorNotifyHdr) + notifyHdr.m_paramSize;
[-] 			m_notifyBuffer.append (p, size);
[+] 			m_notifyBuffer.append(p, size);
[-] 		m_notifyBuffer.append (p, leftoverSize);
[+] 		m_notifyBuffer.append(p, leftoverSize);
[-] 		processNotification (notifyHdr);
[+] 		processNotification(notifyHdr);
[-] 		m_notifyBuffer.clear ();
[+] 		m_notifyBuffer.clear();
[-] Monitor.processError (std.Error const* error)
[+] Monitor.processError(std.Error const* error)
[-] 	m_pluginHost.m_log.m_writer.write (log.StdRecordCode.Error, error, error.m_size);
[+] 	m_pluginHost.m_log.m_writer.write(log.StdRecordCode.Error, error, error.m_size);
[-] 	close ();
[+] 	close();
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_PcapDeviceUi.jnc
----------------------
[-] gui.EnumPropertyOption const* createPcapDeviceOptionArray (bool canOpenFile = true)
[+] gui.EnumPropertyOption const* createPcapDeviceOptionArray(bool canOpenFile = true)
[-] 	io.PcapDeviceDesc const* device = io.createPcapDeviceDescList (&count);
[+] 	io.PcapDeviceDesc const* device = io.createPcapDeviceDescList(&count);
[-] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption[count];
[-] 			device.m_address.m_address.getString ()
[+] 			device.m_address.m_address.getString()
[-] gui.EnumProperty* createPcapDeviceProperty (
[+] gui.EnumProperty* createPcapDeviceProperty(
[-] 	gui.EnumPropertyOption const* optionArray = createPcapDeviceOptionArray (canOpenFile);
[+] 	gui.EnumPropertyOption const* optionArray = createPcapDeviceOptionArray(canOpenFile);
[-] 	size_t optionCount = dynamic countof (optionArray);
[+] 	size_t optionCount = dynamic countof(optionArray);
[-] 	return propertyGrid.createEnumProperty (
[+] 	return propertyGrid.createEnumProperty(
[-] createPcapDeviceComboBox (
[+] createPcapDeviceComboBox(
[-] 	gui.EnumPropertyOption const* optionArray = createPcapDeviceOptionArray (canOpenFile);
[+] 	gui.EnumPropertyOption const* optionArray = createPcapDeviceOptionArray(canOpenFile);
[-] 	size_t optionCount = dynamic countof (optionArray);
[+] 	size_t optionCount = dynamic countof(optionArray);
[-] 	gui.ComboBox* comboBox = toolBar.addComboBox (width);
[+] 	gui.ComboBox* comboBox = toolBar.addComboBox(width);
[-] 		comboBox.addItem (
[+] 		comboBox.addItem(
[-] 			optionArray [i].m_text,
[+] 			optionArray[i].m_text,
[-] 			optionArray [i].m_value
[+] 			optionArray[i].m_value
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_SerialBuggyDrivers.jnc
----------------------
[-] char const* detectSerialBuggyDriver (char const* portName)
[+] char const* detectSerialBuggyDriver(char const* portName)
[-] 		portName [0] != '\\' ? (char const*) $"\\??\\$portName" :
[+] 		portName[0] != '\\' ? (char const*) $"\\??\\$portName" :
[-] 		strncmp (portName, "\\\\.\\", 4) == 0 ? (char const*) $"\\??\\$(portName + 4)" :
[+] 		strncmp(portName, "\\\\.\\", 4) == 0 ? (char const*) $"\\??\\$(portName + 4)" :
[-] 	char const* deviceName = try io.getSymbolicLinkTarget (linkName);
[+] 	char const* deviceName = try io.getSymbolicLinkTarget(linkName);
[-] 	printf ("link name: %s, device name: %s\n", linkName, deviceName);
[+] 	printf("link name: %s, device name: %s\n", linkName, deviceName);
[-] 		stristr (deviceName, "prolific") ? "Prolific" : // prolific drivers are... just... BAD
[+] 		stristr(deviceName, "prolific") ? "Prolific" : // prolific drivers are... just... BAD
[-] void setConservativeSerialSettings (io.Serial* serial)
[+] void setConservativeSerialSettings(io.Serial* serial)
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_SerialUi.jnc
----------------------
[-] 		uint_t get ()
[+] 		uint_t get()
[-] 				m_baudRateCombo ? atoi (m_baudRateCombo.m_editText) :
[+] 				m_baudRateCombo ? atoi(m_baudRateCombo.m_editText) :
[-] 				m_baudRateProp ? atoi (m_baudRateProp.m_value) :
[+] 				m_baudRateProp ? atoi(m_baudRateProp.m_value) :
[-] 		set (uint_t value)
[+] 		set(uint_t value)
[-] 		uint_t get ()
[+] 		uint_t get()
[-] 		set (uint_t value)
[+] 		set(uint_t value)
[-] 		io.SerialStopBits get ()
[+] 		io.SerialStopBits get()
[-] 		set (io.SerialStopBits value)
[+] 		set(io.SerialStopBits value)
[-] 		io.SerialParity get ()
[+] 		io.SerialParity get()
[-] 		set (io.SerialParity value)
[+] 		set(io.SerialParity value)
[-] 		io.SerialFlowControl get ()
[+] 		io.SerialFlowControl get()
[-] 		set (io.SerialFlowControl value)
[+] 		set(io.SerialFlowControl value)
[-] 	create (
[+] 	create(
[-] 	load (doc.Storage* storage);
[+] 	load(doc.Storage* storage);
[-] 	save (doc.Storage* storage);
[+] 	save(doc.Storage* storage);
[-] 	updateProperties ();
[+] 	updateProperties();
[-] 	applyProperties ();
[+] 	applyProperties();
[-] 	restoreDefaultProperties ();
[+] 	restoreDefaultProperties();
[-] SerialSettingUi.create (
[+] SerialSettingUi.create(
[-] 	static gui.EnumPropertyOption baudRateTable [] =
[+] 	static gui.EnumPropertyOption baudRateTable[] =
[-] 	static gui.EnumPropertyOption dataBitsTable [] =
[+] 	static gui.EnumPropertyOption dataBitsTable[] =
[-] 	static gui.EnumPropertyOption stopBitsTable [] =
[+] 	static gui.EnumPropertyOption stopBitsTable[] =
[-] 	static gui.EnumPropertyOption parityTable [] =
[+] 	static gui.EnumPropertyOption parityTable[] =
[-] 	static gui.EnumPropertyOption flowControlTable [] =
[+] 	static gui.EnumPropertyOption flowControlTable[] =
[-] 		m_baudRateCombo = toolBar.addComboBox (
[+] 		m_baudRateCombo = toolBar.addComboBox(
[-] 			countof (baudRateTable)
[+] 			countof(baudRateTable)
[-] 		m_baudRateProp = propertyGrid.createComboProperty (
[+] 		m_baudRateProp = propertyGrid.createComboProperty(
[-] 			countof (baudRateTable)
[+] 			countof(baudRateTable)
[-] 		m_dataBitsCombo = toolBar.addComboBox (
[+] 		m_dataBitsCombo = toolBar.addComboBox(
[-] 			countof (dataBitsTable)
[+] 			countof(dataBitsTable)
[-] 		m_dataBitsProp = propertyGrid.createEnumProperty (
[+] 		m_dataBitsProp = propertyGrid.createEnumProperty(
[-] 			countof (dataBitsTable)
[+] 			countof(dataBitsTable)
[-] 		m_stopBitsCombo = toolBar.addComboBox (
[+] 		m_stopBitsCombo = toolBar.addComboBox(
[-] 			countof (stopBitsTable)
[+] 			countof(stopBitsTable)
[-] 		m_stopBitsProp = propertyGrid.createEnumProperty (
[+] 		m_stopBitsProp = propertyGrid.createEnumProperty(
[-] 			countof (stopBitsTable)
[+] 			countof(stopBitsTable)
[-] 		m_parityCombo = toolBar.addComboBox (
[+] 		m_parityCombo = toolBar.addComboBox(
[-] 			countof (parityTable)
[+] 			countof(parityTable)
[-] 		m_parityProp = propertyGrid.createEnumProperty (
[+] 		m_parityProp = propertyGrid.createEnumProperty(
[-] 			countof (parityTable)
[+] 			countof(parityTable)
[-] 		m_flowControlCombo = toolBar.addComboBox (
[+] 		m_flowControlCombo = toolBar.addComboBox(
[-] 			countof (flowControlTable)
[+] 			countof(flowControlTable)
[-] 		m_flowControlProp = propertyGrid.createEnumProperty (
[+] 		m_flowControlProp = propertyGrid.createEnumProperty(
[-] 			countof (flowControlTable)
[+] 			countof(flowControlTable)
[-] SerialSettingUi.load (doc.Storage* storage)
[+] SerialSettingUi.load(doc.Storage* storage)
[-] 	m_baudRate = storage.readInt ("baudRateVal", Defaults.BaudRate);
[+] 	m_baudRate = storage.readInt("baudRateVal", Defaults.BaudRate);
[-] 	m_dataBits = storage.readInt ("dataBitsVal", Defaults.DataBits); // 8 bits
[+] 	m_dataBits = storage.readInt("dataBitsVal", Defaults.DataBits); // 8 bits
[-] 	m_stopBits = (io.SerialStopBits) storage.readInt ("stopBitsVal", Defaults.StopBits);
[+] 	m_stopBits = (io.SerialStopBits) storage.readInt("stopBitsVal", Defaults.StopBits);
[-] 	m_parity = (io.SerialParity) storage.readInt ("parityVal", Defaults.Parity);
[+] 	m_parity = (io.SerialParity) storage.readInt("parityVal", Defaults.Parity);
[-] 	m_flowControl = (io.SerialFlowControl) storage.readInt ("flowControlVal", Defaults.FlowControl);
[+] 	m_flowControl = (io.SerialFlowControl) storage.readInt("flowControlVal", Defaults.FlowControl);
[-] SerialSettingUi.save (doc.Storage* storage)
[+] SerialSettingUi.save(doc.Storage* storage)
[-] 	storage.writeInt ("baudRateVal", m_baudRate);
[+] 	storage.writeInt("baudRateVal", m_baudRate);
[-] 	storage.writeInt ("dataBitsVal", m_dataBits);
[+] 	storage.writeInt("dataBitsVal", m_dataBits);
[-] 	storage.writeInt ("stopBitsVal", m_stopBits);
[+] 	storage.writeInt("stopBitsVal", m_stopBits);
[-] 	storage.writeInt ("parityVal", m_parity);
[+] 	storage.writeInt("parityVal", m_parity);
[-] 	storage.writeInt ("flowControlVal", m_flowControl);
[+] 	storage.writeInt("flowControlVal", m_flowControl);
[-] SerialSettingUi.updateProperties ()
[+] SerialSettingUi.updateProperties()
[-] SerialSettingUi.applyProperties ()
[+] SerialSettingUi.applyProperties()
[-] SerialSettingUi.restoreDefaultProperties ()
[+] SerialSettingUi.restoreDefaultProperties()
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_SocketUi.jnc
----------------------
[-] gui.EnumPropertyOption const* createNetworkAdapterOptionArray (NetworkAdapterUsage usage)
[+] gui.EnumPropertyOption const* createNetworkAdapterOptionArray(NetworkAdapterUsage usage)
[-] 	io.NetworkAdapterDesc const* adapterList = io.createNetworkAdapterDescList (null, &addressCount);
[+] 	io.NetworkAdapterDesc const* adapterList = io.createNetworkAdapterDescList(null, &addressCount);
[-] 	switch (usage)
[+] 	switch(usage)
[-] 		optionArray = new gui.EnumPropertyOption [addressCount];
[+] 		optionArray = new gui.EnumPropertyOption[addressCount];
[-] 		optionArray = new gui.EnumPropertyOption [addressCount];
[+] 		optionArray = new gui.EnumPropertyOption[addressCount];
[-] 				address.m_address.getString ()
[+] 				address.m_address.getString()
[-] gui.EnumProperty* createNetworkAdapterProperty (
[+] gui.EnumProperty* createNetworkAdapterProperty(
[-] 	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
[+] 	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray(usage);
[-] 	size_t optionCount = dynamic countof (optionArray);
[+] 	size_t optionCount = dynamic countof(optionArray);
[-] 	return propertyGrid.createEnumProperty (
[+] 	return propertyGrid.createEnumProperty(
[-] gui.EnumProperty* createNetworkAdapterProperty (
[+] gui.EnumProperty* createNetworkAdapterProperty(
[-] 	return createNetworkAdapterProperty (propertyGrid,,, usage, name, toolTipText);
[+] 	return createNetworkAdapterProperty(propertyGrid,,, usage, name, toolTipText);
[-] createNetworkAdapterComboBox (
[+] createNetworkAdapterComboBox(
[-] 	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray (usage);
[+] 	gui.EnumPropertyOption const* optionArray = createNetworkAdapterOptionArray(usage);
[-] 	size_t optionCount = dynamic countof (optionArray);
[+] 	size_t optionCount = dynamic countof(optionArray);
[-] 	gui.ComboBox* comboBox = toolBar.addComboBox (width);
[+] 	gui.ComboBox* comboBox = toolBar.addComboBox(width);
[-] 		comboBox.addItem (
[+] 		comboBox.addItem(
[-] 			optionArray [i].m_text,
[+] 			optionArray[i].m_text,
[-] 			optionArray [i].m_value
[+] 			optionArray[i].m_value
[-] 	static char DefaultRemoteAddress [] = "ioninja.com";
[+] 	static char DefaultRemoteAddress[] = "ioninja.com";
[-] 	createProperties (
[+] 	createProperties(
[-] 	load (doc.Storage* storage);
[+] 	load(doc.Storage* storage);
[-] 	save (doc.Storage* storage);
[+] 	save(doc.Storage* storage);
[-] 	restoreDefaults ();
[+] 	restoreDefaults();
[-] SocketPropertySet.createProperties (
[+] SocketPropertySet.createProperties(
[-] 		m_remoteAddressProp = propertyGrid.createStringProperty (
[+] 		m_remoteAddressProp = propertyGrid.createStringProperty(
[-] 		m_remotePortProp = propertyGrid.createIntProperty (
[+] 		m_remotePortProp = propertyGrid.createIntProperty(
[-] 		m_useLocalAddressProp = propertyGrid.createBoolProperty (
[+] 		m_useLocalAddressProp = propertyGrid.createBoolProperty(
[-] 		m_adapterProp = io.createNetworkAdapterProperty (
[+] 		m_adapterProp = io.createNetworkAdapterProperty(
[-] 		m_localPortProp = propertyGrid.createIntProperty (
[+] 		m_localPortProp = propertyGrid.createIntProperty(
[-] 		m_reuseLocalAddressProp = propertyGrid.createBoolProperty (
[+] 		m_reuseLocalAddressProp = propertyGrid.createBoolProperty(
[-] 		m_tcpKeepAliveProp = propertyGrid.createBoolProperty (
[+] 		m_tcpKeepAliveProp = propertyGrid.createBoolProperty(
[-] 		m_tcpNagleProp = propertyGrid.createBoolProperty (
[+] 		m_tcpNagleProp = propertyGrid.createBoolProperty(
[-] 		m_tcpResetProp = propertyGrid.createBoolProperty (
[+] 		m_tcpResetProp = propertyGrid.createBoolProperty(
[-] 		m_udpBroadcastProp = propertyGrid.createBoolProperty (
[+] 		m_udpBroadcastProp = propertyGrid.createBoolProperty(
[-] SocketPropertySet.load (doc.Storage* storage)
[+] SocketPropertySet.load(doc.Storage* storage)
[-] 		m_remoteAddressProp.m_value = storage.readString ("address", DefaultRemoteAddress);
[+] 		m_remoteAddressProp.m_value = storage.readString("address", DefaultRemoteAddress);
[-] 		m_remotePortProp.m_value = storage.readInt ("remotePort", m_defaultRemotePort);
[+] 		m_remotePortProp.m_value = storage.readInt("remotePort", m_defaultRemotePort);
[-] 		m_useLocalAddressProp.m_value = storage.readBool ("useLocalAddress");
[+] 		m_useLocalAddressProp.m_value = storage.readBool("useLocalAddress");
[-] 		m_adapterProp.m_currentIndex = storage.readInt ("adapterIdx");
[+] 		m_adapterProp.m_currentIndex = storage.readInt("adapterIdx");
[-] 		m_localPortProp.m_value = storage.readInt ("localPort", m_defaultLocalPort);
[+] 		m_localPortProp.m_value = storage.readInt("localPort", m_defaultLocalPort);
[-] 		m_reuseLocalAddressProp.m_value = storage.readBool ("reuseLocalAddress", false);
[+] 		m_reuseLocalAddressProp.m_value = storage.readBool("reuseLocalAddress", false);
[-] 		m_tcpKeepAliveProp.m_value = storage.readBool ("tcpKeepAlive", Defaults.TcpKeepAlive);
[+] 		m_tcpKeepAliveProp.m_value = storage.readBool("tcpKeepAlive", Defaults.TcpKeepAlive);
[-] 		m_tcpNagleProp.m_value = storage.readBool ("isNagleEnabled", Defaults.TcpNagle);
[+] 		m_tcpNagleProp.m_value = storage.readBool("isNagleEnabled", Defaults.TcpNagle);
[-] 		m_tcpResetProp.m_value = storage.readBool ("closeKind", Defaults.TcpReset);
[+] 		m_tcpResetProp.m_value = storage.readBool("closeKind", Defaults.TcpReset);
[-] 		m_udpBroadcastProp.m_value = storage.readBool ("udpBroadcast", Defaults.UdpBroadcast);
[+] 		m_udpBroadcastProp.m_value = storage.readBool("udpBroadcast", Defaults.UdpBroadcast);
[-] SocketPropertySet.save (doc.Storage* storage)
[+] SocketPropertySet.save(doc.Storage* storage)
[-] 		storage.writeString ("address", m_remoteAddressProp.m_value);
[+] 		storage.writeString("address", m_remoteAddressProp.m_value);
[-] 		storage.writeInt ("remotePort", m_remotePortProp.m_value);
[+] 		storage.writeInt("remotePort", m_remotePortProp.m_value);
[-] 		storage.writeBool ("useLocalAddress", m_useLocalAddressProp.m_value);
[+] 		storage.writeBool("useLocalAddress", m_useLocalAddressProp.m_value);
[-] 		storage.writeInt ("adapterIdx", (int) m_adapterProp.m_currentIndex);
[+] 		storage.writeInt("adapterIdx", (int) m_adapterProp.m_currentIndex);
[-] 		storage.writeInt ("localPort", m_localPortProp.m_value);
[+] 		storage.writeInt("localPort", m_localPortProp.m_value);
[-] 		storage.writeBool ("reuseLocalAddress", m_reuseLocalAddressProp.m_value);
[+] 		storage.writeBool("reuseLocalAddress", m_reuseLocalAddressProp.m_value);
[-] 		storage.writeBool ("tcpKeepAlive", m_tcpKeepAliveProp.m_value);
[+] 		storage.writeBool("tcpKeepAlive", m_tcpKeepAliveProp.m_value);
[-] 		storage.writeBool ("isNagleEnabled", m_tcpNagleProp.m_value);
[+] 		storage.writeBool("isNagleEnabled", m_tcpNagleProp.m_value);
[-] 		storage.writeBool ("closeKind", m_tcpResetProp.m_value);
[+] 		storage.writeBool("closeKind", m_tcpResetProp.m_value);
[-] 		storage.writeBool ("udpBroadcast", m_udpBroadcastProp.m_value);
[+] 		storage.writeBool("udpBroadcast", m_udpBroadcastProp.m_value);
[-] SocketPropertySet.restoreDefaults ()
[+] SocketPropertySet.restoreDefaults()
[-] io.SocketOptions getSocketOptions (
[+] io.SocketOptions getSocketOptions(
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_SpiSignalDecoder.jnc
----------------------
[-] 	start (
[+] 	start(
[-] 	SpiDecodeResult add (
[+] 	SpiDecodeResult add(
[-] SpiSignalDecoder.start (
[+] SpiSignalDecoder.start(
[-] SpiDecodeResult SpiSignalDecoder.add (
[+] SpiDecodeResult SpiSignalDecoder.add(
[-] 	static bool spiSelectorTable [2] [2] [2] =
[+] 	static bool spiSelectorTable[2] [2] [2] =
[-] 	if (spiSelectorTable [m_cpol] [m_cpha] [sclk])
[+] 	if (spiSelectorTable[m_cpol] [m_cpha] [sclk])
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_SshUi.jnc
----------------------
[-] 	static char DefaultChannelType [] = "session";
[+] 	static char DefaultChannelType[] = "session";
[-] 	static char DefaultProcessType [] = "shell";
[+] 	static char DefaultProcessType[] = "shell";
[-] 	static char DefaultPtyType [] = "xterm";
[+] 	static char DefaultPtyType[] = "xterm";
[-] 	createProperties (
[+] 	createProperties(
[-] 	load (doc.Storage* storage);
[+] 	load(doc.Storage* storage);
[-] 	save (doc.Storage* storage);
[+] 	save(doc.Storage* storage);
[-] 	restoreDefaults ();
[+] 	restoreDefaults();
[-] SshPropertySet.createProperties (
[+] SshPropertySet.createProperties(
[-] 	static gui.EnumPropertyOption authenticationMethodTable [] =
[+] 	static gui.EnumPropertyOption authenticationMethodTable[] =
[-] 		m_userNameProp = propertyGrid.createStringProperty (
[+] 		m_userNameProp = propertyGrid.createStringProperty(
[-] 		m_authenticationMethodProp = propertyGrid.createEnumProperty (
[+] 		m_authenticationMethodProp = propertyGrid.createEnumProperty(
[-] 			countof (authenticationMethodTable)
[+] 			countof(authenticationMethodTable)
[-] 		m_privateKeyFileProp = propertyGrid.createFileProperty (
[+] 		m_privateKeyFileProp = propertyGrid.createFileProperty(
[-] 		m_rememberLastPasswordProp = propertyGrid.createBoolProperty (
[+] 		m_rememberLastPasswordProp = propertyGrid.createBoolProperty(
[-] 		m_channelTypeProp = propertyGrid.createStringProperty (
[+] 		m_channelTypeProp = propertyGrid.createStringProperty(
[-] 		m_processTypeProp = propertyGrid.createStringProperty (
[+] 		m_processTypeProp = propertyGrid.createStringProperty(
[-] 		m_execProp = propertyGrid.createStringProperty (
[+] 		m_execProp = propertyGrid.createStringProperty(
[-] 		m_ptyTypeProp = propertyGrid.createStringProperty (
[+] 		m_ptyTypeProp = propertyGrid.createStringProperty(
[-] SshPropertySet.load (doc.Storage* storage)
[+] SshPropertySet.load(doc.Storage* storage)
[-] 		m_userNameProp.m_value = storage.readString ("userName");
[+] 		m_userNameProp.m_value = storage.readString("userName");
[-] 		m_authenticationMethodProp.m_value = storage.readInt ("authenticationMethod", Defaults.AuthenticationMethod);
[+] 		m_authenticationMethodProp.m_value = storage.readInt("authenticationMethod", Defaults.AuthenticationMethod);
[-] 		m_privateKeyFileProp.m_value = storage.readString ("privateKeyFile");
[+] 		m_privateKeyFileProp.m_value = storage.readString("privateKeyFile");
[-] 		m_rememberLastPasswordProp.m_value = storage.readBool ("rememberLastPassword", Defaults.RememberLastPassword);
[+] 		m_rememberLastPasswordProp.m_value = storage.readBool("rememberLastPassword", Defaults.RememberLastPassword);
[-] 		m_channelTypeProp.m_value = storage.readString ("channelType", DefaultChannelType);
[+] 		m_channelTypeProp.m_value = storage.readString("channelType", DefaultChannelType);
[-] 		m_processTypeProp.m_value = storage.readString ("processType", DefaultProcessType);
[+] 		m_processTypeProp.m_value = storage.readString("processType", DefaultProcessType);
[-] 		m_execProp.m_value = storage.readString ("exec");
[+] 		m_execProp.m_value = storage.readString("exec");
[-] 		m_ptyTypeProp.m_value = storage.readString ("ptyType", DefaultPtyType);
[+] 		m_ptyTypeProp.m_value = storage.readString("ptyType", DefaultPtyType);
[-] SshPropertySet.save (doc.Storage* storage)
[+] SshPropertySet.save(doc.Storage* storage)
[-] 		storage.writeString ("userName", m_userNameProp.m_value);
[+] 		storage.writeString("userName", m_userNameProp.m_value);
[-] 		storage.writeInt ("authenticationMethod", m_authenticationMethodProp.m_value);
[+] 		storage.writeInt("authenticationMethod", m_authenticationMethodProp.m_value);
[-] 		storage.writeString ("privateKeyFile", m_privateKeyFileProp.m_value);
[+] 		storage.writeString("privateKeyFile", m_privateKeyFileProp.m_value);
[-] 		storage.writeBool ("rememberLastPassword", m_rememberLastPasswordProp.m_value);
[+] 		storage.writeBool("rememberLastPassword", m_rememberLastPasswordProp.m_value);
[-] 		storage.writeString ("channelType", m_channelTypeProp.m_value);
[+] 		storage.writeString("channelType", m_channelTypeProp.m_value);
[-] 		storage.writeString ("processType", m_processTypeProp.m_value);
[+] 		storage.writeString("processType", m_processTypeProp.m_value);
[-] 		storage.writeString ("exec", m_execProp.m_value);
[+] 		storage.writeString("exec", m_execProp.m_value);
[-] 		storage.writeString ("ptyType", m_ptyTypeProp.m_value);
[+] 		storage.writeString("ptyType", m_ptyTypeProp.m_value);
[-] SshPropertySet.restoreDefaults ()
[+] SshPropertySet.restoreDefaults()
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_TcpIp.jnc
----------------------
[-] 	uint8_t m_dstAddress [6];
[+] 	uint8_t m_dstAddress[6];
[-] 	uint8_t m_srcAddress [6];
[+] 	uint8_t m_srcAddress[6];
[-] 	uint16_t m_srcAddress [8];
[+] 	uint16_t m_srcAddress[8];
[-] 	uint16_t m_dstAddress [8];
[+] 	uint16_t m_dstAddress[8];
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_TcpSequencer.jnc
----------------------
[-] 	function* m_onData (
[+] 	function* m_onData(
[-] 	function* m_onDataDrop ();
[+] 	function* m_onDataDrop();
[-] 	reset (uint32_t seqNumber);
[+] 	reset(uint32_t seqNumber);
[-] 	write (
[+] 	write(
[-] 	addOutOfSeqSegment (
[+] 	addOutOfSeqSegment(
[-] 	writeInSeqSegment (
[+] 	writeInSeqSegment(
[-] 	writeAlignedOutOfSeqSegments ();
[+] 	writeAlignedOutOfSeqSegments();
[-] TcpSequencer.reset (uint32_t seqNumber)
[+] TcpSequencer.reset(uint32_t seqNumber)
[-] TcpSequencer.write (
[+] TcpSequencer.write(
[-] 	if ((intptr_t) (seqNumber - m_seqNumber) > 0)
[+] 	if ((intptr_t)(seqNumber - m_seqNumber) > 0)
[-] 		addOutOfSeqSegment (seqNumber, p, size);
[+] 		addOutOfSeqSegment(seqNumber, p, size);
[-] 		writeInSeqSegment (seqNumber, p, size);
[+] 		writeInSeqSegment(seqNumber, p, size);
[-] 		writeAlignedOutOfSeqSegments ();
[+] 		writeAlignedOutOfSeqSegments();
[-] TcpSequencer.addOutOfSeqSegment (
[+] TcpSequencer.addOutOfSeqSegment(
[-] 				segment.m_p = new char [size];
[+] 				segment.m_p = new char[size];
[-] 				memcpy (segment.m_p, p, size);
[+] 				memcpy(segment.m_p, p, size);
[-] 	segment.m_p = new char [size];
[+] 	segment.m_p = new char[size];
[-] 	memcpy (segment.m_p, p, size);
[+] 	memcpy(segment.m_p, p, size);
[-] 	m_outOfSeqList.insertBefore (segment, it);
[+] 	m_outOfSeqList.insertBefore(segment, it);
[-] 		m_onDataDrop ();
[+] 		m_onDataDrop();
[-] 		OutOfSeqSegment* segment = m_outOfSeqList.removeHead ();
[+] 		OutOfSeqSegment* segment = m_outOfSeqList.removeHead();
[-] 		writeInSeqSegment (segment.m_seqNumber, segment.m_p, segment.m_size);
[+] 		writeInSeqSegment(segment.m_seqNumber, segment.m_p, segment.m_size);
[-] 	writeAlignedOutOfSeqSegments ();
[+] 	writeAlignedOutOfSeqSegments();
[-] TcpSequencer.writeInSeqSegment (
[+] TcpSequencer.writeInSeqSegment(
[-] 	if ((intptr_t) (m_seqNumber - seqNumber) > 0) // retransmission
[+] 	if ((intptr_t)(m_seqNumber - seqNumber) > 0) // retransmission
[-] 		m_onData (p, size);
[+] 		m_onData(p, size);
[-] 	m_seqNumber = seqNumber + (uint32_t) size;
[+] 	m_seqNumber = seqNumber + (uint32_t)size;
[-] TcpSequencer.writeAlignedOutOfSeqSegments ()
[+] TcpSequencer.writeAlignedOutOfSeqSegments()
[-] 		m_outOfSeqList.removeHead ();
[+] 		m_outOfSeqList.removeHead();
[-] 		writeInSeqSegment (segment.m_seqNumber, segment.m_p, segment.m_size);
[+] 		writeInSeqSegment(segment.m_seqNumber, segment.m_p, segment.m_size);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_UartSignalDecoder.jnc
----------------------
[-] 	start (
[+] 	start(
[-] 	UartDecodeResult add (
[+] 	UartDecodeResult add(
[-] 	UartDecodeResult onTimer ();
[+] 	UartDecodeResult onTimer();
[-] 	UartDecodeResult finalizeFrame ();
[+] 	UartDecodeResult finalizeFrame();
[-] 	bool checkParity ();
[+] 	bool checkParity();
[-] UartSignalDecoder.start (
[+] UartSignalDecoder.start(
[-] UartDecodeResult UartSignalDecoder.add (
[+] UartDecodeResult UartSignalDecoder.add(
[-] 	UartDecodeResult result = finalizeFrame ();
[+] 	UartDecodeResult result = finalizeFrame();
[-] 	add (timestamp, lineState);
[+] 	add(timestamp, lineState);
[-] UartDecodeResult UartSignalDecoder.onTimer ()
[+] UartDecodeResult UartSignalDecoder.onTimer()
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 		finalizeFrame () :
[+] 		finalizeFrame() :
[-] UartDecodeResult UartSignalDecoder.finalizeFrame ()
[+] UartDecodeResult UartSignalDecoder.finalizeFrame()
[-] 		m_parity && !checkParity () ? UartDecodeResult.ParityError :
[+] 		m_parity && !checkParity() ? UartDecodeResult.ParityError :
[-] bool isEvenNonZeroBitCount (uint_t c)
[+] bool isEvenNonZeroBitCount(uint_t c)
[-] bool UartSignalDecoder.checkParity ()
[+] bool UartSignalDecoder.checkParity()
[-] 	switch (m_parity)
[+] 	switch(m_parity)
[-] 		return isEvenNonZeroBitCount (bits);
[+] 		return isEvenNonZeroBitCount(bits);
[-] 		return !isEvenNonZeroBitCount (bits);
[+] 		return !isEvenNonZeroBitCount(bits);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\io_UsbDb.jnc
----------------------
[-] 	UsbProduct* addProduct (
[+] 	UsbProduct* addProduct(
[-] 	UsbProduct const* findProduct (uint_t productId) const
[+] 	UsbProduct const* findProduct(uint_t productId) const
[-] 		return m_productMap.findValue (productId);
[+] 		return m_productMap.findValue(productId);
[-] UsbProduct* UsbVendor.addProduct (
[+] UsbProduct* UsbVendor.addProduct(
[-] 	m_productMap [id] = product;
[+] 	m_productMap[id] = product;
[-] 	bool errorcode load (char const* fileName);
[+] 	bool errorcode load(char const* fileName);
[-] 	UsbVendor* addVendor (
[+] 	UsbVendor* addVendor(
[-] 	UsbVendor const* findVendor (uint_t vendorId) const
[+] 	UsbVendor const* findVendor(uint_t vendorId) const
[-] 		return m_vendorMap.findValue (vendorId);
[+] 		return m_vendorMap.findValue(vendorId);
[-] 	UsbProduct const* findProduct (
[+] 	UsbProduct const* findProduct(
[-] 		UsbVendor* vendor =  m_vendorMap.findValue (vendorId);
[+] 		UsbVendor* vendor =  m_vendorMap.findValue(vendorId);
[-] 		return vendor ? vendor.findProduct (productId) : null;
[+] 		return vendor ? vendor.findProduct(productId) : null;
[-] UsbDb* getStdUsbDb ()
[+] UsbDb* getStdUsbDb()
[-] 		try usbDb.load (__DIR__ "/usb.ids"); // ignore result
[+] 		try usbDb.load(__DIR__ "/usb.ids"); // ignore result
[-] UsbVendor* UsbDb.addVendor (
[+] UsbVendor* UsbDb.addVendor(
[-] 	m_vendorMap [id] = vendor;
[+] 	m_vendorMap[id] = vendor;
[-] bool errorcode UsbDb.load (char const* fileName)
[+] bool errorcode UsbDb.load(char const* fileName)
[-] 	m_vendorMap.clear ();
[+] 	m_vendorMap.clear();
[-] 	file.open (fileName, io.FileOpenFlags.ReadOnly);
[+] 	file.open(fileName, io.FileOpenFlags.ReadOnly);
[-] 	char const* p = file.view (0, size, false);
[+] 	char const* p = file.view(0, size, false);
[-] 		reswitch (state, p, end - p)
[+] 		reswitch(state, p, end - p)
[-] 			vendor = addVendor (
[+] 			vendor = addVendor(
[-] 				strtol (state.m_subMatchArray [0].m_text,, 16),
[+] 				strtol(state.m_subMatchArray[0].m_text,, 16),
[-] 				state.m_subMatchArray [1].m_text
[+] 				state.m_subMatchArray[1].m_text
[-] 				std.setError ("invalid USB database file format");
[+] 				std.setError("invalid USB database file format");
[-] 			vendor.addProduct (
[+] 			vendor.addProduct(
[-] 				strtol (state.m_subMatchArray [0].m_text,, 16),
[+] 				strtol(state.m_subMatchArray[0].m_text,, 16),
[-] 				state.m_subMatchArray [1].m_text
[+] 				state.m_subMatchArray[1].m_text
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\ip4Checksum.jnc
----------------------
[-] uint16_t calcIp4Checksum (
[+] uint16_t calcIp4Checksum(
[-] uint16_t finalizeIp4Checksum (uint16_t checksum)
[+] uint16_t finalizeIp4Checksum(uint16_t checksum)
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\log_ChecksumCalc.jnc
----------------------
[-] 	createInformationValues (
[+] 	createInformationValues(
[-] 	createInformationValuesGrouped (
[+] 	createInformationValuesGrouped(
[-] ChecksumInfoSet.createInformationValues (
[+] ChecksumInfoSet.createInformationValues(
[-] 		m_crc16Info_ansi = informationGrid.createValue (
[+] 		m_crc16Info_ansi = informationGrid.createValue(
[-] 		m_crc16Info_modbus = informationGrid.createValue (
[+] 		m_crc16Info_modbus = informationGrid.createValue(
[-] 		m_crc16Info_xmodem = informationGrid.createValue (
[+] 		m_crc16Info_xmodem = informationGrid.createValue(
[-] 		m_crc16Info_usb = informationGrid.createValue (
[+] 		m_crc16Info_usb = informationGrid.createValue(
[-] 		m_crc32Info = informationGrid.createValue (
[+] 		m_crc32Info = informationGrid.createValue(
[-] 		m_ip4ChecksumInfo = informationGrid.createValue (
[+] 		m_ip4ChecksumInfo = informationGrid.createValue(
[-] 		m_sum8Info = informationGrid.createValue (
[+] 		m_sum8Info = informationGrid.createValue(
[-] 		m_sum16Info_le = informationGrid.createValue (
[+] 		m_sum16Info_le = informationGrid.createValue(
[-] 		m_sum16Info_be = informationGrid.createValue (
[+] 		m_sum16Info_be = informationGrid.createValue(
[-] ChecksumInfoSet.createInformationValuesGrouped (
[+] ChecksumInfoSet.createInformationValuesGrouped(
[-] 	gui.InformationGroup* subGroup = informationGrid.createGroup (
[+] 	gui.InformationGroup* subGroup = informationGrid.createGroup(
[-] 	createInformationValues (informationGrid, subGroup,, mask);
[+] 	createInformationValues(informationGrid, subGroup,, mask);
[-] 	static ChecksumCalcRangeProcessor* factory (ChecksumInfoSet* infoSet)
[+] 	static ChecksumCalcRangeProcessor* factory(ChecksumInfoSet* infoSet)
[-] 		return new ChecksumCalcRangeProcessor (infoSet);
[+] 		return new ChecksumCalcRangeProcessor(infoSet);
[-] 	construct (ChecksumInfoSet* infoSet)
[+] 	construct(ChecksumInfoSet* infoSet)
[-] 	override processBin (
[+] 	override processBin(
[-] 	override processEndOfRange ();
[+] 	override processEndOfRange();
[-] ChecksumCalcRangeProcessor.processBin (
[+] ChecksumCalcRangeProcessor.processBin(
[-] 	m_sum8 = sum8 (p, size, m_sum8);
[+] 	m_sum8 = sum8(p, size, m_sum8);
[-] 	m_crc16_ansi = crc16_ansi (p, size, m_crc16_ansi);
[+] 	m_crc16_ansi = crc16_ansi(p, size, m_crc16_ansi);
[-] 	m_crc16_modbus = crc16_ansi (p, size, m_crc16_modbus);
[+] 	m_crc16_modbus = crc16_ansi(p, size, m_crc16_modbus);
[-] 	m_crc16_xmodem = crc16_ccitt (p, size, m_crc16_xmodem);
[+] 	m_crc16_xmodem = crc16_ccitt(p, size, m_crc16_xmodem);
[-] 	m_crc32 = crc32 (p, size, m_crc32);
[+] 	m_crc32 = crc32(p, size, m_crc32);
[-] ChecksumCalcRangeProcessor.processEndOfRange ()
[+] ChecksumCalcRangeProcessor.processEndOfRange()
[-] uint64_t sum8 (
[+] uint64_t sum8(
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\log_ThroughputCalc.jnc
----------------------
[-] 	createInformationValues (
[+] 	createInformationValues(
[-] 	createInformationValuesGrouped (
[+] 	createInformationValuesGrouped(
[-] ThroughputInfoSet.createInformationValues (
[+] ThroughputInfoSet.createInformationValues(
[-] 		m_timeSpanInfo = informationGrid.createValue (group, insertBefore, true, "Time span");
[+] 		m_timeSpanInfo = informationGrid.createValue(group, insertBefore, true, "Time span");
[-] 		m_txTotalSizeInfo = informationGrid.createValue (group, insertBefore, true, "TX total bytes");
[+] 		m_txTotalSizeInfo = informationGrid.createValue(group, insertBefore, true, "TX total bytes");
[-] 		m_txThroughputInfo = informationGrid.createValue (group, insertBefore, true, "TX throughput");
[+] 		m_txThroughputInfo = informationGrid.createValue(group, insertBefore, true, "TX throughput");
[-] 		m_rxTotalSizeInfo = informationGrid.createValue (group, insertBefore, true, "RX total bytes");
[+] 		m_rxTotalSizeInfo = informationGrid.createValue(group, insertBefore, true, "RX total bytes");
[-] 		m_rxThroughputInfo = informationGrid.createValue (group, insertBefore, true, "RX throughput");
[+] 		m_rxThroughputInfo = informationGrid.createValue(group, insertBefore, true, "RX throughput");
[-] 		m_totalSizeInfo = informationGrid.createValue (group, insertBefore, true, "Total bytes");
[+] 		m_totalSizeInfo = informationGrid.createValue(group, insertBefore, true, "Total bytes");
[-] 		m_totalThroughputInfo = informationGrid.createValue (group, insertBefore, true, "Total throughput");
[+] 		m_totalThroughputInfo = informationGrid.createValue(group, insertBefore, true, "Total throughput");
[-] ThroughputInfoSet.createInformationValuesGrouped (
[+] ThroughputInfoSet.createInformationValuesGrouped(
[-] 	gui.InformationGroup* subGroup = informationGrid.createGroup (
[+] 	gui.InformationGroup* subGroup = informationGrid.createGroup(
[-] 	createInformationValues (informationGrid, subGroup,, mask);
[+] 	createInformationValues(informationGrid, subGroup,, mask);
[-] 	static ThroughputCalcRangeProcessor* factory (ThroughputInfoSet* infoSet)
[+] 	static ThroughputCalcRangeProcessor* factory(ThroughputInfoSet* infoSet)
[-] 		return new ThroughputCalcRangeProcessor (infoSet);
[+] 		return new ThroughputCalcRangeProcessor(infoSet);
[-] 	construct (ThroughputInfoSet* infoSet)
[+] 	construct(ThroughputInfoSet* infoSet)
[-] 	override processText (
[+] 	override processText(
[-] 	override processBin (
[+] 	override processBin(
[-] 	override processDualBin (
[+] 	override processDualBin(
[-] 	override processEndOfRange ();
[+] 	override processEndOfRange();
[-] ThroughputCalcRangeProcessor.processText (
[+] ThroughputCalcRangeProcessor.processText(
[-] ThroughputCalcRangeProcessor.processBin (
[+] ThroughputCalcRangeProcessor.processBin(
[-] 	switch (partCode)
[+] 	switch(partCode)
[-] ThroughputCalcRangeProcessor.processDualBin (
[+] ThroughputCalcRangeProcessor.processDualBin(
[-] 	switch (partCode)
[+] 	switch(partCode)
[-] ThroughputCalcRangeProcessor.processEndOfRange ()
[+] ThroughputCalcRangeProcessor.processEndOfRange()
[-] 		m_infoSet.m_txTotalSizeInfo.m_value = formatIntegerWithThousandSep (m_txTotalSize);
[+] 		m_infoSet.m_txTotalSizeInfo.m_value = formatIntegerWithThousandSep(m_txTotalSize);
[-] 		m_infoSet.m_rxTotalSizeInfo.m_value = formatIntegerWithThousandSep (m_rxTotalSize);
[+] 		m_infoSet.m_rxTotalSizeInfo.m_value = formatIntegerWithThousandSep(m_rxTotalSize);
[-] 		m_infoSet.m_totalSizeInfo.m_value = formatIntegerWithThousandSep (m_totalSize);
[+] 		m_infoSet.m_totalSizeInfo.m_value = formatIntegerWithThousandSep(m_totalSize);
[-] 			m_infoSet.m_txThroughputInfo.m_value = formatIntegerWithThousandSep (m_txTotalSize * 10000000 / timeSpan);
[+] 			m_infoSet.m_txThroughputInfo.m_value = formatIntegerWithThousandSep(m_txTotalSize * 10000000 / timeSpan);
[-] 			m_infoSet.m_rxThroughputInfo.m_value = formatIntegerWithThousandSep (m_rxTotalSize * 10000000 / timeSpan);
[+] 			m_infoSet.m_rxThroughputInfo.m_value = formatIntegerWithThousandSep(m_rxTotalSize * 10000000 / timeSpan);
[-] 			m_infoSet.m_totalThroughputInfo.m_value = formatIntegerWithThousandSep (m_totalSize * 10000000 / timeSpan);
[+] 			m_infoSet.m_totalThroughputInfo.m_value = formatIntegerWithThousandSep(m_totalSize * 10000000 / timeSpan);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\parseInteger.jnc
----------------------
[-] long parseInteger (
[+] long parseInteger(
[-] 		length = strlen (p);
[+] 		length = strlen(p);
[-] 		length >= 2 && p [0] == '0' ?
[+] 		length >= 2 && p[0] == '0' ?
[-] 		length >= 3 && (p [1] == 'x' || p [1] == 'X') ?
[+] 		length >= 3 && (p[1] == 'x' || p[1] == 'X') ?
[-] 	return strtol (p, null, radix);
[+] 	return strtol(p, null, radix);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\common\parseVersion.jnc
----------------------
[-] uint_t parseVersion (
[+] uint_t parseVersion(
[-] 		length = strlen (p);
[+] 		length = strlen(p);
[-] 	uint_t version = strtol (p, &end) << 16;
[+] 	uint_t version = strtol(p, &end) << 16;
[-] 		version |= strtol (p, &end) << 8;
[+] 		version |= strtol(p, &end) << 8;
[-] 			version |= strtol (p, &end);
[+] 			version |= strtol(p, &end);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\packets\default.jnc
----------------------
[-] alignment (1);
[+] alignment(1);
[-] 	char m_name [8];
[+] 	char m_name[8];
[-] 	void initialize (char const* name)
[+] 	void initialize(char const* name)
[-] 		size_t size = strlen (name) + 1;
[+] 		size_t size = strlen(name) + 1;
[-] 		if (size > sizeof (m_name))
[+] 		if (size > sizeof(m_name))
[-] 			size = sizeof (m_name);
[+] 			size = sizeof(m_name);
[-] 		memcpy (m_name, name, size);
[+] 		memcpy(m_name, name, size);
[-] 	void updateLength ()
[+] 	void updateLength()
[-] 		m_length = dynamic sizeof (this);
[+] 		m_length = dynamic sizeof(this);
[-] 	void calcChecksum ()
[+] 	void calcChecksum()
[-] 		m_checksum = crc16_ansi (this, dynamic sizeof (this));
[+] 		m_checksum = crc16_ansi(this, dynamic sizeof(this));
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\packets\ModBus.jnc
----------------------
[-] 	initialize ()
[+] 	initialize()
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		updateModbusChecksum (this);
[+] 		updateModbusChecksum(this);
[-] 	initialize ()
[+] 	initialize()
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		updateModbusChecksum (this);
[+] 		updateModbusChecksum(this);
[-] 	initialize ()
[+] 	initialize()
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		updateModbusChecksum (this);
[+] 		updateModbusChecksum(this);
[-] updateModbusChecksum (void* p)
[+] updateModbusChecksum(void* p)
[-] 	size_t size = dynamic sizeof (p);
[+] 	size_t size = dynamic sizeof(p);
[-] 	*(uint16_t*) (p + size) = crc16_ansi (p, size, 0xffff);
[+] 	*(uint16_t*)(p + size) = crc16_ansi(p, size, 0xffff);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\packets\TcpIp.jnc
----------------------
[-] alignment (1);
[+] alignment(1);
[-] 	initialize ()
[+] 	initialize()
[-] 		initializeEthernetIpHdr (&m_ethernet, &m_ip, (io.IpProtocol) 0);
[+] 		initializeEthernetIpHdr(&m_ethernet, &m_ip, (io.IpProtocol) 0);
[-] 	calcLength ()
[+] 	calcLength()
[-] 		m_ip.m_totalLength = dynamic sizeof (&m_ip);
[+] 		m_ip.m_totalLength = dynamic sizeof(&m_ip);
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		m_ip.m_headerChecksum = calcIpHdrChecksum (&m_ip);
[+] 		m_ip.m_headerChecksum = calcIpHdrChecksum(&m_ip);
[-] 	setSrcAddress (char const* addressString)
[+] 	setSrcAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	setDstAddress (char const* addressString)
[+] 	setDstAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	initialize ()
[+] 	initialize()
[-] 		initializeEthernetIpHdr (&m_ethernet, &m_ip, io.IpProtocol.Icmp);
[+] 		initializeEthernetIpHdr(&m_ethernet, &m_ip, io.IpProtocol.Icmp);
[-] 	calcLength ()
[+] 	calcLength()
[-] 		m_ip.m_totalLength = dynamic sizeof (&m_ip);
[+] 		m_ip.m_totalLength = dynamic sizeof(&m_ip);
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		m_ip.m_headerChecksum = calcIpHdrChecksum (&m_ip);
[+] 		m_ip.m_headerChecksum = calcIpHdrChecksum(&m_ip);
[-] 	setSrcAddress (char const* addressString)
[+] 	setSrcAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	setDstAddress (char const* addressString)
[+] 	setDstAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	initialize ()
[+] 	initialize()
[-] 		initializeEthernetIpHdr (&m_ethernet, &m_ip, io.IpProtocol.Tcp);
[+] 		initializeEthernetIpHdr(&m_ethernet, &m_ip, io.IpProtocol.Tcp);
[-] 	calcLength ()
[+] 	calcLength()
[-] 		m_ip.m_totalLength = dynamic sizeof (&m_ip);
[+] 		m_ip.m_totalLength = dynamic sizeof(&m_ip);
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		m_ip.m_headerChecksum = calcIpHdrChecksum (&m_ip);
[+] 		m_ip.m_headerChecksum = calcIpHdrChecksum(&m_ip);
[-] 		m_tcp.m_checksum = calcTcpUdpChecksum (&m_ip, &m_tcp, dynamic sizeof (&m_tcp));
[+] 		m_tcp.m_checksum = calcTcpUdpChecksum(&m_ip, &m_tcp, dynamic sizeof(&m_tcp));
[-] 	setSrcAddress (char const* addressString)
[+] 	setSrcAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	setDstAddress (char const* addressString)
[+] 	setDstAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	initialize ()
[+] 	initialize()
[-] 		initializeEthernetIpHdr (&m_ethernet, &m_ip, io.IpProtocol.Udp);
[+] 		initializeEthernetIpHdr(&m_ethernet, &m_ip, io.IpProtocol.Udp);
[-] 	calcLength ()
[+] 	calcLength()
[-] 		m_ip.m_totalLength = dynamic sizeof (&m_ip);
[+] 		m_ip.m_totalLength = dynamic sizeof(&m_ip);
[-] 		m_udp.m_length = dynamic sizeof (&m_udp);
[+] 		m_udp.m_length = dynamic sizeof(&m_udp);
[-] 	calcChecksum ()
[+] 	calcChecksum()
[-] 		m_ip.m_headerChecksum = calcIpHdrChecksum (&m_ip);
[+] 		m_ip.m_headerChecksum = calcIpHdrChecksum(&m_ip);
[-] 		m_udp.m_checksum = calcTcpUdpChecksum (&m_ip, &m_udp, dynamic sizeof (&m_udp));
[+] 		m_udp.m_checksum = calcTcpUdpChecksum(&m_ip, &m_udp, dynamic sizeof(&m_udp));
[-] 	setSrcAddress (char const* addressString)
[+] 	setSrcAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] 	setDstAddress (char const* addressString)
[+] 	setDstAddress(char const* addressString)
[-] 		bool result = try addr.parse (addressString);
[+] 		bool result = try addr.parse(addressString);
[-] initializeEthernetIpHdr (
[+] initializeEthernetIpHdr(
[-] 	ipHdr.m_totalLength = dynamic sizeof (ipHdr);
[+] 	ipHdr.m_totalLength = dynamic sizeof(ipHdr);
[-] uint_t calcChecksum16 (
[+] uint_t calcChecksum16(
[-] bigendian uint16_t adjustIpCheckSum (uint_t checksum)
[+] bigendian uint16_t adjustIpCheckSum(uint_t checksum)
[-] bigendian uint16_t calcIpHdrChecksum (io.IpHdr const* ipHdr)
[+] bigendian uint16_t calcIpHdrChecksum(io.IpHdr const* ipHdr)
[-] 	size_t maxSize = dynamic sizeof (ipHdr);
[+] 	size_t maxSize = dynamic sizeof(ipHdr);
[-] 	uint_t checksum = calcChecksum16 (ipHdr, size);
[+] 	uint_t checksum = calcChecksum16(ipHdr, size);
[-] 	return adjustIpCheckSum (checksum);
[+] 	return adjustIpCheckSum(checksum);
[-] bigendian uint16_t calcTcpUdpChecksum (
[+] bigendian uint16_t calcTcpUdpChecksum(
[-] 		calcChecksum16 (&pseudoHdr, sizeof (pseudoHdr)) +
[+] 		calcChecksum16(&pseudoHdr, sizeof(pseudoHdr)) +
[-] 		calcChecksum16 (p, size);
[+] 		calcChecksum16(p, size);
[-] 	return adjustIpCheckSum (checksum);
[+] 	return adjustIpCheckSum(checksum);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\DeviceMonLog\DeviceMonLogRepresenter.jnc
----------------------
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ($"Capture started on \e[34m$name");
[+] 		target.addHyperText($"Capture started on \e[34m$name");
[-] 		target.addHyperText ($"Capture started with filter \e[34m$nameFilter");
[+] 		target.addHyperText($"Capture started with filter \e[34m$nameFilter");
[-] 		target.addHyperText ("Capture stopped");
[+] 		target.addHyperText("Capture stopped");
[-] 		target.addHyperText ($"Cannot start capture: $(error.m_description)");
[+] 		target.addHyperText($"Cannot start capture: $(error.m_description)");
[-] 			switch (error.m_code)
[+] 			switch(error.m_code)
[-] 			switch (error.m_code)
[+] 			switch(error.m_code)
[-] 			target.addHyperText ($"Read this \e^$url\e[4;34mKB article\e[m for more details");
[+] 			target.addHyperText($"Read this \e^$url\e[4;34mKB article\e[m for more details");
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Echo\EchoLayer.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 		basetype.construct (pluginHost);
[+] 		basetype.construct(pluginHost);
[-] 		pluginHost.m_log.addListener (onLogRecord @ pluginHost.m_mainThreadScheduler);
[+] 		pluginHost.m_log.addListener(onLogRecord @ pluginHost.m_mainThreadScheduler);
[-] 	onLogRecord (
[+] 	onLogRecord(
[-] 			try transmit (p, size);
[+] 			try transmit(p, size);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\EzTapPro\EzTapPro.jnc
----------------------
[-] alignment (1)
[+] alignment(1)
[-] alignment (default)
[+] alignment(default)
[-] construct ()
[+] construct()
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.ClockMsbsChanged] = sizeof (EzTapClockMsbsChangedParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.ClockMsbsChanged] = sizeof(EzTapClockMsbsChangedParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.DceData] = sizeof (EzTapDataParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.DceData] = sizeof(EzTapDataParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.DceControlLineChanged] = sizeof (EzTapControlLineChangedParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.DceControlLineChanged] = sizeof(EzTapControlLineChangedParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.DteData] = sizeof (EzTapDataParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.DteData] = sizeof(EzTapDataParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.DteControlLineChanged] = sizeof (EzTapControlLineChangedParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.DteControlLineChanged] = sizeof(EzTapControlLineChangedParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.GenericReply] = sizeof (EzTapGenericReplyParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.GenericReply] = sizeof(EzTapGenericReplyParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.GetControlLinesReply] = sizeof (EzTapGetContorlLinesReplyParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.GetControlLinesReply] = sizeof(EzTapGetContorlLinesReplyParams);
[-] 	g_ezTapResponseSizeMap [EzTapResponseCode.Error] = sizeof (EzTapErrorParams);
[+] 	g_ezTapResponseSizeMap[EzTapResponseCode.Error] = sizeof(EzTapErrorParams);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\EzTapPro\EzTapProSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.InformationValue* m_infoTable [InfoId._Count];
[+] 	gui.InformationValue* m_infoTable[InfoId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? stopCapture () : try capture ();
[+] 		m_state ? stopCapture() : try capture();
[-] 	onPortComboEnter ()
[+] 	onPortComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onBaudRateChanged ();
[+] 	onBaudRateChanged();
[-] 	onSerialEvent (
[+] 	onSerialEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	flipDteDce ();
[+] 	flipDteDce();
[-] 	gui.ComboBox* createSerialSettingComboBox (
[+] 	gui.ComboBox* createSerialSettingComboBox(
[-] 		function* onChanged ()
[+] 		function* onChanged()
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] 	io.SerialOptions getSerialOptions ();
[+] 	io.SerialOptions getSerialOptions();
[-] 	uint_t getReadInterval ()
[+] 	uint_t getReadInterval()
[-] 	bool errorcode resetAcquisition ();
[+] 	bool errorcode resetAcquisition();
[-] 	bool errorcode startAcquisition ();
[+] 	bool errorcode startAcquisition();
[-] 	bool errorcode configureSerial ();
[+] 	bool errorcode configureSerial();
[-] 	bool errorcode getControlLines ();
[+] 	bool errorcode getControlLines();
[-] 	bool errorcode decodeResponse (
[+] 	bool errorcode decodeResponse(
[-] 	updateDteControlLines (
[+] 	updateDteControlLines(
[-] 	updateDceControlLines (
[+] 	updateDceControlLines(
[-] 	updateLineInfoValue (
[+] 	updateLineInfoValue(
[-] EzTapProSession.construct (doc.PluginHost* pluginHost)
[+] EzTapProSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] EzTapProSession.createUi ()
[+] EzTapProSession.createUi()
[-] 	static gui.EnumPropertyOption parityTable [] =
[+] 	static gui.EnumPropertyOption parityTable[] =
[-] 	static gui.EnumPropertyOption signalLevelTable [] =
[+] 	static gui.EnumPropertyOption signalLevelTable[] =
[-] 	static gui.EnumPropertyOption readModeTable [] =
[+] 	static gui.EnumPropertyOption readModeTable[] =
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Refresh port list", "images/refresh.png");
[+] 	m_actionTable[ActionId.Refresh] = createAction("Refresh port list", "images/refresh.png");
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumeratePorts;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumeratePorts;
[-] 	m_actionTable [ActionId.Capture]  = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture]  = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 	m_serialSettingUi.create (
[+] 	m_serialSettingUi.create(
[-] 	bindingof (m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[+] 	bindingof(m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[-] 	m_pluginHost.m_menu.addSeparator ();
[+] 	m_pluginHost.m_menu.addSeparator();
[-] 	m_actionTable [ActionId.Flip] = createAction ("Flip DTE/DCE", "images/flip.png");
[+] 	m_actionTable[ActionId.Flip] = createAction("Flip DTE/DCE", "images/flip.png");
[-] 	m_actionTable [ActionId.Flip].m_isCheckable = true;
[+] 	m_actionTable[ActionId.Flip].m_isCheckable = true;
[-] 	m_actionTable [ActionId.Flip].m_onTriggered = flipDteDce;
[+] 	m_actionTable[ActionId.Flip].m_onTriggered = flipDteDce;
[-] 	m_statusPane = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPane = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_parityProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_parityProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (parityTable)
[+] 		countof(parityTable)
[-] 	m_signalLevelProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_signalLevelProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (signalLevelTable)
[+] 		countof(signalLevelTable)
[-] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 			countof (readModeTable)
[+] 			countof(readModeTable)
[-] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 		m_readModeProp = new gui.EnumProperty (null);
[+] 		m_readModeProp = new gui.EnumProperty(null);
[-] 		m_readIntervalProp = new gui.IntProperty (null);
[+] 		m_readIntervalProp = new gui.IntProperty(null);
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_infoTable [InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DTR");
[+] 	m_infoTable[InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DTR");
[-] 	m_infoTable [InfoId.Rts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "RTS");
[+] 	m_infoTable[InfoId.Rts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "RTS");
[-] 	m_infoTable [InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DSR");
[+] 	m_infoTable[InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DSR");
[-] 	m_infoTable [InfoId.Cts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "CTS");
[+] 	m_infoTable[InfoId.Cts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "CTS");
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] gui.ComboBox* EzTapProSession.createSerialSettingComboBox (
[+] gui.ComboBox* EzTapProSession.createSerialSettingComboBox(
[-] 	function* onChanged ()
[+] 	function* onChanged()
[-] 	m_pluginHost.m_toolBar.addLabel (labelText);
[+] 	m_pluginHost.m_toolBar.addLabel(labelText);
[-] 	gui.ComboBox* comboBox = m_pluginHost.m_toolBar.addComboBox ();
[+] 	gui.ComboBox* comboBox = m_pluginHost.m_toolBar.addComboBox();
[-] 		comboBox.addItem (optionTable [i].m_text, optionTable [i].m_value);
[+] 		comboBox.addItem(optionTable[i].m_text, optionTable[i].m_value);
[-] 	comboBox.adjustSizeToContents ();
[+] 	comboBox.adjustSizeToContents();
[-] EzTapProSession.enumeratePorts ()
[+] EzTapProSession.enumeratePorts()
[-] 	m_portCombo.clear ();
[+] 	m_portCombo.clear();
[-] 	io.SerialPortDesc const* portList = io.createSerialPortDescList (&count);
[+] 	io.SerialPortDesc const* portList = io.createSerialPortDescList(&count);
[-] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption[count];
[-] 		m_portCombo.addItem (description, port.m_deviceName);
[+] 		m_portCombo.addItem(description, port.m_deviceName);
[-] 	m_portProp.setOptions (optionArray, count);
[+] 	m_portProp.setOptions(optionArray, count);
[-] EzTapProSession.flipDteDce ()
[+] EzTapProSession.flipDteDce()
[-] io.SerialOptions EzTapProSession.getSerialOptions ()
[+] io.SerialOptions EzTapProSession.getSerialOptions()
[-] bool errorcode EzTapProSession.capture ()
[+] bool errorcode EzTapProSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_serial.m_readInterval = getReadInterval ();
[+] 	m_serial.m_readInterval = getReadInterval();
[-] 	m_serial.m_options = getSerialOptions ();
[+] 	m_serial.m_options = getSerialOptions();
[-] 	m_serial.open (portName);
[+] 	m_serial.open(portName);
[-] 	writeLog (SerialLogRecordCode.PortOpened, p, dynamic sizeof (p));
[+] 	writeLog(SerialLogRecordCode.PortOpened, p, dynamic sizeof(p));
[-] 	m_responseBuffer.clear ();
[+] 	m_responseBuffer.clear();
[-] 	resetAcquisition ();
[+] 	resetAcquisition();
[-] 	configureSerial ();
[+] 	configureSerial();
[-] 	startAcquisition ();
[+] 	startAcquisition();
[-] 	getControlLines ();
[+] 	getControlLines();
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_serial.close ();
[+] 	m_serial.close();
[-] EzTapProSession.stopCapture ()
[+] EzTapProSession.stopCapture()
[-] 	resetAcquisition ();
[+] 	resetAcquisition();
[-] 	writeLogString (SerialLogRecordCode.PortClosed, m_portName);
[+] 	writeLogString(SerialLogRecordCode.PortClosed, m_portName);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] 	m_serial.close ();
[+] 	m_serial.close();
[-] bool errorcode EzTapProSession.resetAcquisition ()
[+] bool errorcode EzTapProSession.resetAcquisition()
[-] 	m_serial.write (&params, sizeof (params));
[+] 	m_serial.write(&params, sizeof(params));
[-] bool errorcode EzTapProSession.startAcquisition ()
[+] bool errorcode EzTapProSession.startAcquisition()
[-] 	m_serial.write (&params, sizeof (params));
[+] 	m_serial.write(&params, sizeof(params));
[-] bool errorcode EzTapProSession.configureSerial ()
[+] bool errorcode EzTapProSession.configureSerial()
[-] 		writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 		writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 		writeLog (SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof (dataBits));
[+] 		writeLog(SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
[-] 		writeLog (SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof (stopBits));
[+] 		writeLog(SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));
[-] 		writeLog (SerialLogRecordCode.ParityChanged, &parity, sizeof (parity));
[+] 		writeLog(SerialLogRecordCode.ParityChanged, &parity, sizeof(parity));
[-] 	m_serial.write (&params, sizeof (params));
[+] 	m_serial.write(&params, sizeof(params));
[-] 	m_serial.write (&params, sizeof (params));
[+] 	m_serial.write(&params, sizeof(params));
[-] bool errorcode EzTapProSession.getControlLines ()
[+] bool errorcode EzTapProSession.getControlLines()
[-] 	m_serial.write (&params, sizeof (params));
[+] 	m_serial.write(&params, sizeof(params));
[-] void EzTapProSession.updateDteControlLines (
[+] void EzTapProSession.updateDteControlLines(
[-] 		writeLog (SerialLogRecordCode.ControlLineChanged, params, sizeof (params));
[+] 		writeLog(SerialLogRecordCode.ControlLineChanged, params, sizeof(params));
[-] void EzTapProSession.updateDceControlLines (
[+] void EzTapProSession.updateDceControlLines(
[-] 		writeLog (SerialLogRecordCode.StatusLineChanged, params, sizeof (params));
[+] 		writeLog(SerialLogRecordCode.StatusLineChanged, params, sizeof(params));
[-] bool errorcode EzTapProSession.decodeResponse (
[+] bool errorcode EzTapProSession.decodeResponse(
[-] 			m_responseSize = g_ezTapResponseSizeMap [code];
[+] 			m_responseSize = g_ezTapResponseSizeMap[code];
[-] 				std.setError ("invalid packet from EZ-Tap Pro");
[+] 				std.setError("invalid packet from EZ-Tap Pro");
[-] 			m_responseBuffer.clear ();
[+] 			m_responseBuffer.clear();
[-] 			m_responseBuffer.reserve (m_responseSize);
[+] 			m_responseBuffer.reserve(m_responseSize);
[-] 			m_responseBuffer.append (p, size);
[+] 			m_responseBuffer.append(p, size);
[-] 		m_responseBuffer.append (p, missing);
[+] 		m_responseBuffer.append(p, missing);
[-] 		uint_t code = m_responseBuffer [0] & EzTapResponseCode.Mask;
[+] 		uint_t code = m_responseBuffer[0] & EzTapResponseCode.Mask;
[-] 		switch (code)
[+] 		switch(code)
[-] 			uint64_t recordCode = code == EzTapResponseCode.DteData != m_actionTable [ActionId.Flip].m_isChecked ?
[+] 			uint64_t recordCode = code == EzTapResponseCode.DteData != m_actionTable[ActionId.Flip].m_isChecked ?
[-] 			writeLog (recordCode, &params.m_data, 1);
[+] 			writeLog(recordCode, &params.m_data, 1);
[-] 			if (code == EzTapResponseCode.DteControlLineChanged != m_actionTable [ActionId.Flip].m_isChecked)
[+] 			if (code == EzTapResponseCode.DteControlLineChanged != m_actionTable[ActionId.Flip].m_isChecked)
[-] 				updateDteControlLines (params.m_dsr, params.m_cts);
[+] 				updateDteControlLines(params.m_dsr, params.m_cts);
[-] 				updateDceControlLines (params.m_dsr, params.m_cts);
[+] 				updateDceControlLines(params.m_dsr, params.m_cts);
[-] 			if (m_actionTable [ActionId.Flip].m_isChecked)
[+] 			if (m_actionTable[ActionId.Flip].m_isChecked)
[-] 				updateDteControlLines (params.m_dsr, params.m_cts);
[+] 				updateDteControlLines(params.m_dsr, params.m_cts);
[-] 				updateDceControlLines (params.m_dtr, params.m_rts);
[+] 				updateDceControlLines(params.m_dtr, params.m_rts);
[-] 				updateDteControlLines (params.m_dtr, params.m_rts);
[+] 				updateDteControlLines(params.m_dtr, params.m_rts);
[-] 				updateDceControlLines (params.m_dsr, params.m_cts);
[+] 				updateDceControlLines(params.m_dsr, params.m_cts);
[-] 				writeLog (log.StdRecordCode.RxBufferFullLossy);
[+] 				writeLog(log.StdRecordCode.RxBufferFullLossy);
[-] 				std.setError ("invalid error code from EZ-Tap Pro");
[+] 				std.setError("invalid error code from EZ-Tap Pro");
[-] 			assert (false, "invalid response code"); // should have been checked earlier
[+] 			assert(false, "invalid response code"); // should have been checked earlier
[-] size_t errorcode EzTapProSession.transmit (
[+] size_t errorcode EzTapProSession.transmit(
[-] 	size_t result = m_serial.write (p, size);
[+] 	size_t result = m_serial.write(p, size);
[-] 	writeLog (log.StdRecordCode.Tx, p, result);
[+] 	writeLog(log.StdRecordCode.Tx, p, result);
[-] void EzTapProSession.load (doc.Storage* storage)
[+] void EzTapProSession.load(doc.Storage* storage)
[-] 	m_serialSettingUi.load (storage);
[+] 	m_serialSettingUi.load(storage);
[-] 	m_portCombo.m_editText = storage.readString ("portName");
[+] 	m_portCombo.m_editText = storage.readString("portName");
[-] 	m_parityProp.m_currentIndex = storage.readInt ("parity");
[+] 	m_parityProp.m_currentIndex = storage.readInt("parity");
[-] 	m_signalLevelProp.m_currentIndex = storage.readInt ("signalLevel");
[+] 	m_signalLevelProp.m_currentIndex = storage.readInt("signalLevel");
[-] 	m_actionTable [ActionId.Flip].m_isChecked = storage.readBool ("flipDteDce");
[+] 	m_actionTable[ActionId.Flip].m_isChecked = storage.readBool("flipDteDce");
[-] 	m_readModeProp.m_value = storage.readBool ("readMode", Defaults.ReadMode);
[+] 	m_readModeProp.m_value = storage.readBool("readMode", Defaults.ReadMode);
[-] 	m_readIntervalProp.m_value = storage.readInt ("readInterval", Defaults.ReadInterval);
[+] 	m_readIntervalProp.m_value = storage.readInt("readInterval", Defaults.ReadInterval);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void EzTapProSession.save (doc.Storage* storage)
[+] void EzTapProSession.save(doc.Storage* storage)
[-] 	m_serialSettingUi.save (storage);
[+] 	m_serialSettingUi.save(storage);
[-] 	storage.writeString ("portName", m_portCombo.m_editText);
[+] 	storage.writeString("portName", m_portCombo.m_editText);
[-] 	storage.writeInt ("parity", m_parityProp.m_currentIndex);
[+] 	storage.writeInt("parity", m_parityProp.m_currentIndex);
[-] 	storage.writeInt ("signalLevel", m_signalLevelProp.m_currentIndex);
[+] 	storage.writeInt("signalLevel", m_signalLevelProp.m_currentIndex);
[-] 	storage.writeBool ("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[+] 	storage.writeBool("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[-] 	storage.writeInt ("readMode", m_readModeProp.m_value);
[+] 	storage.writeInt("readMode", m_readModeProp.m_value);
[-] 	storage.writeInt ("readInterval", m_readIntervalProp.m_value);
[+] 	storage.writeInt("readInterval", m_readIntervalProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void EzTapProSession.updateProperties ()
[+] void EzTapProSession.updateProperties()
[-] 	m_serialSettingUi.updateProperties ();
[+] 	m_serialSettingUi.updateProperties();
[-] 	m_flipProp.m_value = m_actionTable [ActionId.Flip].m_isChecked;
[+] 	m_flipProp.m_value = m_actionTable[ActionId.Flip].m_isChecked;
[-] bool errorcode EzTapProSession.applyProperties ()
[+] bool errorcode EzTapProSession.applyProperties()
[-] 	m_serialSettingUi.applyProperties ();
[+] 	m_serialSettingUi.applyProperties();
[-] 	m_actionTable [ActionId.Flip].m_isChecked = m_flipProp.m_value;
[+] 	m_actionTable[ActionId.Flip].m_isChecked = m_flipProp.m_value;
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	io.SerialOptions options = getSerialOptions ();
[+] 	io.SerialOptions options = getSerialOptions();
[-] 	uint_t readInterval = getReadInterval ();
[+] 	uint_t readInterval = getReadInterval();
[-] 		writeLog (SerialLogRecordCode.ReadModeChanged, &mode, sizeof (mode));
[+] 		writeLog(SerialLogRecordCode.ReadModeChanged, &mode, sizeof(mode));
[-] 		writeLog (SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof (readInterval));
[+] 		writeLog(SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof(readInterval));
[-] 	configureSerial ();
[+] 	configureSerial();
[-] void EzTapProSession.restoreDefaultProperties ()
[+] void EzTapProSession.restoreDefaultProperties()
[-] 	m_serialSettingUi.restoreDefaultProperties ();
[+] 	m_serialSettingUi.restoreDefaultProperties();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] EzTapProSession.waitSerialEvents ()
[+] EzTapProSession.waitSerialEvents()
[-] 	m_serial.wait (eventMask, onSerialEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_serial.wait(eventMask, onSerialEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] EzTapProSession.onSerialEvent (
[+] EzTapProSession.onSerialEvent(
[-] 		writeLog (log.StdRecordCode.Error, &m_serial.m_ioError, m_serial.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, &m_serial.m_ioError, m_serial.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFullLossy);
[+] 		writeLog(log.StdRecordCode.RxBufferFullLossy);
[-] 		size_t result = m_serial.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_serial.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			decodeResponse (m_readBuffer.m_p, result);
[+] 			decodeResponse(m_readBuffer.m_p, result);
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] 	stopCapture ();
[+] 	stopCapture();
[-] EzTapProSession.onBaudRateChanged ()
[+] EzTapProSession.onBaudRateChanged()
[-] 	configureSerial ();
[+] 	configureSerial();
[-] EzTapProSession.updateLineInfoValue (
[+] EzTapProSession.updateLineInfoValue(
[-] 	m_infoTable [infoId].m_value = line ? "on" : "off";
[+] 	m_infoTable[infoId].m_value = line ? "on" : "off";
[-] 	m_infoTable [infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[+] 	m_infoTable[infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_infoTable [InfoId.Dtr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dtr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Rts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Rts].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Dsr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dsr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Cts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Cts].m_isEnabled = m_state;
[-] 	updateLineInfoValue (InfoId.Dtr, m_dteControlLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dtr, m_dteControlLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Rts, m_dteControlLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Rts, m_dteControlLines & io.SerialStatusLines.Cts);
[-] 	updateLineInfoValue (InfoId.Dsr, m_dceControlLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dsr, m_dceControlLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Cts, m_dceControlLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Cts, m_dceControlLines & io.SerialStatusLines.Cts);
----------------------
27/02/2019 18:02:24 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\File\FileLogRepresenter.jnc
----------------------
[-] bool representFileLog (
[+] bool representFileLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ($"Opened file \e[34m$fileName\e[m ($(io.getFileStreamKindString (*kind)))");
[+] 		target.addHyperText($"Opened file \e[34m$fileName\e[m ($(io.getFileStreamKindString (*kind)))");
[-] 		target.addHyperText ($"Cannot open file: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open file: $(error.m_description)");
[-] 		target.addHyperText ($"File closed");
[+] 		target.addHyperText($"File closed");
[-] 		target.addHyperText ("End-of-file reached");
[+] 		target.addHyperText("End-of-file reached");
[-] 		target.addHyperText ($"File cleared");
[+] 		target.addHyperText($"File cleared");
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\File\FileSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	close ();
[+] 	close();
[-] 	clear ();
[+] 	clear();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onOpen ()
[+] 	onOpen()
[-] 		m_state ? close () : try open ();
[+] 		m_state ? close() : try open();
[-] 	onFileNameComboEnter ()
[+] 	onFileNameComboEnter()
[-] 		try open ();
[+] 		try open();
[-] 	onFileStreamEvent (
[+] 	onFileStreamEvent(
[-] 	io.FileStreamOptions getFileStreamOptions ();
[+] 	io.FileStreamOptions getFileStreamOptions();
[-] 	waitFileStreamEvents ();
[+] 	waitFileStreamEvents();
[-] 	createUi ();
[+] 	createUi();
[-] FileSession.construct (doc.PluginHost* pluginHost)
[+] FileSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] FileSession.createUi ()
[+] FileSession.createUi()
[-] 	static gui.EnumPropertyOption accessModeTable [] =
[+] 	static gui.EnumPropertyOption accessModeTable[] =
[-] 	m_pluginHost.m_toolBar.addLabel ("File:");
[+] 	m_pluginHost.m_toolBar.addLabel("File:");
[-] 	m_fileNameCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_fileNameCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_accessCombo = m_pluginHost.m_toolBar.addComboBox ("Access:", accessModeTable, countof (accessModeTable));
[+] 	m_accessCombo = m_pluginHost.m_toolBar.addComboBox("Access:", accessModeTable, countof (accessModeTable));
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Clear] = new gui.Icon ("images/clear.png");
[+] 	m_iconTable[IconId.Clear] = new gui.Icon("images/clear.png");
[-] 	m_actionTable [ActionId.Open] = createAction ("Open", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpen;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpen;
[-] 	m_actionTable [ActionId.Clear] = createAction ("Clear", m_iconTable [IconId.Clear]);
[+] 	m_actionTable[ActionId.Clear] = createAction("Clear", m_iconTable [IconId.Clear]);
[-] 	m_actionTable [ActionId.Clear].m_onTriggered += clear;
[+] 	m_actionTable[ActionId.Clear].m_onTriggered += clear;
[-] 	m_actionTable [ActionId.Clear].m_isEnabled = false;
[+] 	m_actionTable[ActionId.Clear].m_isEnabled = false;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_fileNameProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_fileNameProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_accessProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_accessProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (accessModeTable)
[+] 		countof(accessModeTable)
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("File session");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("File session");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode FileSession.open ()
[+] bool errorcode FileSession.open()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_fileNameCombo.addEditTextToHistory ();
[+] 	m_fileNameCombo.addEditTextToHistory();
[-] 	m_file.m_options = getFileStreamOptions ();
[+] 	m_file.m_options = getFileStreamOptions();
[-] 	m_file.open (fileName, openFlags);
[+] 	m_file.open(fileName, openFlags);
[-] 	writeLog (FileLogRecordCode.Opened, p, dynamic sizeof (p));
[+] 	writeLog(FileLogRecordCode.Opened, p, dynamic sizeof(p));
[-] 	waitFileStreamEvents ();
[+] 	waitFileStreamEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_file.close ();
[+] 	m_file.close();
[-] FileSession.close ()
[+] FileSession.close()
[-] 	writeLog (FileLogRecordCode.Closed);
[+] 	writeLog(FileLogRecordCode.Closed);
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] FileSession.clear ()
[+] FileSession.clear()
[-] 	try m_file.clear ();
[+] 	try m_file.clear();
[-] 	writeLog (FileLogRecordCode.Cleared);
[+] 	writeLog(FileLogRecordCode.Cleared);
[-] io.FileStreamOptions FileSession.getFileStreamOptions ()
[+] io.FileStreamOptions FileSession.getFileStreamOptions()
[-] FileSession.waitFileStreamEvents ()
[+] FileSession.waitFileStreamEvents()
[-] 	m_file.wait (eventMask, onFileStreamEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_file.wait(eventMask, onFileStreamEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void FileSession.load (doc.Storage* storage)
[+] void FileSession.load(doc.Storage* storage)
[-] 	m_fileNameCombo.loadHistory (storage, "fileNameHistory");
[+] 	m_fileNameCombo.loadHistory(storage, "fileNameHistory");
[-] 	m_fileNameCombo.m_editText = storage.readString ("fileName");
[+] 	m_fileNameCombo.m_editText = storage.readString("fileName");
[-] 	m_accessCombo.m_currentData = storage.readInt ("access");
[+] 	m_accessCombo.m_currentData = storage.readInt("access");
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void FileSession.save (doc.Storage* storage)
[+] void FileSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_fileNameCombo.saveHistory (storage, "fileNameHistory");
[+] 	m_fileNameCombo.saveHistory(storage, "fileNameHistory");
[-] 	storage.writeString ("fileName", m_fileNameCombo.m_editText);
[+] 	storage.writeString("fileName", m_fileNameCombo.m_editText);
[-] 	storage.writeInt ("access", m_accessCombo.m_currentData);
[+] 	storage.writeInt("access", m_accessCombo.m_currentData);
[-] void FileSession.updateProperties ()
[+] void FileSession.updateProperties()
[-] bool errorcode FileSession.applyProperties ()
[+] bool errorcode FileSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_file.m_options = getFileStreamOptions ();
[+] 	m_file.m_options = getFileStreamOptions();
[-] void FileSession.restoreDefaultProperties ()
[+] void FileSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode FileSession.transmit (
[+] size_t errorcode FileSession.transmit(
[-] 	size_t result = m_file.write (p, size);
[+] 	size_t result = m_file.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] FileSession.onFileStreamEvent (
[+] FileSession.onFileStreamEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_file.m_ioError, m_file.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_file.m_ioError, m_file.m_ioError.m_size);
[-] 		close ();
[+] 		close();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_file.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_file.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 			size_t result = m_file.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_file.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (FileLogRecordCode.Eof);
[+] 		writeLog(FileLogRecordCode.Eof);
[-] 		close ();
[+] 		close();
[-] 	waitFileStreamEvents ();
[+] 	waitFileStreamEvents();
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close" : "Open";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close" : "Open";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_actionTable [ActionId.Clear].m_isEnabled = m_state && m_file.m_kind == io.FileStreamKind.Disk;
[+] 	m_actionTable[ActionId.Clear].m_isEnabled = m_state && m_file.m_kind == io.FileStreamKind.Disk;
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\GenericSerialTap\GenericSerialTapSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.InformationValue* m_infoTable [InfoId._Count];
[+] 	gui.InformationValue* m_infoTable[InfoId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onOpen ()
[+] 	onOpen()
[-] 		m_state ? close () : try open ();
[+] 		m_state ? close() : try open();
[-] 	onPortComboEnter ()
[+] 	onPortComboEnter()
[-] 		try open ();
[+] 		try open();
[-] 	onBaudRateChanged ();
[+] 	onBaudRateChanged();
[-] 	onSerialEvent (
[+] 	onSerialEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	flipDteDce ();
[+] 	flipDteDce();
[-] 	gui.ComboBox* createSerialSettingComboBox (
[+] 	gui.ComboBox* createSerialSettingComboBox(
[-] 		function* onChanged ()
[+] 		function* onChanged()
[-] 	bool errorcode configurePort (SerialPort* port);
[+] 	bool errorcode configurePort(SerialPort* port);
[-] 	waitSerialEvents (SerialPort* port);
[+] 	waitSerialEvents(SerialPort* port);
[-] 	io.SerialOptions getSerialOptions ();
[+] 	io.SerialOptions getSerialOptions();
[-] 	uint_t getReadInterval ()
[+] 	uint_t getReadInterval()
[-] 	updateLineInfoValue (
[+] 	updateLineInfoValue(
[-] SerialTapSession.construct (doc.PluginHost* pluginHost)
[+] SerialTapSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SerialTapSession.createUi ()
[+] SerialTapSession.createUi()
[-] 	static gui.EnumPropertyOption readModeTable [] =
[+] 	static gui.EnumPropertyOption readModeTable[] =
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("DTE:");
[+] 	m_pluginHost.m_toolBar.addLabel("DTE:");
[-] 	m_dtePortCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_dtePortCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_pluginHost.m_toolBar.addLabel ("DCE:");
[+] 	m_pluginHost.m_toolBar.addLabel("DCE:");
[-] 	m_dcePortCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_dcePortCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	io.SerialPortDesc const* portList = io.createSerialPortDescList (&portCount);
[+] 	io.SerialPortDesc const* portList = io.createSerialPortDescList(&portCount);
[-] 		m_dtePortCombo.addItem (port.m_deviceName, null);
[+] 		m_dtePortCombo.addItem(port.m_deviceName, null);
[-] 		m_dcePortCombo.addItem (port.m_deviceName, null);
[+] 		m_dcePortCombo.addItem(port.m_deviceName, null);
[-] 	m_dtePortCombo.adjustSizeToContents ();
[+] 	m_dtePortCombo.adjustSizeToContents();
[-] 	m_dcePortCombo.adjustSizeToContents ();
[+] 	m_dcePortCombo.adjustSizeToContents();
[-] 	m_actionTable [ActionId.Refresh]  = createAction ("Refresh port list", "images/refresh.png");
[+] 	m_actionTable[ActionId.Refresh]  = createAction("Refresh port list", "images/refresh.png");
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumeratePorts;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumeratePorts;
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onOpen;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onOpen;
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_dtePortProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_dtePortProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 	m_dcePortProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_dcePortProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 	m_serialSettingUi.create (
[+] 	m_serialSettingUi.create(
[-] 	bindingof (m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[+] 	bindingof(m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[-] 	m_pluginHost.m_menu.addSeparator ();
[+] 	m_pluginHost.m_menu.addSeparator();
[-] 	m_actionTable [ActionId.Flip] = createAction ("Flip DTE/DCE", "images/flip.png");
[+] 	m_actionTable[ActionId.Flip] = createAction("Flip DTE/DCE", "images/flip.png");
[-] 	m_actionTable [ActionId.Flip].m_onTriggered += flipDteDce;
[+] 	m_actionTable[ActionId.Flip].m_onTriggered += flipDteDce;
[-] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_statusPane = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPane = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 			countof (readModeTable)
[+] 			countof(readModeTable)
[-] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 		m_readModeProp = new gui.EnumProperty (null);
[+] 		m_readModeProp = new gui.EnumProperty(null);
[-] 		m_readIntervalProp = new gui.IntProperty (null);
[+] 		m_readIntervalProp = new gui.IntProperty(null);
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial tap");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial tap");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_infoTable [InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DTR");
[+] 	m_infoTable[InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DTR");
[-] 	m_infoTable [InfoId.Rts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "RTS");
[+] 	m_infoTable[InfoId.Rts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "RTS");
[-] 	m_infoTable [InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DSR");
[+] 	m_infoTable[InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DSR");
[-] 	m_infoTable [InfoId.Cts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "CTS");
[+] 	m_infoTable[InfoId.Cts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "CTS");
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] gui.ComboBox* SerialTapSession.createSerialSettingComboBox (
[+] gui.ComboBox* SerialTapSession.createSerialSettingComboBox(
[-] 	function* onChanged ()
[+] 	function* onChanged()
[-] 	m_pluginHost.m_toolBar.addLabel (labelText);
[+] 	m_pluginHost.m_toolBar.addLabel(labelText);
[-] 	gui.ComboBox* comboBox = m_pluginHost.m_toolBar.addComboBox ();
[+] 	gui.ComboBox* comboBox = m_pluginHost.m_toolBar.addComboBox();
[-] 		comboBox.addItem (optionTable [i].m_text, optionTable [i].m_value);
[+] 		comboBox.addItem(optionTable[i].m_text, optionTable[i].m_value);
[-] 	comboBox.adjustSizeToContents ();
[+] 	comboBox.adjustSizeToContents();
[-] SerialTapSession.enumeratePorts ()
[+] SerialTapSession.enumeratePorts()
[-] 	m_dtePortCombo.clear ();
[+] 	m_dtePortCombo.clear();
[-] 	m_dcePortCombo.clear ();
[+] 	m_dcePortCombo.clear();
[-] 	io.SerialPortDesc const* portList = io.createSerialPortDescList (&count);
[+] 	io.SerialPortDesc const* portList = io.createSerialPortDescList(&count);
[-] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption[count];
[-] 		m_dtePortCombo.addItem (description, port.m_deviceName);
[+] 		m_dtePortCombo.addItem(description, port.m_deviceName);
[-] 		m_dcePortCombo.addItem (description, port.m_deviceName);
[+] 		m_dcePortCombo.addItem(description, port.m_deviceName);
[-] 	m_dtePortProp.setOptions (optionArray, count);
[+] 	m_dtePortProp.setOptions(optionArray, count);
[-] 	m_dcePortProp.setOptions (optionArray, count);
[+] 	m_dcePortProp.setOptions(optionArray, count);
[-] SerialTapSession.flipDteDce ()
[+] SerialTapSession.flipDteDce()
[-] 	m_uiReactor.restart (); // need to re-bind DTE/DCE
[+] 	m_uiReactor.restart(); // need to re-bind DTE/DCE
[-] io.SerialOptions SerialTapSession.getSerialOptions ()
[+] io.SerialOptions SerialTapSession.getSerialOptions()
[-] bool errorcode SerialTapSession.configurePort (SerialPort* port)
[+] bool errorcode SerialTapSession.configurePort(SerialPort* port)
[-] 	uint_t readInterval = getReadInterval ();
[+] 	uint_t readInterval = getReadInterval();
[-] 	port.m_serial.m_options = getSerialOptions ();
[+] 	port.m_serial.m_options = getSerialOptions();
[-] 	return port.m_serial.setupDevice (
[+] 	return port.m_serial.setupDevice(
[-] bool errorcode SerialTapSession.open ()
[+] bool errorcode SerialTapSession.open()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	if (strcmp (m_dtePort.m_name, m_dcePort.m_name) == 0)
[+] 	if (strcmp(m_dtePort.m_name, m_dcePort.m_name) == 0)
[-] 		std.setError ("ports A and B cannot be the same");
[+] 		std.setError("ports A and B cannot be the same");
[-] 	configurePort (m_dtePort);
[+] 	configurePort(m_dtePort);
[-] 	configurePort (m_dcePort);
[+] 	configurePort(m_dcePort);
[-] 	char const* driverNameA = io.detectSerialBuggyDriver (m_dtePort.m_name);
[+] 	char const* driverNameA = io.detectSerialBuggyDriver(m_dtePort.m_name);
[-] 	char const* driverNameB = io.detectSerialBuggyDriver (m_dcePort.m_name);
[+] 	char const* driverNameB = io.detectSerialBuggyDriver(m_dcePort.m_name);
[-] 		writeLogString (SerialLogRecordCode.BuggyDriverDetected, driverNameA ? driverNameA : driverNameB);
[+] 		writeLogString(SerialLogRecordCode.BuggyDriverDetected, driverNameA ? driverNameA : driverNameB);
[-] 		io.setConservativeSerialSettings (m_dtePort.m_serial);
[+] 		io.setConservativeSerialSettings(m_dtePort.m_serial);
[-] 		io.setConservativeSerialSettings (m_dcePort.m_serial);
[+] 		io.setConservativeSerialSettings(m_dcePort.m_serial);
[-] 	m_dtePort.m_serial.open (m_dtePort.m_name);
[+] 	m_dtePort.m_serial.open(m_dtePort.m_name);
[-] 	m_dcePort.m_serial.open (m_dcePort.m_name);
[+] 	m_dcePort.m_serial.open(m_dcePort.m_name);
[-] 	writeLog (SerialLogRecordCode.PortOpened, p, dynamic sizeof (p));
[+] 	writeLog(SerialLogRecordCode.PortOpened, p, dynamic sizeof(p));
[-] 	waitSerialEvents (m_dtePort);
[+] 	waitSerialEvents(m_dtePort);
[-] 	waitSerialEvents (m_dcePort);
[+] 	waitSerialEvents(m_dcePort);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_dtePort.m_serial.close ();
[+] 	m_dtePort.m_serial.close();
[-] 	m_dcePort.m_serial.close ();
[+] 	m_dcePort.m_serial.close();
[-] SerialTapSession.close ()
[+] SerialTapSession.close()
[-] 	writeLogString (SerialLogRecordCode.PortClosed, $"$(m_dtePort.m_name):$(m_dcePort.m_name)");
[+] 	writeLogString(SerialLogRecordCode.PortClosed, $"$(m_dtePort.m_name):$(m_dcePort.m_name)");
[-] 	m_dtePort.m_serial.close ();
[+] 	m_dtePort.m_serial.close();
[-] 	m_dcePort.m_serial.close ();
[+] 	m_dcePort.m_serial.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void SerialTapSession.load (doc.Storage* storage)
[+] void SerialTapSession.load(doc.Storage* storage)
[-] 	m_serialSettingUi.load (storage);
[+] 	m_serialSettingUi.load(storage);
[-] 	m_dtePortCombo.m_editText = storage.readString ("dtePortName");
[+] 	m_dtePortCombo.m_editText = storage.readString("dtePortName");
[-] 	m_dcePortCombo.m_editText = storage.readString ("dcePortName");
[+] 	m_dcePortCombo.m_editText = storage.readString("dcePortName");
[-] 	m_actionTable [ActionId.Flip].m_isChecked = storage.readBool ("flipDteDce");
[+] 	m_actionTable[ActionId.Flip].m_isChecked = storage.readBool("flipDteDce");
[-] 	m_readModeProp.m_value = storage.readBool ("readMode", Defaults.ReadMode);
[+] 	m_readModeProp.m_value = storage.readBool("readMode", Defaults.ReadMode);
[-] 	m_readIntervalProp.m_value = storage.readInt ("readInterval", Defaults.ReadInterval);
[+] 	m_readIntervalProp.m_value = storage.readInt("readInterval", Defaults.ReadInterval);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SerialTapSession.save (doc.Storage* storage)
[+] void SerialTapSession.save(doc.Storage* storage)
[-] 	m_serialSettingUi.save (storage);
[+] 	m_serialSettingUi.save(storage);
[-] 	storage.writeString ("dtePortName", m_dtePortCombo.m_editText);
[+] 	storage.writeString("dtePortName", m_dtePortCombo.m_editText);
[-] 	storage.writeString ("dcePortName", m_dcePortCombo.m_editText);
[+] 	storage.writeString("dcePortName", m_dcePortCombo.m_editText);
[-] 	storage.writeBool ("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[+] 	storage.writeBool("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[-] 	storage.writeInt ("readMode", m_readModeProp.m_value);
[+] 	storage.writeInt("readMode", m_readModeProp.m_value);
[-] 	storage.writeInt ("readInterval", m_readIntervalProp.m_value);
[+] 	storage.writeInt("readInterval", m_readIntervalProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void SerialTapSession.updateProperties ()
[+] void SerialTapSession.updateProperties()
[-] 	m_serialSettingUi.updateProperties ();
[+] 	m_serialSettingUi.updateProperties();
[-] 	m_flipProp.m_value = m_actionTable [ActionId.Flip].m_isChecked;
[+] 	m_flipProp.m_value = m_actionTable[ActionId.Flip].m_isChecked;
[-] bool errorcode SerialTapSession.applyProperties ()
[+] bool errorcode SerialTapSession.applyProperties()
[-] 	m_serialSettingUi.applyProperties ();
[+] 	m_serialSettingUi.applyProperties();
[-] 	m_actionTable [ActionId.Flip].m_isChecked = m_flipProp.m_value;
[+] 	m_actionTable[ActionId.Flip].m_isChecked = m_flipProp.m_value;
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	io.SerialOptions options = getSerialOptions ();
[+] 	io.SerialOptions options = getSerialOptions();
[-] 	uint_t readInterval = getReadInterval ();
[+] 	uint_t readInterval = getReadInterval();
[-] 	configurePort (m_dtePort);
[+] 	configurePort(m_dtePort);
[-] 	configurePort (m_dcePort);
[+] 	configurePort(m_dcePort);
[-] 		writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 		writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 		writeLog (SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof (dataBits));
[+] 		writeLog(SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
[-] 		writeLog (SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof (stopBits));
[+] 		writeLog(SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));
[-] 		writeLog (SerialLogRecordCode.ParityChanged, &parity, sizeof (parity));
[+] 		writeLog(SerialLogRecordCode.ParityChanged, &parity, sizeof(parity));
[-] 		writeLog (SerialLogRecordCode.ReadModeChanged, &mode, sizeof (mode));
[+] 		writeLog(SerialLogRecordCode.ReadModeChanged, &mode, sizeof(mode));
[-] 		writeLog (SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof (readInterval));
[+] 		writeLog(SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof(readInterval));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] void SerialTapSession.restoreDefaultProperties ()
[+] void SerialTapSession.restoreDefaultProperties()
[-] 	m_serialSettingUi.restoreDefaultProperties ();
[+] 	m_serialSettingUi.restoreDefaultProperties();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] SerialTapSession.waitSerialEvents (SerialPort* port)
[+] SerialTapSession.waitSerialEvents(SerialPort* port)
[-] 	port.m_serial.wait (
[+] 	port.m_serial.wait(
[-] SerialTapSession.onSerialEvent (
[+] SerialTapSession.onSerialEvent(
[-] 		writeLog (log.StdRecordCode.Error, port.m_serial.m_ioError, port.m_serial.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, port.m_serial.m_ioError, port.m_serial.m_ioError.m_size);
[-] 		close ();
[+] 		close();
[-] 		writeLog (log.StdRecordCode.RxBufferFullLossy);
[+] 		writeLog(log.StdRecordCode.RxBufferFullLossy);
[-] 		size_t result = port.m_serial.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = port.m_serial.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (code, m_readBuffer.m_p, result);
[+] 			writeLog(code, m_readBuffer.m_p, result);
[-] 		writeLog (recordCode, params, sizeof (params));
[+] 		writeLog(recordCode, params, sizeof(params));
[-] 	waitSerialEvents (port);
[+] 	waitSerialEvents(port);
[-] SerialTapSession.onBaudRateChanged ()
[+] SerialTapSession.onBaudRateChanged()
[-] 	configurePort (m_dtePort);
[+] 	configurePort(m_dtePort);
[-] 	configurePort (m_dcePort);
[+] 	configurePort(m_dcePort);
[-] 	writeLog (SerialLogRecordCode.BaudRateChanged, &value, sizeof (value));
[+] 	writeLog(SerialLogRecordCode.BaudRateChanged, &value, sizeof(value));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] SerialTapSession.updateLineInfoValue (
[+] SerialTapSession.updateLineInfoValue(
[-] 	m_infoTable [infoId].m_value = line ? "on" : "off";
[+] 	m_infoTable[infoId].m_value = line ? "on" : "off";
[-] 	m_infoTable [infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[+] 	m_infoTable[infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_infoTable [InfoId.Dtr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dtr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Rts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Rts].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Dsr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dsr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Cts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Cts].m_isEnabled = m_state;
[-] 	updateLineInfoValue (InfoId.Dtr, m_dcePort.m_serialStatusLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dtr, m_dcePort.m_serialStatusLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Rts, m_dcePort.m_serialStatusLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Rts, m_dcePort.m_serialStatusLines & io.SerialStatusLines.Cts);
[-] 	updateLineInfoValue (InfoId.Dsr, m_dtePort.m_serialStatusLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dsr, m_dtePort.m_serialStatusLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Cts, m_dtePort.m_serialStatusLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Cts, m_dtePort.m_serialStatusLines & io.SerialStatusLines.Cts);
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\Decoder.jnc
----------------------
[-] 	construct (log.Writer* logWriter)
[+] 	construct(log.Writer* logWriter)
[-] 		m_buffer.setSize (Defaults.BufferSize);
[+] 		m_buffer.setSize(Defaults.BufferSize);
[-] 	abstract reset ();
[+] 	abstract reset();
[-] 	abstract decode (
[+] 	abstract decode(
[-] 	writeLogUnexpectedCode (
[+] 	writeLogUnexpectedCode(
[-] Decoder.writeLogUnexpectedCode (
[+] Decoder.writeLogUnexpectedCode(
[-] 	m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.UnexpectedCode, &params, sizeof (params));
[+] 	m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.UnexpectedCode, &params, sizeof(params));
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\I2cDecoder.jnc
----------------------
[-] 	construct (log.Writer* logWriter);
[+] 	construct(log.Writer* logWriter);
[-] 	override reset ()
[+] 	override reset()
[-] 	override decode (
[+] 	override decode(
[-] 	static bool isAddress10Bit (uchar_t c)
[+] 	static bool isAddress10Bit(uchar_t c)
[-] I2cDecoder.construct (log.Writer* logWriter)
[+] I2cDecoder.construct(log.Writer* logWriter)
[-] 	basetype.construct (logWriter);
[+] 	basetype.construct(logWriter);
[-] I2cDecoder.decode (
[+] I2cDecoder.decode(
[-] 	static uint64_t recordCodeTable [2] [2] =
[+] 	static uint64_t recordCodeTable[2] [2] =
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 		switch (c)
[+] 		switch(c)
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.BufferOverflow);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.BufferOverflow);
[-] 		switch (code)
[+] 		switch(code)
[-] 			size_t size = data - (uchar_t*) m_buffer.m_p;
[+] 			size_t size = data - (uchar_t*)m_buffer.m_p;
[-] 				m_logWriter.write (timestamp, recordCodeTable [m_isRead] [m_ack], m_buffer.m_p, size);
[+] 				m_logWriter.write(timestamp, recordCodeTable[m_isRead] [m_ack], m_buffer.m_p, size);
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof (uint_t));
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof(uint_t));
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
[-] 			size_t size = data - (uchar_t*) m_buffer.m_p;
[+] 			size_t size = data - (uchar_t*)m_buffer.m_p;
[-] 				m_logWriter.write (timestamp, recordCodeTable [m_isRead] [m_ack], m_buffer.m_p, size);
[+] 				m_logWriter.write(timestamp, recordCodeTable[m_isRead] [m_ack], m_buffer.m_p, size);
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cStart);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 			switch (m_addressState)
[+] 			switch(m_addressState)
[-] 				if (isAddress10Bit (m_data))
[+] 				if (isAddress10Bit(m_data))
[-] 					m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart7Bit, m_transactionHdr, sizeof (uint8_t));
[+] 					m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart7Bit, m_transactionHdr, sizeof(uint8_t));
[-] 				*(uint8_t*) m_transactionHdr = m_data;
[+] 				*(uint8_t*)m_transactionHdr = m_data;
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart10Bit, m_transactionHdr, sizeof (uint16_t));
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cFinalizeStart10Bit, m_transactionHdr, sizeof(uint16_t));
[-] 					size_t size = data - (uchar_t*) m_buffer.m_p;
[+] 					size_t size = data - (uchar_t*)m_buffer.m_p;
[-] 						m_logWriter.write (timestamp, recordCodeTable [m_isRead] [m_ack], m_buffer.m_p, size);
[+] 						m_logWriter.write(timestamp, recordCodeTable[m_isRead] [m_ack], m_buffer.m_p, size);
[-] 				size_t size = data - (uchar_t*) m_buffer.m_p;
[+] 				size_t size = data - (uchar_t*)m_buffer.m_p;
[-] 					m_logWriter.write (timestamp, recordCodeTable [m_isRead] [m_ack], m_buffer.m_p, size);
[+] 					m_logWriter.write(timestamp, recordCodeTable[m_isRead] [m_ack], m_buffer.m_p, size);
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
[-] 			size_t size = data - (uchar_t*) m_buffer.m_p;
[+] 			size_t size = data - (uchar_t*)m_buffer.m_p;
[-] 				m_logWriter.write (timestamp, recordCodeTable [m_isRead] [m_ack], m_buffer.m_p, size);
[+] 				m_logWriter.write(timestamp, recordCodeTable[m_isRead] [m_ack], m_buffer.m_p, size);
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, &m_bitCount, sizeof (uint_t));
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, &m_bitCount, sizeof(uint_t));
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.I2cStop);
[-] 				m_logWriter.write (
[+] 				m_logWriter.write(
[-] 	m_size = data - (uchar_t*) m_buffer.m_p;
[+] 	m_size = data - (uchar_t*)m_buffer.m_p;
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\I2cSpiSnifferLogRepresenter.jnc
----------------------
[-] bool representI2cSpiSnifferLog (
[+] bool representI2cSpiSnifferLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ($"Sniffer device \e[34m$name\e[m opened");
[+] 		target.addHyperText($"Sniffer device \e[34m$name\e[m opened");
[-] 		target.addHyperText ($"Interface \e[34m#0\e[m claimed");
[+] 		target.addHyperText($"Interface \e[34m#0\e[m claimed");
[-] 		target.addHyperText ($"In endpoint \e[34m#86\e[m opened");
[+] 		target.addHyperText($"In endpoint \e[34m#86\e[m opened");
[-] 		target.addHyperText ($"Out endpoint \e[34m#2\e[m opened");
[+] 		target.addHyperText($"Out endpoint \e[34m#2\e[m opened");
[-] 		target.addHyperText ($"Capture started");
[+] 		target.addHyperText($"Capture started");
[-] 		target.addHyperText ("Capture stopped");
[+] 		target.addHyperText("Capture stopped");
[-] 		target.addHyperText ($"Cannot open sniffer: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open sniffer: $(error.m_description)");
[-] 		target.addHyperText ($"Unexpected code from sniffer (code: $code, decoder state: $state)");
[+] 		target.addHyperText($"Unexpected code from sniffer (code: $code, decoder state: $state)");
[-] 		target.addHyperText ($"Incomplete byte received ($(bitCount) bits)");
[+] 		target.addHyperText($"Incomplete byte received ($(bitCount) bits)");
[-] 		target.addHyperText ("FPGA buffer overflow");
[+] 		target.addHyperText("FPGA buffer overflow");
[-] 		target.addHyperText ("...still waiting...");
[+] 		target.addHyperText("...still waiting...");
[-] 		target.addHyperText ("FPGA disabled");
[+] 		target.addHyperText("FPGA disabled");
[-] 		target.addHyperText ("FPGA firmware up-to-date");
[+] 		target.addHyperText("FPGA firmware up-to-date");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 		target.addHyperText ("Erasing flash memory...");
[+] 		target.addHyperText("Erasing flash memory...");
[-] 		target.addHyperText ("Uploading FPGA firmware...");
[+] 		target.addHyperText("Uploading FPGA firmware...");
[-] 		target.addHyperText ("Enabling FPGA...");
[+] 		target.addHyperText("Enabling FPGA...");
[-] 		target.addHyperText ("FPGA ready");
[+] 		target.addHyperText("FPGA ready");
[-] 		target.addHyperText (I2cSpiSnifferLogPartCode.I2cStartBegin, "I2C \e[32mstart\e[m");
[+] 		target.addHyperText(I2cSpiSnifferLogPartCode.I2cStartBegin, "I2C \e[32mstart\e[m");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 		target.addHyperText ("I2C \e[31mstop\e[m");
[+] 		target.addHyperText("I2C \e[31mstop\e[m");
[-] 		target.addHyperText ("I2C \e[31mstop\e[m out-of-transaction");
[+] 		target.addHyperText("I2C \e[31mstop\e[m out-of-transaction");
[-] 		target.addBin (log.StdRecordCode.Tx, p, size);
[+] 		target.addBin(log.StdRecordCode.Tx, p, size);
[-] 		target.addBin (log.StdRecordCode.Rx, p, size);
[+] 		target.addBin(log.StdRecordCode.Rx, p, size);
[-] 		target.addHyperText ("SPI SS \e[32mlow\e[m");
[+] 		target.addHyperText("SPI SS \e[32mlow\e[m");
[-] 		target.addHyperText ("SPI SS \e[31mhigh\e[m");
[+] 		target.addHyperText("SPI SS \e[31mhigh\e[m");
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\I2cSpiSnifferSession.jnc
----------------------
[-] 	char const* m_statusText [] =
[+] 	char const* m_statusText[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	void stopCapture ();
[+] 	void stopCapture();
[-] 	override size_t transmit (
[+] 	override size_t transmit(
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ();
[+] 	onCapture();
[-] 	onUpdateCompleted (bool result);
[+] 	onUpdateCompleted(bool result);
[-] 	onInEndpointEvent (
[+] 	onInEndpointEvent(
[-] 	onTest ();
[+] 	onTest();
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	bool errorcode startCapture ();
[+] 	bool errorcode startCapture();
[-] I2cSpiSnifferSession.construct (doc.PluginHost* pluginHost)
[+] I2cSpiSnifferSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_uploader.construct (pluginHost);
[+] 	m_uploader.construct(pluginHost);
[-] 	m_spiDecoder.construct (pluginHost.m_log.m_writer);
[+] 	m_spiDecoder.construct(pluginHost.m_log.m_writer);
[-] 	m_i2cDecoder.construct (pluginHost.m_log.m_writer);
[+] 	m_i2cDecoder.construct(pluginHost.m_log.m_writer);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] I2cSpiSnifferSession.createUi ()
[+] I2cSpiSnifferSession.createUi()
[-] 	static gui.EnumPropertyOption protocolTable [] =
[+] 	static gui.EnumPropertyOption protocolTable[] =
[-] 	static gui.EnumPropertyOption spiModeTable [] =
[+] 	static gui.EnumPropertyOption spiModeTable[] =
[-] 	static gui.EnumPropertyOption endiannessTable [] =
[+] 	static gui.EnumPropertyOption endiannessTable[] =
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.Stop] = new gui.Icon ("images/stop.png");
[+] 	m_iconTable[IconId.Stop] = new gui.Icon("images/stop.png");
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Sniffer:");
[+] 	m_pluginHost.m_toolBar.addLabel("Sniffer:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh]  = createAction ("Re-enumerate sniffers", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh]  = createAction("Re-enumerate sniffers", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_actionTable [ActionId.Test] = createAction("Test");
[+] 	m_actionTable[ActionId.Test] = createAction("Test");
[-] 	m_actionTable [ActionId.Test].m_onTriggered += onTest;
[+] 	m_actionTable[ActionId.Test].m_onTriggered += onTest;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_protocolProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_protocolProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (protocolTable)
[+] 		countof(protocolTable)
[-] 	m_spiModeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_spiModeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (spiModeTable)
[+] 		countof(spiModeTable)
[-] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (endiannessTable)
[+] 		countof(endiannessTable)
[-] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_showI2cStopProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_showI2cStopProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_showRawDataProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_showRawDataProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid,,, ids);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid,,, ids);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("USB connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("USB connection");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] I2cSpiSnifferSession.onCapture ()
[+] I2cSpiSnifferSession.onCapture()
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		try capture ();
[+] 		try capture();
[-] I2cSpiSnifferSession.onUpdateCompleted (bool result)
[+] I2cSpiSnifferSession.onUpdateCompleted(bool result)
[-] 		try startCapture ();
[+] 		try startCapture();
[-] 		stopCapture ();
[+] 		stopCapture();
[-] I2cSpiSnifferSession.onTest ()
[+] I2cSpiSnifferSession.onTest()
[-] 	static char const data1 [] =
[+] 	static char const data1[] =
[-] 	m_decoder.decode (data1, sizeof (data1));
[+] 	m_decoder.decode(data1, sizeof(data1));
[-] size_t I2cSpiSnifferSession.transmit (
[+] size_t I2cSpiSnifferSession.transmit(
[-] 		writeLog (log.StdRecordCode.Bin, p, size);
[+] 		writeLog(log.StdRecordCode.Bin, p, size);
[-] 	m_decoder.reset ();
[+] 	m_decoder.reset();
[-] 	m_decoder.decode (p, size);
[+] 	m_decoder.decode(p, size);
[-] I2cSpiSnifferSession.enumerateDevices ()
[+] I2cSpiSnifferSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [i].m_text = text;
[+] 		optionTable[i].m_text = text;
[-] 		optionTable [i].m_value = device;
[+] 		optionTable[i].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, count);
[+] 	m_deviceProp.setOptions(optionTable, count);
[-] bool errorcode I2cSpiSnifferSession.capture ()
[+] bool errorcode I2cSpiSnifferSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	writeLogString (I2cSpiSnifferLogRecordCode.DeviceOpened, m_deviceCombo.m_currentText);
[+] 	writeLogString(I2cSpiSnifferLogRecordCode.DeviceOpened, m_deviceCombo.m_currentText);
[-] 	return m_uploader.update (m_device, m_protocolProp.m_value);
[+] 	return m_uploader.update(m_device, m_protocolProp.m_value);
[-] 	writeLogLastError (I2cSpiSnifferLogRecordCode.CaptureError);
[+] 	writeLogLastError(I2cSpiSnifferLogRecordCode.CaptureError);
[-] bool errorcode I2cSpiSnifferSession.startCapture ()
[+] bool errorcode I2cSpiSnifferSession.startCapture()
[-] 	m_iface = m_device.claimInterface (0);
[+] 	m_iface = m_device.claimInterface(0);
[-] 	writeLog (I2cSpiSnifferLogRecordCode.InterfaceClaimed);
[+] 	writeLog(I2cSpiSnifferLogRecordCode.InterfaceClaimed);
[-] 	m_outEndpoint = m_iface.openEndpoint (UsbEndpoint.Out);
[+] 	m_outEndpoint = m_iface.openEndpoint(UsbEndpoint.Out);
[-] 	writeLog (I2cSpiSnifferLogRecordCode.OutEndpointOpened);
[+] 	writeLog(I2cSpiSnifferLogRecordCode.OutEndpointOpened);
[-] 	m_inEndpoint = m_iface.openEndpoint (UsbEndpoint.In);
[+] 	m_inEndpoint = m_iface.openEndpoint(UsbEndpoint.In);
[-] 	writeLog (I2cSpiSnifferLogRecordCode.InEndpointOpened);
[+] 	writeLog(I2cSpiSnifferLogRecordCode.InEndpointOpened);
[-] 	switch (m_protocolProp.m_value)
[+] 	switch(m_protocolProp.m_value)
[-] 	m_decoder.reset ();
[+] 	m_decoder.reset();
[-] 	m_outEndpoint.write (&startCode, sizeof (startCode));
[+] 	m_outEndpoint.write(&startCode, sizeof(startCode));
[-] 	writeLog (I2cSpiSnifferLogRecordCode.CaptureStarted);
[+] 	writeLog(I2cSpiSnifferLogRecordCode.CaptureStarted);
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	writeLogLastError (I2cSpiSnifferLogRecordCode.CaptureError);
[+] 	writeLogLastError(I2cSpiSnifferLogRecordCode.CaptureError);
[-] I2cSpiSnifferSession.stopCapture ()
[+] I2cSpiSnifferSession.stopCapture()
[-] 		try m_outEndpoint.write (&stopCode, sizeof (stopCode));
[+] 		try m_outEndpoint.write(&stopCode, sizeof(stopCode));
[-] 		m_outEndpoint.blockingWait (io.UsbEndpointEvents.WriteCompleted);
[+] 		m_outEndpoint.blockingWait(io.UsbEndpointEvents.WriteCompleted);
[-] 		m_outEndpoint.close ();
[+] 		m_outEndpoint.close();
[-] 		m_inEndpoint.close ();
[+] 		m_inEndpoint.close();
[-] 		m_iface.release ();
[+] 		m_iface.release();
[-] 		m_device.close ();
[+] 		m_device.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		writeLog (I2cSpiSnifferLogRecordCode.CaptureStopped);
[+] 		writeLog(I2cSpiSnifferLogRecordCode.CaptureStopped);
[-] 	m_uploader.cancel ();
[+] 	m_uploader.cancel();
[-] I2cSpiSnifferSession.waitInEndpointEvents ()
[+] I2cSpiSnifferSession.waitInEndpointEvents()
[-] 	m_inEndpoint.wait (eventMask, onInEndpointEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_inEndpoint.wait(eventMask, onInEndpointEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] I2cSpiSnifferSession.onInEndpointEvent (
[+] I2cSpiSnifferSession.onInEndpointEvent(
[-] 		writeLogError (log.StdRecordCode.Error, m_inEndpoint.m_ioError);
[+] 		writeLogError(log.StdRecordCode.Error, m_inEndpoint.m_ioError);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		size_t size = m_inEndpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t size = m_inEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 		m_stdSessionInfoSet.addRxData (size);
[+] 		m_stdSessionInfoSet.addRxData(size);
[-] 			writeLog (log.StdRecordCode.Bin, m_readBuffer.m_p, size);
[+] 			writeLog(log.StdRecordCode.Bin, m_readBuffer.m_p, size);
[-] 		m_decoder.decode (m_readBuffer.m_p, size);
[+] 		m_decoder.decode(m_readBuffer.m_p, size);
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] I2cSpiSnifferSession.load (doc.Storage* storage)
[+] I2cSpiSnifferSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_protocolProp.m_value = storage.readInt ("protocol", Defaults.Proto);
[+] 	m_protocolProp.m_value = storage.readInt("protocol", Defaults.Proto);
[-] 	m_spiModeProp.m_value = storage.readInt ("spiMode", Defaults.SpiMode);
[+] 	m_spiModeProp.m_value = storage.readInt("spiMode", Defaults.SpiMode);
[-] 	m_endiannessProp.m_value = storage.readInt ("endianness", Defaults.Endianness);
[+] 	m_endiannessProp.m_value = storage.readInt("endianness", Defaults.Endianness);
[-] 	m_dataBitsProp.m_value = storage.readInt ("dataBits", Defaults.DataBits);
[+] 	m_dataBitsProp.m_value = storage.readInt("dataBits", Defaults.DataBits);
[-] 	m_showI2cStopProp.m_value = storage.readBool ("showI2cStop", Defaults.ShowI2cStop);
[+] 	m_showI2cStopProp.m_value = storage.readBool("showI2cStop", Defaults.ShowI2cStop);
[-] 	m_showRawDataProp.m_value = storage.readBool ("showRawData", Defaults.ShowRawData);
[+] 	m_showRawDataProp.m_value = storage.readBool("showRawData", Defaults.ShowRawData);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] I2cSpiSnifferSession.save (doc.Storage* storage)
[+] I2cSpiSnifferSession.save(doc.Storage* storage)
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeInt ("protocol", m_protocolProp.m_value);
[+] 	storage.writeInt("protocol", m_protocolProp.m_value);
[-] 	storage.writeInt ("spiMode", m_spiModeProp.m_value);
[+] 	storage.writeInt("spiMode", m_spiModeProp.m_value);
[-] 	storage.writeInt ("endianness", m_endiannessProp.m_value);
[+] 	storage.writeInt("endianness", m_endiannessProp.m_value);
[-] 	storage.writeInt ("dataBits", m_dataBitsProp.m_value);
[+] 	storage.writeInt("dataBits", m_dataBitsProp.m_value);
[-] 	storage.writeBool ("showI2cStop", m_showI2cStopProp.m_value);
[+] 	storage.writeBool("showI2cStop", m_showI2cStopProp.m_value);
[-] 	storage.writeBool ("showRawData", m_showRawDataProp.m_value);
[+] 	storage.writeBool("showRawData", m_showRawDataProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] I2cSpiSnifferSession.updateProperties ()
[+] I2cSpiSnifferSession.updateProperties()
[-] bool errorcode I2cSpiSnifferSession.applyProperties ()
[+] bool errorcode I2cSpiSnifferSession.applyProperties()
[-] 	m_readBuffer.detach (); // drop buffer, so we re-allocate each time
[+] 	m_readBuffer.detach(); // drop buffer, so we re-allocate each time
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] I2cSpiSnifferSession.restoreDefaultProperties ()
[+] I2cSpiSnifferSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Close Device" : "Open Device";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Close Device" : "Open Device";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.Stop : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.Stop : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_statusText [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_statusText[m_state];
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\Protocol.jnc
----------------------
[-] static char const* const g_protocolNameTable [] =
[+] static char const* const g_protocolNameTable[] =
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\SpiDecoder.jnc
----------------------
[-] 	construct (log.Writer* logWriter);
[+] 	construct(log.Writer* logWriter);
[-] 	override reset ()
[+] 	override reset()
[-] 	override decode (
[+] 	override decode(
[-] SpiDecoder.construct (log.Writer* logWriter)
[+] SpiDecoder.construct(log.Writer* logWriter)
[-] 	basetype.construct (logWriter);
[+] 	basetype.construct(logWriter);
[-] 	m_misoBuffer.setSize (m_buffer.m_size / 2);
[+] 	m_misoBuffer.setSize(m_buffer.m_size / 2);
[-] SpiDecoder.decode (
[+] SpiDecoder.decode(
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 		switch (c)
[+] 		switch(c)
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.BufferOverflow);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.BufferOverflow);
[-] 		switch (code)
[+] 		switch(code)
[-] 			size_t size = mosi - (uchar_t*) m_buffer.m_p;
[+] 			size_t size = mosi - (uchar_t*)m_buffer.m_p;
[-] 				memcpy (m_buffer.m_p + size, m_misoBuffer.m_p, size);
[+] 				memcpy(m_buffer.m_p + size, m_misoBuffer.m_p, size);
[-] 				m_logWriter.write (timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[+] 				m_logWriter.write(timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof (uint_t));
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof(uint_t));
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.SpiStart, null, 0);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.SpiStart, null, 0);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 				writeLogUnexpectedCode (timestamp, code, m_state);
[+] 				writeLogUnexpectedCode(timestamp, code, m_state);
[-] 				size_t size = mosi - (uchar_t*) m_buffer.m_p;
[+] 				size_t size = mosi - (uchar_t*)m_buffer.m_p;
[-] 				memcpy (m_buffer.m_p + size, m_misoBuffer.m_p, size);
[+] 				memcpy(m_buffer.m_p + size, m_misoBuffer.m_p, size);
[-] 				m_logWriter.write (timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[+] 				m_logWriter.write(timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[-] 			size_t size = mosi - (uchar_t*) m_buffer.m_p;
[+] 			size_t size = mosi - (uchar_t*)m_buffer.m_p;
[-] 				memcpy (m_buffer.m_p + size, m_misoBuffer.m_p, size);
[+] 				memcpy(m_buffer.m_p + size, m_misoBuffer.m_p, size);
[-] 				m_logWriter.write (timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[+] 				m_logWriter.write(timestamp, log.StdRecordCode.TxRx, m_buffer.m_p, 2 * size);
[-] 				m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof (uint_t));
[+] 				m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.IncompleteByte, m_bitCount, sizeof(uint_t));
[-] 			m_logWriter.write (timestamp, I2cSpiSnifferLogRecordCode.SpiStop, null, 0);
[+] 			m_logWriter.write(timestamp, I2cSpiSnifferLogRecordCode.SpiStop, null, 0);
[-] 	m_size = mosi - (uchar_t*) m_buffer.m_p;
[+] 	m_size = mosi - (uchar_t*)m_buffer.m_p;
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\I2cSpiSniffer\Uploader.jnc
----------------------
[-] 	char m_tag [0x4c];
[+] 	char m_tag[0x4c];
[-] 	bool isValid () const
[+] 	bool isValid() const
[-] 	char const* getId () const
[+] 	char const* getId() const
[-] 	uint_t getVersion () const
[+] 	uint_t getVersion() const
[-] 		char const* p = memchr (m_tag, 0, countof (m_tag));
[+] 		char const* p = memchr(m_tag, 0, countof(m_tag));
[-] 		return p ? parseVersion (p + 1) : 0;
[+] 		return p ? parseVersion(p + 1) : 0;
[-] 	static char const* const m_firmwareIdTable [] =
[+] 	static char const* const m_firmwareIdTable[] =
[-] 	static char const* const m_firmwareFileNameTable [] =
[+] 	static char const* const m_firmwareFileNameTable[] =
[-] 	event m_onUpdateCompleted (bool result);
[+] 	event m_onUpdateCompleted(bool result);
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	cancel ();
[+] 	cancel();
[-] 	bool errorcode update (
[+] 	bool errorcode update(
[-] 	bool errorcode enableFpga ();
[+] 	bool errorcode enableFpga();
[-] 	bool errorcode eraseNextFlashSector ();
[+] 	bool errorcode eraseNextFlashSector();
[-] 	bool errorcode sendNextBlock ();
[+] 	bool errorcode sendNextBlock();
[-] 	bool checkStatus (UsbControlReqCode code);
[+] 	bool checkStatus(UsbControlReqCode code);
[-] 	onFlashStatusTimer (uint_t syncId);
[+] 	onFlashStatusTimer(uint_t syncId);
[-] 	onFpgaStatusTimer (uint_t syncId);
[+] 	onFpgaStatusTimer(uint_t syncId);
[-] 	onProgressDlgButtonClicked (gui.StdDlgButton button);
[+] 	onProgressDlgButtonClicked(gui.StdDlgButton button);
[-] 	onTransferCompleted (
[+] 	onTransferCompleted(
[-] Uploader.construct (doc.PluginHost* pluginHost)
[+] Uploader.construct(doc.PluginHost* pluginHost)
[-] Uploader.cancel ()
[+] Uploader.cancel()
[-] 	m_progressDlg.hide ();
[+] 	m_progressDlg.hide();
[-] 	m_timer.stop ();
[+] 	m_timer.stop();
[-] 	m_onUpdateCompleted (false);
[+] 	m_onUpdateCompleted(false);
[-] bool errorcode Uploader.update (
[+] bool errorcode Uploader.update(
[-] 	cancel ();
[+] 	cancel();
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 	m_logWriter.write (I2cSpiSnifferLogRecordCode.FpgaDisabled);
[+] 	m_logWriter.write(I2cSpiSnifferLogRecordCode.FpgaDisabled);
[-] 	char const* fileName = m_firmwareFileNameTable [m_protocol];
[+] 	char const* fileName = m_firmwareFileNameTable[m_protocol];
[-] 	m_firmwareFile.open (fileName, io.FileOpenFlags.ReadOnly);
[+] 	m_firmwareFile.open(fileName, io.FileOpenFlags.ReadOnly);
[-] 	LatticeHdr const* fileHdr = (LatticeHdr const*) m_firmwareFile.view (0, sizeof (LatticeHdr));
[+] 	LatticeHdr const* fileHdr = (LatticeHdr const*) m_firmwareFile.view(0, sizeof(LatticeHdr));
[-] 	uint_t fileVersion = fileHdr.getVersion ();;
[+] 	uint_t fileVersion = fileHdr.getVersion();;
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 		sizeof (deviceHdr)
[+] 		sizeof(deviceHdr)
[-] 		deviceHdr.isValid () &&
[+] 		deviceHdr.isValid() &&
[-] 		strcmp (deviceHdr.getId (), fileHdr.getId ()) == 0 &&
[+] 		strcmp(deviceHdr.getId(), fileHdr.getId()) == 0 &&
[-] 		deviceHdr.getVersion () >= fileVersion;
[+] 		deviceHdr.getVersion() >= fileVersion;
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.FirmwareUpToDate);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.FirmwareUpToDate);
[-] 		enableFpga ();
[+] 		enableFpga();
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.FirmwareUpdateRequired, params, dynamic sizeof (params));
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.FirmwareUpdateRequired, params, dynamic sizeof(params));
[-] 		m_progressDlg.show ();
[+] 		m_progressDlg.show();
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.ErasingFlash);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.ErasingFlash);
[-] 		eraseNextFlashSector ();
[+] 		eraseNextFlashSector();
[-] 		m_timer.startPeriodicTimer (
[+] 		m_timer.startPeriodicTimer(
[-] bool errorcode Uploader.enableFpga ()
[+] bool errorcode Uploader.enableFpga()
[-] 	m_logWriter.write (I2cSpiSnifferLogRecordCode.EnablingFpga);
[+] 	m_logWriter.write(I2cSpiSnifferLogRecordCode.EnablingFpga);
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 	m_timer.startPeriodicTimer (
[+] 	m_timer.startPeriodicTimer(
[-] bool errorcode Uploader.eraseNextFlashSector ()
[+] bool errorcode Uploader.eraseNextFlashSector()
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] bool errorcode Uploader.sendNextBlock ()
[+] bool errorcode Uploader.sendNextBlock()
[-] 	void const* p = m_firmwareFile.view (m_offset, size);
[+] 	void const* p = m_firmwareFile.view(m_offset, size);
[-] 	m_block.setSize (size);
[+] 	m_block.setSize(size);
[-] 	memcpy (m_block.m_p, p, size);
[+] 	memcpy(m_block.m_p, p, size);
[-] 		return enableFpga ();
[+] 		return enableFpga();
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] bool Uploader.checkStatus (UsbControlReqCode code)
[+] bool Uploader.checkStatus(UsbControlReqCode code)
[-] 	try m_device.controlTransfer (
[+] 	try m_device.controlTransfer(
[-] 		sizeof (status)
[+] 		sizeof(status)
[-] Uploader.onFlashStatusTimer (uint_t syncId)
[+] Uploader.onFlashStatusTimer(uint_t syncId)
[-] 	bool result = checkStatus (UsbControlReqCode.GetFlashStatus);
[+] 	bool result = checkStatus(UsbControlReqCode.GetFlashStatus);
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.StillWaiting);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.StillWaiting);
[-] 		eraseNextFlashSector ();
[+] 		eraseNextFlashSector();
[-] 		m_timer.stop ();
[+] 		m_timer.stop();
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.UploadingFirmware);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.UploadingFirmware);
[-] 		sendNextBlock ();
[+] 		sendNextBlock();
[-] 	m_logWriter.writeLastError (log.StdRecordCode.Error);
[+] 	m_logWriter.writeLastError(log.StdRecordCode.Error);
[-] 	cancel ();
[+] 	cancel();
[-] Uploader.onFpgaStatusTimer (uint_t syncId)
[+] Uploader.onFpgaStatusTimer(uint_t syncId)
[-] 	bool result = checkStatus (UsbControlReqCode.GetFpgaStatus);
[+] 	bool result = checkStatus(UsbControlReqCode.GetFpgaStatus);
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.FpgaReady);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.FpgaReady);
[-] 		m_timer.stop ();
[+] 		m_timer.stop();
[-] 		m_progressDlg.hide ();
[+] 		m_progressDlg.hide();
[-] 		m_onUpdateCompleted (true);
[+] 		m_onUpdateCompleted(true);
[-] 		m_logWriter.write (I2cSpiSnifferLogRecordCode.StillWaiting);
[+] 		m_logWriter.write(I2cSpiSnifferLogRecordCode.StillWaiting);
[-] 		std.setError ("Can't start FPGA");
[+] 		std.setError("Can't start FPGA");
[-] 		m_logWriter.writeLastError (log.StdRecordCode.Error);
[+] 		m_logWriter.writeLastError(log.StdRecordCode.Error);
[-] 		cancel ();
[+] 		cancel();
[-] 	m_logWriter.writeLastError (log.StdRecordCode.Error);
[+] 	m_logWriter.writeLastError(log.StdRecordCode.Error);
[-] 	cancel ();
[+] 	cancel();
[-] Uploader.onProgressDlgButtonClicked (gui.StdDlgButton button)
[+] Uploader.onProgressDlgButtonClicked(gui.StdDlgButton button)
[-] 	switch (button)
[+] 	switch(button)
[-] 		cancel ();
[+] 		cancel();
[-] Uploader.onTransferCompleted (
[+] Uploader.onTransferCompleted(
[-] 		m_logWriter.writeError (log.StdRecordCode.Error, error);
[+] 		m_logWriter.writeError(log.StdRecordCode.Error, error);
[-] 		cancel ();
[+] 		cancel();
[-] 		sendNextBlock ();
[+] 		sendNextBlock();
[-] 	m_logWriter.writeLastError (log.StdRecordCode.Error);
[+] 	m_logWriter.writeLastError(log.StdRecordCode.Error);
[-] 	cancel ();
[+] 	cancel();
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Mailslot\MailslotLogRepresenter.jnc
----------------------
[-] bool representMailslotLog (
[+] bool representMailslotLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ($"Opened mailslot \e[34m$fileName");
[+] 		target.addHyperText($"Opened mailslot \e[34m$fileName");
[-] 		target.addHyperText ($"Cannot open mailslot: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open mailslot: $(error.m_description)");
[-] 		target.addHyperText ($"Mailslot closed");
[+] 		target.addHyperText($"Mailslot closed");
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Mailslot\MailslotSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	createUi ();
[+] 	createUi();
[-] 	onOpen ()
[+] 	onOpen()
[-] 		m_state ? close () : try open ();
[+] 		m_state ? close() : try open();
[-] 	onNameComboEnter ()
[+] 	onNameComboEnter()
[-] 		try open ();
[+] 		try open();
[-] 	onMailslotEvent (
[+] 	onMailslotEvent(
[-] 	io.MailslotOptions getMailslotOptions ();
[+] 	io.MailslotOptions getMailslotOptions();
[-] 	waitMailslotEvents ();
[+] 	waitMailslotEvents();
[-] MailslotSession.construct (doc.PluginHost* pluginHost)
[+] MailslotSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] MailslotSession.createUi ()
[+] MailslotSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Mailslot:");
[+] 	m_pluginHost.m_toolBar.addLabel("Mailslot:");
[-] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_actionTable [ActionId.Open] = createAction ("Open", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpen;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpen;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (
[+] 	m_bufferPropertySet.createPropertiesGrouped(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Mailslot");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Mailslot");
[-] 	m_stdSessionInfoSet.createInformationValues (
[+] 	m_stdSessionInfoSet.createInformationValues(
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode MailslotSession.open ()
[+] bool errorcode MailslotSession.open()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_nameCombo.addEditTextToHistory ();
[+] 	m_nameCombo.addEditTextToHistory();
[-] 	m_mailslot.m_options = getMailslotOptions ();
[+] 	m_mailslot.m_options = getMailslotOptions();
[-] 	m_mailslot.open (fileName);
[+] 	m_mailslot.open(fileName);
[-] 	writeLogString (MailslotLogRecordCode.Opened, fileName);
[+] 	writeLogString(MailslotLogRecordCode.Opened, fileName);
[-] 	waitMailslotEvents ();
[+] 	waitMailslotEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_mailslot.close ();
[+] 	m_mailslot.close();
[-] MailslotSession.close ()
[+] MailslotSession.close()
[-] 	writeLog (MailslotLogRecordCode.Closed);
[+] 	writeLog(MailslotLogRecordCode.Closed);
[-] 	m_mailslot.close ();
[+] 	m_mailslot.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] io.MailslotOptions MailslotSession.getMailslotOptions ()
[+] io.MailslotOptions MailslotSession.getMailslotOptions()
[-] MailslotSession.waitMailslotEvents ()
[+] MailslotSession.waitMailslotEvents()
[-] 	m_mailslot.wait (eventMask, onMailslotEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_mailslot.wait(eventMask, onMailslotEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void MailslotSession.load (doc.Storage* storage)
[+] void MailslotSession.load(doc.Storage* storage)
[-] 	m_nameCombo.loadHistory (storage, "nameHistory");
[+] 	m_nameCombo.loadHistory(storage, "nameHistory");
[-] 	m_nameCombo.m_editText = storage.readString ("name");
[+] 	m_nameCombo.m_editText = storage.readString("name");
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void MailslotSession.save (doc.Storage* storage)
[+] void MailslotSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_nameCombo.saveHistory (storage, "nameHistory");
[+] 	m_nameCombo.saveHistory(storage, "nameHistory");
[-] 	storage.writeString ("name", m_nameCombo.m_editText);
[+] 	storage.writeString("name", m_nameCombo.m_editText);
[-] void MailslotSession.updateProperties ()
[+] void MailslotSession.updateProperties()
[-] bool errorcode MailslotSession.applyProperties ()
[+] bool errorcode MailslotSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_mailslot.m_options = getMailslotOptions ();
[+] 	m_mailslot.m_options = getMailslotOptions();
[-] void MailslotSession.restoreDefaultProperties ()
[+] void MailslotSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] MailslotSession.onMailslotEvent (
[+] MailslotSession.onMailslotEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_mailslot.m_ioError, m_mailslot.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_mailslot.m_ioError, m_mailslot.m_ioError.m_size);
[-] 		close ();
[+] 		close();
[-] 		size_t result = m_mailslot.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_mailslot.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitMailslotEvents ();
[+] 	waitMailslotEvents();
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close" : "Open";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close" : "Open";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\MailslotMon\MailslotMonitor.jnc
----------------------
[-] 	construct (MailslotMonSession* session);
[+] 	construct(MailslotMonSession* session);
[-] 	override processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	override processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr);
[-] 	override processError (std.Error const* error);
[+] 	override processError(std.Error const* error);
[-] 	setFileId (
[+] 	setFileId(
[-] MailslotMonitor.construct (MailslotMonSession* session)
[+] MailslotMonitor.construct(MailslotMonSession* session)
[-] 	basetype.construct (session.m_pluginHost);
[+] 	basetype.construct(session.m_pluginHost);
[-] MailslotMonitor.setFileId (
[+] MailslotMonitor.setFileId(
[-] 	uint32_t fileId = m_fileIdMgr.getHiFileId (loFileId);
[+] 	uint32_t fileId = m_fileIdMgr.getHiFileId(loFileId);
[-] 		uint32_t ids [] = { fileId, processId }
[+] 		uint32_t ids[] = { fileId, processId }
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, MailslotMonLogRecordCode.FileIdChanged, ids, sizeof (ids));
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, MailslotMonLogRecordCode.FileIdChanged, ids, sizeof(ids));
[-] MailslotMonitor.processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr)
[+] MailslotMonitor.processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr)
[-] 	switch (notifyHdr.m_code)
[+] 	switch(notifyHdr.m_code)
[-] 			uint32_t fileId = m_fileIdMgr.getHiFileId (params.m_fileId);
[+] 			uint32_t fileId = m_fileIdMgr.getHiFileId(params.m_fileId);
[-] 			logParams.append (&fileId, sizeof (fileId));
[+] 			logParams.append(&fileId, sizeof(fileId));
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			error.m_size = sizeof (error);
[+] 			error.m_size = sizeof(error);
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			logParams.append (&error, error.m_size);
[+] 			logParams.append(&error, error.m_size);
[-] 		name.copy ((utf16_t const*) (params + 1));
[+] 		name.copy((utf16_t const*) (params + 1));
[-] 		logParams.append (name.m_sz, name.m_length + 1);
[+] 		logParams.append(name.m_sz, name.m_length + 1);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 			uint32_t fileId = m_fileIdMgr.getHiFileId (params.m_fileId);
[+] 			uint32_t fileId = m_fileIdMgr.getHiFileId(params.m_fileId);
[-] 			logParams.append (&fileId, sizeof (fileId));
[+] 			logParams.append(&fileId, sizeof(fileId));
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			error.m_size = sizeof (error);
[+] 			error.m_size = sizeof(error);
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			logParams.append (&error, error.m_size);
[+] 			logParams.append(&error, error.m_size);
[-] 		name.copy ((utf16_t const*) (params + 1));
[+] 		name.copy((utf16_t const*) (params + 1));
[-] 		logParams.append (name.m_sz, name.m_length + 1);
[+] 		logParams.append(name.m_sz, name.m_length + 1);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		setFileId (notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[+] 		setFileId(notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[-] 		m_fileIdMgr.removeLowFileId (params.m_fileId);
[+] 		m_fileIdMgr.removeLowFileId(params.m_fileId);
[-] 		m_pluginHost.m_log.m_writer.write (notifyHdr.m_timestamp, MailslotMonLogRecordCode.FileClosed);
[+] 		m_pluginHost.m_log.m_writer.write(notifyHdr.m_timestamp, MailslotMonLogRecordCode.FileClosed);
[-] 		setFileId (notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[+] 		setFileId(notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] MailslotMonitor.processError (std.Error const* error)
[+] MailslotMonitor.processError(std.Error const* error)
[-] 	m_pluginHost.m_log.m_writer.write (log.StdRecordCode.Error, error, error.m_size);
[+] 	m_pluginHost.m_log.m_writer.write(log.StdRecordCode.Error, error, error.m_size);
[-] 	m_session.close ();
[+] 	m_session.close();
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\MailslotMon\MailslotMonLogRepresenter.jnc
----------------------
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* name = (char const*) (p + sizeof (fileId));
[+] 		char const* name = (char const*) (p + sizeof(fileId));
[-] 		target.addHyperText ($"File \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[+] 		target.addHyperText($"File \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[-] 		char const* name = (char const*) (p + sizeof (fileId) + sizeof (pid));
[+] 		char const* name = (char const*) (p + sizeof(fileId) + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[-] 		target.addHyperText ($"Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[-] 		std.Error const* error = (std.Error const*) (p + sizeof (pid));
[+] 		std.Error const* error = (std.Error const*) (p + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m: Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m: Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[-] 		char const* name = (char const*) (p + sizeof (fileId));
[+] 		char const* name = (char const*) (p + sizeof(fileId));
[-] 		target.addHyperText ($"File \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[+] 		target.addHyperText($"File \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[-] 		char const* name = (char const*) (p + sizeof (fileId) + sizeof (pid));
[+] 		char const* name = (char const*) (p + sizeof(fileId) + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[-] 		target.addHyperText ($"Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[-] 		std.Error const* error = (std.Error const*) (p + sizeof (pid));
[+] 		std.Error const* error = (std.Error const*) (p + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m: Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m: Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[-] 		target.addHyperText (MailslotMonLogPartCode.Suffix, "File closed");
[+] 		target.addHyperText(MailslotMonLogPartCode.Suffix, "File closed");
[-] 		target.addHyperText (MailslotMonLogPartCode.Prefix, $"File \e[34m#$fileId\e[m: ");
[+] 		target.addHyperText(MailslotMonLogPartCode.Prefix, $"File \e[34m#$fileId\e[m: ");
[-] 		target.addHyperText (MailslotMonLogPartCode.Prefix, $"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: ");
[+] 		target.addHyperText(MailslotMonLogPartCode.Prefix, $"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: ");
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\MailslotMon\MailslotMonSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? close () : try capture ();
[+] 		m_state ? close() : try capture();
[-] 	onNameComboEnter ()
[+] 	onNameComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	createUi ();
[+] 	createUi();
[-] MailslotMonSession.construct (doc.PluginHost* pluginHost)
[+] MailslotMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_msfsMonitor.construct (this);
[+] 	m_msfsMonitor.construct(this);
[-] 	m_lanmanMonitor.construct (this);
[+] 	m_lanmanMonitor.construct(this);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] MailslotMonSession.createUi ()
[+] MailslotMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Name filter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Name filter:");
[-] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_useLanmanMonitorProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_useLanmanMonitorProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Mailslot monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Mailslot monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (
[+] 	m_stdSessionInfoSet.createInformationValues(
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode MailslotMonSession.capture ()
[+] bool errorcode MailslotMonSession.capture()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_nameCombo.addEditTextToHistory ();
[+] 	m_nameCombo.addEditTextToHistory();
[-] 	m_msfsMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_msfsMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 	m_msfsMonitor.capture (r"\device\mailslot", name);
[+] 	m_msfsMonitor.capture(r"\device\mailslot", name);
[-] 		m_lanmanMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 		m_lanmanMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 		m_lanmanMonitor.capture (r"\device\lanmanredirector", name);
[+] 		m_lanmanMonitor.capture(r"\device\lanmanredirector", name);
[-] 	writeLogString (DeviceMonLogRecordCode.CaptureStarted_filter, name);
[+] 	writeLogString(DeviceMonLogRecordCode.CaptureStarted_filter, name);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	m_msfsMonitor.close ();
[+] 	m_msfsMonitor.close();
[-] 	m_lanmanMonitor.close ();
[+] 	m_lanmanMonitor.close();
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] MailslotMonSession.close ()
[+] MailslotMonSession.close()
[-] 	writeLog (DeviceMonLogRecordCode.CaptureStopped);
[+] 	writeLog(DeviceMonLogRecordCode.CaptureStopped);
[-] 	m_msfsMonitor.close ();
[+] 	m_msfsMonitor.close();
[-] 	m_lanmanMonitor.close ();
[+] 	m_lanmanMonitor.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void MailslotMonSession.load (doc.Storage* storage)
[+] void MailslotMonSession.load(doc.Storage* storage)
[-] 	m_nameCombo.loadHistory (storage, "nameHistory");
[+] 	m_nameCombo.loadHistory(storage, "nameHistory");
[-] 	m_nameCombo.m_editText = storage.readString ("name");
[+] 	m_nameCombo.m_editText = storage.readString("name");
[-] 	m_useLanmanMonitorProp.m_value = storage.readString ("useLanmanMonitor");
[+] 	m_useLanmanMonitorProp.m_value = storage.readString("useLanmanMonitor");
[-] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt ("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[+] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_msfsMonitor.setReadBufferSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_msfsMonitor.setReadBufferSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_lanmanMonitor.setReadBufferSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_lanmanMonitor.setReadBufferSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void MailslotMonSession.save (doc.Storage* storage)
[+] void MailslotMonSession.save(doc.Storage* storage)
[-] 	m_nameCombo.saveHistory (storage, "nameHistory");
[+] 	m_nameCombo.saveHistory(storage, "nameHistory");
[-] 	storage.writeString ("name", m_nameCombo.m_currentText);
[+] 	storage.writeString("name", m_nameCombo.m_currentText);
[-] 	storage.writeBool ("useLanmanMonitor", m_useLanmanMonitorProp.m_value);
[+] 	storage.writeBool("useLanmanMonitor", m_useLanmanMonitorProp.m_value);
[-] 	storage.writeInt ("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[+] 	storage.writeInt("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void MailslotMonSession.updateProperties ()
[+] void MailslotMonSession.updateProperties()
[-] bool errorcode MailslotMonSession.applyProperties ()
[+] bool errorcode MailslotMonSession.applyProperties()
[-] 	m_msfsMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_msfsMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 	m_lanmanMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_lanmanMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] void MailslotMonSession.restoreDefaultProperties ()
[+] void MailslotMonSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusAsciiParser.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 	override parse (
[+] 	override parse(
[-] 	override reset ();
[+] 	override reset();
[-] 	ModbusLogRecordCode getPacketRecordCode ()
[+] 	ModbusLogRecordCode getPacketRecordCode()
[-] ModbusAsciiParser.parse (
[+] ModbusAsciiParser.parse(
[-] 	updateLastTimestamp (timestamp);
[+] 	updateLastTimestamp(timestamp);
[-] 	writer.write (timestamp, originalRecordCode, p, size);
[+] 	writer.write(timestamp, originalRecordCode, p, size);
[-] 	ModbusLogRecordCode recordCode = getPacketRecordCode ();
[+] 	ModbusLogRecordCode recordCode = getPacketRecordCode();
[-] 		switch (m_state)
[+] 		switch(m_state)
[-] 			p = memchr (p, ':', end - p);
[+] 			p = memchr(p, ':', end - p);
[-] 			m_dataBuffer.clear ();
[+] 			m_dataBuffer.clear();
[-] 			p = memchr (p, '\r', end - p);
[+] 			p = memchr(p, '\r', end - p);
[-] 				std.setError ("Missing '\\n' in Modbus ASCII frame");
[+] 				std.setError("Missing '\\n' in Modbus ASCII frame");
[-] 				writer.writeLastError (timestamp, ModbusLogRecordCode.ParseError);
[+] 				writer.writeLastError(timestamp, ModbusLogRecordCode.ParseError);
[-] 				reset ();
[+] 				reset();
[-] 			m_dataBuffer.append (adu, p - adu + 1);
[+] 			m_dataBuffer.append(adu, p - adu + 1);
[-] 			writer.write (timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[+] 			writer.write(timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[-] 				recordCode = getPacketRecordCode ();
[+] 				recordCode = getPacketRecordCode();
[-] 		m_dataBuffer.append (adu, end - adu);
[+] 		m_dataBuffer.append(adu, end - adu);
[-] 			std.setError ("Modbus ASCII frame is too big and still incomplete");
[+] 			std.setError("Modbus ASCII frame is too big and still incomplete");
[-] 			writer.writeLastError (timestamp, ModbusLogRecordCode.ParseError);
[+] 			writer.writeLastError(timestamp, ModbusLogRecordCode.ParseError);
[-] 			reset ();
[+] 			reset();
[-] ModbusAsciiParser.reset ()
[+] ModbusAsciiParser.reset()
[-] 	m_dataBuffer.clear ();
[+] 	m_dataBuffer.clear();
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLayer.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override bool convert (
[+] 	override bool convert(
[-] 	createUi ();
[+] 	createUi();
[-] 	onStreamRoleComboChanged ()
[+] 	onStreamRoleComboChanged()
[-] 		setStreamRoles (m_streamRoleCombo.m_currentData);
[+] 		setStreamRoles(m_streamRoleCombo.m_currentData);
[-] 	setStreamRoles (ModbusParserMode txMode);
[+] 	setStreamRoles(ModbusParserMode txMode);
[-] ModbusLayer.construct (doc.PluginHost* pluginHost)
[+] ModbusLayer.construct(doc.PluginHost* pluginHost)
[-] 	basetype1.construct (pluginHost);
[+] 	basetype1.construct(pluginHost);
[-] 	pluginHost.m_log.addConverter (this, &m_logGuid);
[+] 	pluginHost.m_log.addConverter(this, &m_logGuid);
[-] 	createUi ();
[+] 	createUi();
[-] ModbusLayer.createUi ()
[+] ModbusLayer.createUi()
[-] 	static gui.EnumPropertyOption protocolTable [] =
[+] 	static gui.EnumPropertyOption protocolTable[] =
[-] 	static gui.EnumPropertyOption streamRoleTable [] =
[+] 	static gui.EnumPropertyOption streamRoleTable[] =
[-] 	m_streamRoleCombo = m_pluginHost.m_toolBar.addComboBox (
[+] 	m_streamRoleCombo = m_pluginHost.m_toolBar.addComboBox(
[-] 		countof (streamRoleTable)
[+] 		countof(streamRoleTable)
[-] 	m_protocolProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_protocolProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (protocolTable)
[+] 		countof(protocolTable)
[-] 	m_streamRoleProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_streamRoleProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (streamRoleTable)
[+] 		countof(streamRoleTable)
[-] 	m_halfDuplexTimeoutProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_halfDuplexTimeoutProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] void ModbusLayer.load (doc.Storage* storage)
[+] void ModbusLayer.load(doc.Storage* storage)
[-] 	m_streamRoleCombo.m_currentData = storage.readInt ("streamRole", Def.StreamRole);
[+] 	m_streamRoleCombo.m_currentData = storage.readInt("streamRole", Def.StreamRole);
[-] 	m_protocolProp.m_value = storage.readInt ("protocol", Def.Protocol);
[+] 	m_protocolProp.m_value = storage.readInt("protocol", Def.Protocol);
[-] 	m_halfDuplexTimeoutProp.m_value = storage.readInt ("halfDuplexTimeout", Def.HalfDuplexTimeout);
[+] 	m_halfDuplexTimeoutProp.m_value = storage.readInt("halfDuplexTimeout", Def.HalfDuplexTimeout);
[-] 	applyProperties ();
[+] 	applyProperties();
[-] void ModbusLayer.save (doc.Storage* storage)
[+] void ModbusLayer.save(doc.Storage* storage)
[-] 	storage.writeInt ("streamRole", m_streamRoleCombo.m_currentData);
[+] 	storage.writeInt("streamRole", m_streamRoleCombo.m_currentData);
[-] 	storage.writeInt ("protocol", m_protocolProp.m_value);
[+] 	storage.writeInt("protocol", m_protocolProp.m_value);
[-] 	storage.writeInt ("halfDuplexTimeout", m_halfDuplexTimeoutProp.m_value);
[+] 	storage.writeInt("halfDuplexTimeout", m_halfDuplexTimeoutProp.m_value);
[-] void ModbusLayer.updateProperties ()
[+] void ModbusLayer.updateProperties()
[-] bool errorcode ModbusLayer.applyProperties ()
[+] bool errorcode ModbusLayer.applyProperties()
[-] 	m_pluginHost.m_log.suspend ();
[+] 	m_pluginHost.m_log.suspend();
[-] 		switch (m_protocolProp.m_value)
[+] 		switch(m_protocolProp.m_value)
[-] 	setStreamRoles (mode);
[+] 	setStreamRoles(mode);
[-] 	m_pluginHost.m_log.resume ();
[+] 	m_pluginHost.m_log.resume();
[-] void ModbusLayer.restoreDefaultProperties ()
[+] void ModbusLayer.restoreDefaultProperties()
[-] bool ModbusLayer.convert (
[+] bool ModbusLayer.convert(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 	parser.parse (writer, timestamp, recordCode, p, size);
[+] 	parser.parse(writer, timestamp, recordCode, p, size);
[-] void ModbusLayer.setStreamRoles (ModbusParserMode mode)
[+] void ModbusLayer.setStreamRoles(ModbusParserMode mode)
[-] 		uint64_t timeout = (uint64_t) m_halfDuplexTimeoutProp.m_value * 10000;
[+] 		uint64_t timeout = (uint64_t)m_halfDuplexTimeoutProp.m_value * 10000;
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLogRepresenter.jnc
----------------------
[-] bool representModbusLog (
[+] bool representModbusLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		representModbusRtuAdu (target, io.ModbusRole.Master, p, size, foldFlags);
[+] 		representModbusRtuAdu(target, io.ModbusRole.Master, p, size, foldFlags);
[-] 		representModbusRtuAdu (target, io.ModbusRole.Slave, p, size, foldFlags);
[+] 		representModbusRtuAdu(target, io.ModbusRole.Slave, p, size, foldFlags);
[-] 		representModbusAsciiAdu (target, io.ModbusRole.Master, p, size, foldFlags);
[+] 		representModbusAsciiAdu(target, io.ModbusRole.Master, p, size, foldFlags);
[-] 		representModbusAsciiAdu (target, io.ModbusRole.Slave, p, size, foldFlags);
[+] 		representModbusAsciiAdu(target, io.ModbusRole.Slave, p, size, foldFlags);
[-] 		representModbusTcpAdu (target, io.ModbusRole.Master, p, size, foldFlags);
[+] 		representModbusTcpAdu(target, io.ModbusRole.Master, p, size, foldFlags);
[-] 		representModbusTcpAdu (target, io.ModbusRole.Slave, p, size, foldFlags);
[+] 		representModbusTcpAdu(target, io.ModbusRole.Slave, p, size, foldFlags);
[-] 		target.addHyperText ($"Invalid or unsupported Modbus function: \e[31m0x%(1; 02x)/%1\e[m" (code));
[+] 		target.addHyperText($"Invalid or unsupported Modbus function: \e[31m0x%(1; 02x)/%1\e[m" (code));
[-] 		target.addHyperText ($"Modbus parse error: $(error.m_description)");
[+] 		target.addHyperText($"Modbus parse error: $(error.m_description)");
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLog_Ascii.jnc
----------------------
[-] uint8_t lrc (
[+] uint8_t lrc(
[-] representModbusAsciiAdu (
[+] representModbusAsciiAdu(
[-] 	assert (size > 3);
[+] 	assert(size > 3);
[-] 	decodeHexString (&aduBuffer, p + 1, size - 3); // exclude ':' and "\r\n"
[+] 	decodeHexString(&aduBuffer, p + 1, size - 3); // exclude ':' and "\r\n"
[-] 	uint8_t actualChecksum = aduBuffer.m_p [checksumOffset];
[+] 	uint8_t actualChecksum = aduBuffer.m_p[checksumOffset];
[-] 	uint16_t expectedChecksum = lrc (aduBuffer.m_p, checksumOffset);
[+] 	uint16_t expectedChecksum = lrc(aduBuffer.m_p, checksumOffset);
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 				getModbusPduDigest (role, pduHdr) :
[+] 				getModbusPduDigest(role, pduHdr) :
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 		representModbusPdu (
[+] 		representModbusPdu(
[-] 			1 + sizeof (io.ModbusRtuAduHdr) * 2,
[+] 			1 + sizeof(io.ModbusRtuAduHdr) * 2,
[-] 		target.addBin (p, size);
[+] 		target.addBin(p, size);
[-] 		target.retroColorize (-size, 1, attr); // :
[+] 		target.retroColorize(-size, 1, attr); // :
[-] 		target.retroColorize (-2, 2, attr);    // \r\n
[+] 		target.retroColorize(-2, 2, attr);    // \r\n
[-] 		target.retroColorize (-size + 1, sizeof (io.ModbusAsciiAduHdr), attr);
[+] 		target.retroColorize(-size + 1, sizeof(io.ModbusAsciiAduHdr), attr);
[-] 		target.retroColorize (-4, 2, attr); // LRC8 (hex)
[+] 		target.retroColorize(-4, 2, attr); // LRC8 (hex)
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLog_Pdu.jnc
----------------------
[-] char const* getModbusCoilsDigest (
[+] char const* getModbusCoilsDigest(
[-] 	switch (count)
[+] 	switch(count)
[-] 	digest.append ("{");
[+] 	digest.append("{");
[-] 		digest.append ($" \e[34m$value\e[m");
[+] 		digest.append($" \e[34m$value\e[m");
[-] 		digest.append (" ...");
[+] 		digest.append(" ...");
[-] 	digest.append (" }");
[+] 	digest.append(" }");
[-] 	return digest.detachString ();
[+] 	return digest.detachString();
[-] representModbusCoils (
[+] representModbusCoils(
[-] 	switch (count)
[+] 	switch(count)
[-] 		target.addHyperText ("    Value:     [\e[31mNONE\e[m]");
[+] 		target.addHyperText("    Value:     [\e[31mNONE\e[m]");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			sizeof (uint8_t) * offsetMultiplier,
[+] 			sizeof(uint8_t)* offsetMultiplier,
[-] 		target.addHyperText ($"    [\e^-2\e[34m-\e[m] Values [$count]");
[+] 		target.addHyperText($"    [\e^-2\e[34m-\e[m] Values [$count]");
[-] 		representModbusCoilValues (target, p, count, baseOffset, offsetMultiplier);
[+] 		representModbusCoilValues(target, p, count, baseOffset, offsetMultiplier);
[-] 		target.addHyperText ($"    [\e^+2\e[34m+\e[m] Values [$count]");
[+] 		target.addHyperText($"    [\e^+2\e[34m+\e[m] Values [$count]");
[-] 		target.addHyperText ($"        $(getModbusCoilsDigest (p, count))");
[+] 		target.addHyperText($"        $(getModbusCoilsDigest (p, count))");
[-] size_t getDecimalLength (uint8_t n)
[+] size_t getDecimalLength(uint8_t n)
[-] representModbusCoilValues (
[+] representModbusCoilValues(
[-] 	char padding [] = "        ";
[+] 	char padding[] = "        ";
[-] 	size_t basePaddingLength = getDecimalLength (count - 1) + 1;
[+] 	size_t basePaddingLength = getDecimalLength(count - 1) + 1;
[-] 		uint8_t c = p [j];
[+] 		uint8_t c = p[j];
[-] 			size_t indexLength = getDecimalLength (i);
[+] 			size_t indexLength = getDecimalLength(i);
[-] 			padding [basePaddingLength - indexLength] = 0;
[+] 			padding[basePaddingLength - indexLength] = 0;
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				sizeof (uint8_t) * offsetMultiplier,
[+] 				sizeof(uint8_t)* offsetMultiplier,
[-] char const* getModbusRegistersDigest (
[+] char const* getModbusRegistersDigest(
[-] 	switch (count)
[+] 	switch(count)
[-] 	digest.append ($"{");
[+] 	digest.append($"{");
[-] 		uint16_t value = p [i];
[+] 		uint16_t value = p[i];
[-] 		digest.append ($" \e[34m$value\e[m");
[+] 		digest.append($" \e[34m$value\e[m");
[-] 		digest.append (" ...");
[+] 		digest.append(" ...");
[-] 	digest.append (" }");
[+] 	digest.append(" }");
[-] 	return digest.detachString ();
[+] 	return digest.detachString();
[-] representModbusRegisters (
[+] representModbusRegisters(
[-] 	switch (count)
[+] 	switch(count)
[-] 		target.addHyperText ("    Value:     [\e[31mNONE\e[m]");
[+] 		target.addHyperText("    Value:     [\e[31mNONE\e[m]");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			sizeof (uint16_t) * offsetMultiplier,
[+] 			sizeof(uint16_t)* offsetMultiplier,
[-] 			p [0]
[+] 			p[0]
[-] 		target.addHyperText ($"    [\e^-2\e[34m-\e[m] Values [$count]");
[+] 		target.addHyperText($"    [\e^-2\e[34m-\e[m] Values [$count]");
[-] 		representModbusRegisterValues (target, p, count, baseOffset, offsetMultiplier);
[+] 		representModbusRegisterValues(target, p, count, baseOffset, offsetMultiplier);
[-] 		target.addHyperText ($"    [\e^+2\e[34m+\e[m] Values [$count]");
[+] 		target.addHyperText($"    [\e^+2\e[34m+\e[m] Values [$count]");
[-] 		target.addHyperText ($"        $(getModbusRegistersDigest (p, count))");
[+] 		target.addHyperText($"        $(getModbusRegistersDigest (p, count))");
[-] representModbusRegisterValues (
[+] representModbusRegisterValues(
[-] 	char padding [] = "        ";
[+] 	char padding[] = "        ";
[-] 	size_t basePaddingLength = getDecimalLength (count - 1) + 1;
[+] 	size_t basePaddingLength = getDecimalLength(count - 1) + 1;
[-] 		size_t indexLength = getDecimalLength (i);
[+] 		size_t indexLength = getDecimalLength(i);
[-] 		padding [basePaddingLength - indexLength] = 0;
[+] 		padding[basePaddingLength - indexLength] = 0;
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			baseOffset + i * sizeof (uint16_t) * offsetMultiplier,
[+] 			baseOffset + i * sizeof(uint16_t)* offsetMultiplier,
[-] 			sizeof (uint16_t) * offsetMultiplier,
[+] 			sizeof(uint16_t)* offsetMultiplier,
[-] 			p [i]
[+] 			p[i]
[-] char const* formatModbusFuncDescription (
[+] char const* formatModbusFuncDescription(
[-] 			io.getModbusFuncString ((io.ModbusFunc) (func & ~io.ModbusFunc.ExceptionFlag))
[+] 			io.getModbusFuncString((io.ModbusFunc) (func & ~io.ModbusFunc.ExceptionFlag))
[-] 			io.getModbusFuncString (func),
[+] 			io.getModbusFuncString(func),
[-] representModbusPdu (
[+] representModbusPdu(
[-] 	target.addHyperText (
[+] 	target.addHyperText(
[-] 		baseOffset + offsetof (hdr.m_func) * offsetMultiplier,
[+] 		baseOffset + offsetof(hdr.m_func) * offsetMultiplier,
[-] 		sizeof (hdr.m_func) * offsetMultiplier,
[+] 		sizeof(hdr.m_func) * offsetMultiplier,
[-] 		formatModbusFuncDescription (role, hdr.m_func)
[+] 		formatModbusFuncDescription(role, hdr.m_func)
[-] 	switch (hdr.m_func)
[+] 	switch(hdr.m_func)
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_address) * offsetMultiplier,
[-] 				sizeof (pdu.m_address) * offsetMultiplier,
[+] 				sizeof(pdu.m_address) * offsetMultiplier,
[-] 				baseOffset + offsetof (pdu.m_count) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_count) * offsetMultiplier,
[-] 				sizeof (pdu.m_count) * offsetMultiplier,
[+] 				sizeof(pdu.m_count) * offsetMultiplier,
[-] 				target.addHyperText (
[+] 				target.addHyperText(
[-] 					baseOffset + offsetof (pdu.m_size) * offsetMultiplier,
[+] 					baseOffset + offsetof(pdu.m_size) * offsetMultiplier,
[-] 					sizeof (pdu.m_size) * offsetMultiplier,
[+] 					sizeof(pdu.m_size) * offsetMultiplier,
[-] 				representModbusCoils (
[+] 				representModbusCoils(
[-] 					baseOffset + sizeof (io.ModbusReadReplyPdu) * offsetMultiplier,
[+] 					baseOffset + sizeof(io.ModbusReadReplyPdu) * offsetMultiplier,
[-] 				target.addHyperText (
[+] 				target.addHyperText(
[-] 					baseOffset + offsetof (pdu.m_size) * offsetMultiplier,
[+] 					baseOffset + offsetof(pdu.m_size) * offsetMultiplier,
[-] 					sizeof (pdu.m_size) * offsetMultiplier,
[+] 					sizeof(pdu.m_size) * offsetMultiplier,
[-] 				representModbusRegisters (
[+] 				representModbusRegisters(
[-] 					baseOffset + sizeof (io.ModbusReadReplyPdu) * offsetMultiplier,
[+] 					baseOffset + sizeof(io.ModbusReadReplyPdu) * offsetMultiplier,
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			baseOffset + offsetof (pdu.m_address) * offsetMultiplier,
[+] 			baseOffset + offsetof(pdu.m_address) * offsetMultiplier,
[-] 			sizeof (pdu.m_address) * offsetMultiplier,
[+] 			sizeof(pdu.m_address) * offsetMultiplier,
[-] 			baseOffset + offsetof (pdu.m_value) * offsetMultiplier,
[+] 			baseOffset + offsetof(pdu.m_value) * offsetMultiplier,
[-] 			sizeof (pdu.m_value) * offsetMultiplier,
[+] 			sizeof(pdu.m_value) * offsetMultiplier,
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_address) * offsetMultiplier,
[-] 				sizeof (pdu.m_address) * offsetMultiplier,
[+] 				sizeof(pdu.m_address) * offsetMultiplier,
[-] 				baseOffset + offsetof (pdu.m_count) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_count) * offsetMultiplier,
[-] 				sizeof (pdu.m_count) * offsetMultiplier,
[+] 				sizeof(pdu.m_count) * offsetMultiplier,
[-] 				baseOffset + offsetof (pdu.m_size) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_size) * offsetMultiplier,
[-] 				sizeof (pdu.m_size) * offsetMultiplier,
[+] 				sizeof(pdu.m_size) * offsetMultiplier,
[-] 				representModbusCoils (
[+] 				representModbusCoils(
[-] 					baseOffset + sizeof (io.ModbusWriteMultiplePdu) * offsetMultiplier,
[+] 					baseOffset + sizeof(io.ModbusWriteMultiplePdu) * offsetMultiplier,
[-] 				representModbusRegisters (
[+] 				representModbusRegisters(
[-] 					baseOffset + sizeof (io.ModbusWriteMultiplePdu) * offsetMultiplier,
[+] 					baseOffset + sizeof(io.ModbusWriteMultiplePdu) * offsetMultiplier,
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_address) * offsetMultiplier,
[-] 				sizeof (pdu.m_address) * offsetMultiplier,
[+] 				sizeof(pdu.m_address) * offsetMultiplier,
[-] 				baseOffset + offsetof (pdu.m_count) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_count) * offsetMultiplier,
[-] 				sizeof (pdu.m_count) * offsetMultiplier,
[+] 				sizeof(pdu.m_count) * offsetMultiplier,
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_exception) * offsetMultiplier,
[+] 				baseOffset + offsetof(pdu.m_exception) * offsetMultiplier,
[-] 				sizeof (pdu.m_exception) * offsetMultiplier,
[+] 				sizeof(pdu.m_exception) * offsetMultiplier,
[-] 				io.getModbusExceptionString (pdu.m_exception)
[+] 				io.getModbusExceptionString(pdu.m_exception)
[-] char const* getModbusPduDigest (
[+] char const* getModbusPduDigest(
[-] 	digest.append ($"Fn: \e[34m%1\e[m %2" (
[+] 	digest.append($"Fn: \e[34m%1\e[m %2" (
[-] 		formatModbusFuncDescription (role, hdr.m_func)
[+] 		formatModbusFuncDescription(role, hdr.m_func)
[-] 	switch (hdr.m_func)
[+] 	switch(hdr.m_func)
[-] 			digest.append ($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m");
[+] 			digest.append($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m");
[-] 				digest.append ($" N: \e[34m$(pdu.m_count)\e[m");
[+] 				digest.append($" N: \e[34m$(pdu.m_count)\e[m");
[-] 			digest.append (" ");
[+] 			digest.append(" ");
[-] 				digest.append (getModbusCoilsDigest (
[+] 				digest.append(getModbusCoilsDigest(
[-] 				digest.append (getModbusRegistersDigest (
[+] 				digest.append(getModbusRegistersDigest(
[-] 		digest.append ($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m Val: \e[34m$(pdu.m_value)\e[m");
[+] 		digest.append($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m Val: \e[34m$(pdu.m_value)\e[m");
[-] 			digest.append ($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m ");
[+] 			digest.append($" Addr: \e[34m0x$(pdu.m_address; 04x)\e[m ");
[-] 				digest.append (getModbusCoilsDigest (
[+] 				digest.append(getModbusCoilsDigest(
[-] 				digest.append (getModbusRegistersDigest (
[+] 				digest.append(getModbusRegistersDigest(
[-] 			digest.append ($"Addr: \e[34m0x$(pdu.m_address; 04x) N: \e[34m$(pdu.m_count)\e[m");
[+] 			digest.append($"Addr: \e[34m0x$(pdu.m_address; 04x) N: \e[34m$(pdu.m_count)\e[m");
[-] 			digest.append (
[+] 			digest.append(
[-] 				io.getModbusExceptionString (pdu.m_exception)
[+] 				io.getModbusExceptionString(pdu.m_exception)
[-] 	return digest.detachString ();
[+] 	return digest.detachString();
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLog_Rtu.jnc
----------------------
[-] representModbusRtuAdu (
[+] representModbusRtuAdu(
[-] 	size_t checksumOffset = size - sizeof (uint16_t);
[+] 	size_t checksumOffset = size - sizeof(uint16_t);
[-] 	uint16_t expectedChecksum = crc16_ansi (p, checksumOffset, 0xffff);
[+] 	uint16_t expectedChecksum = crc16_ansi(p, checksumOffset, 0xffff);
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 				getModbusPduDigest (role, pduHdr) :
[+] 				getModbusPduDigest(role, pduHdr) :
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			offsetof (aduHdr.m_deviceAddress),
[+] 			offsetof(aduHdr.m_deviceAddress),
[-] 			sizeof (aduHdr.m_deviceAddress),
[+] 			sizeof(aduHdr.m_deviceAddress),
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				sizeof (uint16_t),
[+] 				sizeof(uint16_t),
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				sizeof (uint16_t),
[+] 				sizeof(uint16_t),
[-] 		representModbusPdu (
[+] 		representModbusPdu(
[-] 			sizeof (io.ModbusRtuAduHdr),,
[+] 			sizeof(io.ModbusRtuAduHdr),,
[-] 		target.addBin (p, size);
[+] 		target.addBin(p, size);
[-] 		target.retroColorize (-size, sizeof (io.ModbusRtuAduHdr), attr);
[+] 		target.retroColorize(-size, sizeof(io.ModbusRtuAduHdr), attr);
[-] 		target.retroColorize (-sizeof (uint16_t), sizeof (uint16_t), attr);
[+] 		target.retroColorize(-sizeof(uint16_t), sizeof(uint16_t), attr);
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusLog_Tcp.jnc
----------------------
[-] representModbusTcpAdu (
[+] representModbusTcpAdu(
[-] 	size_t checksumOffset = size - sizeof (uint16_t);
[+] 	size_t checksumOffset = size - sizeof(uint16_t);
[-] 	uint16_t expectedChecksum = crc16_ansi (p, checksumOffset, 0xffff);
[+] 	uint16_t expectedChecksum = crc16_ansi(p, checksumOffset, 0xffff);
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			getModbusPduDigest (role, pduHdr)
[+] 			getModbusPduDigest(role, pduHdr)
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			offsetof (aduHdr.m_transactionId),
[+] 			offsetof(aduHdr.m_transactionId),
[-] 			sizeof (aduHdr.m_transactionId),
[+] 			sizeof(aduHdr.m_transactionId),
[-] 			offsetof (aduHdr.m_protocol),
[+] 			offsetof(aduHdr.m_protocol),
[-] 			sizeof (aduHdr.m_protocol),
[+] 			sizeof(aduHdr.m_protocol),
[-] 			offsetof (aduHdr.m_length),
[+] 			offsetof(aduHdr.m_length),
[-] 			sizeof (aduHdr.m_length),
[+] 			sizeof(aduHdr.m_length),
[-] 			offsetof (aduHdr.m_deviceAddress),
[+] 			offsetof(aduHdr.m_deviceAddress),
[-] 			sizeof (aduHdr.m_deviceAddress),
[+] 			sizeof(aduHdr.m_deviceAddress),
[-] 		representModbusPdu (
[+] 		representModbusPdu(
[-] 			sizeof (io.ModbusTcpAduHdr),,
[+] 			sizeof(io.ModbusTcpAduHdr),,
[-] 		target.addBin (p, size);
[+] 		target.addBin(p, size);
[-] 		target.retroColorize (-size, sizeof (io.ModbusTcpAduHdr), attr);
[+] 		target.retroColorize(-size, sizeof(io.ModbusTcpAduHdr), attr);
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusParserBase.jnc
----------------------
[-] 	abstract parse (
[+] 	abstract parse(
[-] 	abstract reset ();
[+] 	abstract reset();
[-] 	updateLastTimestamp (uint64_t timestamp);
[+] 	updateLastTimestamp(uint64_t timestamp);
[-] ModbusParserBase.m_mode.set (ModbusParserMode mode)
[+] ModbusParserBase.m_mode.set(ModbusParserMode mode)
[-] 	reset ();
[+] 	reset();
[-] ModbusParserBase.updateLastTimestamp (uint64_t timestamp)
[+] ModbusParserBase.updateLastTimestamp(uint64_t timestamp)
[-] 		reset ();
[+] 		reset();
----------------------
27/02/2019 18:02:25 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusRtuParser.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 	override parse (
[+] 	override parse(
[-] 	override reset ();
[+] 	override reset();
[-] 	ModbusLogRecordCode getPacketRecordCode ()
[+] 	ModbusLogRecordCode getPacketRecordCode()
[-] ModbusRtuParser.parse (
[+] ModbusRtuParser.parse(
[-] 		std.setError (
[+] 		std.setError(
[-] 		writer.writeLastError (timestamp, ModbusLogRecordCode.ParseError);
[+] 		writer.writeLastError(timestamp, ModbusLogRecordCode.ParseError);
[-] 		reset ();
[+] 		reset();
[-] 	updateLastTimestamp (timestamp);
[+] 	updateLastTimestamp(timestamp);
[-] 	writer.write (timestamp, originalRecordCode, p, size);
[+] 	writer.write(timestamp, originalRecordCode, p, size);
[-] 	ModbusLogRecordCode recordCode = getPacketRecordCode ();
[+] 	ModbusLogRecordCode recordCode = getPacketRecordCode();
[-] 			m_expectedSize = io.getModbusRtuAduSize (m_modbusRole, (io.ModbusRtuAduHdr const*) p, size);
[+] 			m_expectedSize = io.getModbusRtuAduSize(m_modbusRole, (io.ModbusRtuAduHdr const*) p, size);
[-] 			m_dataBuffer.append (p, size);
[+] 			m_dataBuffer.append(p, size);
[-] 		m_dataBuffer.append (p, leftoverSize);
[+] 		m_dataBuffer.append(p, leftoverSize);
[-] 		size_t expectedSize = io.getModbusRtuAduSize (
[+] 		size_t expectedSize = io.getModbusRtuAduSize(
[-] 		writer.write (timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[+] 		writer.write(timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[-] 		m_dataBuffer.clear ();
[+] 		m_dataBuffer.clear();
[-] 			recordCode = getPacketRecordCode ();
[+] 			recordCode = getPacketRecordCode();
[-] 	writer.writeLastError (timestamp, ModbusLogRecordCode.ParseError);
[+] 	writer.writeLastError(timestamp, ModbusLogRecordCode.ParseError);
[-] 	reset ();
[+] 	reset();
[-] ModbusRtuParser.reset ()
[+] ModbusRtuParser.reset()
[-] 	m_dataBuffer.clear ();
[+] 	m_dataBuffer.clear();
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Modbus\ModbusTcpParser.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 	override parse (
[+] 	override parse(
[-] 	override reset ();
[+] 	override reset();
[-] ModbusTcpParser.parse (
[+] ModbusTcpParser.parse(
[-] 	writer.write (timestamp, originalRecordCode, p, size);
[+] 	writer.write(timestamp, originalRecordCode, p, size);
[-] 			m_expectedSize = sizeof (io.ModbusTcpAduHdr);
[+] 			m_expectedSize = sizeof(io.ModbusTcpAduHdr);
[-] 			m_dataBuffer.append (p, size);
[+] 			m_dataBuffer.append(p, size);
[-] 		m_dataBuffer.append (p, leftoverSize);
[+] 		m_dataBuffer.append(p, leftoverSize);
[-] 		size_t expectedSize = offsetof (io.ModbusTcpAduHdr.m_deviceAddress) + aduHdr.m_length;
[+] 		size_t expectedSize = offsetof(io.ModbusTcpAduHdr.m_deviceAddress) + aduHdr.m_length;
[-] 		writer.write (timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[+] 		writer.write(timestamp, recordCode, m_dataBuffer.m_p, m_dataBuffer.m_size);
[-] 		reset ();
[+] 		reset();
[-] ModbusTcpParser.reset ()
[+] ModbusTcpParser.reset()
[-] 	m_dataBuffer.clear ();
[+] 	m_dataBuffer.clear();
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLogRepresenter.jnc
----------------------
[-] bool representSnifferLog (
[+] bool representSnifferLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		representPacket (target, p, size, foldFlags);
[+] 		representPacket(target, p, size, foldFlags);
[-] 		representPacket (target, p, size, foldFlags);
[+] 		representPacket(target, p, size, foldFlags);
[-] 		representDefragmentedIp (target, p, size, foldFlags);
[+] 		representDefragmentedIp(target, p, size, foldFlags);
[-] representPacket (
[+] representPacket(
[-] 	representEthernet (target, p, size, foldFlags);
[+] 	representEthernet(target, p, size, foldFlags);
[-] representColorizedBin (
[+] representColorizedBin(
[-] 	target.addBin (p, size);
[+] 	target.addBin(p, size);
[-] 		size_t size = hdrSizeTable [i];
[+] 		size_t size = hdrSizeTable[i];
[-] 		attr.m_textColor = hdrColorTable [i];
[+] 		attr.m_textColor = hdrColorTable[i];
[-] 		target.retroColorize (retroOffset, size, attr);
[+] 		target.retroColorize(retroOffset, size, attr);
[-] representDefragmentedIp (
[+] representDefragmentedIp(
[-] 	target.addPlainText ("Defragmented IP packet");
[+] 	target.addPlainText("Defragmented IP packet");
[-] 		target.addHyperText ("[\e^-1\e[34m-\e[m]");
[+] 		target.addHyperText("[\e^-1\e[34m-\e[m]");
[-] 		size_t hdrSizeTable [8];
[+] 		size_t hdrSizeTable[8];
[-] 		uint_t hdrColorTable [8];
[+] 		uint_t hdrColorTable[8];
[-] 		size_t hdrCount = representIpHdr (target, p, size, 0, hdrSizeTable, hdrColorTable, 0);
[+] 		size_t hdrCount = representIpHdr(target, p, size, 0, hdrSizeTable, hdrColorTable, 0);
[-] 		representColorizedBin (target, p, size, hdrSizeTable, hdrColorTable, hdrCount);
[+] 		representColorizedBin(target, p, size, hdrSizeTable, hdrColorTable, hdrCount);
[-] 		representIp (target, p, size, 0);
[+] 		representIp(target, p, size, 0);
[-] representPacketData (
[+] representPacketData(
[-] 	target.addBin (p + baseOffset, length);
[+] 	target.addBin(p + baseOffset, length);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Arp.jnc
----------------------
[-] representArpHdr (
[+] representArpHdr(
[-] 	size_t srcHardwareAddrOffset = baseOffset + sizeof (io.ArpHdr);
[+] 	size_t srcHardwareAddrOffset = baseOffset + sizeof(io.ArpHdr);
[-] 	size_t arpSize = sizeof (io.ArpHdr) + (arpHdr.m_hardwareLength + arpHdr.m_protocolLength) * 2;
[+] 	size_t arpSize = sizeof(io.ArpHdr) + (arpHdr.m_hardwareLength + arpHdr.m_protocolLength) * 2;
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		baseOffset + offsetof (arpHdr.m_hardwareType),
[+] 		baseOffset + offsetof(arpHdr.m_hardwareType),
[-] 		sizeof (arpHdr.m_hardwareType),
[+] 		sizeof(arpHdr.m_hardwareType),
[-] 		getArpHardwareTypeString (arpHdr.m_hardwareType),
[+] 		getArpHardwareTypeString(arpHdr.m_hardwareType),
[-] 		baseOffset + offsetof (arpHdr.m_protocolType),
[+] 		baseOffset + offsetof(arpHdr.m_protocolType),
[-] 		sizeof (arpHdr.m_protocolType),
[+] 		sizeof(arpHdr.m_protocolType),
[-] 		getArpProtocolTypeString (arpHdr.m_protocolType),
[+] 		getArpProtocolTypeString(arpHdr.m_protocolType),
[-] 		baseOffset + offsetof (arpHdr.m_hardwareLength),
[+] 		baseOffset + offsetof(arpHdr.m_hardwareLength),
[-] 		sizeof (arpHdr.m_hardwareLength),
[+] 		sizeof(arpHdr.m_hardwareLength),
[-] 		baseOffset + offsetof (arpHdr.m_protocolLength),
[+] 		baseOffset + offsetof(arpHdr.m_protocolLength),
[-] 		sizeof (arpHdr.m_protocolLength),
[+] 		sizeof(arpHdr.m_protocolLength),
[-] 		baseOffset + offsetof (arpHdr.m_opcode),
[+] 		baseOffset + offsetof(arpHdr.m_opcode),
[-] 		sizeof (arpHdr.m_opcode),
[+] 		sizeof(arpHdr.m_opcode),
[-] 		getArpOpcodeString (arpHdr.m_opcode),
[+] 		getArpOpcodeString(arpHdr.m_opcode),
[-] 		getArpHardwareAddressString (
[+] 		getArpHardwareAddressString(
[-] 		getArpProtocolAddressString (
[+] 		getArpProtocolAddressString(
[-] 		getArpHardwareAddressString (
[+] 		getArpHardwareAddressString(
[-] 		getArpProtocolAddressString (
[+] 		getArpProtocolAddressString(
[-] 	hdrSizeTable [hdrIdx] = arpSize;
[+] 	hdrSizeTable[hdrIdx] = arpSize;
[-] 	hdrColorTable [hdrIdx] = SnifferLogHdrColor.Arp;
[+] 	hdrColorTable[hdrIdx] = SnifferLogHdrColor.Arp;
[-] representArp (
[+] representArp(
[-] 	if (baseOffset + sizeof (io.ArpHdr) > size)
[+] 	if (baseOffset + sizeof(io.ArpHdr) > size)
[-] 		target.addHyperText ($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID SIZE: \e[34m$size");
[+] 		target.addHyperText($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID SIZE: \e[34m$size");
[-] 	size_t arpSize = sizeof (io.ArpHdr) + 2 * (arpHdr.m_hardwareLength + arpHdr.m_protocolLength);
[+] 	size_t arpSize = sizeof(io.ArpHdr) + 2 * (arpHdr.m_hardwareLength + arpHdr.m_protocolLength);
[-] 		target.addHyperText ($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID SIZE: \e[34m$size");
[+] 		target.addHyperText($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID SIZE: \e[34m$size");
[-] 	size_t srcHardwareAddrOffset = baseOffset + sizeof (io.ArpHdr);
[+] 	size_t srcHardwareAddrOffset = baseOffset + sizeof(io.ArpHdr);
[-] 	switch (arpHdr.m_opcode)
[+] 	switch(arpHdr.m_opcode)
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			getArpProtocolAddressString (
[+] 			getArpProtocolAddressString(
[-] 			getArpProtocolAddressString (
[+] 			getArpProtocolAddressString(
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			getArpProtocolAddressString (
[+] 			getArpProtocolAddressString(
[-] 			getArpHardwareAddressString (
[+] 			getArpHardwareAddressString(
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			getArpHardwareAddressString (
[+] 			getArpHardwareAddressString(
[-] 			getArpProtocolAddressString (
[+] 			getArpProtocolAddressString(
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			getArpHardwareAddressString (
[+] 			getArpHardwareAddressString(
[-] 			getArpProtocolAddressString (
[+] 			getArpProtocolAddressString(
[-] 		target.addHyperText ($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID OPCODE \e[34m$(arpHdr.m_opcode)");
[+] 		target.addHyperText($"[\e^+1\e[34m+\e[m] \e[1mARP\e[m INVALID OPCODE \e[34m$(arpHdr.m_opcode)");
[-] char const* getArpHardwareTypeString (io.ArpHardwareType type)
[+] char const* getArpHardwareTypeString(io.ArpHardwareType type)
[-] 	switch (type)
[+] 	switch(type)
[-] char const* getArpProtocolTypeString (io.ArpProtocolType type)
[+] char const* getArpProtocolTypeString(io.ArpProtocolType type)
[-] 	switch (type)
[+] 	switch(type)
[-] char const* getArpOpcodeString (io.ArpOpcode opcode)
[+] char const* getArpOpcodeString(io.ArpOpcode opcode)
[-] 	static char const* opcodeStringTable [] =
[+] 	static char const* opcodeStringTable[] =
[-] 	return opcodeStringTable [opcode < countof (opcodeStringTable) ? opcode : 0];
[+] 	return opcodeStringTable[opcode < countof(opcodeStringTable) ? opcode : 0];
[-] char const* getArpHardwareAddressString (
[+] char const* getArpHardwareAddressString(
[-] 	switch (type)
[+] 	switch(type)
[-] char const* getArpProtocolAddressString (
[+] char const* getArpProtocolAddressString(
[-] 	switch (type)
[+] 	switch(type)
[-] 			formatIpString (*(bigendian uint32_t const*) p) :
[+] 			formatIpString(*(bigendian uint32_t const*) p) :
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Ethernet.jnc
----------------------
[-] char const* formatEthernetString (uint8_t const* ethernet)
[+] char const* formatEthernetString(uint8_t const* ethernet)
[-] 	return std.format (
[+] 	return std.format(
[-] 		ethernet [0], ethernet [1], ethernet [2],
[+] 		ethernet[0], ethernet[1], ethernet[2],
[-] 		ethernet [3], ethernet [4], ethernet [5]
[+] 		ethernet[3], ethernet[4], ethernet[5]
[-] representEthernet (
[+] representEthernet(
[-] 	if (size < sizeof (io.EthernetHdr))
[+] 	if (size < sizeof(io.EthernetHdr))
[-] 		target.addHyperText ("\e[1mBAD FRAME");
[+] 		target.addHyperText("\e[1mBAD FRAME");
[-] 		target.addBin (p, size);
[+] 		target.addBin(p, size);
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			offsetof (ethernetHdr.m_type),
[+] 			offsetof(ethernetHdr.m_type),
[-] 			sizeof (ethernetHdr.m_type),
[+] 			sizeof(ethernetHdr.m_type),
[-] 			offsetof (ethernetHdr.m_srcAddress),
[+] 			offsetof(ethernetHdr.m_srcAddress),
[-] 			sizeof (ethernetHdr.m_srcAddress),
[+] 			sizeof(ethernetHdr.m_srcAddress),
[-] 			formatEthernetString (ethernetHdr.m_srcAddress),
[+] 			formatEthernetString(ethernetHdr.m_srcAddress),
[-] 			offsetof (ethernetHdr.m_dstAddress),
[+] 			offsetof(ethernetHdr.m_dstAddress),
[-] 			sizeof (ethernetHdr.m_dstAddress),
[+] 			sizeof(ethernetHdr.m_dstAddress),
[-] 			formatEthernetString (ethernetHdr.m_dstAddress)
[+] 			formatEthernetString(ethernetHdr.m_dstAddress)
[-] 		size_t hdrSizeTable [8] = { sizeof (io.EthernetHdr) }
[+] 		size_t hdrSizeTable[8] = { sizeof(io.EthernetHdr) }
[-] 		uint_t hdrColorTable [8] = { SnifferLogHdrColor.Ethernet }
[+] 		uint_t hdrColorTable[8] = { SnifferLogHdrColor.Ethernet }
[-] 		switch (ethernetHdr.m_type)
[+] 		switch(ethernetHdr.m_type)
[-] 			hdrCount = representIpHdr (target, p, size, sizeof (io.EthernetHdr), hdrSizeTable, hdrColorTable, 1);
[+] 			hdrCount = representIpHdr(target, p, size, sizeof(io.EthernetHdr), hdrSizeTable, hdrColorTable, 1);
[-] 			hdrCount = representArpHdr (target, p, size, sizeof (io.EthernetHdr), hdrSizeTable, hdrColorTable, 1);
[+] 			hdrCount = representArpHdr(target, p, size, sizeof(io.EthernetHdr), hdrSizeTable, hdrColorTable, 1);
[-] 		representColorizedBin (target, p, size, hdrSizeTable, hdrColorTable, hdrCount);
[+] 		representColorizedBin(target, p, size, hdrSizeTable, hdrColorTable, hdrCount);
[-] 		switch (ethernetHdr.m_type)
[+] 		switch(ethernetHdr.m_type)
[-] 			representIp (target, p, size, sizeof (io.EthernetHdr));
[+] 			representIp(target, p, size, sizeof(io.EthernetHdr));
[-] 			representArp (target, p, size, sizeof (io.EthernetHdr));
[+] 			representArp(target, p, size, sizeof(io.EthernetHdr));
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			formatEthernetString (ethernetHdr.m_srcAddress),
[+] 			formatEthernetString(ethernetHdr.m_srcAddress),
[-] 			formatEthernetString (ethernetHdr.m_dstAddress),
[+] 			formatEthernetString(ethernetHdr.m_dstAddress),
[-] 		representPacketData (target, p, size, sizeof (io.EthernetHdr), -1);
[+] 		representPacketData(target, p, size, sizeof(io.EthernetHdr), -1);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Icmp.jnc
----------------------
[-] representIcmpHdr (
[+] representIcmpHdr(
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		baseOffset + offsetof (icmpHdr.m_type),
[+] 		baseOffset + offsetof(icmpHdr.m_type),
[-] 		sizeof (icmpHdr.m_type),
[+] 		sizeof(icmpHdr.m_type),
[-] 		baseOffset + offsetof (icmpHdr.m_code),
[+] 		baseOffset + offsetof(icmpHdr.m_code),
[-] 		sizeof (icmpHdr.m_code),
[+] 		sizeof(icmpHdr.m_code),
[-] 		baseOffset + offsetof (icmpHdr.m_checksum),
[+] 		baseOffset + offsetof(icmpHdr.m_checksum),
[-] 		sizeof (icmpHdr.m_checksum),
[+] 		sizeof(icmpHdr.m_checksum),
[-] 		baseOffset + offsetof (icmpHdr.m_id),
[+] 		baseOffset + offsetof(icmpHdr.m_id),
[-] 		sizeof (icmpHdr.m_id),
[+] 		sizeof(icmpHdr.m_id),
[-] 		baseOffset + offsetof (icmpHdr.m_seqNumber),
[+] 		baseOffset + offsetof(icmpHdr.m_seqNumber),
[-] 		sizeof (icmpHdr.m_seqNumber),
[+] 		sizeof(icmpHdr.m_seqNumber),
[-] 	hdrSizeTable [hdrIdx] = sizeof (io.IcmpHdr);
[+] 	hdrSizeTable[hdrIdx] = sizeof(io.IcmpHdr);
[-] 	hdrColorTable [hdrIdx] = SnifferLogHdrColor.Icmp;
[+] 	hdrColorTable[hdrIdx] = SnifferLogHdrColor.Icmp;
[-] representIcmp (
[+] representIcmp(
[-] 	if (baseOffset + sizeof (io.IcmpHdr) > size)
[+] 	if (baseOffset + sizeof(io.IcmpHdr) > size)
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			formatIpString (ipHdr.m_srcAddress),
[+] 			formatIpString(ipHdr.m_srcAddress),
[-] 			formatIpString (ipHdr.m_dstAddress),
[+] 			formatIpString(ipHdr.m_dstAddress),
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		formatIpString (ipHdr.m_srcAddress),
[+] 		formatIpString(ipHdr.m_srcAddress),
[-] 		formatIpString (ipHdr.m_dstAddress),
[+] 		formatIpString(ipHdr.m_dstAddress),
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Ip.jnc
----------------------
[-] char const* formatIpString (bigendian uint32_t ip32)
[+] char const* formatIpString(bigendian uint32_t ip32)
[-] 	return std.format (
[+] 	return std.format(
[-] 		ip8 [0], ip8 [1], ip8 [2], ip8 [3]
[+] 		ip8[0], ip8[1], ip8[2], ip8[3]
[-] representIpHdr (
[+] representIpHdr(
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		baseOffset + offsetof (ipHdr.m_version),
[+] 		baseOffset + offsetof(ipHdr.m_version),
[-] 		sizeof (ipHdr.m_version),
[+] 		sizeof(ipHdr.m_version),
[-] 		baseOffset + offsetof (ipHdr.m_headerLength),
[+] 		baseOffset + offsetof(ipHdr.m_headerLength),
[-] 		sizeof (ipHdr.m_headerLength),
[+] 		sizeof(ipHdr.m_headerLength),
[-] 		baseOffset + offsetof (ipHdr.m_typeOfService),
[+] 		baseOffset + offsetof(ipHdr.m_typeOfService),
[-] 		sizeof (ipHdr.m_typeOfService),
[+] 		sizeof(ipHdr.m_typeOfService),
[-] 		baseOffset + offsetof (ipHdr.m_totalLength),
[+] 		baseOffset + offsetof(ipHdr.m_totalLength),
[-] 		sizeof (ipHdr.m_totalLength),
[+] 		sizeof(ipHdr.m_totalLength),
[-] 		baseOffset + offsetof (ipHdr.m_identification),
[+] 		baseOffset + offsetof(ipHdr.m_identification),
[-] 		sizeof (ipHdr.m_identification),
[+] 		sizeof(ipHdr.m_identification),
[-] 		baseOffset + offsetof (ipHdr.m_flags),
[+] 		baseOffset + offsetof(ipHdr.m_flags),
[-] 		sizeof (ipHdr.m_flags),
[+] 		sizeof(ipHdr.m_flags),
[-] 		baseOffset + offsetof (ipHdr.m_fragmentOffset),
[+] 		baseOffset + offsetof(ipHdr.m_fragmentOffset),
[-] 		sizeof (ipHdr.m_fragmentOffset),
[+] 		sizeof(ipHdr.m_fragmentOffset),
[-] 		baseOffset + offsetof (ipHdr.m_timeToLive),
[+] 		baseOffset + offsetof(ipHdr.m_timeToLive),
[-] 		sizeof (ipHdr.m_timeToLive),
[+] 		sizeof(ipHdr.m_timeToLive),
[-] 		baseOffset + offsetof (ipHdr.m_protocol),
[+] 		baseOffset + offsetof(ipHdr.m_protocol),
[-] 		sizeof (ipHdr.m_protocol),
[+] 		sizeof(ipHdr.m_protocol),
[-] 		baseOffset + offsetof (ipHdr.m_headerChecksum),
[+] 		baseOffset + offsetof(ipHdr.m_headerChecksum),
[-] 		sizeof (ipHdr.m_headerChecksum),
[+] 		sizeof(ipHdr.m_headerChecksum),
[-] 		baseOffset + offsetof (ipHdr.m_srcAddress),
[+] 		baseOffset + offsetof(ipHdr.m_srcAddress),
[-] 		sizeof (ipHdr.m_srcAddress),
[+] 		sizeof(ipHdr.m_srcAddress),
[-] 		formatIpString (ipHdr.m_srcAddress),
[+] 		formatIpString(ipHdr.m_srcAddress),
[-] 		baseOffset + offsetof (ipHdr.m_dstAddress),
[+] 		baseOffset + offsetof(ipHdr.m_dstAddress),
[-] 		sizeof (ipHdr.m_dstAddress),
[+] 		sizeof(ipHdr.m_dstAddress),
[-] 		formatIpString (ipHdr.m_dstAddress)
[+] 		formatIpString(ipHdr.m_dstAddress)
[-] 	if	(ipHdrSize < sizeof (io.IpHdr) || baseOffset + ipHdrSize > size)
[+] 	if	(ipHdrSize < sizeof(io.IpHdr) || baseOffset + ipHdrSize > size)
[-] 		target.addHyperText ($"INVALID HEADER SIZE: $ipHdrSize");
[+] 		target.addHyperText($"INVALID HEADER SIZE: $ipHdrSize");
[-] 		hdrSizeTable [hdrIdx] = sizeof (io.IpHdr);
[+] 		hdrSizeTable[hdrIdx] = sizeof(io.IpHdr);
[-] 		target.addHyperText ("\e[1mFRAGMENTED");
[+] 		target.addHyperText("\e[1mFRAGMENTED");
[-] 		hdrSizeTable [hdrIdx] = sizeof (io.IpHdr);
[+] 		hdrSizeTable[hdrIdx] = sizeof(io.IpHdr);
[-] 	hdrSizeTable [hdrIdx] = ipHdrSize;
[+] 	hdrSizeTable[hdrIdx] = ipHdrSize;
[-] 	hdrColorTable [hdrIdx] = SnifferLogHdrColor.Ip;
[+] 	hdrColorTable[hdrIdx] = SnifferLogHdrColor.Ip;
[-] 	if (ipHdrSize > sizeof (io.IpHdr))
[+] 	if (ipHdrSize > sizeof(io.IpHdr))
[-] 		hdrSizeTable [hdrIdx] = ipHdrSize - sizeof (io.IpHdr);
[+] 		hdrSizeTable[hdrIdx] = ipHdrSize - sizeof(io.IpHdr);
[-] 		hdrColorTable [hdrIdx] = SnifferLogHdrColor.IpOptions;
[+] 		hdrColorTable[hdrIdx] = SnifferLogHdrColor.IpOptions;
[-] 	switch (ipHdr.m_protocol)
[+] 	switch(ipHdr.m_protocol)
[-] 		return representIcmpHdr (target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[+] 		return representIcmpHdr(target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[-] 		return representTcpHdr (target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[+] 		return representTcpHdr(target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[-] 		return representUdpHdr (target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[+] 		return representUdpHdr(target, p, size, baseOffset + ipHdrSize, hdrSizeTable, hdrColorTable, hdrIdx);
[-] char const* formatIpLogText (io.IpHdr const* ipHdr)
[+] char const* formatIpLogText(io.IpHdr const* ipHdr)
[-] 		formatIpString (ipHdr.m_srcAddress),
[+] 		formatIpString(ipHdr.m_srcAddress),
[-] 		formatIpString (ipHdr.m_dstAddress)
[+] 		formatIpString(ipHdr.m_dstAddress)
[-] representIp (
[+] representIp(
[-] 	if (baseOffset + sizeof (io.IpHdr) > size)
[+] 	if (baseOffset + sizeof(io.IpHdr) > size)
[-] 		target.addHyperText (std.format ("[\e^+1\e[34m+\e[m] \e[1mIP\e[m [INVALID SIZE:%d]", size));
[+] 		target.addHyperText(std.format("[\e^+1\e[34m+\e[m] \e[1mIP\e[m [INVALID SIZE:%d]", size));
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 				formatIpLogText (ipHdr),
[+] 				formatIpLogText(ipHdr),
[-] 		target.addHyperText ($"%1 [PROTO:%2; FRAGMENTED]" (formatIpLogText (ipHdr), ipHdr.m_protocol));
[+] 		target.addHyperText($"%1 [PROTO:%2; FRAGMENTED]" (formatIpLogText (ipHdr), ipHdr.m_protocol));
[-] 	switch (ipHdr.m_protocol)
[+] 	switch(ipHdr.m_protocol)
[-] 		representIcmp (target, ipHdr, p, size, baseOffset + ipHdrSize);
[+] 		representIcmp(target, ipHdr, p, size, baseOffset + ipHdrSize);
[-] 		representTcp (target, ipHdr, p, size, baseOffset + ipHdrSize);
[+] 		representTcp(target, ipHdr, p, size, baseOffset + ipHdrSize);
[-] 		representUdp (target, ipHdr, p, size, baseOffset + ipHdrSize);
[+] 		representUdp(target, ipHdr, p, size, baseOffset + ipHdrSize);
[-] 		target.addHyperText ($"%1 [PROTO:%2]" (formatIpLogText (ipHdr), ipHdr.m_protocol));
[+] 		target.addHyperText($"%1 [PROTO:%2]" (formatIpLogText (ipHdr), ipHdr.m_protocol));
[-] 		representPacketData (target, p, size, baseOffset + ipHdrSize, dataSize);
[+] 		representPacketData(target, p, size, baseOffset + ipHdrSize, dataSize);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Tcp.jnc
----------------------
[-] char const* formatTcpFlagString (io.TcpFlags flags)
[+] char const* formatTcpFlagString(io.TcpFlags flags)
[-] 	return std.format (
[+] 	return std.format(
[-] representTcpHdr (
[+] representTcpHdr(
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		baseOffset + offsetof (tcpHdr.m_srcPort),
[+] 		baseOffset + offsetof(tcpHdr.m_srcPort),
[-] 		sizeof (tcpHdr.m_srcPort),
[+] 		sizeof(tcpHdr.m_srcPort),
[-] 		baseOffset + offsetof (tcpHdr.m_dstPort),
[+] 		baseOffset + offsetof(tcpHdr.m_dstPort),
[-] 		sizeof (tcpHdr.m_dstPort),
[+] 		sizeof(tcpHdr.m_dstPort),
[-] 		baseOffset + offsetof (tcpHdr.m_seqNumber),
[+] 		baseOffset + offsetof(tcpHdr.m_seqNumber),
[-] 		sizeof (tcpHdr.m_seqNumber),
[+] 		sizeof(tcpHdr.m_seqNumber),
[-] 		baseOffset + offsetof (tcpHdr.m_ackNumber),
[+] 		baseOffset + offsetof(tcpHdr.m_ackNumber),
[-] 		sizeof (tcpHdr.m_ackNumber),
[+] 		sizeof(tcpHdr.m_ackNumber),
[-] 		baseOffset + offsetof (tcpHdr.m_dataOffset),
[+] 		baseOffset + offsetof(tcpHdr.m_dataOffset),
[-] 		sizeof (tcpHdr.m_dataOffset),
[+] 		sizeof(tcpHdr.m_dataOffset),
[-] 		baseOffset + offsetof (tcpHdr.m_flags),
[+] 		baseOffset + offsetof(tcpHdr.m_flags),
[-] 		sizeof (tcpHdr.m_flags),
[+] 		sizeof(tcpHdr.m_flags),
[-] 		formatTcpFlagString (tcpHdr.m_flags),
[+] 		formatTcpFlagString(tcpHdr.m_flags),
[-] 		baseOffset + offsetof (tcpHdr.m_window),
[+] 		baseOffset + offsetof(tcpHdr.m_window),
[-] 		sizeof (tcpHdr.m_window),
[+] 		sizeof(tcpHdr.m_window),
[-] 		baseOffset + offsetof (tcpHdr.m_checksum),
[+] 		baseOffset + offsetof(tcpHdr.m_checksum),
[-] 		sizeof (tcpHdr.m_checksum),
[+] 		sizeof(tcpHdr.m_checksum),
[-] 		baseOffset + offsetof (tcpHdr.m_urgentData),
[+] 		baseOffset + offsetof(tcpHdr.m_urgentData),
[-] 		sizeof (tcpHdr.m_urgentData),
[+] 		sizeof(tcpHdr.m_urgentData),
[-] 	hdrSizeTable [hdrIdx] = sizeof (io.TcpHdr);
[+] 	hdrSizeTable[hdrIdx] = sizeof(io.TcpHdr);
[-] 	hdrColorTable [hdrIdx] = SnifferLogHdrColor.Tcp;
[+] 	hdrColorTable[hdrIdx] = SnifferLogHdrColor.Tcp;
[-] 	if (dataOffset > sizeof (io.TcpHdr))
[+] 	if (dataOffset > sizeof(io.TcpHdr))
[-] 		hdrSizeTable [hdrIdx] = dataOffset - sizeof (io.TcpHdr);
[+] 		hdrSizeTable[hdrIdx] = dataOffset - sizeof(io.TcpHdr);
[-] 		hdrColorTable [hdrIdx] = SnifferLogHdrColor.TcpOptions;
[+] 		hdrColorTable[hdrIdx] = SnifferLogHdrColor.TcpOptions;
[-] representTcp (
[+] representTcp(
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			formatIpString (ipHdr.m_srcAddress),
[+] 			formatIpString(ipHdr.m_srcAddress),
[-] 			formatIpString (ipHdr.m_dstAddress),
[+] 			formatIpString(ipHdr.m_dstAddress),
[-] 	size_t dataSize = ipHdr.m_totalLength - sizeof (io.IpHdr) - dataOffset;
[+] 	size_t dataSize = ipHdr.m_totalLength - sizeof(io.IpHdr) - dataOffset;
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			formatIpString (ipHdr.m_srcAddress),
[+] 			formatIpString(ipHdr.m_srcAddress),
[-] 			formatIpString (ipHdr.m_dstAddress),
[+] 			formatIpString(ipHdr.m_dstAddress),
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		formatIpString (ipHdr.m_srcAddress),
[+] 		formatIpString(ipHdr.m_srcAddress),
[-] 		formatIpString (ipHdr.m_dstAddress),
[+] 		formatIpString(ipHdr.m_dstAddress),
[-] 		formatTcpFlagString (tcpHdr.m_flags),
[+] 		formatTcpFlagString(tcpHdr.m_flags),
[-] 	representPacketData (target, p, size, baseOffset, dataSize);
[+] 	representPacketData(target, p, size, baseOffset, dataSize);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferLog_Udp.jnc
----------------------
[-] representUdpHdr (
[+] representUdpHdr(
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		baseOffset + offsetof (udpHdr.m_srcPort),
[+] 		baseOffset + offsetof(udpHdr.m_srcPort),
[-] 		sizeof (udpHdr.m_srcPort),
[+] 		sizeof(udpHdr.m_srcPort),
[-] 		baseOffset + offsetof (udpHdr.m_dstPort),
[+] 		baseOffset + offsetof(udpHdr.m_dstPort),
[-] 		sizeof (udpHdr.m_dstPort),
[+] 		sizeof(udpHdr.m_dstPort),
[-] 		baseOffset + offsetof (udpHdr.m_length),
[+] 		baseOffset + offsetof(udpHdr.m_length),
[-] 		sizeof (udpHdr.m_length),
[+] 		sizeof(udpHdr.m_length),
[-] 		baseOffset + offsetof (udpHdr.m_checksum),
[+] 		baseOffset + offsetof(udpHdr.m_checksum),
[-] 		sizeof (udpHdr.m_checksum),
[+] 		sizeof(udpHdr.m_checksum),
[-] 	hdrSizeTable [hdrIdx] = sizeof (io.UdpHdr);
[+] 	hdrSizeTable[hdrIdx] = sizeof(io.UdpHdr);
[-] 	hdrColorTable [hdrIdx] = SnifferLogHdrColor.Udp;
[+] 	hdrColorTable[hdrIdx] = SnifferLogHdrColor.Udp;
[-] representUdp (
[+] representUdp(
[-] 		target.addHyperText (std.format (
[+] 		target.addHyperText(std.format(
[-] 			formatIpString (ipHdr.m_srcAddress),
[+] 			formatIpString(ipHdr.m_srcAddress),
[-] 			formatIpString (ipHdr.m_dstAddress),
[+] 			formatIpString(ipHdr.m_dstAddress),
[-] 	size_t dataSize = udpHdr.m_length - sizeof (io.UdpHdr);
[+] 	size_t dataSize = udpHdr.m_length - sizeof(io.UdpHdr);
[-] 	baseOffset += sizeof (io.UdpHdr);
[+] 	baseOffset += sizeof(io.UdpHdr);
[-] 	target.addHyperText (std.format (
[+] 	target.addHyperText(std.format(
[-] 		formatIpString (ipHdr.m_srcAddress),
[+] 		formatIpString(ipHdr.m_srcAddress),
[-] 		formatIpString (ipHdr.m_dstAddress),
[+] 		formatIpString(ipHdr.m_dstAddress),
[-] 	representPacketData (target, p, size, baseOffset, dataSize);
[+] 	representPacketData(target, p, size, baseOffset, dataSize);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\NetworkSniffer\SnifferSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	bool errorcode capture (
[+] 	bool errorcode capture(
[-] 	bool errorcode openCapFile (
[+] 	bool errorcode openCapFile(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onCapture ()
[+] 	onCapture()
[-] 		try (m_state ? stopCapture () : capture ());
[+] 		try(m_state ? stopCapture() : capture());
[-] 	onSetFilter ()
[+] 	onSetFilter()
[-] 		try (m_state ? applyFilter () : capture ());
[+] 		try(m_state ? applyFilter() : capture());
[-] 	onDeviceComboEnter ()
[+] 	onDeviceComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onFileDlgCompleted (gui.StdDlgButton button);
[+] 	onFileDlgCompleted(gui.StdDlgButton button);
[-] 	onPcapEvent (
[+] 	onPcapEvent(
[-] 	bool errorcode applyFilter ();
[+] 	bool errorcode applyFilter();
[-] 	processPacket (
[+] 	processPacket(
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	createUi ();
[+] 	createUi();
[-] SnifferSession.construct (doc.PluginHost* pluginHost)
[+] SnifferSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] SnifferSession.createUi ()
[+] SnifferSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = io.createPcapDeviceComboBox (m_pluginHost.m_toolBar);
[+] 	m_deviceCombo = io.createPcapDeviceComboBox(m_pluginHost.m_toolBar);
[-] 	m_pluginHost.m_toolBar.addLabel ("Filter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Filter:");
[-] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = io.createPcapDeviceProperty (
[+] 	m_deviceProp = io.createPcapDeviceProperty(
[-] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Network sniffer");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Network sniffer");
[-] 	m_stdSessionInfoSet.createInformationValues (
[+] 	m_stdSessionInfoSet.createInformationValues(
[-] 	m_throughputInfoSet.createInformationValuesGrouped (
[+] 	m_throughputInfoSet.createInformationValuesGrouped(
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] SnifferSession.onFileDlgCompleted (gui.StdDlgButton button)
[+] SnifferSession.onFileDlgCompleted(gui.StdDlgButton button)
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	try openCapFile (fileName, filterString);
[+] 	try openCapFile(fileName, filterString);
[-] bool errorcode SnifferSession.capture ()
[+] bool errorcode SnifferSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 		m_fileDlg.show ();
[+] 		m_fileDlg.show();
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	return try capture (device, filterString);
[+] 	return try capture(device, filterString);
[-] bool errorcode SnifferSession.capture (
[+] bool errorcode SnifferSession.capture(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openDevice (
[+] 	bool result = try m_pcap.openDevice(
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] bool errorcode SnifferSession.openCapFile (
[+] bool errorcode SnifferSession.openCapFile(
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openFile (
[+] 	bool result = try m_pcap.openFile(
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] SnifferSession.stopCapture ()
[+] SnifferSession.stopCapture()
[-] 	writeLog (PcapLogRecordCode.CaptureStopped);
[+] 	writeLog(PcapLogRecordCode.CaptureStopped);
[-] 	m_pcap.close ();
[+] 	m_pcap.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] bool errorcode SnifferSession.applyFilter ()
[+] bool errorcode SnifferSession.applyFilter()
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	writeLogString (PcapLogRecordCode.ChangingFilter, filter);
[+] 	writeLogString(PcapLogRecordCode.ChangingFilter, filter);
[-] 	bool result = try m_pcap.setFilter (filter);
[+] 	bool result = try m_pcap.setFilter(filter);
[-] 		writeLogLastError (PcapLogRecordCode.FilterError);
[+] 		writeLogLastError(PcapLogRecordCode.FilterError);
[-] 	writeLog (PcapLogRecordCode.FilterChanged);
[+] 	writeLog(PcapLogRecordCode.FilterChanged);
[-] SnifferSession.waitPcapEvents ()
[+] SnifferSession.waitPcapEvents()
[-] 	m_pcap.wait (eventMask, onPcapEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_pcap.wait(eventMask, onPcapEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void SnifferSession.load (doc.Storage* storage)
[+] void SnifferSession.load(doc.Storage* storage)
[-] 	m_filterCombo.loadHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.loadHistory(storage, "captureFilterHistory");
[-] 	m_deviceCombo.m_currentIndex = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex = storage.readInt("deviceIdx");
[-] 	m_filterCombo.m_editText = storage.readString ("captureFilter");
[+] 	m_filterCombo.m_editText = storage.readString("captureFilter");
[-] 	m_promisciousProp.m_value = storage.readBool ("promiscious", Defaults.Promiscious);
[+] 	m_promisciousProp.m_value = storage.readBool("promiscious", Defaults.Promiscious);
[-] 	m_ipFragmentLimitProp.m_value = storage.readInt ("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[+] 	m_ipFragmentLimitProp.m_value = storage.readInt("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[-] 	m_ipFragmentTimeoutProp.m_value = storage.readInt ("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[+] 	m_ipFragmentTimeoutProp.m_value = storage.readInt("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[-] 	m_snapshotSizeProp.m_value = storage.readInt ("snapshotSize", Defaults.SnapshotSize);
[+] 	m_snapshotSizeProp.m_value = storage.readInt("snapshotSize", Defaults.SnapshotSize);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SnifferSession.save (doc.Storage* storage)
[+] void SnifferSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_filterCombo.saveHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.saveHistory(storage, "captureFilterHistory");
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeString ("captureFilter", m_filterCombo.m_editText);
[+] 	storage.writeString("captureFilter", m_filterCombo.m_editText);
[-] 	storage.writeBool ("promiscious", m_promisciousProp.m_value);
[+] 	storage.writeBool("promiscious", m_promisciousProp.m_value);
[-] 	storage.writeInt ("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[+] 	storage.writeInt("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[-] 	storage.writeInt ("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[+] 	storage.writeInt("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[-] 	storage.writeInt ("snapshotSize", m_snapshotSizeProp.m_value);
[+] 	storage.writeInt("snapshotSize", m_snapshotSizeProp.m_value);
[-] void SnifferSession.updateProperties ()
[+] void SnifferSession.updateProperties()
[-] bool errorcode SnifferSession.applyProperties ()
[+] bool errorcode SnifferSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	applyFilter ();
[+] 	applyFilter();
[-] void SnifferSession.restoreDefaultProperties ()
[+] void SnifferSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode SnifferSession.transmit (
[+] size_t errorcode SnifferSession.transmit(
[-] 	size_t result = try m_pcap.write (p, size);
[+] 	size_t result = try m_pcap.write(p, size);
[-] 		writeLog (SnifferLogRecordCode.InjectedPacket, p, result);
[+] 		writeLog(SnifferLogRecordCode.InjectedPacket, p, result);
[-] 		m_stdSessionInfoSet.addTxData (size);
[+] 		m_stdSessionInfoSet.addTxData(size);
[-] SnifferSession.onPcapEvent (
[+] SnifferSession.onPcapEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_pcap.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_pcap.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			processPacket (m_readBuffer.m_p, result);
[+] 			processPacket(m_readBuffer.m_p, result);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] SnifferSession.processPacket (
[+] SnifferSession.processPacket(
[-] 	writeLog (SnifferLogRecordCode.Packet, p, size);
[+] 	writeLog(SnifferLogRecordCode.Packet, p, size);
[-] 	m_stdSessionInfoSet.addRxData (size);
[+] 	m_stdSessionInfoSet.addRxData(size);
[-] 	if (size < sizeof (io.EthernetHdr) + sizeof (io.IpHdr))
[+] 	if (size < sizeof(io.EthernetHdr) + sizeof(io.IpHdr))
[-] 	p += sizeof (io.EthernetHdr);
[+] 	p += sizeof(io.EthernetHdr);
[-] 	size -= sizeof (io.EthernetHdr);
[+] 	size -= sizeof(io.EthernetHdr);
[-] 		ipHdr = m_ipDefragmenter.defragment (ipHdr, size);
[+] 		ipHdr = m_ipDefragmenter.defragment(ipHdr, size);
[-] 			size = dynamic sizeof (ipHdr);
[+] 			size = dynamic sizeof(ipHdr);
[-] 			writeLog (SnifferLogRecordCode.DefragmentedIp, ipHdr, size);
[+] 			writeLog(SnifferLogRecordCode.DefragmentedIp, ipHdr, size);
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PcapLog\PcapLogRepresenter.jnc
----------------------
[-] bool representPcapLog (
[+] bool representPcapLog(
[-] 	printf ("representPcapLog (%llu)\n", recordCode);
[+] 	printf("representPcapLog (%llu)\n", recordCode);
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 		target.addPlainText (PcapLogPartCode.CaptureCompleted, "ok");
[+] 		target.addPlainText(PcapLogPartCode.CaptureCompleted, "ok");
[-] 		target.addPlainText (PcapLogPartCode.CaptureCompleted, $"error: $(error.m_description)");
[+] 		target.addPlainText(PcapLogPartCode.CaptureCompleted, $"error: $(error.m_description)");
[-] 		target.addPlainText ("Capture stopped");
[+] 		target.addPlainText("Capture stopped");
[-] 		target.addHyperText (PcapLogPartCode.ChangingFilter, $"Changing capture filter to \e[34m$filter\e[m...");
[+] 		target.addHyperText(PcapLogPartCode.ChangingFilter, $"Changing capture filter to \e[34m$filter\e[m...");
[-] 		target.addPlainText (PcapLogPartCode.FilterCompleted, "ok");
[+] 		target.addPlainText(PcapLogPartCode.FilterCompleted, "ok");
[-] 		target.addPlainText (PcapLogPartCode.FilterCompleted, $"error: $(error.m_description)");
[+] 		target.addPlainText(PcapLogPartCode.FilterCompleted, $"error: $(error.m_description)");
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PipeListener\PipeListenerLogRepresenter.jnc
----------------------
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ($"Listening on \e[34m$name");
[+] 		target.addHyperText($"Listening on \e[34m$name");
[-] 		target.addHyperText ($"Cannot listen: $(error.m_description)");
[+] 		target.addHyperText($"Cannot listen: $(error.m_description)");
[-] 		target.addHyperText ($"Stopped listening on \e[34m$name");
[+] 		target.addHyperText($"Stopped listening on \e[34m$name");
[-] 		target.addHyperText ("Client connected");
[+] 		target.addHyperText("Client connected");
[-] 		target.addHyperText ("Client disconnected");
[+] 		target.addHyperText("Client disconnected");
[-] 		target.addHyperText ("Client connected and rejected ");
[+] 		target.addHyperText("Client connected and rejected ");
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PipeListener\PipeListenerSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode listen ();
[+] 	bool errorcode listen();
[-] 	stopListen ();
[+] 	stopListen();
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onListen ()
[+] 	onListen()
[-] 		m_listenerState ? stopListen () : try listen ();
[+] 		m_listenerState ? stopListen() : try listen();
[-] 	onPipeNameComboEnter ()
[+] 	onPipeNameComboEnter()
[-] 		try listen ();
[+] 		try listen();
[-] 	onListenerPipeEvent (
[+] 	onListenerPipeEvent(
[-] 	onConnectionPipeEvent (
[+] 	onConnectionPipeEvent(
[-] 	io.FileStreamOptions getFileStreamOptions ();
[+] 	io.FileStreamOptions getFileStreamOptions();
[-] 	waitListenerPipeEvents ();
[+] 	waitListenerPipeEvents();
[-] 	waitConnectionPipeEvents ();
[+] 	waitConnectionPipeEvents();
[-] 	createUi ();
[+] 	createUi();
[-] PipeListenerSession.construct (doc.PluginHost* pluginHost)
[+] PipeListenerSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] PipeListenerSession.createUi ()
[+] PipeListenerSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Name:");
[+] 	m_pluginHost.m_toolBar.addLabel("Name:");
[-] 	m_pipeNameCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_pipeNameCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Listen] = new gui.Icon ("images/listen.png");
[+] 	m_iconTable[IconId.Listen] = new gui.Icon("images/listen.png");
[-] 	m_iconTable [IconId.StopListen] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopListen] = new gui.Icon("images/pause.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Listen] = createAction ("Listen", m_iconTable [IconId.Listen]);
[+] 	m_actionTable[ActionId.Listen] = createAction("Listen", m_iconTable [IconId.Listen]);
[-] 	m_actionTable [ActionId.Listen].m_onTriggered += onListen;
[+] 	m_actionTable[ActionId.Listen].m_onTriggered += onListen;
[-] 	m_actionTable [ActionId.Disconnect] = createAction ("Disconnect", m_iconTable [IconId.Disconnect]);
[+] 	m_actionTable[ActionId.Disconnect] = createAction("Disconnect", m_iconTable [IconId.Disconnect]);
[-] 	m_actionTable [ActionId.Disconnect].m_onTriggered += disconnect;
[+] 	m_actionTable[ActionId.Disconnect].m_onTriggered += disconnect;
[-] 	m_statusPaneTable [StatusPaneId.ConnectionState] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.ConnectionState] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_statusPaneTable [StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_pipeNameProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_pipeNameProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_messageModeProp =  m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_messageModeProp =  m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_overrideOldConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_overrideOldConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Pipe listener");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Pipe listener");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode PipeListenerSession.listen ()
[+] bool errorcode PipeListenerSession.listen()
[-] 	stopListen ();
[+] 	stopListen();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_pipeNameCombo.addEditTextToHistory ();
[+] 	m_pipeNameCombo.addEditTextToHistory();
[-] 	io.FileStreamOptions options = getFileStreamOptions ();
[+] 	io.FileStreamOptions options = getFileStreamOptions();
[-] 	m_listenerPipe.open (name);
[+] 	m_listenerPipe.open(name);
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (name)
[+] 		strlen(name)
[-] 	waitListenerPipeEvents ();
[+] 	waitListenerPipeEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_listenerPipe.close ();
[+] 	m_listenerPipe.close();
[-] PipeListenerSession.stopListen ()
[+] PipeListenerSession.stopListen()
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (m_pipeName)
[+] 		strlen(m_pipeName)
[-] 	m_listenerPipe.close ();
[+] 	m_listenerPipe.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] PipeListenerSession.disconnect ()
[+] PipeListenerSession.disconnect()
[-] 	writeLog (PipeListenerLogRecordCode.ClientDisconnected);
[+] 	writeLog(PipeListenerLogRecordCode.ClientDisconnected);
[-] 	m_connectionPipe.close ();
[+] 	m_connectionPipe.close();
[-] io.FileStreamOptions PipeListenerSession.getFileStreamOptions ()
[+] io.FileStreamOptions PipeListenerSession.getFileStreamOptions()
[-] PipeListenerSession.waitListenerPipeEvents ()
[+] PipeListenerSession.waitListenerPipeEvents()
[-] 	m_listenerPipe.wait (eventMask, onListenerPipeEvent ~(++m_listenerSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_listenerPipe.wait(eventMask, onListenerPipeEvent ~(++m_listenerSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] PipeListenerSession.waitConnectionPipeEvents ()
[+] PipeListenerSession.waitConnectionPipeEvents()
[-] 	m_connectionPipe.wait (eventMask, onConnectionPipeEvent ~(++m_connectionSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_connectionPipe.wait(eventMask, onConnectionPipeEvent ~(++m_connectionSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void PipeListenerSession.load (doc.Storage* storage)
[+] void PipeListenerSession.load(doc.Storage* storage)
[-] 	m_pipeNameCombo.loadHistory (storage, "pipeNameHistory");
[+] 	m_pipeNameCombo.loadHistory(storage, "pipeNameHistory");
[-] 	m_pipeNameCombo.m_editText = storage.readString ("pipeName");
[+] 	m_pipeNameCombo.m_editText = storage.readString("pipeName");
[-] 	m_messageModeProp.m_value = storage.readBool ("messageMode", Defaults.MessageMode);
[+] 	m_messageModeProp.m_value = storage.readBool("messageMode", Defaults.MessageMode);
[-] 	m_overrideOldConnectionProp.m_value = storage.readBool ("overrideOldConnection", Defaults.OverrideConnection);
[+] 	m_overrideOldConnectionProp.m_value = storage.readBool("overrideOldConnection", Defaults.OverrideConnection);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void PipeListenerSession.save (doc.Storage* storage)
[+] void PipeListenerSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_pipeNameCombo.saveHistory (storage, "pipeNameHistory");
[+] 	m_pipeNameCombo.saveHistory(storage, "pipeNameHistory");
[-] 	storage.writeString ("pipeName", m_pipeNameCombo.m_editText);
[+] 	storage.writeString("pipeName", m_pipeNameCombo.m_editText);
[-] 	storage.writeBool ("messageMode", m_messageModeProp.m_value);
[+] 	storage.writeBool("messageMode", m_messageModeProp.m_value);
[-] 	storage.writeBool ("overrideOldConnection", m_overrideOldConnectionProp.m_value);
[+] 	storage.writeBool("overrideOldConnection", m_overrideOldConnectionProp.m_value);
[-] void PipeListenerSession.updateProperties ()
[+] void PipeListenerSession.updateProperties()
[-] bool errorcode PipeListenerSession.applyProperties ()
[+] bool errorcode PipeListenerSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	io.FileStreamOptions options = getFileStreamOptions ();
[+] 	io.FileStreamOptions options = getFileStreamOptions();
[-] void PipeListenerSession.restoreDefaultProperties ()
[+] void PipeListenerSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode PipeListenerSession.transmit (
[+] size_t errorcode PipeListenerSession.transmit(
[-] 	size_t result = m_connectionPipe.write (p, size);
[+] 	size_t result = m_connectionPipe.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] PipeListenerSession.onListenerPipeEvent (
[+] PipeListenerSession.onListenerPipeEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_listenerPipe.m_ioError, m_listenerPipe.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_listenerPipe.m_ioError, m_listenerPipe.m_ioError.m_size);
[-] 		stopListen ();
[+] 		stopListen();
[-] 		io.FileStream* pipe = m_listenerPipe.accept ();
[+] 		io.FileStream* pipe = m_listenerPipe.accept();
[-] 			pipe.close ();
[+] 			pipe.close();
[-] 			writeLog (PipeListenerLogRecordCode.ClientRejected);
[+] 			writeLog(PipeListenerLogRecordCode.ClientRejected);
[-] 			disconnect ();
[+] 			disconnect();
[-] 			writeLog (PipeListenerLogRecordCode.ClientConnected);
[+] 			writeLog(PipeListenerLogRecordCode.ClientConnected);
[-] 			waitConnectionPipeEvents ();
[+] 			waitConnectionPipeEvents();
[-] 	waitListenerPipeEvents ();
[+] 	waitListenerPipeEvents();
[-] PipeListenerSession.onConnectionPipeEvent (
[+] PipeListenerSession.onConnectionPipeEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_connectionPipe.m_ioError, m_connectionPipe.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_connectionPipe.m_ioError, m_connectionPipe.m_ioError.m_size);
[-] 		disconnect ();
[+] 		disconnect();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_connectionPipe.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_connectionPipe.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		disconnect ();
[+] 		disconnect();
[-] 	waitConnectionPipeEvents ();
[+] 	waitConnectionPipeEvents();
[-] 	m_actionTable [ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[+] 	m_actionTable[ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[-] 	m_actionTable [ActionId.Listen].m_icon = m_iconTable [m_listenerState ? IconId.StopListen : IconId.Listen];
[+] 	m_actionTable[ActionId.Listen].m_icon = m_iconTable[m_listenerState ? IconId.StopListen : IconId.Listen];
[-] 	m_actionTable [ActionId.Disconnect].m_isEnabled = m_connectionState == State.Opened;
[+] 	m_actionTable[ActionId.Disconnect].m_isEnabled = m_connectionState == State.Opened;
[-] 	m_statusPaneTable [StatusPaneId.ListenerState].m_text = m_listenerState  ? "Listening" : "Not listening";
[+] 	m_statusPaneTable[StatusPaneId.ListenerState].m_text = m_listenerState  ? "Listening" : "Not listening";
[-] 	m_statusPaneTable [StatusPaneId.ConnectionState].m_text = m_connectionState  ? "Connected" : "Not connected";
[+] 	m_statusPaneTable[StatusPaneId.ConnectionState].m_text = m_connectionState  ? "Connected" : "Not connected";
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PipeMon\PipeMonitor.jnc
----------------------
[-] 	construct (PipeMonSession* session);
[+] 	construct(PipeMonSession* session);
[-] 	override processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	override processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr);
[-] 	override processError (std.Error const* error);
[+] 	override processError(std.Error const* error);
[-] 	setFileId (
[+] 	setFileId(
[-] 	processFsctlNotification (
[+] 	processFsctlNotification(
[-] PipeMonitor.construct (PipeMonSession* session)
[+] PipeMonitor.construct(PipeMonSession* session)
[-] 	basetype.construct (session.m_pluginHost);
[+] 	basetype.construct(session.m_pluginHost);
[-] PipeMonitor.setFileId (
[+] PipeMonitor.setFileId(
[-] 	uint32_t fileId = m_fileIdMgr.getHiFileId (loFileId);
[+] 	uint32_t fileId = m_fileIdMgr.getHiFileId(loFileId);
[-] 		uint32_t ids [] = { fileId, processId }
[+] 		uint32_t ids[] = { fileId, processId }
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, PipeMonLogRecordCode.FileIdChanged, ids, sizeof (ids));
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, PipeMonLogRecordCode.FileIdChanged, ids, sizeof(ids));
[-] PipeMonitor.processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr)
[+] PipeMonitor.processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr)
[-] 	switch (notifyHdr.m_code)
[+] 	switch(notifyHdr.m_code)
[-] 			uint32_t fileId = m_fileIdMgr.getHiFileId (params.m_fileId);
[+] 			uint32_t fileId = m_fileIdMgr.getHiFileId(params.m_fileId);
[-] 			logParams.append (&fileId, sizeof (fileId));
[+] 			logParams.append(&fileId, sizeof(fileId));
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			error.m_size = sizeof (error);
[+] 			error.m_size = sizeof(error);
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			logParams.append (&error, error.m_size);
[+] 			logParams.append(&error, error.m_size);
[-] 		name.copy ((utf16_t const*) (params + 1));
[+] 		name.copy((utf16_t const*) (params + 1));
[-] 		logParams.append (name.m_sz, name.m_length + 1);
[+] 		logParams.append(name.m_sz, name.m_length + 1);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 			uint32_t fileId = m_fileIdMgr.getHiFileId (params.m_fileId);
[+] 			uint32_t fileId = m_fileIdMgr.getHiFileId(params.m_fileId);
[-] 			logParams.append (&fileId, sizeof (fileId));
[+] 			logParams.append(&fileId, sizeof(fileId));
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			error.m_size = sizeof (error);
[+] 			error.m_size = sizeof(error);
[-] 			logParams.append (&notifyHdr.m_processId, sizeof (notifyHdr.m_processId));
[+] 			logParams.append(&notifyHdr.m_processId, sizeof(notifyHdr.m_processId));
[-] 			logParams.append (&error, error.m_size);
[+] 			logParams.append(&error, error.m_size);
[-] 		name.copy ((utf16_t const*) (params + 1));
[+] 		name.copy((utf16_t const*) (params + 1));
[-] 		logParams.append (name.m_sz, name.m_length + 1);
[+] 		logParams.append(name.m_sz, name.m_length + 1);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		setFileId (notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[+] 		setFileId(notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[-] 		m_fileIdMgr.removeLowFileId (params.m_fileId);
[+] 		m_fileIdMgr.removeLowFileId(params.m_fileId);
[-] 		m_pluginHost.m_log.m_writer.write (notifyHdr.m_timestamp, PipeMonLogRecordCode.FileClosed);
[+] 		m_pluginHost.m_log.m_writer.write(notifyHdr.m_timestamp, PipeMonLogRecordCode.FileClosed);
[-] 		setFileId (notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[+] 		setFileId(notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		setFileId (notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[+] 		setFileId(notifyHdr.m_timestamp, params.m_fileId, notifyHdr.m_processId);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		processFsctlNotification (
[+] 		processFsctlNotification(
[-] PipeMonitor.processFsctlNotification (
[+] PipeMonitor.processFsctlNotification(
[-] 	switch (code)
[+] 	switch(code)
[-] 		setFileId (timestamp, loFileId, processId);
[+] 		setFileId(timestamp, loFileId, processId);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, PipeMonLogRecordCode.ConnectionAccepted);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, PipeMonLogRecordCode.ConnectionAccepted);
[-] 		setFileId (timestamp, loFileId, processId);
[+] 		setFileId(timestamp, loFileId, processId);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, PipeMonLogRecordCode.ConnectionClosed);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, PipeMonLogRecordCode.ConnectionClosed);
[-] 		transactionParams.m_fileId  = m_fileIdMgr.getHiFileId (loFileId);
[+] 		transactionParams.m_fileId  = m_fileIdMgr.getHiFileId(loFileId);
[-] 		setFileId (timestamp, loFileId, processId);
[+] 		setFileId(timestamp, loFileId, processId);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 			 sizeof (transactionParams)
[+] 			 sizeof(transactionParams)
[-] 			m_pluginHost.m_log.m_writer.write (
[+] 			m_pluginHost.m_log.m_writer.write(
[-] 			m_pluginHost.m_log.m_writer.write (
[+] 			m_pluginHost.m_log.m_writer.write(
[-] PipeMonitor.processError (std.Error const* error)
[+] PipeMonitor.processError(std.Error const* error)
[-] 	m_pluginHost.m_log.m_writer.write (log.StdRecordCode.Error, error, error.m_size);
[+] 	m_pluginHost.m_log.m_writer.write(log.StdRecordCode.Error, error, error.m_size);
[-] 	m_session.close ();
[+] 	m_session.close();
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PipeMon\PipeMonLogRepresenter.jnc
----------------------
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* name = (char const*) (p + sizeof (fileId));
[+] 		char const* name = (char const*) (p + sizeof(fileId));
[-] 		target.addHyperText ($"File \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[+] 		target.addHyperText($"File \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[-] 		char const* name = (char const*) (p + sizeof (fileId) + sizeof (pid));
[+] 		char const* name = (char const*) (p + sizeof(fileId) + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Server file opened: \e[34m$name");
[-] 		target.addHyperText ($"Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[-] 		std.Error const* error = (std.Error const*) (p + sizeof (pid));
[+] 		std.Error const* error = (std.Error const*) (p + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m: Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m: Cannot open server file \e[34m$name\e[m$: $(error.m_description)");
[-] 		char const* name = (char const*) (p + sizeof (fileId));
[+] 		char const* name = (char const*) (p + sizeof(fileId));
[-] 		target.addHyperText ($"File \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[+] 		target.addHyperText($"File \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[-] 		char const* name = (char const*) (p + sizeof (fileId) + sizeof (pid));
[+] 		char const* name = (char const*) (p + sizeof(fileId) + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: Client file opened: \e[34m$name");
[-] 		target.addHyperText ($"Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[-] 		std.Error const* error = (std.Error const*) (p + sizeof (pid));
[+] 		std.Error const* error = (std.Error const*) (p + sizeof(pid));
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m: Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m: Cannot open client file \e[34m$name\e[m: $(error.m_description)");
[-] 		target.addHyperText (PipeMonLogPartCode.Suffix, "File closed");
[+] 		target.addHyperText(PipeMonLogPartCode.Suffix, "File closed");
[-] 		target.addHyperText (PipeMonLogPartCode.Suffix, "Connection accepted");
[+] 		target.addHyperText(PipeMonLogPartCode.Suffix, "Connection accepted");
[-] 		target.addHyperText (PipeMonLogPartCode.Suffix, "Connection closed");
[+] 		target.addHyperText(PipeMonLogPartCode.Suffix, "Connection closed");
[-] 		target.addHyperText (PipeMonLogPartCode.Suffix, $"Pipe transaction: TX: \e[34m$(params.m_txDataSize)\e[m B; RX: \e[34m$(params.m_rxDataSize)\e[m B");
[+] 		target.addHyperText(PipeMonLogPartCode.Suffix, $"Pipe transaction: TX: \e[34m$(params.m_txDataSize)\e[m B; RX: \e[34m$(params.m_rxDataSize)\e[m B");
[-] 		target.addHyperText (PipeMonLogPartCode.Prefix, $"File \e[34m#$fileId\e[m: ");
[+] 		target.addHyperText(PipeMonLogPartCode.Prefix, $"File \e[34m#$fileId\e[m: ");
[-] 		target.addHyperText (PipeMonLogPartCode.Prefix, $"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: ");
[+] 		target.addHyperText(PipeMonLogPartCode.Prefix, $"PID \e[34m#$pid\e[m file \e[34m#$fileId\e[m: ");
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\PipeMon\PipeMonSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? close () : try capture ();
[+] 		m_state ? close() : try capture();
[-] 	onNameComboEnter ()
[+] 	onNameComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onMonitorError ();
[+] 	onMonitorError();
[-] 	createUi ();
[+] 	createUi();
[-] PipeMonSession.construct (doc.PluginHost* pluginHost)
[+] PipeMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_npfsMonitor.construct (this);
[+] 	m_npfsMonitor.construct(this);
[-] 	m_lanmanMonitor.construct (this);
[+] 	m_lanmanMonitor.construct(this);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] PipeMonSession.createUi ()
[+] PipeMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Name filter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Name filter:");
[-] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_nameCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_nameProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_useLanmanMonitorProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_useLanmanMonitorProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Pipe monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Pipe monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode PipeMonSession.capture ()
[+] bool errorcode PipeMonSession.capture()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_nameCombo.addEditTextToHistory ();
[+] 	m_nameCombo.addEditTextToHistory();
[-] 	m_npfsMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_npfsMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 	m_npfsMonitor.capture (r"\device\namedpipe", name);
[+] 	m_npfsMonitor.capture(r"\device\namedpipe", name);
[-] 		m_lanmanMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 		m_lanmanMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 		m_lanmanMonitor.capture (r"\device\lanmanredirector", name);
[+] 		m_lanmanMonitor.capture(r"\device\lanmanredirector", name);
[-] 	writeLogString (DeviceMonLogRecordCode.CaptureStarted_filter, name);
[+] 	writeLogString(DeviceMonLogRecordCode.CaptureStarted_filter, name);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	m_npfsMonitor.close ();
[+] 	m_npfsMonitor.close();
[-] 	m_lanmanMonitor.close ();
[+] 	m_lanmanMonitor.close();
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] PipeMonSession.close ()
[+] PipeMonSession.close()
[-] 	writeLog (DeviceMonLogRecordCode.CaptureStopped);
[+] 	writeLog(DeviceMonLogRecordCode.CaptureStopped);
[-] 	m_npfsMonitor.close ();
[+] 	m_npfsMonitor.close();
[-] 	m_lanmanMonitor.close ();
[+] 	m_lanmanMonitor.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void PipeMonSession.load (doc.Storage* storage)
[+] void PipeMonSession.load(doc.Storage* storage)
[-] 	m_nameCombo.loadHistory (storage, "nameHistory");
[+] 	m_nameCombo.loadHistory(storage, "nameHistory");
[-] 	m_nameCombo.m_editText = storage.readString ("name");
[+] 	m_nameCombo.m_editText = storage.readString("name");
[-] 	m_useLanmanMonitorProp.m_value = storage.readString ("useLanmanMonitor");
[+] 	m_useLanmanMonitorProp.m_value = storage.readString("useLanmanMonitor");
[-] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt ("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[+] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_npfsMonitor.setReadBufferSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_npfsMonitor.setReadBufferSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_lanmanMonitor.setReadBufferSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_lanmanMonitor.setReadBufferSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void PipeMonSession.save (doc.Storage* storage)
[+] void PipeMonSession.save(doc.Storage* storage)
[-] 	m_nameCombo.saveHistory (storage, "nameHistory");
[+] 	m_nameCombo.saveHistory(storage, "nameHistory");
[-] 	storage.writeString ("name", m_nameCombo.m_currentText);
[+] 	storage.writeString("name", m_nameCombo.m_currentText);
[-] 	storage.writeBool ("useLanmanMonitor", m_useLanmanMonitorProp.m_value);
[+] 	storage.writeBool("useLanmanMonitor", m_useLanmanMonitorProp.m_value);
[-] 	storage.writeInt ("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[+] 	storage.writeInt("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void PipeMonSession.updateProperties ()
[+] void PipeMonSession.updateProperties()
[-] bool errorcode PipeMonSession.applyProperties ()
[+] bool errorcode PipeMonSession.applyProperties()
[-] 	m_npfsMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_npfsMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 	m_lanmanMonitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_lanmanMonitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] void PipeMonSession.restoreDefaultProperties ()
[+] void PipeMonSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\RegexColorizer\RegexColorizerHighlighter.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 	clearRegex_s ();
[+] 	clearRegex_s();
[-] 	bool errorcode addRegexPattern_s (
[+] 	bool errorcode addRegexPattern_s(
[-] 	bool errorcode finalizeRegex_s ();
[+] 	bool errorcode finalizeRegex_s();
[-] 	write_l (
[+] 	write_l(
[-] 	finalizeWrite_l (log.Writer* writer)
[+] 	finalizeWrite_l(log.Writer* writer)
[-] 		write_l (writer, null, 0); // send eof
[+] 		write_l(writer, null, 0); // send eof
[-] 		m_regexState.reset ();
[+] 		m_regexState.reset();
[-] RegexColorizerHighlighter.clearRegex_s ()
[+] RegexColorizerHighlighter.clearRegex_s()
[-] 	m_regexDfa.clear ();
[+] 	m_regexDfa.clear();
[-] 	m_attrArray.clear ();
[+] 	m_attrArray.clear();
[-] bool errorcode RegexColorizerHighlighter.addRegexPattern_s (
[+] bool errorcode RegexColorizerHighlighter.addRegexPattern_s(
[-] 	m_regexDfa.incrementalCompile (regexString);
[+] 	m_regexDfa.incrementalCompile(regexString);
[-] 	m_attrArray.append (attr);
[+] 	m_attrArray.append(attr);
[-] bool errorcode RegexColorizerHighlighter.finalizeRegex_s ()
[+] bool errorcode RegexColorizerHighlighter.finalizeRegex_s()
[-] 		m_regexDfa.incrementalCompile (".");
[+] 		m_regexDfa.incrementalCompile(".");
[-] 		m_regexDfa.finalize ();
[+] 		m_regexDfa.finalize();
[-] 	m_regexState.reset ();
[+] 	m_regexState.reset();
[-] RegexColorizerHighlighter.write_l (
[+] RegexColorizerHighlighter.write_l(
[-] 		result = try m_regexDfa.match (m_regexState, p, length);
[+] 		result = try m_regexDfa.match(m_regexState, p, length);
[-] 			writer.retroColorize (
[+] 			writer.retroColorize(
[-] 				(gui.TextAttr) m_attrArray [result],
[+] 				(gui.TextAttr) m_attrArray[result],
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\RegexColorizer\RegexColorizerLayer.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override bool convert (
[+] 	override bool convert(
[-] 	createUi ();
[+] 	createUi();
[-] 	onAddPattern ();
[+] 	onAddPattern();
[-] 	onRemoveLastPattern ();
[+] 	onRemoveLastPattern();
[-] 	onRemoveAllExtraPatterns ();
[+] 	onRemoveAllExtraPatterns();
[-] RegexColorizerLayer.construct (doc.PluginHost* pluginHost)
[+] RegexColorizerLayer.construct(doc.PluginHost* pluginHost)
[-] 	basetype1.construct (pluginHost);
[+] 	basetype1.construct(pluginHost);
[-] 	pluginHost.m_log.addConverter (this);
[+] 	pluginHost.m_log.addConverter(this);
[-] 	createUi ();
[+] 	createUi();
[-] 	onAddPattern (); // add pattern #1
[+] 	onAddPattern(); // add pattern #1
[-] RegexColorizerLayer.createUi ()
[+] RegexColorizerLayer.createUi()
[-] 	m_addPatternProp = m_pluginHost.m_propertyGrid.createActionProperty (
[+] 	m_addPatternProp = m_pluginHost.m_propertyGrid.createActionProperty(
[-] 	m_removeLastPatternProp = m_pluginHost.m_propertyGrid.createActionProperty (
[+] 	m_removeLastPatternProp = m_pluginHost.m_propertyGrid.createActionProperty(
[-] 	m_removeAllExtraPatternsProp = m_pluginHost.m_propertyGrid.createActionProperty (
[+] 	m_removeAllExtraPatternsProp = m_pluginHost.m_propertyGrid.createActionProperty(
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] RegexColorizerLayer.onAddPattern ()
[+] RegexColorizerLayer.onAddPattern()
[-] 	RegexPattern* pattern = new RegexPattern (
[+] 	RegexPattern* pattern = new RegexPattern(
[-] 	m_patternArray.append (pattern);
[+] 	m_patternArray.append(pattern);
[-] RegexColorizerLayer.onRemoveLastPattern ()
[+] RegexColorizerLayer.onRemoveLastPattern()
[-] 	RegexPattern* pattern = m_patternArray [m_patternArray.m_count - 1];
[+] 	RegexPattern* pattern = m_patternArray[m_patternArray.m_count - 1];
[-] 	m_pluginHost.m_propertyGrid.removeProperty (pattern.m_groupProp);
[+] 	m_pluginHost.m_propertyGrid.removeProperty(pattern.m_groupProp);
[-] 	m_patternArray.setCount (m_patternArray.m_count - 1);
[+] 	m_patternArray.setCount(m_patternArray.m_count - 1);
[-] RegexColorizerLayer.onRemoveAllExtraPatterns ()
[+] RegexColorizerLayer.onRemoveAllExtraPatterns()
[-] 		RegexPattern* pattern = m_patternArray [i];
[+] 		RegexPattern* pattern = m_patternArray[i];
[-] 		m_pluginHost.m_propertyGrid.removeProperty (pattern.m_groupProp);
[+] 		m_pluginHost.m_propertyGrid.removeProperty(pattern.m_groupProp);
[-] 	m_patternArray.setCount (1);
[+] 	m_patternArray.setCount(1);
[-] void RegexColorizerLayer.load (doc.Storage* storage)
[+] void RegexColorizerLayer.load(doc.Storage* storage)
[-] 	((RegexPattern*) m_patternArray [0]).load (storage);
[+] 	((RegexPattern*)m_patternArray[0]).load(storage);
[-] 	m_patternArray.setCount (1); // drop the rest
[+] 	m_patternArray.setCount(1); // drop the rest
[-] 		char const* regexString = storage.readString ("regex");
[+] 		char const* regexString = storage.readString("regex");
[-] 		if (!strlen (regexString))
[+] 		if (!strlen(regexString))
[-] 		RegexPattern* pattern = new RegexPattern (
[+] 		RegexPattern* pattern = new RegexPattern(
[-] 		pattern.load (storage);
[+] 		pattern.load(storage);
[-] 		m_patternArray.append (pattern);
[+] 		m_patternArray.append(pattern);
[-] 	applyProperties ();
[+] 	applyProperties();
[-] void RegexColorizerLayer.save (doc.Storage* storage)
[+] void RegexColorizerLayer.save(doc.Storage* storage)
[-] 		RegexPattern* pattern = m_patternArray [i];
[+] 		RegexPattern* pattern = m_patternArray[i];
[-] 		pattern.save (storage);
[+] 		pattern.save(storage);
[-] bool errorcode RegexColorizerLayer.applyProperties ()
[+] bool errorcode RegexColorizerLayer.applyProperties()
[-] 	m_pluginHost.m_log.suspend ();
[+] 	m_pluginHost.m_log.suspend();
[-] 	m_txHighlighter.clearRegex_s ();
[+] 	m_txHighlighter.clearRegex_s();
[-] 	m_rxHighlighter.clearRegex_s ();
[+] 	m_rxHighlighter.clearRegex_s();
[-] 		RegexPattern* pattern = m_patternArray [i];
[+] 		RegexPattern* pattern = m_patternArray[i];
[-] 		if (!strlen (regexString))
[+] 		if (!strlen(regexString))
[-] 		gui.TextAttr attr = pattern.buildTextAttr ();
[+] 		gui.TextAttr attr = pattern.buildTextAttr();
[-] 			m_txHighlighter.addRegexPattern_s (regexString, attr);
[+] 			m_txHighlighter.addRegexPattern_s(regexString, attr);
[-] 			m_rxHighlighter.addRegexPattern_s (regexString, attr);
[+] 			m_rxHighlighter.addRegexPattern_s(regexString, attr);
[-] 	m_txHighlighter.finalizeRegex_s ();
[+] 	m_txHighlighter.finalizeRegex_s();
[-] 	m_rxHighlighter.finalizeRegex_s ();
[+] 	m_rxHighlighter.finalizeRegex_s();
[-] 	m_pluginHost.m_log.resume ();
[+] 	m_pluginHost.m_log.resume();
[-] bool RegexColorizerLayer.convert (
[+] bool RegexColorizerLayer.convert(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		m_rxHighlighter.finalizeWrite_l (writer);
[+] 		m_rxHighlighter.finalizeWrite_l(writer);
[-] 		writer.write (timestamp, recordCode, p, size);
[+] 		writer.write(timestamp, recordCode, p, size);
[-] 		m_txHighlighter.write_l (writer, p, size);
[+] 		m_txHighlighter.write_l(writer, p, size);
[-] 		m_txHighlighter.finalizeWrite_l (writer);
[+] 		m_txHighlighter.finalizeWrite_l(writer);
[-] 		writer.write (timestamp, recordCode, p, size);
[+] 		writer.write(timestamp, recordCode, p, size);
[-] 		m_rxHighlighter.write_l (writer, p, size);
[+] 		m_rxHighlighter.write_l(writer, p, size);
[-] 		writer.write (timestamp, recordCode, p, size);
[+] 		writer.write(timestamp, recordCode, p, size);
[-] 		m_txHighlighter.write_l (writer, p, halfSize);
[+] 		m_txHighlighter.write_l(writer, p, halfSize);
[-] 		m_rxHighlighter.write_l (writer, p + halfSize, halfSize);
[+] 		m_rxHighlighter.write_l(writer, p + halfSize, halfSize);
[-] 		m_txHighlighter.finalizeWrite_l (writer);
[+] 		m_txHighlighter.finalizeWrite_l(writer);
[-] 		m_rxHighlighter.finalizeWrite_l (writer);
[+] 		m_rxHighlighter.finalizeWrite_l(writer);
[-] 		writer.write (timestamp, recordCode, p, size);
[+] 		writer.write(timestamp, recordCode, p, size);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\RegexColorizer\RegexPattern.jnc
----------------------
[-] 	construct (
[+] 	construct(
[-] 	gui.TextAttr buildTextAttr ();
[+] 	gui.TextAttr buildTextAttr();
[-] 	void load (doc.Storage* storage);
[+] 	void load(doc.Storage* storage);
[-] 	void save (doc.Storage* storage);
[+] 	void save(doc.Storage* storage);
[-] RegexPattern.construct (
[+] RegexPattern.construct(
[-] 	m_groupProp = propertyGrid.createGroupProperty (
[+] 	m_groupProp = propertyGrid.createGroupProperty(
[-] 	m_isTxEnabledProp = propertyGrid.createBoolProperty (
[+] 	m_isTxEnabledProp = propertyGrid.createBoolProperty(
[-] 	m_isRxEnabledProp = propertyGrid.createBoolProperty (
[+] 	m_isRxEnabledProp = propertyGrid.createBoolProperty(
[-] 	m_regexProp = propertyGrid.createStringProperty (
[+] 	m_regexProp = propertyGrid.createStringProperty(
[-] 	m_colorProp = propertyGrid.createColorProperty (
[+] 	m_colorProp = propertyGrid.createColorProperty(
[-] 	gui.FlagPropertyOption fontFlagTable [] =
[+] 	gui.FlagPropertyOption fontFlagTable[] =
[-] 	m_fontFlagProp = propertyGrid.createFlagProperty (
[+] 	m_fontFlagProp = propertyGrid.createFlagProperty(
[-] 		countof (fontFlagTable)
[+] 		countof(fontFlagTable)
[-] 	static Initializer initializerTable [] =
[+] 	static Initializer initializerTable[] =
[-] 	index %= countof (initializerTable);
[+] 	index %= countof(initializerTable);
[-] 	m_regexProp.m_value = initializerTable [index].m_regex;
[+] 	m_regexProp.m_value = initializerTable[index].m_regex;
[-] 	m_colorProp.m_value = initializerTable [index].m_color;
[+] 	m_colorProp.m_value = initializerTable[index].m_color;
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] gui.TextAttr RegexPattern.buildTextAttr ()
[+] gui.TextAttr RegexPattern.buildTextAttr()
[-] void RegexPattern.load (doc.Storage* storage)
[+] void RegexPattern.load(doc.Storage* storage)
[-] 	m_isTxEnabledProp.m_value = storage.readBool ("isTxEnabled");
[+] 	m_isTxEnabledProp.m_value = storage.readBool("isTxEnabled");
[-] 	m_isRxEnabledProp.m_value = storage.readBool ("isRxEnabled");
[+] 	m_isRxEnabledProp.m_value = storage.readBool("isRxEnabled");
[-] 	m_regexProp.m_value = storage.readString ("regex");
[+] 	m_regexProp.m_value = storage.readString("regex");
[-] 	m_colorProp.m_value = storage.readInt ("color");
[+] 	m_colorProp.m_value = storage.readInt("color");
[-] 	m_fontFlagProp.m_value = storage.readInt ("fontFlags");
[+] 	m_fontFlagProp.m_value = storage.readInt("fontFlags");
[-] void RegexPattern.save (doc.Storage* storage)
[+] void RegexPattern.save(doc.Storage* storage)
[-] 	storage.writeBool ("isTxEnabled", m_isTxEnabledProp.m_value);
[+] 	storage.writeBool("isTxEnabled", m_isTxEnabledProp.m_value);
[-] 	storage.writeBool ("isRxEnabled", m_isRxEnabledProp.m_value);
[+] 	storage.writeBool("isRxEnabled", m_isRxEnabledProp.m_value);
[-] 	storage.writeString ("regex", m_regexProp.m_value);
[+] 	storage.writeString("regex", m_regexProp.m_value);
[-] 	storage.writeInt ("color", m_colorProp.m_value);
[+] 	storage.writeInt("color", m_colorProp.m_value);
[-] 	storage.writeInt ("fontFlags", m_fontFlagProp.m_value);
[+] 	storage.writeInt("fontFlags", m_fontFlagProp.m_value);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Serial\SerialLogRepresenter.jnc
----------------------
[-] char const* getTableString (
[+] char const* getTableString(
[-] 	return value < dynamic countof (table) ? table [value] : "\e[31mundefined\e[m";
[+] 	return value < dynamic countof(table) ? table[value] : "\e[31mundefined\e[m";
[-] char const* getOnOffString (uint_t line)
[+] char const* getOnOffString(uint_t line)
[-] char const* getStatusLineChangeString (
[+] char const* getStatusLineChangeString(
[-] 		char const* valueString = getOnOffString (lines & io.SerialStatusLines.Dsr);
[+] 		char const* valueString = getOnOffString(lines & io.SerialStatusLines.Dsr);
[-] 		char const* valueString = getOnOffString (lines & io.SerialStatusLines.Cts);
[+] 		char const* valueString = getOnOffString(lines & io.SerialStatusLines.Cts);
[-] bool representSerialLog (
[+] bool representSerialLog(
[-] 	static char const* flowControlStringTable [] =
[+] 	static char const* flowControlStringTable[] =
[-] 	static char const* stopBitsStringTable [] =
[+] 	static char const* stopBitsStringTable[] =
[-] 	static char const* parityStringTable [] =
[+] 	static char const* parityStringTable[] =
[-] 	static char const* readModeTable [] =
[+] 	static char const* readModeTable[] =
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* dtrString = getOnOffString (params.m_dtr);
[+] 		char const* dtrString = getOnOffString(params.m_dtr);
[-] 		char const* rtsString = getOnOffString (params.m_rts);
[+] 		char const* rtsString = getOnOffString(params.m_rts);
[-] 		char const* dsrString = getOnOffString (params.m_statusLines & io.SerialStatusLines.Dsr);
[+] 		char const* dsrString = getOnOffString(params.m_statusLines & io.SerialStatusLines.Dsr);
[-] 		char const* ctsString = getOnOffString (params.m_statusLines & io.SerialStatusLines.Cts);
[+] 		char const* ctsString = getOnOffString(params.m_statusLines & io.SerialStatusLines.Cts);
[-] 			char const* flowControlString = getTableString (params.m_flowControl, flowControlStringTable);
[+] 			char const* flowControlString = getTableString(params.m_flowControl, flowControlStringTable);
[-] 			char const* stopBitsString = getTableString (params.m_stopBits, stopBitsStringTable);
[+] 			char const* stopBitsString = getTableString(params.m_stopBits, stopBitsStringTable);
[-] 			char const* parityString = getTableString (params.m_parity, parityStringTable);
[+] 			char const* parityString = getTableString(params.m_parity, parityStringTable);
[-] 				char const* readModeString = getTableString (readMode, readModeTable);
[+] 				char const* readModeString = getTableString(readMode, readModeTable);
[-] 		target.addHyperText (string);
[+] 		target.addHyperText(string);
[-] 			target.addHyperText ($"[\e^+1\e[34m+\e[m] Opened port \e[34m$name\e[m at \e[34m$(params.m_baudRate)\e[m bps");
[+] 			target.addHyperText($"[\e^+1\e[34m+\e[m] Opened port \e[34m$name\e[m at \e[34m$(params.m_baudRate)\e[m bps");
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				getTableString (params.m_flowControl, flowControlStringTable),
[+] 				getTableString(params.m_flowControl, flowControlStringTable),
[-] 				getTableString (params.m_stopBits, stopBitsStringTable),
[+] 				getTableString(params.m_stopBits, stopBitsStringTable),
[-] 				getTableString (params.m_parity, parityStringTable)
[+] 				getTableString(params.m_parity, parityStringTable)
[-] 		target.addHyperText ($"Port \e[34m$name\e[m closed");
[+] 		target.addHyperText($"Port \e[34m$name\e[m closed");
[-] 		target.addHyperText ($"Cannot open port: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open port: $(error.m_description)");
[-] 		target.addHyperText ($"Set baud rate: \e[34m$baudRate\e[m bps");
[+] 		target.addHyperText($"Set baud rate: \e[34m$baudRate\e[m bps");
[-] 		char const* flowControlString = getTableString (flowControl, flowControlStringTable);
[+] 		char const* flowControlString = getTableString(flowControl, flowControlStringTable);
[-] 		target.addHyperText ($"Set flow control: \e[34m$flowControlString");
[+] 		target.addHyperText($"Set flow control: \e[34m$flowControlString");
[-] 		target.addHyperText ($"Set data bits: \e[34m$dataBits\e[m bits");
[+] 		target.addHyperText($"Set data bits: \e[34m$dataBits\e[m bits");
[-] 		char const* stopBitsString = getTableString (stopBits, stopBitsStringTable);
[+] 		char const* stopBitsString = getTableString(stopBits, stopBitsStringTable);
[-] 		target.addHyperText ($"Set stop bits: $stopBitsString");
[+] 		target.addHyperText($"Set stop bits: $stopBitsString");
[-] 		char const* parityString = getTableString (parity, parityStringTable);
[+] 		char const* parityString = getTableString(parity, parityStringTable);
[-] 		target.addHyperText ($"Set parity: \e[34m$parityString");
[+] 		target.addHyperText($"Set parity: \e[34m$parityString");
[-] 		char const* rtsString = getOnOffString (rts);
[+] 		char const* rtsString = getOnOffString(rts);
[-] 		target.addHyperText ($"Set RTS: $rtsString");
[+] 		target.addHyperText($"Set RTS: $rtsString");
[-] 		char const* dtrString = getOnOffString (dtr);
[+] 		char const* dtrString = getOnOffString(dtr);
[-] 		target.addHyperText ($"Set DTR: $dtrString");
[+] 		target.addHyperText($"Set DTR: $dtrString");
[-] 		char const* string = getStatusLineChangeString (
[+] 		char const* string = getStatusLineChangeString(
[-] 		target.addHyperText (string);
[+] 		target.addHyperText(string);
[-] 		char const* string = getStatusLineChangeString (
[+] 		char const* string = getStatusLineChangeString(
[-] 		target.addHyperText (string);
[+] 		target.addHyperText(string);
[-] 		char const* modeString = getTableString (mode, readModeTable);
[+] 		char const* modeString = getTableString(mode, readModeTable);
[-] 		target.addHyperText ($"Set read mode: \e[34m$modeString");
[+] 		target.addHyperText($"Set read mode: \e[34m$modeString");
[-] 		target.addHyperText ($"Set read interval: \e[34m$interval\e[m ms");
[+] 		target.addHyperText($"Set read interval: \e[34m$interval\e[m ms");
[-] 		target.addHyperText ($"Using conservative serial settings due to an unsafe driver: \e[34m$driver");
[+] 		target.addHyperText($"Using conservative serial settings due to an unsafe driver: \e[34m$driver");
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Serial\SerialSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.InformationValue* m_infoTable [InfoId._Count];
[+] 	gui.InformationValue* m_infoTable[InfoId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode open ();
[+] 	bool errorcode open();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onOpen ()
[+] 	onOpen()
[-] 		m_state ? close () : try open ();
[+] 		m_state ? close() : try open();
[-] 	onPortComboEnter ()
[+] 	onPortComboEnter()
[-] 		try open ();
[+] 		try open();
[-] 	onBaudRateChanged ();
[+] 	onBaudRateChanged();
[-] 	onDtrChanged ();
[+] 	onDtrChanged();
[-] 	onRtsChanged ();
[+] 	onRtsChanged();
[-] 	onSerialEvent (
[+] 	onSerialEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] 	io.SerialOptions getSerialOptions ();
[+] 	io.SerialOptions getSerialOptions();
[-] 	uint_t getReadInterval ()
[+] 	uint_t getReadInterval()
[-] 	updateLineInfoValue (
[+] 	updateLineInfoValue(
[-] SerialSession.construct (doc.PluginHost* pluginHost)
[+] SerialSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SerialSession.createUi ()
[+] SerialSession.createUi()
[-] 	static gui.EnumPropertyOption readModeTable [] =
[+] 	static gui.EnumPropertyOption readModeTable[] =
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/connect.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/connect.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Re-enumerate ports", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh] = createAction("Re-enumerate ports", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumeratePorts;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumeratePorts;
[-] 	m_actionTable [ActionId.Open] = createAction ("Open", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpen;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpen;
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 	m_serialSettingUi.create (
[+] 	m_serialSettingUi.create(
[-] 	bindingof (m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[+] 	bindingof(m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[-] 	m_pluginHost.m_menu.addSeparator ();
[+] 	m_pluginHost.m_menu.addSeparator();
[-] 	m_actionTable [ActionId.Dtr] = createAction ("DTR", "images/dtr.png", true, true);
[+] 	m_actionTable[ActionId.Dtr] = createAction("DTR", "images/dtr.png", true, true);
[-] 	m_actionTable [ActionId.Dtr].m_onTriggered += onDtrChanged;
[+] 	m_actionTable[ActionId.Dtr].m_onTriggered += onDtrChanged;
[-] 	m_actionTable [ActionId.Rts] = createAction ("RTS", "images/rts.png", true, false);
[+] 	m_actionTable[ActionId.Rts] = createAction("RTS", "images/rts.png", true, false);
[-] 	m_actionTable [ActionId.Rts].m_onTriggered += onRtsChanged;
[+] 	m_actionTable[ActionId.Rts].m_onTriggered += onRtsChanged;
[-] 	m_statusPane = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPane = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_dtrProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_dtrProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_rtsProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_rtsProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 		m_readModeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 			countof (readModeTable)
[+] 			countof(readModeTable)
[-] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 		m_readIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 		m_readModeProp = new gui.EnumProperty (null);
[+] 		m_readModeProp = new gui.EnumProperty(null);
[-] 		m_readIntervalProp = new gui.IntProperty (null);
[+] 		m_readIntervalProp = new gui.IntProperty(null);
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_infoTable [InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DTR");
[+] 	m_infoTable[InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DTR");
[-] 	m_infoTable [InfoId.Rts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "RTS");
[+] 	m_infoTable[InfoId.Rts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "RTS");
[-] 	m_infoTable [InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DSR");
[+] 	m_infoTable[InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DSR");
[-] 	m_infoTable [InfoId.Cts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "CTS");
[+] 	m_infoTable[InfoId.Cts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "CTS");
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] io.SerialOptions SerialSession.getSerialOptions ()
[+] io.SerialOptions SerialSession.getSerialOptions()
[-] bool errorcode SerialSession.open ()
[+] bool errorcode SerialSession.open()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_serial.m_readInterval = getReadInterval ();
[+] 	m_serial.m_readInterval = getReadInterval();
[-] 	m_serial.m_options = getSerialOptions ();
[+] 	m_serial.m_options = getSerialOptions();
[-] 	m_serial.m_dtr = m_actionTable [ActionId.Dtr].m_isChecked;
[+] 	m_serial.m_dtr = m_actionTable[ActionId.Dtr].m_isChecked;
[-] 	m_serial.m_rts = m_actionTable [ActionId.Rts].m_isChecked;
[+] 	m_serial.m_rts = m_actionTable[ActionId.Rts].m_isChecked;
[-] 	char const* driverName = io.detectSerialBuggyDriver (portName);
[+] 	char const* driverName = io.detectSerialBuggyDriver(portName);
[-] 		writeLogString (SerialLogRecordCode.BuggyDriverDetected, driverName);
[+] 		writeLogString(SerialLogRecordCode.BuggyDriverDetected, driverName);
[-] 		io.setConservativeSerialSettings (m_serial);
[+] 		io.setConservativeSerialSettings(m_serial);
[-] 	m_serial.open (portName);
[+] 	m_serial.open(portName);
[-] 	writeLog (SerialLogRecordCode.PortOpened, p, dynamic sizeof (p));
[+] 	writeLog(SerialLogRecordCode.PortOpened, p, dynamic sizeof(p));
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_serial.close ();
[+] 	m_serial.close();
[-] SerialSession.close ()
[+] SerialSession.close()
[-] 	writeLogString (SerialLogRecordCode.PortClosed, m_portName);
[+] 	writeLogString(SerialLogRecordCode.PortClosed, m_portName);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] 	m_serial.close ();
[+] 	m_serial.close();
[-] void SerialSession.load (doc.Storage* storage)
[+] void SerialSession.load(doc.Storage* storage)
[-] 	m_serialSettingUi.load (storage);
[+] 	m_serialSettingUi.load(storage);
[-] 	m_portCombo.m_editText = storage.readString ("portName");
[+] 	m_portCombo.m_editText = storage.readString("portName");
[-] 	m_actionTable [ActionId.Dtr].m_isChecked = storage.readBool ("dtr", Defaults.Dtr);
[+] 	m_actionTable[ActionId.Dtr].m_isChecked = storage.readBool("dtr", Defaults.Dtr);
[-] 	m_actionTable [ActionId.Rts].m_isChecked = storage.readBool ("rts", Defaults.Rts);
[+] 	m_actionTable[ActionId.Rts].m_isChecked = storage.readBool("rts", Defaults.Rts);
[-] 	m_readModeProp.m_value = storage.readBool ("readMode", Defaults.ReadMode);
[+] 	m_readModeProp.m_value = storage.readBool("readMode", Defaults.ReadMode);
[-] 	m_readIntervalProp.m_value = storage.readInt ("readInterval", Defaults.ReadInterval);
[+] 	m_readIntervalProp.m_value = storage.readInt("readInterval", Defaults.ReadInterval);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SerialSession.save (doc.Storage* storage)
[+] void SerialSession.save(doc.Storage* storage)
[-] 	m_serialSettingUi.save (storage);
[+] 	m_serialSettingUi.save(storage);
[-] 	storage.writeString ("portName", m_portCombo.m_editText);
[+] 	storage.writeString("portName", m_portCombo.m_editText);
[-] 	storage.writeBool ("dtr", m_actionTable [ActionId.Dtr].m_isChecked);
[+] 	storage.writeBool("dtr", m_actionTable [ActionId.Dtr].m_isChecked);
[-] 	storage.writeBool ("rts", m_actionTable [ActionId.Rts].m_isChecked);
[+] 	storage.writeBool("rts", m_actionTable [ActionId.Rts].m_isChecked);
[-] 	storage.writeInt ("readMode", m_readModeProp.m_value);
[+] 	storage.writeInt("readMode", m_readModeProp.m_value);
[-] 	storage.writeInt ("readInterval", m_readIntervalProp.m_value);
[+] 	storage.writeInt("readInterval", m_readIntervalProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void SerialSession.updateProperties ()
[+] void SerialSession.updateProperties()
[-] 	m_serialSettingUi.updateProperties ();
[+] 	m_serialSettingUi.updateProperties();
[-] 	m_dtrProp.m_value = m_actionTable [ActionId.Dtr].m_isChecked;
[+] 	m_dtrProp.m_value = m_actionTable[ActionId.Dtr].m_isChecked;
[-] 	m_rtsProp.m_value = m_actionTable [ActionId.Rts].m_isChecked;
[+] 	m_rtsProp.m_value = m_actionTable[ActionId.Rts].m_isChecked;
[-] bool errorcode SerialSession.applyProperties ()
[+] bool errorcode SerialSession.applyProperties()
[-] 	m_serialSettingUi.applyProperties ();
[+] 	m_serialSettingUi.applyProperties();
[-] 	m_actionTable [ActionId.Dtr].m_isChecked = m_dtrProp.m_value;
[+] 	m_actionTable[ActionId.Dtr].m_isChecked = m_dtrProp.m_value;
[-] 	m_actionTable [ActionId.Rts].m_isChecked = m_rtsProp.m_value;
[+] 	m_actionTable[ActionId.Rts].m_isChecked = m_rtsProp.m_value;
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	io.SerialOptions options = getSerialOptions ();
[+] 	io.SerialOptions options = getSerialOptions();
[-] 	uint_t readInterval = getReadInterval ();
[+] 	uint_t readInterval = getReadInterval();
[-] 	m_serial.setupDevice (
[+] 	m_serial.setupDevice(
[-] 		writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 		writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 		writeLog (SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof (dataBits));
[+] 		writeLog(SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
[-] 		writeLog (SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof (stopBits));
[+] 		writeLog(SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));
[-] 		writeLog (SerialLogRecordCode.ParityChanged, &parity, sizeof (parity));
[+] 		writeLog(SerialLogRecordCode.ParityChanged, &parity, sizeof(parity));
[-] 		writeLog (SerialLogRecordCode.FlowControlChanged, &flowControl, sizeof (flowControl));
[+] 		writeLog(SerialLogRecordCode.FlowControlChanged, &flowControl, sizeof(flowControl));
[-] 		writeLog (SerialLogRecordCode.DtrChanged, &dtr, sizeof (dtr));
[+] 		writeLog(SerialLogRecordCode.DtrChanged, &dtr, sizeof(dtr));
[-] 		writeLog (SerialLogRecordCode.RtsChanged, &rts, sizeof (rts));
[+] 		writeLog(SerialLogRecordCode.RtsChanged, &rts, sizeof(rts));
[-] 		writeLog (SerialLogRecordCode.ReadModeChanged, &mode, sizeof (mode));
[+] 		writeLog(SerialLogRecordCode.ReadModeChanged, &mode, sizeof(mode));
[-] 		writeLog (SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof (readInterval));
[+] 		writeLog(SerialLogRecordCode.ReadIntervalChanged, &readInterval, sizeof(readInterval));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] void SerialSession.restoreDefaultProperties ()
[+] void SerialSession.restoreDefaultProperties()
[-] 	m_serialSettingUi.restoreDefaultProperties ();
[+] 	m_serialSettingUi.restoreDefaultProperties();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode SerialSession.transmit (
[+] size_t errorcode SerialSession.transmit(
[-] 	size_t result = m_serial.write (p, size);
[+] 	size_t result = m_serial.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] 		waitSerialEvents ();
[+] 		waitSerialEvents();
[-] SerialSession.enumeratePorts ()
[+] SerialSession.enumeratePorts()
[-] 	m_portCombo.clear ();
[+] 	m_portCombo.clear();
[-] 	io.SerialPortDesc const* portList = io.createSerialPortDescList (&count);
[+] 	io.SerialPortDesc const* portList = io.createSerialPortDescList(&count);
[-] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption[count];
[-] 		m_portCombo.addItem (description, port.m_deviceName);
[+] 		m_portCombo.addItem(description, port.m_deviceName);
[-] 	m_portProp.setOptions (optionArray, count);
[+] 	m_portProp.setOptions(optionArray, count);
[-] SerialSession.waitSerialEvents ()
[+] SerialSession.waitSerialEvents()
[-] 	m_serial.wait (eventMask, onSerialEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_serial.wait(eventMask, onSerialEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] SerialSession.onSerialEvent (
[+] SerialSession.onSerialEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_serial.m_ioError, m_serial.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_serial.m_ioError, m_serial.m_ioError.m_size);
[-] 		close ();
[+] 		close();
[-] 		writeLog (log.StdRecordCode.RxBufferFullLossy);
[+] 		writeLog(log.StdRecordCode.RxBufferFullLossy);
[-] 		size_t result = m_serial.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_serial.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (SerialLogRecordCode.StatusLineChanged, params, sizeof (params));
[+] 		writeLog(SerialLogRecordCode.StatusLineChanged, params, sizeof(params));
[-] 	waitSerialEvents ();
[+] 	waitSerialEvents();
[-] SerialSession.onBaudRateChanged ()
[+] SerialSession.onBaudRateChanged()
[-] 	m_serial.setupDevice (
[+] 	m_serial.setupDevice(
[-] 	writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 	writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] SerialSession.onDtrChanged ()
[+] SerialSession.onDtrChanged()
[-] 	bool value = m_actionTable [ActionId.Dtr].m_isChecked;
[+] 	bool value = m_actionTable[ActionId.Dtr].m_isChecked;
[-] 	writeLog (SerialLogRecordCode.DtrChanged, &value, sizeof (value));
[+] 	writeLog(SerialLogRecordCode.DtrChanged, &value, sizeof(value));
[-] SerialSession.onRtsChanged ()
[+] SerialSession.onRtsChanged()
[-] 	bool value = m_actionTable [ActionId.Rts].m_isChecked;
[+] 	bool value = m_actionTable[ActionId.Rts].m_isChecked;
[-] 	writeLog (SerialLogRecordCode.RtsChanged, &value, sizeof (value));
[+] 	writeLog(SerialLogRecordCode.RtsChanged, &value, sizeof(value));
[-] SerialSession.updateLineInfoValue (
[+] SerialSession.updateLineInfoValue(
[-] 	m_infoTable [infoId].m_value = line ? "on" : "off";
[+] 	m_infoTable[infoId].m_value = line ? "on" : "off";
[-] 	m_infoTable [infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[+] 	m_infoTable[infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close" : "Open";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close" : "Open";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_actionTable [ActionId.Rts].m_isEnabled = m_serialSettingUi.m_flowControlProp.m_value != io.SerialFlowControl.RtsCts;
[+] 	m_actionTable[ActionId.Rts].m_isEnabled = m_serialSettingUi.m_flowControlProp.m_value != io.SerialFlowControl.RtsCts;
[-] 	m_infoTable [InfoId.Dtr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dtr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Rts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Rts].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Dsr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dsr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Cts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Cts].m_isEnabled = m_state;
[-] 	updateLineInfoValue (InfoId.Dtr, m_serialDtr);
[+] 	updateLineInfoValue(InfoId.Dtr, m_serialDtr);
[-] 	updateLineInfoValue (InfoId.Rts, m_serialRts);
[+] 	updateLineInfoValue(InfoId.Rts, m_serialRts);
[-] 	updateLineInfoValue (InfoId.Dsr, m_serialStatusLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dsr, m_serialStatusLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Cts, m_serialStatusLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Cts, m_serialStatusLines & io.SerialStatusLines.Cts);
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonitor.jnc
----------------------
[-] 	construct (SerialMonSession* session);
[+] 	construct(SerialMonSession* session);
[-] 	bool errorcode capture (char const* deviceName);
[+] 	bool errorcode capture(char const* deviceName);
[-] 	override processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr)
[+] 	override processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr)
[-] 		m_processor->processNotification (notifyHdr);
[+] 		m_processor->processNotification(notifyHdr);
[-] 	override processError (std.Error const* error);
[+] 	override processError(std.Error const* error);
[-] SerialMonitor.construct (SerialMonSession* session)
[+] SerialMonitor.construct(SerialMonSession* session)
[-] 	basetype.construct (session.m_pluginHost);
[+] 	basetype.construct(session.m_pluginHost);
[-] 	switch (sys.g_systemInfo.m_osKind)
[+] 	switch(sys.g_systemInfo.m_osKind)
[-] 		m_processor = new SerialMonProcessor_win (m_session.m_pluginHost.m_log.m_writer);
[+] 		m_processor = new SerialMonProcessor_win(m_session.m_pluginHost.m_log.m_writer);
[-] 		m_processor = new SerialMonProcessor_lnx (m_session.m_pluginHost.m_log.m_writer);
[+] 		m_processor = new SerialMonProcessor_lnx(m_session.m_pluginHost.m_log.m_writer);
[-] 		std.setError ("Unsupported OS");
[+] 		std.setError("Unsupported OS");
[-] bool errorcode SerialMonitor.capture (char const* deviceName)
[+] bool errorcode SerialMonitor.capture(char const* deviceName)
[-] 		basetype.capture (deviceName);
[+] 		basetype.capture(deviceName);
[-] 		static io.psx.DeviceMonitorIoctlDesc ioctlDescTable [] =
[+] 		static io.psx.DeviceMonitorIoctlDesc ioctlDescTable[] =
[-] 			{ psx.TCSETA,   sizeof (psx.termio) },
[+] 			{ psx.TCSETA,   sizeof(psx.termio) },
[-] 			{ psx.TCSETAW,  sizeof (psx.termio) },
[+] 			{ psx.TCSETAW,  sizeof(psx.termio) },
[-] 			{ psx.TCSETAF,  sizeof (psx.termio) },
[+] 			{ psx.TCSETAF,  sizeof(psx.termio) },
[-] 			{ psx.TCSETS,   sizeof (psx.termios) },
[+] 			{ psx.TCSETS,   sizeof(psx.termios) },
[-] 			{ psx.TCSETSW,  sizeof (psx.termios) },
[+] 			{ psx.TCSETSW,  sizeof(psx.termios) },
[-] 			{ psx.TCSETSF,  sizeof (psx.termios) },
[+] 			{ psx.TCSETSF,  sizeof(psx.termios) },
[-] 			{ psx.TIOCMGET, sizeof (uint_t) },
[+] 			{ psx.TIOCMGET, sizeof(uint_t) },
[-] 			{ psx.TIOCMBIS, sizeof (uint_t) },
[+] 			{ psx.TIOCMBIS, sizeof(uint_t) },
[-] 			{ psx.TIOCMBIC, sizeof (uint_t) },
[+] 			{ psx.TIOCMBIC, sizeof(uint_t) },
[-] 		basetype.capture (deviceName, null, ioctlDescTable, sizeof (ioctlDescTable) / sizeof (ioctlDescTable [0]));
[+] 		basetype.capture(deviceName, null, ioctlDescTable, sizeof(ioctlDescTable) / sizeof(ioctlDescTable[0]));
[-] 	m_processor.reset ();
[+] 	m_processor.reset();
[-] SerialMonitor.processError (std.Error const* error)
[+] SerialMonitor.processError(std.Error const* error)
[-] 	m_pluginHost.m_log.m_writer.write (log.StdRecordCode.Error, error, error.m_size);
[+] 	m_pluginHost.m_log.m_writer.write(log.StdRecordCode.Error, error, error.m_size);
[-] 	m_session.close ();
[+] 	m_session.close();
----------------------
27/02/2019 18:02:26 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonitor_mi.jnc
----------------------
[-] 	construct (log.Writer* logWriter)
[+] 	construct(log.Writer* logWriter)
[-] 		reset ();
[+] 		reset();
[-] 	reset ();
[+] 	reset();
[-] 	bool errorcode write (
[+] 	bool errorcode write(
[-] 	bool errorcode processMsg (io.DeviceMonitorMiMsgHdr const* hdr);
[+] 	bool errorcode processMsg(io.DeviceMonitorMiMsgHdr const* hdr);
[-] SerialMonitor_mi.reset ()
[+] SerialMonitor_mi.reset()
[-] 	m_expectedMsgSize = sizeof (io.DeviceMonitorMiMsgHdr);
[+] 	m_expectedMsgSize = sizeof(io.DeviceMonitorMiMsgHdr);
[-] 	m_buffer.clear ();
[+] 	m_buffer.clear();
[-] bool errorcode SerialMonitor_mi.write (
[+] bool errorcode SerialMonitor_mi.write(
[-] 				m_buffer.append (p, size);
[+] 				m_buffer.append(p, size);
[-] 			m_buffer.append (p, leftover);
[+] 			m_buffer.append(p, leftover);
[-] 		size_t msgSize = sizeof (io.DeviceMonitorMiMsgHdr) + hdr.m_paramSize;
[+] 		size_t msgSize = sizeof(io.DeviceMonitorMiMsgHdr) + hdr.m_paramSize;
[-] 		processMsg (hdr);
[+] 		processMsg(hdr);
[-] 		m_expectedMsgSize = sizeof (io.DeviceMonitorMiMsgHdr);
[+] 		m_expectedMsgSize = sizeof(io.DeviceMonitorMiMsgHdr);
[-] 		m_buffer.clear ();
[+] 		m_buffer.clear();
[-] bool errorcode SerialMonitor_mi.processMsg (io.DeviceMonitorMiMsgHdr const* hdr)
[+] bool errorcode SerialMonitor_mi.processMsg(io.DeviceMonitorMiMsgHdr const* hdr)
[-] 	switch (hdr.m_code)
[+] 	switch(hdr.m_code)
[-] 		if (hdr.m_paramSize < sizeof (std.Error) ||
[+] 		if (hdr.m_paramSize < sizeof(std.Error) ||
[-] 			std.setError ("machine interface error: ERROR message too small");
[+] 			std.setError("machine interface error: ERROR message too small");
[-] 		std.setError (error);
[+] 		std.setError(error);
[-] 		if (hdr.m_paramSize < sizeof (io.DeviceMonitorMiStartParams))
[+] 		if (hdr.m_paramSize < sizeof(io.DeviceMonitorMiStartParams))
[-] 			std.setError ("machine interface error: START message too small");
[+] 			std.setError("machine interface error: START message too small");
[-] 			m_processor = new SerialMonProcessor_win (m_logWriter);
[+] 			m_processor = new SerialMonProcessor_win(m_logWriter);
[-] 			m_processor = new SerialMonProcessor_lnx (m_logWriter);
[+] 			m_processor = new SerialMonProcessor_lnx(m_logWriter);
[-] 			std.setError ("unsupported target OS");
[+] 			std.setError("unsupported target OS");
[-] 			std.setError ("machine interface error: NOTIFY before START");
[+] 			std.setError("machine interface error: NOTIFY before START");
[-] 		if (hdr.m_paramSize < sizeof (io.DeviceMonitorNotifyHdr) ||
[+] 		if (hdr.m_paramSize < sizeof(io.DeviceMonitorNotifyHdr) ||
[-] 			hdr.m_paramSize < sizeof (io.DeviceMonitorNotifyHdr) + notifyHdr.m_paramSize)
[+] 			hdr.m_paramSize < sizeof(io.DeviceMonitorNotifyHdr) + notifyHdr.m_paramSize)
[-] 			std.setError ("machine interface error: NOTIFY message too small");
[+] 			std.setError("machine interface error: NOTIFY message too small");
[-] 		m_processor.processNotification (notifyHdr);
[+] 		m_processor.processNotification(notifyHdr);
[-] 		std.setError ("machine interface error: undefined message code");
[+] 		std.setError("machine interface error: undefined message code");
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonLogRepresenter.jnc
----------------------
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText ("Port opened");
[+] 		target.addHyperText("Port opened");
[-] 		target.addHyperText ($"PID \e[34m#$pid\e[m: Port opened");
[+] 		target.addHyperText($"PID \e[34m#$pid\e[m: Port opened");
[-] 		target.addHyperText ("Port closed");
[+] 		target.addHyperText("Port closed");
[-] 		return representSerialLog (target, recordCode, p, size, foldFlags);
[+] 		return representSerialLog(target, recordCode, p, size, foldFlags);
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonProcessor.jnc
----------------------
[-] 	construct (log.Writer* logWriter)
[+] 	construct(log.Writer* logWriter)
[-] 		reset ();
[+] 		reset();
[-] 	reset ()
[+] 	reset()
[-] 	abstract processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	abstract processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr);
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonProcessor_lnx.jnc
----------------------
[-] 	unsigned char c_cc [NCC];
[+] 	unsigned char c_cc[NCC];
[-] 	cc_t c_cc [NCCS];
[+] 	cc_t c_cc[NCCS];
[-] 	construct (log.Writer* logWriter)
[+] 	construct(log.Writer* logWriter)
[-] 		basetype.construct (logWriter);
[+] 		basetype.construct(logWriter);
[-] 	override processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	override processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr);
[-] 	processIoctlNotification (
[+] 	processIoctlNotification(
[-] 	processTermiosSetAttr (
[+] 	processTermiosSetAttr(
[-] SerialMonProcessor_lnx.processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr)
[+] SerialMonProcessor_lnx.processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr)
[-] 	switch (notifyHdr.m_code)
[+] 	switch(notifyHdr.m_code)
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (notifyHdr. m_processId)
[+] 			sizeof(notifyHdr. m_processId)
[-] 		m_logWriter.write (notifyHdr.m_timestamp, SerialMonLogRecordCode.DeviceClosed);
[+] 		m_logWriter.write(notifyHdr.m_timestamp, SerialMonLogRecordCode.DeviceClosed);
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 		processIoctlNotification (
[+] 		processIoctlNotification(
[-] SerialMonProcessor_lnx.processIoctlNotification (
[+] SerialMonProcessor_lnx.processIoctlNotification(
[-] 	switch (code)
[+] 	switch(code)
[-] 		if (argDataSize < sizeof (psx.termio))
[+] 		if (argDataSize < sizeof(psx.termio))
[-] 		processTermiosSetAttr (timestamp, attr.c_cflag, attr.c_iflag, 0);
[+] 		processTermiosSetAttr(timestamp, attr.c_cflag, attr.c_iflag, 0);
[-] 		if (argDataSize < sizeof (psx.termios))
[+] 		if (argDataSize < sizeof(psx.termios))
[-] 		processTermiosSetAttr (timestamp, attr.c_cflag, attr.c_iflag, attr.c_ospeed);
[+] 		processTermiosSetAttr(timestamp, attr.c_cflag, attr.c_iflag, attr.c_ospeed);
[-] 		if (argDataSize < sizeof (uint_t))
[+] 		if (argDataSize < sizeof(uint_t))
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 				sizeof (params)
[+] 				sizeof(params)
[-] 		if (argDataSize < sizeof (uint_t))
[+] 		if (argDataSize < sizeof(uint_t))
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 				sizeof (value)
[+] 				sizeof(value)
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 				sizeof (value)
[+] 				sizeof(value)
[-] SerialMonProcessor_lnx.processTermiosSetAttr (
[+] SerialMonProcessor_lnx.processTermiosSetAttr(
[-] 	switch (speed)
[+] 	switch(speed)
[-] 	switch (byteSize)
[+] 	switch(byteSize)
[-] 	m_logWriter.write (
[+] 	m_logWriter.write(
[-] 		sizeof (baudRate)
[+] 		sizeof(baudRate)
[-] 	m_logWriter.write (
[+] 	m_logWriter.write(
[-] 		sizeof (dataBits)
[+] 		sizeof(dataBits)
[-] 	m_logWriter.write (
[+] 	m_logWriter.write(
[-] 		sizeof (stopBits)
[+] 		sizeof(stopBits)
[-] 	m_logWriter.write (
[+] 	m_logWriter.write(
[-] 		sizeof (parity)
[+] 		sizeof(parity)
[-] 	m_logWriter.write (
[+] 	m_logWriter.write(
[-] 		sizeof (flowControl)
[+] 		sizeof(flowControl)
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonProcessor_win.jnc
----------------------
[-] 	construct (log.Writer* logWriter)
[+] 	construct(log.Writer* logWriter)
[-] 		basetype.construct (logWriter);
[+] 		basetype.construct(logWriter);
[-] 	override processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr);
[+] 	override processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr);
[-] 	processIoctlNotification (
[+] 	processIoctlNotification(
[-] SerialMonProcessor_win.processNotification (io.DeviceMonitorNotifyHdr const* notifyHdr)
[+] SerialMonProcessor_win.processNotification(io.DeviceMonitorNotifyHdr const* notifyHdr)
[-] 	switch (notifyHdr.m_code)
[+] 	switch(notifyHdr.m_code)
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (notifyHdr. m_processId)
[+] 			sizeof(notifyHdr. m_processId)
[-] 		m_logWriter.write (notifyHdr.m_timestamp, SerialMonLogRecordCode.DeviceClosed);
[+] 		m_logWriter.write(notifyHdr.m_timestamp, SerialMonLogRecordCode.DeviceClosed);
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 		processIoctlNotification (
[+] 		processIoctlNotification(
[-] SerialMonProcessor_win.processIoctlNotification (
[+] SerialMonProcessor_win.processIoctlNotification(
[-] 	switch (code)
[+] 	switch(code)
[-] 		if (inDataSize < sizeof (uint32_t))
[+] 		if (inDataSize < sizeof(uint32_t))
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (uint32_t)
[+] 			sizeof(uint32_t)
[-] 		if (inDataSize < sizeof (wdk.SERIAL_LINE_CONTROL))
[+] 		if (inDataSize < sizeof(wdk.SERIAL_LINE_CONTROL))
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (dataBits)
[+] 			sizeof(dataBits)
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (stopBits)
[+] 			sizeof(stopBits)
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (parity)
[+] 			sizeof(parity)
[-] 		if (inDataSize < sizeof (wdk.SERIAL_HANDFLOW))
[+] 		if (inDataSize < sizeof(wdk.SERIAL_HANDFLOW))
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (flowControl)
[+] 			sizeof(flowControl)
[-] 		if (outDataSize < sizeof (uint_t))
[+] 		if (outDataSize < sizeof(uint_t))
[-] 			m_logWriter.write (
[+] 			m_logWriter.write(
[-] 				sizeof (params)
[+] 				sizeof(params)
[-] 		if (inDataSize < sizeof (char))
[+] 		if (inDataSize < sizeof(char))
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (dtr)
[+] 			sizeof(dtr)
[-] 		m_logWriter.write (
[+] 		m_logWriter.write(
[-] 			sizeof (rts)
[+] 			sizeof(rts)
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SerialMonSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	close ();
[+] 	close();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? close () : try capture ();
[+] 		m_state ? close() : try capture();
[-] 	onPortComboEnter ()
[+] 	onPortComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	createUi ();
[+] 	createUi();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] SerialMonSession.construct (doc.PluginHost* pluginHost)
[+] SerialMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_monitor.construct (this);
[+] 	m_monitor.construct(this);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SerialMonSession.createUi ()
[+] SerialMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Refresh port list", "images/refresh.png");
[+] 	m_actionTable[ActionId.Refresh] = createAction("Refresh port list", "images/refresh.png");
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumeratePorts;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumeratePorts;
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_portProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (
[+] 	m_bufferPropertySet.createProperties(
[-] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_pendingNotifySizeLimitProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumeratePorts ();
[+] 	enumeratePorts();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] SerialMonSession.enumeratePorts ()
[+] SerialMonSession.enumeratePorts()
[-] 	m_portCombo.clear ();
[+] 	m_portCombo.clear();
[-] 	io.SerialPortDesc const* portList = io.createSerialPortDescList (&count);
[+] 	io.SerialPortDesc const* portList = io.createSerialPortDescList(&count);
[-] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionArray = new gui.EnumPropertyOption[count];
[-] 		m_portCombo.addItem (description, port.m_deviceName);
[+] 		m_portCombo.addItem(description, port.m_deviceName);
[-] 	m_portProp.setOptions (optionArray, count);
[+] 	m_portProp.setOptions(optionArray, count);
[-] bool errorcode SerialMonSession.capture ()
[+] bool errorcode SerialMonSession.capture()
[-] 	close ();
[+] 	close();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_monitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_monitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] 	m_monitor.capture (name);
[+] 	m_monitor.capture(name);
[-] 	writeLogString (DeviceMonLogRecordCode.CaptureStarted_name, name);
[+] 	writeLogString(DeviceMonLogRecordCode.CaptureStarted_name, name);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	m_monitor.close ();
[+] 	m_monitor.close();
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] SerialMonSession.close ()
[+] SerialMonSession.close()
[-] 	writeLog (DeviceMonLogRecordCode.CaptureStopped);
[+] 	writeLog(DeviceMonLogRecordCode.CaptureStopped);
[-] 	m_monitor.close ();
[+] 	m_monitor.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void SerialMonSession.load (doc.Storage* storage)
[+] void SerialMonSession.load(doc.Storage* storage)
[-] 	m_portCombo.m_editText = storage.readString ("portName");
[+] 	m_portCombo.m_editText = storage.readString("portName");
[-] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt ("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[+] 	m_pendingNotifySizeLimitProp.m_value = storage.readInt("pendingNotifySizeLimit", Defaults.PendingNotifySizeLimit);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_monitor.setReadBufferSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_monitor.setReadBufferSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SerialMonSession.save (doc.Storage* storage)
[+] void SerialMonSession.save(doc.Storage* storage)
[-] 	storage.writeString ("portName", m_portCombo.m_editText);
[+] 	storage.writeString("portName", m_portCombo.m_editText);
[-] 	storage.writeInt ("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[+] 	storage.writeInt("pendingNotifySizeLimit", m_pendingNotifySizeLimitProp.m_value);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void SerialMonSession.updateProperties ()
[+] void SerialMonSession.updateProperties()
[-] bool errorcode SerialMonSession.applyProperties ()
[+] bool errorcode SerialMonSession.applyProperties()
[-] 	m_monitor.applyProperties (m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[+] 	m_monitor.applyProperties(m_bufferPropertySet, m_pendingNotifySizeLimitProp.m_value);
[-] void SerialMonSession.restoreDefaultProperties ()
[+] void SerialMonSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Capturing" : "Closed";
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialMon\SshSerialMonSession.jnc
----------------------
[-] 	static char const* m_stateStringTable [] =
[+] 	static char const* m_stateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode connect ();
[+] 	bool errorcode connect();
[-] 	bool errorcode connect (io.SocketAddress const* address);
[+] 	bool errorcode connect(io.SocketAddress const* address);
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onConnect ()
[+] 	onConnect()
[-] 		m_state ? disconnect () : try connect ();
[+] 		m_state ? disconnect() : try connect();
[-] 	onComboEnter ()
[+] 	onComboEnter()
[-] 		try connect ();
[+] 		try connect();
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onLoginDlgCompleted (gui.StdDlgButton button);
[+] 	onLoginDlgCompleted(gui.StdDlgButton button);
[-] 	onConsoleSizeChanged ();
[+] 	onConsoleSizeChanged();
[-] 	onSshEvent (
[+] 	onSshEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	handleConnectError (std.Error const* error);
[+] 	handleConnectError(std.Error const* error);
[-] 	handleSshAuthenticateError (std.Error const* error);
[+] 	handleSshAuthenticateError(std.Error const* error);
[-] SshSerialMonSession.construct (doc.PluginHost* pluginHost)
[+] SshSerialMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_monitor.construct (pluginHost.m_log.m_writer);
[+] 	m_monitor.construct(pluginHost.m_log.m_writer);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SshSerialMonSession.createUi ()
[+] SshSerialMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Address:");
[+] 	m_pluginHost.m_toolBar.addLabel("Address:");
[-] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Connect] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Connect] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Connect] = createAction ("Connect && capture", m_iconTable [IconId.Connect]);
[+] 	m_actionTable[ActionId.Connect] = createAction("Connect && capture", m_iconTable [IconId.Connect]);
[-] 	m_actionTable [ActionId.Connect].m_onTriggered += onConnect;
[+] 	m_actionTable[ActionId.Connect].m_onTriggered += onConnect;
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (m_pluginHost.m_propertyGrid, group);
[+] 	m_socketPropertySet.createProperties(m_pluginHost.m_propertyGrid, group);
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_sshPropertySet.createProperties (
[+] 	m_sshPropertySet.createProperties(
[-] 	m_bufferPropertySet.createPropertiesGrouped (
[+] 	m_bufferPropertySet.createPropertiesGrouped(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("SSH session");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("SSH session");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode SshSerialMonSession.connect ()
[+] bool errorcode SshSerialMonSession.connect()
[-] 	disconnect ();
[+] 	disconnect();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_addressCombo.addEditTextToHistory ();
[+] 	m_addressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try address.parse (addressString);
[+] 	bool isDirectAddress = try address.parse(addressString);
[-] 		return try connect (&address);
[+] 		return try connect(&address);
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (addressString)
[+] 		strlen(addressString)
[-] 	m_resolver.resolve (addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_resolver.resolve(addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] bool errorcode SshSerialMonSession.connect (io.SocketAddress const* remoteAddress)
[+] bool errorcode SshSerialMonSession.connect(io.SocketAddress const* remoteAddress)
[-] 	disconnect ();
[+] 	disconnect();
[-] 	m_monitor.reset ();
[+] 	m_monitor.reset();
[-] 	m_ssh.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_ssh.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 		m_ssh.open (remoteAddress.m_family); // any address
[+] 		m_ssh.open(remoteAddress.m_family); // any address
[-] 		localAddress.m_ip4.m_port = (uint16_t) m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[+] 		localAddress.m_ip4.m_port = (uint16_t)m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[-] 		m_ssh.open (&localAddress);
[+] 		m_ssh.open(&localAddress);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 		privateKey = loadFile (m_sshPropertySet.m_privateKeyFileProp.m_value);
[+] 		privateKey = loadFile(m_sshPropertySet.m_privateKeyFileProp.m_value);
[-] 	params.m_privateKeySize = dynamic sizeof (privateKey);
[+] 	params.m_privateKeySize = dynamic sizeof(privateKey);
[-] 	params.m_processExtraSize = strlen (params.m_processExtra);
[+] 	params.m_processExtraSize = strlen(params.m_processExtra);
[-] 	m_ssh.connect (&params);
[+] 	m_ssh.connect(&params);
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] SshSerialMonSession.waitSshEvents ()
[+] SshSerialMonSession.waitSshEvents()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 	m_ssh.wait (eventMask, onSshEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_ssh.wait(eventMask, onSshEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] SshSerialMonSession.handleConnectError (std.Error const* error)
[+] SshSerialMonSession.handleConnectError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] SshSerialMonSession.handleSshAuthenticateError (std.Error const* error)
[+] SshSerialMonSession.handleSshAuthenticateError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_loginDlg.show ();
[+] 	m_loginDlg.show();
[-] SshSerialMonSession.onLoginDlgCompleted (gui.StdDlgButton button)
[+] SshSerialMonSession.onLoginDlgCompleted(gui.StdDlgButton button)
[-] 		m_ssh.close ();
[+] 		m_ssh.close();
[-] 	if (strcmp (m_loginDlg.m_userName, m_sshPropertySet.m_userNameProp.m_value) == 0)
[+] 	if (strcmp(m_loginDlg.m_userName, m_sshPropertySet.m_userNameProp.m_value) == 0)
[-] 		writeLog (SshLogRecordCode.SshAuthenticating);
[+] 		writeLog(SshLogRecordCode.SshAuthenticating);
[-] 		writeLog (SshLogRecordCode.Reconnecting);
[+] 		writeLog(SshLogRecordCode.Reconnecting);
[-] 	switch (m_loginDlg.m_authenticationMethod)
[+] 	switch(m_loginDlg.m_authenticationMethod)
[-] 		m_ssh.authenticate (m_loginDlg.m_userName, null, 0, m_loginDlg.m_password);
[+] 		m_ssh.authenticate(m_loginDlg.m_userName, null, 0, m_loginDlg.m_password);
[-] 		void const* privateKey = loadFile (m_loginDlg.m_privateKeyFileName);
[+] 		void const* privateKey = loadFile(m_loginDlg.m_privateKeyFileName);
[-] 		m_ssh.authenticate (
[+] 		m_ssh.authenticate(
[-] 			dynamic sizeof (privateKey),
[+] 			dynamic sizeof(privateKey),
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] SshSerialMonSession.onConsoleSizeChanged ()
[+] SshSerialMonSession.onConsoleSizeChanged()
[-] 	m_ssh.resizePty (
[+] 	m_ssh.resizePty(
[-] SshSerialMonSession.disconnect ()
[+] SshSerialMonSession.disconnect()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		writeLog (SocketLogRecordCode.ConnectCancelled);
[+] 		writeLog(SocketLogRecordCode.ConnectCancelled);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void SshSerialMonSession.load (doc.Storage* storage)
[+] void SshSerialMonSession.load(doc.Storage* storage)
[-] 	m_addressCombo.loadHistory (storage, "addressHistory");
[+] 	m_addressCombo.loadHistory(storage, "addressHistory");
[-] 	m_addressCombo.m_editText = storage.readString ("address");
[+] 	m_addressCombo.m_editText = storage.readString("address");
[-] 	m_portCombo.loadHistory (storage, "portHistory");
[+] 	m_portCombo.loadHistory(storage, "portHistory");
[-] 	m_portCombo.m_editText = storage.readString ("port");
[+] 	m_portCombo.m_editText = storage.readString("port");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_sshPropertySet.load (storage);
[+] 	m_sshPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SshSerialMonSession.save (doc.Storage* storage)
[+] void SshSerialMonSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_sshPropertySet.save (storage);
[+] 	m_sshPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_addressCombo.saveHistory (storage, "addressHistory");
[+] 	m_addressCombo.saveHistory(storage, "addressHistory");
[-] 	storage.writeString ("address", m_addressCombo.m_editText);
[+] 	storage.writeString("address", m_addressCombo.m_editText);
[-] 	m_portCombo.saveHistory (storage, "portHistory");
[+] 	m_portCombo.saveHistory(storage, "portHistory");
[-] 	storage.writeString ("port", m_portCombo.m_editText);
[+] 	storage.writeString("port", m_portCombo.m_editText);
[-] void SshSerialMonSession.updateProperties ()
[+] void SshSerialMonSession.updateProperties()
[-] bool errorcode SshSerialMonSession.applyProperties ()
[+] bool errorcode SshSerialMonSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_ssh.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_ssh.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] void SshSerialMonSession.restoreDefaultProperties ()
[+] void SshSerialMonSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_sshPropertySet.restoreDefaults ();
[+] 	m_sshPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] SshSerialMonSession.onSshEvent (
[+] SshSerialMonSession.onSshEvent(
[-] 		handleConnectError (m_ssh.m_ioError);
[+] 		handleConnectError(m_ssh.m_ioError);
[-] 		handleSshAuthenticateError (m_ssh.m_ioError);
[+] 		handleSshAuthenticateError(m_ssh.m_ioError);
[-] 		writeLog (SshLogRecordCode.TcpConnectCompleted);
[+] 		writeLog(SshLogRecordCode.TcpConnectCompleted);
[-] 		writeLog (SshLogRecordCode.SshHandshakeCompleted);
[+] 		writeLog(SshLogRecordCode.SshHandshakeCompleted);
[-] 		writeLog (SshLogRecordCode.SshAuthCompleted);
[+] 		writeLog(SshLogRecordCode.SshAuthCompleted);
[-] 		writeLog (SshLogRecordCode.SshChannelOpened);
[+] 		writeLog(SshLogRecordCode.SshChannelOpened);
[-] 		writeLog (SshLogRecordCode.SshPtyRequested);
[+] 		writeLog(SshLogRecordCode.SshPtyRequested);
[-] 		writeLog (SshLogRecordCode.SshProcessStarted);
[+] 		writeLog(SshLogRecordCode.SshProcessStarted);
[-] 		writeLog (SshLogRecordCode.ConnectCompleted);
[+] 		writeLog(SshLogRecordCode.ConnectCompleted);
[-] 		m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 		m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 			size_t size = m_ssh.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t size = m_ssh.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			m_monitor.write (m_readBuffer.m_p, size);
[+] 			m_monitor.write(m_readBuffer.m_p, size);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 		m_ssh.close ();
[+] 		m_ssh.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		size_t size = m_ssh.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t size = m_ssh.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			m_monitor.write (m_readBuffer.m_p, size);
[+] 			m_monitor.write(m_readBuffer.m_p, size);
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	m_pluginHost.m_log.m_writer.writeLastError (log.StdRecordCode.Error);
[+] 	m_pluginHost.m_log.m_writer.writeLastError(log.StdRecordCode.Error);
[-] 	disconnect ();
[+] 	disconnect();
[-] SshSerialMonSession.onResolveCompleted (
[+] SshSerialMonSession.onResolveCompleted(
[-] 		handleConnectError (error);
[+] 		handleConnectError(error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	io.SocketAddress address = addressTable [0];
[+] 	io.SocketAddress address = addressTable[0];
[-] 	connect (&address);
[+] 	connect(&address);
[-] 	m_actionTable [ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect && capture";
[+] 	m_actionTable[ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect && capture";
[-] 	m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? IconId.Disconnect : IconId.Connect];
[+] 	m_actionTable[ActionId.Connect].m_icon = m_iconTable[m_state ? IconId.Disconnect : IconId.Connect];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_stateStringTable[m_state];
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString () : "<peer-address>";
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString() : "<peer-address>";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[-] void const* loadFile (char const* fileName)
[+] void const* loadFile(char const* fileName)
[-] 	file.open (fileName, io.FileOpenFlags.ReadOnly);
[+] 	file.open(fileName, io.FileOpenFlags.ReadOnly);
[-] 	void* p = new char [size];
[+] 	void* p = new char[size];
[-] 	file.read (p, size);
[+] 	file.read(p, size);
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SerialTap\SerialTapSession.jnc
----------------------
[-] bool getGpioPin (
[+] bool getGpioPin(
[-] 	try device.controlTransfer (
[+] 	try device.controlTransfer(
[-] 		sizeof (uint16_t)
[+] 		sizeof(uint16_t)
[-] 	bool errorcode claim (
[+] 	bool errorcode claim(
[-] 	release ();
[+] 	release();
[-] bool errorcode SerialIface.claim (
[+] bool errorcode SerialIface.claim(
[-] 	m_interface = device.claimInterface (ifaceId);
[+] 	m_interface = device.claimInterface(ifaceId);
[-] 	m_bulkEndpoint = m_interface.openEndpoint (ifaceId ? 0x85 : 0x82);
[+] 	m_bulkEndpoint = m_interface.openEndpoint(ifaceId ? 0x85 : 0x82);
[-] 	m_interruptEndpoint = m_interface.openEndpoint (ifaceId ? 0x86 : 0x83);
[+] 	m_interruptEndpoint = m_interface.openEndpoint(ifaceId ? 0x86 : 0x83);
[-] 	bool dsr = getGpioPin (device, ifaceId ? UartGpioPin.Dsr : UartGpioPin.Dtr);
[+] 	bool dsr = getGpioPin(device, ifaceId ? UartGpioPin.Dsr : UartGpioPin.Dtr);
[-] 	bool cts = getGpioPin (device, ifaceId ? UartGpioPin.Cts : UartGpioPin.Rts);
[+] 	bool cts = getGpioPin(device, ifaceId ? UartGpioPin.Cts : UartGpioPin.Rts);
[-] SerialIface.release ()
[+] SerialIface.release()
[-] 		m_bulkEndpoint.close ();
[+] 		m_bulkEndpoint.close();
[-] 		m_interruptEndpoint.close ();
[+] 		m_interruptEndpoint.close();
[-] 		m_interface.release ();
[+] 		m_interface.release();
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.InformationValue* m_infoTable [InfoId._Count];
[+] 	gui.InformationValue* m_infoTable[InfoId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? stopCapture () : try capture ();
[+] 		m_state ? stopCapture() : try capture();
[-] 	onDeviceComboEnter ()
[+] 	onDeviceComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onBaudRateChanged ();
[+] 	onBaudRateChanged();
[-] 	onBulkEndpointEvent (
[+] 	onBulkEndpointEvent(
[-] 	onInterruptEndpointEvent (
[+] 	onInterruptEndpointEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	flipDteDce ();
[+] 	flipDteDce();
[-] 	waitBulkEndpointEvents (SerialIface* iface);
[+] 	waitBulkEndpointEvents(SerialIface* iface);
[-] 	waitInterruptEndpointEvents (SerialIface* iface);
[+] 	waitInterruptEndpointEvents(SerialIface* iface);
[-] 	bool errorcode configureSerialIface (uint_t ifaceId);
[+] 	bool errorcode configureSerialIface(uint_t ifaceId);
[-] 	bool getGpio (uint_t pin);
[+] 	bool getGpio(uint_t pin);
[-] 	updateLineInfoValue (
[+] 	updateLineInfoValue(
[-] SerialTapSession.construct (doc.PluginHost* pluginHost)
[+] SerialTapSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SerialTapSession.createUi ()
[+] SerialTapSession.createUi()
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Tap:");
[+] 	m_pluginHost.m_toolBar.addLabel("Tap:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Re-enumerate devices", "images/refresh.png");
[+] 	m_actionTable[ActionId.Refresh] = createAction("Re-enumerate devices", "images/refresh.png");
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPane = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPane = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_serialSettingUi.create (
[+] 	m_serialSettingUi.create(
[-] 	bindingof (m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[+] 	bindingof(m_serialSettingUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
[-] 	m_pluginHost.m_menu.addSeparator ();
[+] 	m_pluginHost.m_menu.addSeparator();
[-] 	m_actionTable [ActionId.Flip] = createAction ("Flip DTE/DCE", "images/flip.png");
[+] 	m_actionTable[ActionId.Flip] = createAction("Flip DTE/DCE", "images/flip.png");
[-] 	m_actionTable [ActionId.Flip].m_isCheckable = true;
[+] 	m_actionTable[ActionId.Flip].m_isCheckable = true;
[-] 	m_actionTable [ActionId.Flip].m_onTriggered = flipDteDce;
[+] 	m_actionTable[ActionId.Flip].m_onTriggered = flipDteDce;
[-] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group,, mask);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group,, mask);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial tap");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial tap");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_infoTable [InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DTR");
[+] 	m_infoTable[InfoId.Dtr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DTR");
[-] 	m_infoTable [InfoId.Rts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "RTS");
[+] 	m_infoTable[InfoId.Rts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "RTS");
[-] 	m_infoTable [InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "DSR");
[+] 	m_infoTable[InfoId.Dsr] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "DSR");
[-] 	m_infoTable [InfoId.Cts] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "CTS");
[+] 	m_infoTable[InfoId.Cts] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "CTS");
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] SerialTapSession.enumerateDevices ()
[+] SerialTapSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [ftdiCount].m_text = text;
[+] 		optionTable[ftdiCount].m_text = text;
[-] 		optionTable [ftdiCount].m_value = device;
[+] 		optionTable[ftdiCount].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, ftdiCount);
[+] 	m_deviceProp.setOptions(optionTable, ftdiCount);
[-] SerialTapSession.flipDteDce ()
[+] SerialTapSession.flipDteDce()
[-] 	m_uiReactor.restart (); // need to re-bind DTE/DCE
[+] 	m_uiReactor.restart(); // need to re-bind DTE/DCE
[-] bool errorcode SerialTapSession.configureSerialIface (uint_t ifaceId)
[+] bool errorcode SerialTapSession.configureSerialIface(uint_t ifaceId)
[-] 	size_t result = m_device.controlTransfer (
[+] 	size_t result = m_device.controlTransfer(
[-] 		sizeof (uartConfig)
[+] 		sizeof(uartConfig)
[-] bool errorcode SerialTapSession.capture ()
[+] bool errorcode SerialTapSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	configureSerialIface (0);
[+] 	configureSerialIface(0);
[-] 	configureSerialIface (1);
[+] 	configureSerialIface(1);
[-] 	if (m_actionTable [ActionId.Flip].m_isChecked)
[+] 	if (m_actionTable[ActionId.Flip].m_isChecked)
[-] 		m_dceIface.claim (m_device, 0);
[+] 		m_dceIface.claim(m_device, 0);
[-] 		m_dteIface.claim (m_device, 1);
[+] 		m_dteIface.claim(m_device, 1);
[-] 		m_dteIface.claim (m_device, 0);
[+] 		m_dteIface.claim(m_device, 0);
[-] 		m_dceIface.claim (m_device, 1);
[+] 		m_dceIface.claim(m_device, 1);
[-] 	writeLog (SerialLogRecordCode.PortOpened, p, dynamic sizeof (p));
[+] 	writeLog(SerialLogRecordCode.PortOpened, p, dynamic sizeof(p));
[-] 	waitBulkEndpointEvents (m_dteIface);
[+] 	waitBulkEndpointEvents(m_dteIface);
[-] 	waitBulkEndpointEvents (m_dceIface);
[+] 	waitBulkEndpointEvents(m_dceIface);
[-] 	waitInterruptEndpointEvents (m_dteIface);
[+] 	waitInterruptEndpointEvents(m_dteIface);
[-] 	waitInterruptEndpointEvents (m_dceIface);
[+] 	waitInterruptEndpointEvents(m_dceIface);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_dteIface.release ();
[+] 	m_dteIface.release();
[-] 	m_dceIface.release ();
[+] 	m_dceIface.release();
[-] 		m_device.close ();
[+] 		m_device.close();
[-] SerialTapSession.stopCapture ()
[+] SerialTapSession.stopCapture()
[-] 	writeLog (SerialLogRecordCode.PortClosed);
[+] 	writeLog(SerialLogRecordCode.PortClosed);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] 	m_dteIface.release ();
[+] 	m_dteIface.release();
[-] 	m_dceIface.release ();
[+] 	m_dceIface.release();
[-] 	m_device.close ();
[+] 	m_device.close();
[-] SerialTapSession.waitBulkEndpointEvents (SerialIface* iface)
[+] SerialTapSession.waitBulkEndpointEvents(SerialIface* iface)
[-] 	iface.m_bulkEndpoint.wait (
[+] 	iface.m_bulkEndpoint.wait(
[-] SerialTapSession.waitInterruptEndpointEvents (SerialIface* iface)
[+] SerialTapSession.waitInterruptEndpointEvents(SerialIface* iface)
[-] 	iface.m_interruptEndpoint.wait (
[+] 	iface.m_interruptEndpoint.wait(
[-] SerialTapSession.onBulkEndpointEvent (
[+] SerialTapSession.onBulkEndpointEvent(
[-] 		writeLog (log.StdRecordCode.Error, iface.m_bulkEndpoint.m_ioError, iface.m_bulkEndpoint.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, iface.m_bulkEndpoint.m_ioError, iface.m_bulkEndpoint.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = iface.m_bulkEndpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = iface.m_bulkEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (recordCode, m_readBuffer.m_p, result);
[+] 			writeLog(recordCode, m_readBuffer.m_p, result);
[-] 	waitBulkEndpointEvents (iface);
[+] 	waitBulkEndpointEvents(iface);
[-] SerialTapSession.onInterruptEndpointEvent (
[+] SerialTapSession.onInterruptEndpointEvent(
[-] 		writeLog (log.StdRecordCode.Error, iface.m_interruptEndpoint.m_ioError, iface.m_interruptEndpoint.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, iface.m_interruptEndpoint.m_ioError, iface.m_interruptEndpoint.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		size_t result = iface.m_interruptEndpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = iface.m_interruptEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 		if (result >= 10 && (m_readBuffer [6] & 0x02))
[+] 		if (result >= 10 && (m_readBuffer[6] & 0x02))
[-] 			if (m_readBuffer [8] & 0x02)
[+] 			if (m_readBuffer[8] & 0x02)
[-] 			if (m_readBuffer [8] & 0x01)
[+] 			if (m_readBuffer[8] & 0x01)
[-] 				writeLog (recordCode, params, sizeof (params));
[+] 				writeLog(recordCode, params, sizeof(params));
[-] 	waitInterruptEndpointEvents (iface);
[+] 	waitInterruptEndpointEvents(iface);
[-] void SerialTapSession.load (doc.Storage* storage)
[+] void SerialTapSession.load(doc.Storage* storage)
[-] 	m_serialSettingUi.load (storage);
[+] 	m_serialSettingUi.load(storage);
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_actionTable [ActionId.Flip].m_isChecked = storage.readBool ("flipDteDce");
[+] 	m_actionTable[ActionId.Flip].m_isChecked = storage.readBool("flipDteDce");
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SerialTapSession.save (doc.Storage* storage)
[+] void SerialTapSession.save(doc.Storage* storage)
[-] 	m_serialSettingUi.save (storage);
[+] 	m_serialSettingUi.save(storage);
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[+] 	storage.writeBool("flipDteDce", m_actionTable [ActionId.Flip].m_isChecked);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void SerialTapSession.updateProperties ()
[+] void SerialTapSession.updateProperties()
[-] 	m_serialSettingUi.updateProperties ();
[+] 	m_serialSettingUi.updateProperties();
[-] 	m_flipProp.m_value = m_actionTable [ActionId.Flip].m_isChecked;
[+] 	m_flipProp.m_value = m_actionTable[ActionId.Flip].m_isChecked;
[-] bool errorcode SerialTapSession.applyProperties ()
[+] bool errorcode SerialTapSession.applyProperties()
[-] 	m_serialSettingUi.applyProperties ();
[+] 	m_serialSettingUi.applyProperties();
[-] 	m_actionTable [ActionId.Flip].m_isChecked = m_flipProp.m_value;
[+] 	m_actionTable[ActionId.Flip].m_isChecked = m_flipProp.m_value;
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 		writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 		writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 		writeLog (SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof (dataBits));
[+] 		writeLog(SerialLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
[-] 		writeLog (SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof (stopBits));
[+] 		writeLog(SerialLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));
[-] 		writeLog (SerialLogRecordCode.ParityChanged, &parity, sizeof (parity));
[+] 		writeLog(SerialLogRecordCode.ParityChanged, &parity, sizeof(parity));
[-] 	configureSerialIface (0);
[+] 	configureSerialIface(0);
[-] 	configureSerialIface (1);
[+] 	configureSerialIface(1);
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] void SerialTapSession.restoreDefaultProperties ()
[+] void SerialTapSession.restoreDefaultProperties()
[-] 	m_serialSettingUi.restoreDefaultProperties ();
[+] 	m_serialSettingUi.restoreDefaultProperties();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] SerialTapSession.onBaudRateChanged ()
[+] SerialTapSession.onBaudRateChanged()
[-] 	configureSerialIface (0);
[+] 	configureSerialIface(0);
[-] 	configureSerialIface (1);
[+] 	configureSerialIface(1);
[-] 	writeLog (SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof (baudRate));
[+] 	writeLog(SerialLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] SerialTapSession.updateLineInfoValue (
[+] SerialTapSession.updateLineInfoValue(
[-] 	m_infoTable [infoId].m_value = line ? "on" : "off";
[+] 	m_infoTable[infoId].m_value = line ? "on" : "off";
[-] 	m_infoTable [infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[+] 	m_infoTable[infoId].m_valueColor = line ? gui.StdColor.LightRed : gui.StdColor.Gray;
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_infoTable [InfoId.Dtr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dtr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Rts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Rts].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Dsr].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Dsr].m_isEnabled = m_state;
[-] 	m_infoTable [InfoId.Cts].m_isEnabled = m_state;
[+] 	m_infoTable[InfoId.Cts].m_isEnabled = m_state;
[-] 	updateLineInfoValue (InfoId.Dtr, m_dceIface.m_serialStatusLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dtr, m_dceIface.m_serialStatusLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Rts, m_dceIface.m_serialStatusLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Rts, m_dceIface.m_serialStatusLines & io.SerialStatusLines.Cts);
[-] 	updateLineInfoValue (InfoId.Dsr, m_dteIface.m_serialStatusLines & io.SerialStatusLines.Dsr);
[+] 	updateLineInfoValue(InfoId.Dsr, m_dteIface.m_serialStatusLines & io.SerialStatusLines.Dsr);
[-] 	updateLineInfoValue (InfoId.Cts, m_dteIface.m_serialStatusLines & io.SerialStatusLines.Cts);
[+] 	updateLineInfoValue(InfoId.Cts, m_dteIface.m_serialStatusLines & io.SerialStatusLines.Cts);
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SocketLog\SocketLogRepresenter.jnc
----------------------
[-] bool representSocketLog (
[+] bool representSocketLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		char const* addressString = address.getString ();
[+] 		char const* addressString = address.getString();
[-] 		target.addHyperText ($"Cannot open socket at \e[34m$addressString\e[m: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open socket at \e[34m$addressString\e[m: $(error.m_description)");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText (SocketLogPartCode.Connecting, $"Resolving \e[34m$addressString\e[m...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, $"Resolving \e[34m$addressString\e[m...");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText (SocketLogPartCode.Connecting, $"Connecting to \e[34m$addressString\e[m...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, $"Connecting to \e[34m$addressString\e[m...");
[-] 		char const* remoteAddressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* remoteAddressString = ((io.SocketAddress const*) p).getString();
[-] 		char const* localAddressString = ((io.SocketAddress const*) p + 1).getString ();
[+] 		char const* localAddressString = ((io.SocketAddress const*) p + 1).getString();
[-] 		target.addHyperText (SocketLogPartCode.Connecting, $"Connecting to \e[34m$remoteAddressString\e[m from \e[34m$localAddressString\e[m...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, $"Connecting to \e[34m$remoteAddressString\e[m from \e[34m$localAddressString\e[m...");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, $"ok (\e[34m$addressString\e[m)");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, $"ok (\e[34m$addressString\e[m)");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "cancelled");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "cancelled");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, $"error: $(error.m_description)");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, $"error: $(error.m_description)");
[-] 		char const* addressString = params.m_address.getString ();
[+] 		char const* addressString = params.m_address.getString();
[-] 		target.addHyperText ($"Disconnected from \e[34m$addressString\e[m ($closeKind by $initiator node)");
[+] 		target.addHyperText($"Disconnected from \e[34m$addressString\e[m ($closeKind by $initiator node)");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Disconnected from \e[34m$addressString\e[m");
[+] 		target.addHyperText($"Disconnected from \e[34m$addressString\e[m");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Listening on \e[34m$addressString");
[+] 		target.addHyperText($"Listening on \e[34m$addressString");
[-] 		target.addHyperText ($"Cannot listen: $(error.m_description)");
[+] 		target.addHyperText($"Cannot listen: $(error.m_description)");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Stopped listening on \e[34m$addressString");
[+] 		target.addHyperText($"Stopped listening on \e[34m$addressString");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Client connected from \e[34m$addressString");
[+] 		target.addHyperText($"Client connected from \e[34m$addressString");
[-] 		char const* addressString = params.m_address.getString ();
[+] 		char const* addressString = params.m_address.getString();
[-] 		target.addHyperText ($"Client \e[34m$addressString\e[m disconnected ($closeKind by $initiator node)");
[+] 		target.addHyperText($"Client \e[34m$addressString\e[m disconnected ($closeKind by $initiator node)");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Client \e[34m$addressString\e[m is rejected ");
[+] 		target.addHyperText($"Client \e[34m$addressString\e[m is rejected ");
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SshChannel\SshChannelSession.jnc
----------------------
[-] 	static char const* m_stateStringTable [] =
[+] 	static char const* m_stateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode connect ();
[+] 	bool errorcode connect();
[-] 	bool errorcode connect (io.SocketAddress const* address);
[+] 	bool errorcode connect(io.SocketAddress const* address);
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onConnect ()
[+] 	onConnect()
[-] 		m_state ? disconnect () : try connect ();
[+] 		m_state ? disconnect() : try connect();
[-] 	onAddressComboEnter ()
[+] 	onAddressComboEnter()
[-] 		try connect ();
[+] 		try connect();
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onLoginDlgCompleted (gui.StdDlgButton button);
[+] 	onLoginDlgCompleted(gui.StdDlgButton button);
[-] 	onConsoleSizeChanged ();
[+] 	onConsoleSizeChanged();
[-] 	onSshEvent (
[+] 	onSshEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	handleConnectError (std.Error const* error);
[+] 	handleConnectError(std.Error const* error);
[-] 	handleSshAuthenticateError (std.Error const* error);
[+] 	handleSshAuthenticateError(std.Error const* error);
[-] SshChannelSession.construct (doc.PluginHost* pluginHost)
[+] SshChannelSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SshChannelSession.createUi ()
[+] SshChannelSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Address:");
[+] 	m_pluginHost.m_toolBar.addLabel("Address:");
[-] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Connect] = new gui.Icon ("images/connect.png");
[+] 	m_iconTable[IconId.Connect] = new gui.Icon("images/connect.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Connect] = createAction ("Connect", m_iconTable [IconId.Connect]);
[+] 	m_actionTable[ActionId.Connect] = createAction("Connect", m_iconTable [IconId.Connect]);
[-] 	m_actionTable [ActionId.Connect].m_onTriggered += onConnect;
[+] 	m_actionTable[ActionId.Connect].m_onTriggered += onConnect;
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (m_pluginHost.m_propertyGrid, group);
[+] 	m_socketPropertySet.createProperties(m_pluginHost.m_propertyGrid, group);
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_sshPropertySet.createProperties (m_pluginHost.m_propertyGrid, group);
[+] 	m_sshPropertySet.createProperties(m_pluginHost.m_propertyGrid, group);
[-] 	m_bufferPropertySet.createPropertiesGrouped (
[+] 	m_bufferPropertySet.createPropertiesGrouped(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("SSH session");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("SSH session");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode SshChannelSession.connect ()
[+] bool errorcode SshChannelSession.connect()
[-] 	disconnect ();
[+] 	disconnect();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_addressCombo.addEditTextToHistory ();
[+] 	m_addressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try address.parse (addressString);
[+] 	bool isDirectAddress = try address.parse(addressString);
[-] 		return try connect (&address);
[+] 		return try connect(&address);
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (addressString)
[+] 		strlen(addressString)
[-] 	m_resolver.resolve (addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_resolver.resolve(addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] bool errorcode SshChannelSession.connect (io.SocketAddress const* remoteAddress)
[+] bool errorcode SshChannelSession.connect(io.SocketAddress const* remoteAddress)
[-] 	disconnect ();
[+] 	disconnect();
[-] 	m_ssh.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_ssh.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 		m_ssh.open (remoteAddress.m_family); // any address
[+] 		m_ssh.open(remoteAddress.m_family); // any address
[-] 		localAddress.m_ip4.m_port = (uint16_t) m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[+] 		localAddress.m_ip4.m_port = (uint16_t)m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[-] 		m_ssh.open (&localAddress);
[+] 		m_ssh.open(&localAddress);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 		privateKey = loadFile (m_sshPropertySet.m_privateKeyFileProp.m_value);
[+] 		privateKey = loadFile(m_sshPropertySet.m_privateKeyFileProp.m_value);
[-] 	params.m_privateKeySize = dynamic sizeof (privateKey);
[+] 	params.m_privateKeySize = dynamic sizeof(privateKey);
[-] 	params.m_processExtraSize = strlen (params.m_processExtra);
[+] 	params.m_processExtraSize = strlen(params.m_processExtra);
[-] 	m_ssh.connect (&params);
[+] 	m_ssh.connect(&params);
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] SshChannelSession.waitSshEvents ()
[+] SshChannelSession.waitSshEvents()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 	m_ssh.wait (eventMask, onSshEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_ssh.wait(eventMask, onSshEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] SshChannelSession.handleConnectError (std.Error const* error)
[+] SshChannelSession.handleConnectError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] SshChannelSession.handleSshAuthenticateError (std.Error const* error)
[+] SshChannelSession.handleSshAuthenticateError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_loginDlg.show ();
[+] 	m_loginDlg.show();
[-] SshChannelSession.onLoginDlgCompleted (gui.StdDlgButton button)
[+] SshChannelSession.onLoginDlgCompleted(gui.StdDlgButton button)
[-] 		m_ssh.close ();
[+] 		m_ssh.close();
[-] 	if (strcmp (m_loginDlg.m_userName, m_sshPropertySet.m_userNameProp.m_value) == 0)
[+] 	if (strcmp(m_loginDlg.m_userName, m_sshPropertySet.m_userNameProp.m_value) == 0)
[-] 		writeLog (SshLogRecordCode.SshAuthenticating);
[+] 		writeLog(SshLogRecordCode.SshAuthenticating);
[-] 		writeLog (SshLogRecordCode.Reconnecting);
[+] 		writeLog(SshLogRecordCode.Reconnecting);
[-] 	switch (m_loginDlg.m_authenticationMethod)
[+] 	switch(m_loginDlg.m_authenticationMethod)
[-] 		m_ssh.authenticate (m_loginDlg.m_userName, null, 0, m_loginDlg.m_password);
[+] 		m_ssh.authenticate(m_loginDlg.m_userName, null, 0, m_loginDlg.m_password);
[-] 		void const* privateKey = loadFile (m_loginDlg.m_privateKeyFileName);
[+] 		void const* privateKey = loadFile(m_loginDlg.m_privateKeyFileName);
[-] 		m_ssh.authenticate (
[+] 		m_ssh.authenticate(
[-] 			dynamic sizeof (privateKey),
[+] 			dynamic sizeof(privateKey),
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] SshChannelSession.onConsoleSizeChanged ()
[+] SshChannelSession.onConsoleSizeChanged()
[-] 	m_ssh.resizePty (
[+] 	m_ssh.resizePty(
[-] SshChannelSession.disconnect ()
[+] SshChannelSession.disconnect()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		writeLog (SocketLogRecordCode.ConnectCancelled);
[+] 		writeLog(SocketLogRecordCode.ConnectCancelled);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 	m_ssh.close ();
[+] 	m_ssh.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] void SshChannelSession.load (doc.Storage* storage)
[+] void SshChannelSession.load(doc.Storage* storage)
[-] 	m_addressCombo.loadHistory (storage, "addressHistory");
[+] 	m_addressCombo.loadHistory(storage, "addressHistory");
[-] 	m_addressCombo.m_editText = storage.readString ("address");
[+] 	m_addressCombo.m_editText = storage.readString("address");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_sshPropertySet.load (storage);
[+] 	m_sshPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SshChannelSession.save (doc.Storage* storage)
[+] void SshChannelSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_sshPropertySet.save (storage);
[+] 	m_sshPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_addressCombo.saveHistory (storage, "addressHistory");
[+] 	m_addressCombo.saveHistory(storage, "addressHistory");
[-] 	storage.writeString ("address", m_addressCombo.m_editText);
[+] 	storage.writeString("address", m_addressCombo.m_editText);
[-] void SshChannelSession.updateProperties ()
[+] void SshChannelSession.updateProperties()
[-] bool errorcode SshChannelSession.applyProperties ()
[+] bool errorcode SshChannelSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_ssh.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_ssh.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] void SshChannelSession.restoreDefaultProperties ()
[+] void SshChannelSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_sshPropertySet.restoreDefaults ();
[+] 	m_sshPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode SshChannelSession.transmit (
[+] size_t errorcode SshChannelSession.transmit(
[-] 	size_t result = m_ssh.write (p, size);
[+] 	size_t result = m_ssh.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] 		waitSshEvents ();
[+] 		waitSshEvents();
[-] SshChannelSession.onSshEvent (
[+] SshChannelSession.onSshEvent(
[-] 		handleConnectError (m_ssh.m_ioError);
[+] 		handleConnectError(m_ssh.m_ioError);
[-] 		handleSshAuthenticateError (m_ssh.m_ioError);
[+] 		handleSshAuthenticateError(m_ssh.m_ioError);
[-] 		writeLog (SshLogRecordCode.TcpConnectCompleted);
[+] 		writeLog(SshLogRecordCode.TcpConnectCompleted);
[-] 		writeLog (SshLogRecordCode.SshHandshakeCompleted);
[+] 		writeLog(SshLogRecordCode.SshHandshakeCompleted);
[-] 		writeLog (SshLogRecordCode.SshAuthCompleted);
[+] 		writeLog(SshLogRecordCode.SshAuthCompleted);
[-] 		writeLog (SshLogRecordCode.SshChannelOpened);
[+] 		writeLog(SshLogRecordCode.SshChannelOpened);
[-] 		writeLog (SshLogRecordCode.SshPtyRequested);
[+] 		writeLog(SshLogRecordCode.SshPtyRequested);
[-] 		writeLog (SshLogRecordCode.SshProcessStarted);
[+] 		writeLog(SshLogRecordCode.SshProcessStarted);
[-] 		writeLog (SshLogRecordCode.ConnectCompleted);
[+] 		writeLog(SshLogRecordCode.ConnectCompleted);
[-] 		m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 		m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 			size_t result = m_ssh.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_ssh.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 		m_ssh.close ();
[+] 		m_ssh.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		size_t result = m_ssh.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_ssh.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitSshEvents ();
[+] 	waitSshEvents();
[-] SshChannelSession.onResolveCompleted (
[+] SshChannelSession.onResolveCompleted(
[-] 		handleConnectError (error);
[+] 		handleConnectError(error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	io.SocketAddress address = addressTable [0];
[+] 	io.SocketAddress address = addressTable[0];
[-] 	connect (&address);
[+] 	connect(&address);
[-] 	m_actionTable [ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[+] 	m_actionTable[ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[-] 	m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? IconId.Disconnect : IconId.Connect];
[+] 	m_actionTable[ActionId.Connect].m_icon = m_iconTable[m_state ? IconId.Disconnect : IconId.Connect];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_stateStringTable[m_state];
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString () : "<peer-address>";
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString() : "<peer-address>";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[-] void const* loadFile (char const* fileName)
[+] void const* loadFile(char const* fileName)
[-] 	file.open (fileName, io.FileOpenFlags.ReadOnly);
[+] 	file.open(fileName, io.FileOpenFlags.ReadOnly);
[-] 	void* p = new char [size];
[+] 	void* p = new char[size];
[-] 	file.read (p, size);
[+] 	file.read(p, size);
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\SshChannel\SshLogRepresenter.jnc
----------------------
[-] bool representSshLog (
[+] bool representSshLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Performing SSH handshake...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Performing SSH handshake...");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Performing SSH authentification...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Performing SSH authentification...");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Opening SSH channel...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Opening SSH channel...");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Requesting PTY...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Requesting PTY...");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Starting process...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Starting process...");
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, "ok");
[-] 		target.addHyperText ("SSH channel established");
[+] 		target.addHyperText("SSH channel established");
[-] 		target.addHyperText (SocketLogPartCode.Connecting, "Reconnecting...");
[+] 		target.addHyperText(SocketLogPartCode.Connecting, "Reconnecting...");
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TcpConnection\TcpConnectionSession.jnc
----------------------
[-] 	static char const* m_stateStringTable [] =
[+] 	static char const* m_stateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	gui.InformationValue* m_infoTable [InfoId._Count];
[+] 	gui.InformationValue* m_infoTable[InfoId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode connect ();
[+] 	bool errorcode connect();
[-] 	bool errorcode connect (io.SocketAddress const* address);
[+] 	bool errorcode connect(io.SocketAddress const* address);
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	handleSocketError (std.Error const* error);
[+] 	handleSocketError(std.Error const* error);
[-] 	onConnect ()
[+] 	onConnect()
[-] 		m_state ? disconnect () : try connect ();
[+] 		m_state ? disconnect() : try connect();
[-] 	onAddressComboEnter ()
[+] 	onAddressComboEnter()
[-] 		try connect ();
[+] 		try connect();
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onSocketEvent (
[+] 	onSocketEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] TcpConnectionSession.construct (doc.PluginHost* pluginHost)
[+] TcpConnectionSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] TcpConnectionSession.createUi ()
[+] TcpConnectionSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Address:");
[+] 	m_pluginHost.m_toolBar.addLabel("Address:");
[-] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Connect] = new gui.Icon ("images/connect.png");
[+] 	m_iconTable[IconId.Connect] = new gui.Icon("images/connect.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Connect] = createAction ("Connect", m_iconTable [IconId.Connect]);
[+] 	m_actionTable[ActionId.Connect] = createAction("Connect", m_iconTable [IconId.Connect]);
[-] 	m_actionTable [ActionId.Connect].m_onTriggered += onConnect;
[+] 	m_actionTable[ActionId.Connect].m_onTriggered += onConnect;
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* propGroup = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* propGroup = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (m_pluginHost.m_propertyGrid, propGroup);
[+] 	m_socketPropertySet.createProperties(m_pluginHost.m_propertyGrid, propGroup);
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("TCP Connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("TCP Connection");
[-] 	m_infoTable [InfoId.LocalAddress] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "Local address");
[+] 	m_infoTable[InfoId.LocalAddress] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "Local address");
[-] 	m_infoTable [InfoId.RemoteAddress] = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "Remote address");
[+] 	m_infoTable[InfoId.RemoteAddress] = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "Remote address");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode TcpConnectionSession.connect ()
[+] bool errorcode TcpConnectionSession.connect()
[-] 	disconnect ();
[+] 	disconnect();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_addressCombo.addEditTextToHistory ();
[+] 	m_addressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try address.parse (addressString);
[+] 	bool isDirectAddress = try address.parse(addressString);
[-] 		return try connect (&address);
[+] 		return try connect(&address);
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (addressString)
[+] 		strlen(addressString)
[-] 	m_resolver.resolve (addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_resolver.resolve(addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	handleSocketError (std.getLastError ());
[+] 	handleSocketError(std.getLastError());
[-] bool errorcode TcpConnectionSession.connect (io.SocketAddress const* remoteAddress)
[+] bool errorcode TcpConnectionSession.connect(io.SocketAddress const* remoteAddress)
[-] 	disconnect ();
[+] 	disconnect();
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 		m_socket.open (remoteAddress.m_family, io.Protocol.Tcp);
[+] 		m_socket.open(remoteAddress.m_family, io.Protocol.Tcp);
[-] 		m_localAddress.m_ip4.m_port = (uint16_t) m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[+] 		m_localAddress.m_ip4.m_port = (uint16_t)m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[-] 		m_socket.open (io.Protocol.Tcp, &m_localAddress);
[+] 		m_socket.open(io.Protocol.Tcp, &m_localAddress);
[-] 	m_socket.connect (remoteAddress);
[+] 	m_socket.connect(remoteAddress);
[-] 	writeLog (SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof (p));
[+] 	writeLog(SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof(p));
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] 		writeLog (SocketLogRecordCode.Connecting, remoteAddress, sizeof (io.SocketAddress));
[+] 		writeLog(SocketLogRecordCode.Connecting, remoteAddress, sizeof(io.SocketAddress));
[-] 		writeLog (SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof (p));
[+] 		writeLog(SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof(p));
[-] 	handleSocketError (std.getLastError ());
[+] 	handleSocketError(std.getLastError());
[-] TcpConnectionSession.waitSocketEvents ()
[+] TcpConnectionSession.waitSocketEvents()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 	m_socket.wait (eventMask, onSocketEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_socket.wait(eventMask, onSocketEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] TcpConnectionSession.handleSocketError (std.Error const* error)
[+] TcpConnectionSession.handleSocketError(std.Error const* error)
[-] 	writeLog (recordCode, error, error.m_size);
[+] 	writeLog(recordCode, error, error.m_size);
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] TcpConnectionSession.disconnect ()
[+] TcpConnectionSession.disconnect()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		writeLog (SocketLogRecordCode.ConnectCancelled);
[+] 		writeLog(SocketLogRecordCode.ConnectCancelled);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] void TcpConnectionSession.load (doc.Storage* storage)
[+] void TcpConnectionSession.load(doc.Storage* storage)
[-] 	m_addressCombo.loadHistory (storage, "addressHistory");
[+] 	m_addressCombo.loadHistory(storage, "addressHistory");
[-] 	m_addressCombo.m_editText = storage.readString ("address");
[+] 	m_addressCombo.m_editText = storage.readString("address");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void TcpConnectionSession.save (doc.Storage* storage)
[+] void TcpConnectionSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_addressCombo.saveHistory (storage, "addressHistory");
[+] 	m_addressCombo.saveHistory(storage, "addressHistory");
[-] 	storage.writeString ("address", m_addressCombo.m_editText); // overwrite
[+] 	storage.writeString("address", m_addressCombo.m_editText); // overwrite
[-] void TcpConnectionSession.updateProperties ()
[+] void TcpConnectionSession.updateProperties()
[-] bool errorcode TcpConnectionSession.applyProperties ()
[+] bool errorcode TcpConnectionSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] void TcpConnectionSession.restoreDefaultProperties ()
[+] void TcpConnectionSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode TcpConnectionSession.transmit (
[+] size_t errorcode TcpConnectionSession.transmit(
[-] 	size_t result = m_socket.write (p, size);
[+] 	size_t result = m_socket.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] 		waitSocketEvents ();
[+] 		waitSocketEvents();
[-] TcpConnectionSession.onSocketEvent (
[+] TcpConnectionSession.onSocketEvent(
[-] 		handleSocketError (m_socket.m_ioError);
[+] 		handleSocketError(m_socket.m_ioError);
[-] 		writeLog (SocketLogRecordCode.ConnectCompleted);
[+] 		writeLog(SocketLogRecordCode.ConnectCompleted);
[-] 		m_infoTable [InfoId.LocalAddress].m_value = m_localAddress.getString ();
[+] 		m_infoTable[InfoId.LocalAddress].m_value = m_localAddress.getString();
[-] 		m_infoTable [InfoId.RemoteAddress].m_value = m_remoteAddress.getString ();
[+] 		m_infoTable[InfoId.RemoteAddress].m_value = m_remoteAddress.getString();
[-] 		m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 		m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 			size_t result = m_socket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_socket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (recordParams)
[+] 			sizeof(recordParams)
[-] 		m_socket.close ();
[+] 		m_socket.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_socket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_socket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] TcpConnectionSession.onResolveCompleted (
[+] TcpConnectionSession.onResolveCompleted(
[-] 		handleSocketError (error);
[+] 		handleSocketError(error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	io.SocketAddress address = addressTable [0];
[+] 	io.SocketAddress address = addressTable[0];
[-] 	connect (address);
[+] 	connect(address);
[-] 	m_actionTable [ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[+] 	m_actionTable[ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[-] 	m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? IconId.Disconnect : IconId.Connect];
[+] 	m_actionTable[ActionId.Connect].m_icon = m_iconTable[m_state ? IconId.Disconnect : IconId.Connect];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_stateStringTable[m_state];
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString () : "<peer-address>";
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString() : "<peer-address>";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[-] 	m_infoTable [InfoId.LocalAddress].m_isEnabled = m_state == State.Connected;
[+] 	m_infoTable[InfoId.LocalAddress].m_isEnabled = m_state == State.Connected;
[-] 	m_infoTable [InfoId.RemoteAddress].m_isEnabled = m_state == State.Connected;
[+] 	m_infoTable[InfoId.RemoteAddress].m_isEnabled = m_state == State.Connected;
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TcpFlowMon\TcpFlowMonLogRepresenter.jnc
----------------------
[-] bool representTcpFlowMonLog (
[+] bool representTcpFlowMonLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* srcAddressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* srcAddressString = ((io.SocketAddress const*) p).getString();
[-] 		char const* dstAddressString = ((io.SocketAddress const*) p + 1).getString ();
[+] 		char const* dstAddressString = ((io.SocketAddress const*) p + 1).getString();
[-] 		target.addHyperText (TcpFlowMonLogPartCode.Connecting, $"Connecting to \e[34m$dstAddressString\e[m from \e[34m$srcAddressString\e[m...");
[+] 		target.addHyperText(TcpFlowMonLogPartCode.Connecting, $"Connecting to \e[34m$dstAddressString\e[m from \e[34m$srcAddressString\e[m...");
[-] 		target.addHyperText (TcpFlowMonLogPartCode.ConnectCompleted, "ok");
[+] 		target.addHyperText(TcpFlowMonLogPartCode.ConnectCompleted, "ok");
[-] 		char const* addressString1 = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString1 = ((io.SocketAddress const*) p).getString();
[-] 		char const* addressString2 = ((io.SocketAddress const*) p + 1).getString ();
[+] 		char const* addressString2 = ((io.SocketAddress const*) p + 1).getString();
[-] 		target.addHyperText ($"Picked up connection between \e[34m$addressString1\e[m and \e[34m$addressString2\e[m");
[+] 		target.addHyperText($"Picked up connection between \e[34m$addressString1\e[m and \e[34m$addressString2\e[m");
[-] 		char const* addressString = ((io.SocketAddress const*) p).getString ();
[+] 		char const* addressString = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"Disconnected by \e[34m$addressString\e");
[+] 		target.addHyperText($"Disconnected by \e[34m$addressString\e");
[-] 		target.addHyperText ($"Out-of-order segment(s), data dropped\e");
[+] 		target.addHyperText($"Out-of-order segment(s), data dropped\e");
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TcpFlowMon\TcpFlowMonSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	bool errorcode capture (
[+] 	bool errorcode capture(
[-] 	bool errorcode openCapFile (
[+] 	bool errorcode openCapFile(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		try (m_state ? stopCapture () : capture ());
[+] 		try(m_state ? stopCapture() : capture());
[-] 	onSetFilter ()
[+] 	onSetFilter()
[-] 		try (m_state ? applyFilter () : capture ());
[+] 		try(m_state ? applyFilter() : capture());
[-] 	onDeviceComboEnter ()
[+] 	onDeviceComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onFileDlgCompleted (gui.StdDlgButton button);
[+] 	onFileDlgCompleted(gui.StdDlgButton button);
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onPcapEvent (
[+] 	onPcapEvent(
[-] 	onData (
[+] 	onData(
[-] 	onDataDrop ();
[+] 	onDataDrop();
[-] 	char const* createFilterString (io.SocketAddress const* filterAddress);
[+] 	char const* createFilterString(io.SocketAddress const* filterAddress);
[-] 	bool errorcode resolve (char const* addressString);
[+] 	bool errorcode resolve(char const* addressString);
[-] 	bool errorcode applyFilter ();
[+] 	bool errorcode applyFilter();
[-] 	bool errorcode setFilter (io.SocketAddress const* filterAddress);
[+] 	bool errorcode setFilter(io.SocketAddress const* filterAddress);
[-] 	bool decodePacket (
[+] 	bool decodePacket(
[-] 	decodeTcpPacket (
[+] 	decodeTcpPacket(
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	createUi ();
[+] 	createUi();
[-] TcpFlowMonSession.construct (doc.PluginHost* pluginHost)
[+] TcpFlowMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] TcpFlowMonSession.createUi ()
[+] TcpFlowMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = io.createPcapDeviceComboBox (m_pluginHost.m_toolBar);
[+] 	m_deviceCombo = io.createPcapDeviceComboBox(m_pluginHost.m_toolBar);
[-] 	m_pluginHost.m_toolBar.addLabel ("Filter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Filter:");
[-] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = io.createPcapDeviceProperty (
[+] 	m_deviceProp = io.createPcapDeviceProperty(
[-] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_tcpOutOfSeqLimitProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_tcpOutOfSeqLimitProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group,, mask);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group,, mask);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("TCP monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("TCP monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] TcpFlowMonSession.onFileDlgCompleted (gui.StdDlgButton button)
[+] TcpFlowMonSession.onFileDlgCompleted(gui.StdDlgButton button)
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (addressString);
[+] 	bool isDirectAddress = try filterAddress.parse(addressString);
[-] 		try openCapFile (fileName, &filterAddress);
[+] 		try openCapFile(fileName, &filterAddress);
[-] 		try resolve (addressString);
[+] 		try resolve(addressString);
[-] bool errorcode TcpFlowMonSession.capture ()
[+] bool errorcode TcpFlowMonSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 		m_fileDlg.show ();
[+] 		m_fileDlg.show();
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (addressString);
[+] 	bool isDirectAddress = try filterAddress.parse(addressString);
[-] 		return try capture (device, &filterAddress);
[+] 		return try capture(device, &filterAddress);
[-] 	return try resolve (addressString);
[+] 	return try resolve(addressString);
[-] bool errorcode TcpFlowMonSession.capture (
[+] bool errorcode TcpFlowMonSession.capture(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openDevice (
[+] 	bool result = try m_pcap.openDevice(
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] bool errorcode TcpFlowMonSession.openCapFile (
[+] bool errorcode TcpFlowMonSession.openCapFile(
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openFile (fileName, filterString);
[+] 	bool result = try m_pcap.openFile(fileName, filterString);
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] TcpFlowMonSession.stopCapture ()
[+] TcpFlowMonSession.stopCapture()
[-] 		writeLog (SocketLogRecordCode.ResolveCancelled);
[+] 		writeLog(SocketLogRecordCode.ResolveCancelled);
[-] 		writeLog (PcapLogRecordCode.CaptureStopped);
[+] 		writeLog(PcapLogRecordCode.CaptureStopped);
[-] 	m_pcap.close ();
[+] 	m_pcap.close();
[-] 	m_ipDefragmenter.reset ();
[+] 	m_ipDefragmenter.reset();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] bool errorcode TcpFlowMonSession.resolve (char const* addressString)
[+] bool errorcode TcpFlowMonSession.resolve(char const* addressString)
[-] 	writeLogString (SocketLogRecordCode.Resolving, addressString);
[+] 	writeLogString(SocketLogRecordCode.Resolving, addressString);
[-] 	bool result = try m_resolver.resolve (
[+] 	bool result = try m_resolver.resolve(
[-] 		writeLogLastError (SocketLogRecordCode.ResolveError);
[+] 		writeLogLastError(SocketLogRecordCode.ResolveError);
[-] bool errorcode TcpFlowMonSession.applyFilter ()
[+] bool errorcode TcpFlowMonSession.applyFilter()
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (filterString);
[+] 	bool isDirectAddress = try filterAddress.parse(filterString);
[-] 		return try setFilter (&filterAddress);
[+] 		return try setFilter(&filterAddress);
[-] 	writeLogString (SocketLogRecordCode.Resolving, filterString);
[+] 	writeLogString(SocketLogRecordCode.Resolving, filterString);
[-] 	bool result = try m_resolver.resolve (
[+] 	bool result = try m_resolver.resolve(
[-] 		writeLogLastError (SocketLogRecordCode.ResolveError);
[+] 		writeLogLastError(SocketLogRecordCode.ResolveError);
[-] bool errorcode TcpFlowMonSession.setFilter (io.SocketAddress const* filterAddress)
[+] bool errorcode TcpFlowMonSession.setFilter(io.SocketAddress const* filterAddress)
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.ChangingFilter, filterString);
[+] 	writeLogString(PcapLogRecordCode.ChangingFilter, filterString);
[-] 	bool result = try m_pcap.setFilter (filterString);
[+] 	bool result = try m_pcap.setFilter(filterString);
[-] 		writeLogLastError (PcapLogRecordCode.FilterError);
[+] 		writeLogLastError(PcapLogRecordCode.FilterError);
[-] 	writeLog (PcapLogRecordCode.FilterChanged);
[+] 	writeLog(PcapLogRecordCode.FilterChanged);
[-] char const* TcpFlowMonSession.createFilterString (io.SocketAddress const* filterAddress)
[+] char const* TcpFlowMonSession.createFilterString(io.SocketAddress const* filterAddress)
[-] TcpFlowMonSession.waitPcapEvents ()
[+] TcpFlowMonSession.waitPcapEvents()
[-] 	m_pcap.wait (eventMask, onPcapEvent ~(++m_pcapSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_pcap.wait(eventMask, onPcapEvent ~(++m_pcapSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void TcpFlowMonSession.load (doc.Storage* storage)
[+] void TcpFlowMonSession.load(doc.Storage* storage)
[-] 	m_filterCombo.loadHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.loadHistory(storage, "captureFilterHistory");
[-] 	m_deviceCombo.m_currentIndex = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex = storage.readInt("deviceIdx");
[-] 	m_promisciousProp.m_value = storage.readBool ("promiscious");
[+] 	m_promisciousProp.m_value = storage.readBool("promiscious");
[-] 	m_filterCombo.m_editText = storage.readString ("captureFilter");
[+] 	m_filterCombo.m_editText = storage.readString("captureFilter");
[-] 	m_ipFragmentLimitProp.m_value = storage.readInt ("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[+] 	m_ipFragmentLimitProp.m_value = storage.readInt("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[-] 	m_ipFragmentTimeoutProp.m_value = storage.readInt ("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[+] 	m_ipFragmentTimeoutProp.m_value = storage.readInt("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[-] 	m_tcpOutOfSeqLimitProp.m_value = storage.readInt ("tcpOutOfSeqLimit", io.TcpSequencer.DefOutOfSeqLimit);
[+] 	m_tcpOutOfSeqLimitProp.m_value = storage.readInt("tcpOutOfSeqLimit", io.TcpSequencer.DefOutOfSeqLimit);
[-] 	m_snapshotSizeProp.m_value = storage.readInt ("snapshotSize", Defaults.SnapshotSize);
[+] 	m_snapshotSizeProp.m_value = storage.readInt("snapshotSize", Defaults.SnapshotSize);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void TcpFlowMonSession.save (doc.Storage* storage)
[+] void TcpFlowMonSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_filterCombo.saveHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.saveHistory(storage, "captureFilterHistory");
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("promiscious", m_promisciousProp.m_value);
[+] 	storage.writeBool("promiscious", m_promisciousProp.m_value);
[-] 	storage.writeString ("captureFilter", m_filterCombo.m_editText);
[+] 	storage.writeString("captureFilter", m_filterCombo.m_editText);
[-] 	storage.writeInt ("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[+] 	storage.writeInt("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[-] 	storage.writeInt ("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[+] 	storage.writeInt("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[-] 	storage.writeInt ("tcpOutOfSeqLimit", m_tcpOutOfSeqLimitProp.m_value);
[+] 	storage.writeInt("tcpOutOfSeqLimit", m_tcpOutOfSeqLimitProp.m_value);
[-] 	storage.writeInt ("snapshotSize", m_snapshotSizeProp.m_value);
[+] 	storage.writeInt("snapshotSize", m_snapshotSizeProp.m_value);
[-] void TcpFlowMonSession.updateProperties ()
[+] void TcpFlowMonSession.updateProperties()
[-] bool errorcode TcpFlowMonSession.applyProperties ()
[+] bool errorcode TcpFlowMonSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	applyFilter ();
[+] 	applyFilter();
[-] void TcpFlowMonSession.restoreDefaultProperties ()
[+] void TcpFlowMonSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] TcpFlowMonSession.onResolveCompleted (
[+] TcpFlowMonSession.onResolveCompleted(
[-] 		writeLogError (SocketLogRecordCode.ResolveError, error);
[+] 		writeLogError(SocketLogRecordCode.ResolveError, error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 		try setFilter (addressTable);
[+] 		try setFilter(addressTable);
[-] 		try capture (m_pendingDevice, addressTable);
[+] 		try capture(m_pendingDevice, addressTable);
[-] 		try openCapFile (m_pendingFileName, addressTable);
[+] 		try openCapFile(m_pendingFileName, addressTable);
[-] TcpFlowMonSession.onPcapEvent (
[+] TcpFlowMonSession.onPcapEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_pcap.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_pcap.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			decodePacket (m_readBuffer.m_p, result);
[+] 			decodePacket(m_readBuffer.m_p, result);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] TcpFlowMonSession.onData (
[+] TcpFlowMonSession.onData(
[-] 	writeLog (recordCode, p, size);
[+] 	writeLog(recordCode, p, size);
[-] TcpFlowMonSession.onDataDrop ()
[+] TcpFlowMonSession.onDataDrop()
[-] 	writeLog (TcpFlowMonLogRecordCode.OutOfOrderDataDropped);
[+] 	writeLog(TcpFlowMonLogRecordCode.OutOfOrderDataDropped);
[-] bool TcpFlowMonSession.decodePacket (
[+] bool TcpFlowMonSession.decodePacket(
[-] 	if (size < sizeof (io.EthernetHdr))
[+] 	if (size < sizeof(io.EthernetHdr))
[-] 	p += sizeof (io.EthernetHdr);
[+] 	p += sizeof(io.EthernetHdr);
[-] 	size -= sizeof (io.EthernetHdr);
[+] 	size -= sizeof(io.EthernetHdr);
[-] 	switch (ethernetHdr.m_type)
[+] 	switch(ethernetHdr.m_type)
[-] 		if (size < sizeof (io.IpHdr))
[+] 		if (size < sizeof(io.IpHdr))
[-] 			ipHdrSize < sizeof (io.IpHdr) ||
[+] 			ipHdrSize < sizeof(io.IpHdr) ||
[-] 			ipHdr = m_ipDefragmenter.defragment (ipHdr, size);
[+] 			ipHdr = m_ipDefragmenter.defragment(ipHdr, size);
[-] 			size = dynamic sizeof (p);
[+] 			size = dynamic sizeof(p);
[-] 		if (size < sizeof (io.Ip6Hdr))
[+] 		if (size < sizeof(io.Ip6Hdr))
[-] 			ip6Hdr.m_payloadLength + sizeof (io.Ip6Hdr) > size)
[+] 			ip6Hdr.m_payloadLength + sizeof(io.Ip6Hdr) > size)
[-] 		p += sizeof (io.Ip6Hdr);
[+] 		p += sizeof(io.Ip6Hdr);
[-] 	if (size < sizeof (io.TcpHdr))
[+] 	if (size < sizeof(io.TcpHdr))
[-] 	if (tcpHdrSize < sizeof (io.TcpHdr) || tcpHdrSize > size)
[+] 	if (tcpHdrSize < sizeof(io.TcpHdr) || tcpHdrSize > size)
[-] 		if (srcAddress.isMatch (&m_filterAddress))
[+] 		if (srcAddress.isMatch(&m_filterAddress))
[-] 			m_tcpPeer1.m_tcpSequencer.reset (tcpHdr.m_seqNumber + seqNumberDelta);
[+] 			m_tcpPeer1.m_tcpSequencer.reset(tcpHdr.m_seqNumber + seqNumberDelta);
[-] 			m_tcpPeer2.m_tcpSequencer.reset (tcpHdr.m_ackNumber);
[+] 			m_tcpPeer2.m_tcpSequencer.reset(tcpHdr.m_ackNumber);
[-] 		else if (dstAddress.isMatch (&m_filterAddress))
[+] 		else if (dstAddress.isMatch(&m_filterAddress))
[-] 			m_tcpPeer1.m_tcpSequencer.reset (tcpHdr.m_ackNumber);
[+] 			m_tcpPeer1.m_tcpSequencer.reset(tcpHdr.m_ackNumber);
[-] 			m_tcpPeer2.m_tcpSequencer.reset (tcpHdr.m_seqNumber + seqNumberDelta);
[+] 			m_tcpPeer2.m_tcpSequencer.reset(tcpHdr.m_seqNumber + seqNumberDelta);
[-] 			writeLog (
[+] 			writeLog(
[-] 				dynamic sizeof (params)
[+] 				dynamic sizeof(params)
[-] 			writeLog (
[+] 			writeLog(
[-] 				dynamic sizeof (params)
[+] 				dynamic sizeof(params)
[-] 			writeLog (
[+] 			writeLog(
[-] 				dynamic sizeof (params)
[+] 				dynamic sizeof(params)
[-] 			writeLog (TcpFlowMonLogRecordCode.ConnectCompleted);
[+] 			writeLog(TcpFlowMonLogRecordCode.ConnectCompleted);
[-] 		m_tcpPeer1.m_address.isEqual (&srcAddress) &&
[+] 		m_tcpPeer1.m_address.isEqual(&srcAddress) &&
[-] 		m_tcpPeer2.m_address.isEqual (&dstAddress))
[+] 		m_tcpPeer2.m_address.isEqual(&dstAddress))
[-] 		decodeTcpPacket (&m_tcpPeer1, tcpHdr, p, size);
[+] 		decodeTcpPacket(&m_tcpPeer1, tcpHdr, p, size);
[-] 		m_tcpPeer2.m_address.isEqual (&srcAddress) &&
[+] 		m_tcpPeer2.m_address.isEqual(&srcAddress) &&
[-] 		m_tcpPeer1.m_address.isEqual (&dstAddress))
[+] 		m_tcpPeer1.m_address.isEqual(&dstAddress))
[-] 		decodeTcpPacket (&m_tcpPeer2, tcpHdr, p, size);
[+] 		decodeTcpPacket(&m_tcpPeer2, tcpHdr, p, size);
[-] TcpFlowMonSession.decodeTcpPacket (
[+] TcpFlowMonSession.decodeTcpPacket(
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (peer.m_address)
[+] 			sizeof(peer.m_address)
[-] 		writeLog (TcpFlowMonLogRecordCode.ConnectCompleted);
[+] 		writeLog(TcpFlowMonLogRecordCode.ConnectCompleted);
[-] 		peer.m_tcpSequencer.reset (tcpHdr.m_seqNumber + 1);
[+] 		peer.m_tcpSequencer.reset(tcpHdr.m_seqNumber + 1);
[-] 		peer.m_tcpSequencer.write (tcpHdr.m_seqNumber, p, size);
[+] 		peer.m_tcpSequencer.write(tcpHdr.m_seqNumber, p, size);
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text =
[+] 	m_statusPaneTable[StatusPaneId.State].m_text =
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TcpListener\TcpListenerSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode listen ();
[+] 	bool errorcode listen();
[-] 	stopListen ();
[+] 	stopListen();
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onListen ()
[+] 	onListen()
[-] 		m_listenerState ? stopListen () : try listen ();
[+] 		m_listenerState ? stopListen() : try listen();
[-] 	onPortComboEnter ()
[+] 	onPortComboEnter()
[-] 		try listen ();
[+] 		try listen();
[-] 	onListenerSocketEvent (
[+] 	onListenerSocketEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] 	waitConnectionSocketEvents ();
[+] 	waitConnectionSocketEvents();
[-] TcpListenerSession.construct (doc.PluginHost* pluginHost)
[+] TcpListenerSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] TcpListenerSession.createUi ()
[+] TcpListenerSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Adapter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Adapter:");
[-] 	m_adapterCombo = io.createNetworkAdapterComboBox (m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[+] 	m_adapterCombo = io.createNetworkAdapterComboBox(m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_portCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_iconTable [IconId.Listen] = new gui.Icon ("images/listen.png");
[+] 	m_iconTable[IconId.Listen] = new gui.Icon("images/listen.png");
[-] 	m_iconTable [IconId.StopListen] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopListen] = new gui.Icon("images/pause.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Listen] = createAction ("Listen", m_iconTable [IconId.Listen]);
[+] 	m_actionTable[ActionId.Listen] = createAction("Listen", m_iconTable [IconId.Listen]);
[-] 	m_actionTable [ActionId.Listen].m_onTriggered += onListen;
[+] 	m_actionTable[ActionId.Listen].m_onTriggered += onListen;
[-] 	m_actionTable [ActionId.Disconnect] = createAction ("Disconnect", m_iconTable [IconId.Disconnect]);
[+] 	m_actionTable[ActionId.Disconnect] = createAction("Disconnect", m_iconTable [IconId.Disconnect]);
[-] 	m_actionTable [ActionId.Disconnect].m_onTriggered += disconnect;
[+] 	m_actionTable[ActionId.Disconnect].m_onTriggered += disconnect;
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (
[+] 	m_socketPropertySet.createProperties(
[-] 	m_overrideOldConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_overrideOldConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("TCP listener");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("TCP listener");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] bool errorcode TcpListenerSession.listen ()
[+] bool errorcode TcpListenerSession.listen()
[-] 	stopListen ();
[+] 	stopListen();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_portCombo.addEditTextToHistory ();
[+] 	m_portCombo.addEditTextToHistory();
[-] 	address.m_ip4.m_port = (uint16_t) atoi (m_portCombo.m_editText); // same for IPv4/IPv6
[+] 	address.m_ip4.m_port = (uint16_t)atoi(m_portCombo.m_editText); // same for IPv4/IPv6
[-] 	m_listenerSocket.open (io.Protocol.Tcp, &address);
[+] 	m_listenerSocket.open(io.Protocol.Tcp, &address);
[-] 	m_listenerSocket.listen ();
[+] 	m_listenerSocket.listen();
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (address)
[+] 		sizeof(address)
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_listenerSocket.close ();
[+] 	m_listenerSocket.close();
[-] TcpListenerSession.stopListen ()
[+] TcpListenerSession.stopListen()
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (m_localAddress)
[+] 		sizeof(m_localAddress)
[-] 	m_listenerSocket.close ();
[+] 	m_listenerSocket.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] TcpListenerSession.disconnect ()
[+] TcpListenerSession.disconnect()
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (params)
[+] 		sizeof(params)
[-] 	m_connectionSocket.close ();
[+] 	m_connectionSocket.close();
[-] void TcpListenerSession.load (doc.Storage* storage)
[+] void TcpListenerSession.load(doc.Storage* storage)
[-] 	m_portCombo.loadHistory (storage, "portHistory");
[+] 	m_portCombo.loadHistory(storage, "portHistory");
[-] 	m_adapterCombo.m_currentIndex  = storage.readInt ("adapterIdx");
[+] 	m_adapterCombo.m_currentIndex  = storage.readInt("adapterIdx");
[-] 	m_portCombo.m_editText = storage.readString ("port");
[+] 	m_portCombo.m_editText = storage.readString("port");
[-] 	m_overrideOldConnectionProp.m_value = storage.readBool ("overrideOldConnection");
[+] 	m_overrideOldConnectionProp.m_value = storage.readBool("overrideOldConnection");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void TcpListenerSession.save (doc.Storage* storage)
[+] void TcpListenerSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_portCombo.saveHistory (storage, "portHistory");
[+] 	m_portCombo.saveHistory(storage, "portHistory");
[-] 	storage.writeInt ("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[+] 	storage.writeInt("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[-] 	storage.writeString ("port", m_portCombo.m_editText);
[+] 	storage.writeString("port", m_portCombo.m_editText);
[-] 	storage.writeBool ("overrideOldConnection", m_overrideOldConnectionProp.m_value);
[+] 	storage.writeBool("overrideOldConnection", m_overrideOldConnectionProp.m_value);
[-] void TcpListenerSession.updateProperties ()
[+] void TcpListenerSession.updateProperties()
[-] 	m_socketPropertySet.m_localPortProp.m_value = atoi (m_portCombo.m_editText);
[+] 	m_socketPropertySet.m_localPortProp.m_value = atoi(m_portCombo.m_editText);
[-] bool errorcode TcpListenerSession.applyProperties ()
[+] bool errorcode TcpListenerSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_connectionSocket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_connectionSocket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] void TcpListenerSession.restoreDefaultProperties ()
[+] void TcpListenerSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode TcpListenerSession.transmit (
[+] size_t errorcode TcpListenerSession.transmit(
[-] 	size_t result = m_connectionSocket.write (p, size);
[+] 	size_t result = m_connectionSocket.write(p, size);
[-] 		writeLog (log.StdRecordCode.Tx, p, result);
[+] 		writeLog(log.StdRecordCode.Tx, p, result);
[-] TcpListenerSession.waitListenerSocketEvents ()
[+] TcpListenerSession.waitListenerSocketEvents()
[-] 	m_listenerSocket.wait (
[+] 	m_listenerSocket.wait(
[-] TcpListenerSession.waitConnectionSocketEvents ()
[+] TcpListenerSession.waitConnectionSocketEvents()
[-] 	m_connectionSocket.wait (
[+] 	m_connectionSocket.wait(
[-] TcpListenerSession.onListenerSocketEvent (
[+] TcpListenerSession.onListenerSocketEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[-] 		m_listenerSocket.close ();
[+] 		m_listenerSocket.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		io.Socket* socket = m_listenerSocket.accept (&address);
[+] 		io.Socket* socket = m_listenerSocket.accept(&address);
[-] 			socket.close ();
[+] 			socket.close();
[-] 			writeLog (SocketLogRecordCode.ClientRejected, &address, sizeof (address));
[+] 			writeLog(SocketLogRecordCode.ClientRejected, &address, sizeof(address));
[-] 		socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 		socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 		disconnect ();
[+] 		disconnect();
[-] 		writeLog (SocketLogRecordCode.ClientConnected, &address, sizeof (address));
[+] 		writeLog(SocketLogRecordCode.ClientConnected, &address, sizeof(address));
[-] 		waitConnectionSocketEvents ();
[+] 		waitConnectionSocketEvents();
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] TcpListenerSession.onConnectionSocketEvent (
[+] TcpListenerSession.onConnectionSocketEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[-] 		m_connectionSocket.close ();
[+] 		m_connectionSocket.close();
[-] 			size_t result = m_connectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_connectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (recordParams)
[+] 			sizeof(recordParams)
[-] 		m_connectionSocket.close ();
[+] 		m_connectionSocket.close();
[-] 		size_t result = m_connectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_connectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitConnectionSocketEvents ();
[+] 	waitConnectionSocketEvents();
[-] 	m_actionTable [ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[+] 	m_actionTable[ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[-] 	m_actionTable [ActionId.Listen].m_icon = m_iconTable [m_listenerState ? IconId.StopListen : IconId.Listen];
[+] 	m_actionTable[ActionId.Listen].m_icon = m_iconTable[m_listenerState ? IconId.StopListen : IconId.Listen];
[-] 	m_actionTable [ActionId.Disconnect].m_isEnabled = m_connectionState != ConnectionState.Closed;
[+] 	m_actionTable[ActionId.Disconnect].m_isEnabled = m_connectionState != ConnectionState.Closed;
[-] 	m_statusPaneTable [StatusPaneId.ListenerState].m_text = m_listenerState ? "Listening" : "Not listening";
[+] 	m_statusPaneTable[StatusPaneId.ListenerState].m_text = m_listenerState ? "Listening" : "Not listening";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_connectionState ? m_remoteAddress.getString () : "<peer>";
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_text = m_connectionState ? m_remoteAddress.getString() : "<peer>";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_connectionState != ConnectionState.Closed;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_isVisible = m_connectionState != ConnectionState.Closed;
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TcpProxy\TcpProxySession.jnc
----------------------
[-] 	static char const* m_listenerStateStringTable [] =
[+] 	static char const* m_listenerStateStringTable[] =
[-] 	static char const* m_clientConnectionStateStringTable [] =
[+] 	static char const* m_clientConnectionStateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode listen ();
[+] 	bool errorcode listen();
[-] 	stopListen ();
[+] 	stopListen();
[-] 	disconnect ();
[+] 	disconnect();
[-] 	bool connectTarget ();
[+] 	bool connectTarget();
[-] 	disconnectTarget ();
[+] 	disconnectTarget();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onListen ();
[+] 	onListen();
[-] 	onTargetAddressChanged ();
[+] 	onTargetAddressChanged();
[-] 	onListenerSocketEvent (
[+] 	onListenerSocketEvent(
[-] 	onServerConnectionSocketEvent (
[+] 	onServerConnectionSocketEvent(
[-] 	onClientConnectionSocketEvent (
[+] 	onClientConnectionSocketEvent(
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	createUi ();
[+] 	createUi();
[-] 	listenImpl ();
[+] 	listenImpl();
[-] 	handleListenError (std.Error const* error);
[+] 	handleListenError(std.Error const* error);
[-] 	handleConnectError (std.Error const* error);
[+] 	handleConnectError(std.Error const* error);
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] 	waitServerConnectionSocketEvents ();
[+] 	waitServerConnectionSocketEvents();
[-] 	waitClientConnectionSocketEvents ();
[+] 	waitClientConnectionSocketEvents();
[-] TcpProxySession.construct (doc.PluginHost* pluginHost)
[+] TcpProxySession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] TcpProxySession.createUi ()
[+] TcpProxySession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Adapter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Adapter:");
[-] 	m_adapterCombo = io.createNetworkAdapterComboBox (m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[+] 	m_adapterCombo = io.createNetworkAdapterComboBox(m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_serverPortCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_serverPortCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_pluginHost.m_toolBar.addLabel ("Remote:");
[+] 	m_pluginHost.m_toolBar.addLabel("Remote:");
[-] 	m_clientAddressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_clientAddressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Listen] = new gui.Icon ("images/listen.png");
[+] 	m_iconTable[IconId.Listen] = new gui.Icon("images/listen.png");
[-] 	m_iconTable [IconId.StopListen] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopListen] = new gui.Icon("images/pause.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Listen] = createAction ("Listen", m_iconTable [IconId.Listen]);
[+] 	m_actionTable[ActionId.Listen] = createAction("Listen", m_iconTable [IconId.Listen]);
[-] 	m_actionTable [ActionId.Listen].m_onTriggered += onListen;
[+] 	m_actionTable[ActionId.Listen].m_onTriggered += onListen;
[-] 	m_actionTable [ActionId.Disconnect] = createAction ("Disconnect", m_iconTable [IconId.Disconnect]);
[+] 	m_actionTable[ActionId.Disconnect] = createAction("Disconnect", m_iconTable [IconId.Disconnect]);
[-] 	m_actionTable [ActionId.Disconnect].m_onTriggered += disconnect;
[+] 	m_actionTable[ActionId.Disconnect].m_onTriggered += disconnect;
[-] 	m_statusPaneTable [StatusPaneId.ServerRemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.ServerRemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.ServerRemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.ServerRemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.ListenerState] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_statusPaneTable [StatusPaneId.ClientConnectionState] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.ClientConnectionState] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_listenerSocketPropertySet.createProperties (
[+] 	m_listenerSocketPropertySet.createProperties(
[-] 	m_overrideConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_overrideConnectionProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_connectionSocketPropertySet.createProperties (
[+] 	m_connectionSocketPropertySet.createProperties(
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("TCP proxy");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("TCP proxy");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] TcpProxySession.onListen ()
[+] TcpProxySession.onListen()
[-] 		stopListen ();
[+] 		stopListen();
[-] 		try listen ();
[+] 		try listen();
[-] bool errorcode TcpProxySession.listen ()
[+] bool errorcode TcpProxySession.listen()
[-] 	stopListen ();
[+] 	stopListen();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_serverPortCombo.addEditTextToHistory ();
[+] 	m_serverPortCombo.addEditTextToHistory();
[-] 	m_clientAddressCombo.addEditTextToHistory ();
[+] 	m_clientAddressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try targetAddress.parse (targetAddressString);
[+] 	bool isDirectAddress = try targetAddress.parse(targetAddressString);
[-] 		listenImpl ();
[+] 		listenImpl();
[-] 		writeLog (
[+] 		writeLog(
[-] 			strlen (targetAddressString)
[+] 			strlen(targetAddressString)
[-] 		m_resolver.resolve (targetAddressString, onResolveCompleted ~(++m_resolverSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 		m_resolver.resolve(targetAddressString, onResolveCompleted ~(++m_resolverSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	handleListenError (std.getLastError ());
[+] 	handleListenError(std.getLastError());
[-] TcpProxySession.listenImpl ()
[+] TcpProxySession.listenImpl()
[-] 	address.m_ip4.m_port = (uint16_t) atoi (m_serverPortCombo.m_editText); // same for IPv4/IPv6
[+] 	address.m_ip4.m_port = (uint16_t)atoi(m_serverPortCombo.m_editText); // same for IPv4/IPv6
[-] 	m_listenerSocket.open (io.Protocol.Tcp, &address);
[+] 	m_listenerSocket.open(io.Protocol.Tcp, &address);
[-] 	m_listenerSocket.listen ();
[+] 	m_listenerSocket.listen();
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (address)
[+] 		sizeof(address)
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	handleListenError (std.getLastError ());
[+] 	handleListenError(std.getLastError());
[-] TcpProxySession.stopListen ()
[+] TcpProxySession.stopListen()
[-] 	switch (m_listenerState)
[+] 	switch(m_listenerState)
[-] 			writeLog (SocketLogRecordCode.ResolveCancelled);
[+] 			writeLog(SocketLogRecordCode.ResolveCancelled);
[-] 			writeLog (
[+] 			writeLog(
[-] 				sizeof (m_localAddress)
[+] 				sizeof(m_localAddress)
[-] 	m_listenerSocket.close ();
[+] 	m_listenerSocket.close();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] TcpProxySession.disconnect ()
[+] TcpProxySession.disconnect()
[-] 	disconnectTarget ();
[+] 	disconnectTarget();
[-] 	writeLog (SocketLogRecordCode.Disconnected, &params, sizeof (params));
[+] 	writeLog(SocketLogRecordCode.Disconnected, &params, sizeof(params));
[-] 	m_serverConnectionSocket.close ();
[+] 	m_serverConnectionSocket.close();
[-] bool TcpProxySession.connectTarget ()
[+] bool TcpProxySession.connectTarget()
[-] 	disconnectTarget ();
[+] 	disconnectTarget();
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (m_clientRemoteAddress)
[+] 		sizeof(m_clientRemoteAddress)
[-] 	m_clientConnectionSocket.open (m_clientRemoteAddress.m_family, io.Protocol.Tcp);
[+] 	m_clientConnectionSocket.open(m_clientRemoteAddress.m_family, io.Protocol.Tcp);
[-] 	m_clientConnectionSocket.connect (&m_clientRemoteAddress);
[+] 	m_clientConnectionSocket.connect(&m_clientRemoteAddress);
[-] 	waitClientConnectionSocketEvents ();
[+] 	waitClientConnectionSocketEvents();
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] TcpProxySession.disconnectTarget ()
[+] TcpProxySession.disconnectTarget()
[-] 	writeLog (SocketLogRecordCode.Disconnected, &params, sizeof (params));
[+] 	writeLog(SocketLogRecordCode.Disconnected, &params, sizeof(params));
[-] 	m_clientConnectionSocket.close ();
[+] 	m_clientConnectionSocket.close();
[-] override void TcpProxySession.load (doc.Storage* storage)
[+] override void TcpProxySession.load(doc.Storage* storage)
[-] 	m_serverPortCombo.loadHistory (storage, "portHistory");
[+] 	m_serverPortCombo.loadHistory(storage, "portHistory");
[-] 	m_clientAddressCombo.loadHistory (storage, "targetAddressHistory");
[+] 	m_clientAddressCombo.loadHistory(storage, "targetAddressHistory");
[-] 	m_adapterCombo.m_currentIndex  = storage.readInt ("adapterIdx");
[+] 	m_adapterCombo.m_currentIndex  = storage.readInt("adapterIdx");
[-] 	m_serverPortCombo.m_editText = storage.readString ("port");
[+] 	m_serverPortCombo.m_editText = storage.readString("port");
[-] 	m_clientAddressCombo.m_editText = storage.readString ("targetAddress");
[+] 	m_clientAddressCombo.m_editText = storage.readString("targetAddress");
[-] 	m_overrideConnectionProp.m_value = storage.readBool ("overrideConnection", Defaults.OverrideConnection);
[+] 	m_overrideConnectionProp.m_value = storage.readBool("overrideConnection", Defaults.OverrideConnection);
[-] 	m_listenerSocketPropertySet.load (storage);
[+] 	m_listenerSocketPropertySet.load(storage);
[-] 	m_connectionSocketPropertySet.load (storage);
[+] 	m_connectionSocketPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] override void TcpProxySession.save (doc.Storage* storage)
[+] override void TcpProxySession.save(doc.Storage* storage)
[-] 	m_serverPortCombo.saveHistory (storage, "portHistory");
[+] 	m_serverPortCombo.saveHistory(storage, "portHistory");
[-] 	m_clientAddressCombo.saveHistory (storage, "targetAddressHistory");
[+] 	m_clientAddressCombo.saveHistory(storage, "targetAddressHistory");
[-] 	m_listenerSocketPropertySet.save (storage);
[+] 	m_listenerSocketPropertySet.save(storage);
[-] 	m_connectionSocketPropertySet.save (storage);
[+] 	m_connectionSocketPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	storage.writeInt ("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[+] 	storage.writeInt("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[-] 	storage.writeString ("port", m_serverPortCombo.m_editText);
[+] 	storage.writeString("port", m_serverPortCombo.m_editText);
[-] 	storage.writeString ("targetAddress", m_clientAddressCombo.m_editText);
[+] 	storage.writeString("targetAddress", m_clientAddressCombo.m_editText);
[-] 	storage.writeBool ("overrideConnection", m_overrideConnectionProp.m_value);
[+] 	storage.writeBool("overrideConnection", m_overrideConnectionProp.m_value);
[-] override void TcpProxySession.updateProperties ()
[+] override void TcpProxySession.updateProperties()
[-] 	m_listenerSocketPropertySet.m_localPortProp.m_value = atoi (m_serverPortCombo.m_editText);
[+] 	m_listenerSocketPropertySet.m_localPortProp.m_value = atoi(m_serverPortCombo.m_editText);
[-] override bool errorcode TcpProxySession.applyProperties ()
[+] override bool errorcode TcpProxySession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] override void TcpProxySession.restoreDefaultProperties ()
[+] override void TcpProxySession.restoreDefaultProperties()
[-] 	m_listenerSocketPropertySet.restoreDefaults ();
[+] 	m_listenerSocketPropertySet.restoreDefaults();
[-] 	m_connectionSocketPropertySet.restoreDefaults ();
[+] 	m_connectionSocketPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] TcpProxySession.onTargetAddressChanged ()
[+] TcpProxySession.onTargetAddressChanged()
[-] TcpProxySession.onListenerSocketEvent (
[+] TcpProxySession.onListenerSocketEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[-] 		m_listenerSocket.close ();
[+] 		m_listenerSocket.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		io.Socket* socket = m_listenerSocket.accept (&address);
[+] 		io.Socket* socket = m_listenerSocket.accept(&address);
[-] 			socket.close ();
[+] 			socket.close();
[-] 			writeLog (SocketLogRecordCode.ClientRejected, &address, sizeof (address));
[+] 			writeLog(SocketLogRecordCode.ClientRejected, &address, sizeof(address));
[-] 		socket.m_options = io.getSocketOptions (m_connectionSocketPropertySet, m_bufferPropertySet);
[+] 		socket.m_options = io.getSocketOptions(m_connectionSocketPropertySet, m_bufferPropertySet);
[-] 		disconnect ();
[+] 		disconnect();
[-] 		writeLog (SocketLogRecordCode.ClientConnected, &address, sizeof (address));
[+] 		writeLog(SocketLogRecordCode.ClientConnected, &address, sizeof(address));
[-] 		waitServerConnectionSocketEvents ();
[+] 		waitServerConnectionSocketEvents();
[-] 		bool result = connectTarget ();
[+] 		bool result = connectTarget();
[-] 			disconnect ();
[+] 			disconnect();
[-] 	waitListenerSocketEvents ();
[+] 	waitListenerSocketEvents();
[-] TcpProxySession.onServerConnectionSocketEvent (
[+] TcpProxySession.onServerConnectionSocketEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_listenerSocket.m_ioError, m_listenerSocket.m_ioError.m_size);
[-] 		m_serverConnectionSocket.close ();
[+] 		m_serverConnectionSocket.close();
[-] 		disconnectTarget ();
[+] 		disconnectTarget();
[-] 			size_t result = m_serverConnectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_serverConnectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (SocketLogRecordCode.Disconnected, &params, sizeof (params));
[+] 		writeLog(SocketLogRecordCode.Disconnected, &params, sizeof(params));
[-] 		m_serverConnectionSocket.close ();
[+] 		m_serverConnectionSocket.close();
[-] 		disconnectTarget ();
[+] 		disconnectTarget();
[-] 		size_t result = m_serverConnectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_serverConnectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Tx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Tx, m_readBuffer.m_p, result);
[-] 				m_clientConnectionSocket.write (m_readBuffer.m_p, result);
[+] 				m_clientConnectionSocket.write(m_readBuffer.m_p, result);
[-] 	waitServerConnectionSocketEvents ();
[+] 	waitServerConnectionSocketEvents();
[-] TcpProxySession.onClientConnectionSocketEvent (
[+] TcpProxySession.onClientConnectionSocketEvent(
[-] 		handleConnectError (m_clientConnectionSocket.m_ioError);
[+] 		handleConnectError(m_clientConnectionSocket.m_ioError);
[-] 		disconnect ();
[+] 		disconnect();
[-] 		writeLog (SocketLogRecordCode.ConnectCompleted);
[+] 		writeLog(SocketLogRecordCode.ConnectCompleted);
[-] 			size_t result = m_clientConnectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 			size_t result = m_clientConnectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 		writeLog (SocketLogRecordCode.Disconnected, &params, sizeof (params));
[+] 		writeLog(SocketLogRecordCode.Disconnected, &params, sizeof(params));
[-] 		m_clientConnectionSocket.close ();
[+] 		m_clientConnectionSocket.close();
[-] 		disconnect ();
[+] 		disconnect();
[-] 		size_t result = m_clientConnectionSocket.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_clientConnectionSocket.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 			m_serverConnectionSocket.write (m_readBuffer.m_p, result);
[+] 			m_serverConnectionSocket.write(m_readBuffer.m_p, result);
[-] 	waitClientConnectionSocketEvents ();
[+] 	waitClientConnectionSocketEvents();
[-] TcpProxySession.onResolveCompleted (
[+] TcpProxySession.onResolveCompleted(
[-] 		writeLog (SocketLogRecordCode.ResolveError, error, error.m_size);
[+] 		writeLog(SocketLogRecordCode.ResolveError, error, error.m_size);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	m_clientRemoteAddress = addressTable [0];
[+] 	m_clientRemoteAddress = addressTable[0];
[-] 	listenImpl ();
[+] 	listenImpl();
[-] TcpProxySession.handleListenError (std.Error const* error)
[+] TcpProxySession.handleListenError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_listenerSocket.close ();
[+] 	m_listenerSocket.close();
[-] TcpProxySession.handleConnectError (std.Error const* error)
[+] TcpProxySession.handleConnectError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_clientConnectionSocket.close ();
[+] 	m_clientConnectionSocket.close();
[-] TcpProxySession.waitListenerSocketEvents ()
[+] TcpProxySession.waitListenerSocketEvents()
[-] 	m_listenerSocket.wait (
[+] 	m_listenerSocket.wait(
[-] TcpProxySession.waitServerConnectionSocketEvents ()
[+] TcpProxySession.waitServerConnectionSocketEvents()
[-] 	m_serverConnectionSocket.wait (
[+] 	m_serverConnectionSocket.wait(
[-] TcpProxySession.waitClientConnectionSocketEvents ()
[+] TcpProxySession.waitClientConnectionSocketEvents()
[-] 	m_clientConnectionSocket.wait (
[+] 	m_clientConnectionSocket.wait(
[-] 	m_actionTable [ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[+] 	m_actionTable[ActionId.Listen].m_text = m_listenerState ? "Stop Listening" : "Listen";
[-] 	m_actionTable [ActionId.Listen].m_icon = m_iconTable [m_listenerState ? IconId.StopListen : IconId.Listen];
[+] 	m_actionTable[ActionId.Listen].m_icon = m_iconTable[m_listenerState ? IconId.StopListen : IconId.Listen];
[-] 	m_actionTable [ActionId.Disconnect].m_isEnabled = m_serverConnectionState || m_clientConnectionState;
[+] 	m_actionTable[ActionId.Disconnect].m_isEnabled = m_serverConnectionState || m_clientConnectionState;
[-] 	m_statusPaneTable [StatusPaneId.ServerRemoteAddress].m_text = m_serverConnectionState ? m_serverRemoteAddress.getString () : "<server-peer>";
[+] 	m_statusPaneTable[StatusPaneId.ServerRemoteAddress].m_text = m_serverConnectionState ? m_serverRemoteAddress.getString() : "<server-peer>";
[-] 	m_statusPaneTable [StatusPaneId.ServerRemoteAddress].m_isVisible = m_serverConnectionState != ServerConnectionState.Closed;
[+] 	m_statusPaneTable[StatusPaneId.ServerRemoteAddress].m_isVisible = m_serverConnectionState != ServerConnectionState.Closed;
[-] 	m_statusPaneTable [StatusPaneId.ListenerState].m_text = m_listenerStateStringTable [m_listenerState];
[+] 	m_statusPaneTable[StatusPaneId.ListenerState].m_text = m_listenerStateStringTable[m_listenerState];
[-] 	m_statusPaneTable [StatusPaneId.ClientConnectionState].m_text = m_clientConnectionStateStringTable [m_clientConnectionState];
[+] 	m_statusPaneTable[StatusPaneId.ClientConnectionState].m_text = m_clientConnectionStateStringTable[m_clientConnectionState];
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TibboModbusGatewayMon\ModbusGatewayMonLogRepresenter.jnc
----------------------
[-] bool representModbusGatewayMonLog (
[+] bool representModbusGatewayMonLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addHyperText (SocketLogPartCode.ConnectCompleted, $"error: Unable send command to device");
[+] 		target.addHyperText(SocketLogPartCode.ConnectCompleted, $"error: Unable send command to device");
[-] 		switch ((*(char const*)p) & 0x7f) {
[+] 		switch((*(char const*)p) & 0x7f) {
[-]                 target.addHyperText ($"$_type TCP $_strAddr UnitId #$_id");
[+]                 target.addHyperText($"$_type TCP $_strAddr UnitId #$_id");
[-]                 target.addBin (p + 2 + _i, size - 2 - _i);
[+]                 target.addBin(p + 2 + _i, size - 2 - _i);
[-]                 target.addHyperText ($"$_type Port#$channel SlaveId #$_id");
[+]                 target.addHyperText($"$_type Port#$channel SlaveId #$_id");
[-]                 target.addBin (p + 2, size - 2);
[+]                 target.addBin(p + 2, size - 2);
[-]                 target.addHyperText (
[+]                 target.addHyperText(
[-]                     _base + offsetof (aduHdr.m_deviceAddress),
[+]                     _base + offsetof(aduHdr.m_deviceAddress),
[-]                     sizeof (aduHdr.m_deviceAddress),
[+]                     sizeof(aduHdr.m_deviceAddress),
[-]                 size_t checksumOffset = size_packet - sizeof (uint16_t);
[+]                 size_t checksumOffset = size_packet - sizeof(uint16_t);
[-]                 uint16_t expectedChecksum = crc16_ansi (aduHdr, checksumOffset, 0xffff);
[+]                 uint16_t expectedChecksum = crc16_ansi(aduHdr, checksumOffset, 0xffff);
[-]                     target.addHyperText (
[+]                     target.addHyperText(
[-]                         sizeof (uint16_t),
[+]                         sizeof(uint16_t),
[-]                     target.addHyperText (
[+]                     target.addHyperText(
[-]                         sizeof (uint16_t),
[+]                         sizeof(uint16_t),
[-]                 representModbusPdu (
[+]                 representModbusPdu(
[-]                     size - sizeof (io.ModbusRtuAduHdr),
[+]                     size - sizeof(io.ModbusRtuAduHdr),
[-]                     sizeof (io.ModbusRtuAduHdr) + _base,
[+]                     sizeof(io.ModbusRtuAduHdr) + _base,
[-]                 representModbusMbap (
[+]                 representModbusMbap(
[-]                     sizeof (ModbusMbapHdr),
[+]                     sizeof(ModbusMbapHdr),
[-]                 representModbusPdu (
[+]                 representModbusPdu(
[-]                     size - sizeof (ModbusMbapHdr),
[+]                     size - sizeof(ModbusMbapHdr),
[-]                     sizeof (io.ModbusRtuAduHdr) + _base,
[+]                     sizeof(io.ModbusRtuAduHdr) + _base,
[-]             static uint8_t rtu_buffer [256];
[+]             static uint8_t rtu_buffer[256];
[-]             target.addHyperText ($"$_type Port#$channel SlaveId #$_id");
[+]             target.addHyperText($"$_type Port#$channel SlaveId #$_id");
[-]             target.addBin (p + 2, size - 2);
[+]             target.addBin(p + 2, size - 2);
[-]             size_t checksumOffset = size - 4 - (sizeof (uint8_t) * 2);
[+]             size_t checksumOffset = size - 4 - (sizeof(uint8_t)* 2);
[-]             size_t checksumOffsetRtu = rtu_size - sizeof (uint8_t);
[+]             size_t checksumOffsetRtu = rtu_size - sizeof(uint8_t);
[-]                 target.addHyperText (
[+]                 target.addHyperText(
[-]                     sizeof (uint8_t) * 2,
[+]                     sizeof(uint8_t)* 2,
[-]                 target.addHyperText (
[+]                 target.addHyperText(
[-]                     sizeof (uint8_t) * 2,
[+]                     sizeof(uint8_t)* 2,
[-]                 target.addHyperText (
[+]                 target.addHyperText(
[-]                     offsetof (aduHdr.m_deviceAddress) + 1,
[+]                     offsetof(aduHdr.m_deviceAddress) + 1,
[-]                     sizeof (aduHdr.m_deviceAddress) * 2,
[+]                     sizeof(aduHdr.m_deviceAddress) * 2,
[-]                 representModbusPdu (
[+]                 representModbusPdu(
[-]                     ((size - 5) / 2) - sizeof (io.ModbusRtuAduHdr),
[+]                     ((size - 5) / 2) - sizeof(io.ModbusRtuAduHdr),
[-]                     sizeof (io.ModbusRtuAduHdr) + 2,
[+]                     sizeof(io.ModbusRtuAduHdr) + 2,
[-] 		target.addHyperText ($"Log: $str");
[+] 		target.addHyperText($"Log: $str");
[-]                         target.addHyperText ($"Wrong ASCII symbol");
[+]                         target.addHyperText($"Wrong ASCII symbol");
[-]             target.addHyperText ($"Wrong ASCII packet size");
[+]             target.addHyperText($"Wrong ASCII packet size");
[-]         target.addHyperText ($"Wrong ASCII packet format");
[+]         target.addHyperText($"Wrong ASCII packet format");
[-] representModbusCoils (
[+] representModbusCoils(
[-] 	switch (count)
[+] 	switch(count)
[-] 		target.addHyperText ("Value:       [\e[31mNONE\e[m]");
[+] 		target.addHyperText("Value:       [\e[31mNONE\e[m]");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			sizeof (uint8_t) * mult,
[+] 			sizeof(uint8_t)* mult,
[-] 		target.addHyperText ($"Values [$count]");
[+] 		target.addHyperText($"Values [$count]");
[-] 		representModbusCoilValues (target, p, count, baseOffset, mult);
[+] 		representModbusCoilValues(target, p, count, baseOffset, mult);
[-] 			target.addHyperText ($"[\e^-1\e[34m-\e[m] Values [$count]");
[+] 			target.addHyperText($"[\e^-1\e[34m-\e[m] Values [$count]");
[-] 			representModbusCoilValues (target, p, count, baseOffset, mult);
[+] 			representModbusCoilValues(target, p, count, baseOffset, mult);
[-] 			target.addHyperText ($"[\e^+1\e[34m+\e[m] Values [$count]");
[+] 			target.addHyperText($"[\e^+1\e[34m+\e[m] Values [$count]");
[-] representModbusCoilValues (
[+] representModbusCoilValues(
[-] 		uint8_t c = p [j];
[+] 		uint8_t c = p[j];
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				sizeof (uint8_t) * mult,
[+] 				sizeof(uint8_t)* mult,
[-] representModbusRegisters (
[+] representModbusRegisters(
[-] 	switch (count)
[+] 	switch(count)
[-] 		target.addHyperText ("Value:       [\e[31mNONE\e[m]");
[+] 		target.addHyperText("Value:       [\e[31mNONE\e[m]");
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			sizeof (uint16_t) * mult,
[+] 			sizeof(uint16_t)* mult,
[-] 			p [0]
[+] 			p[0]
[-] 		target.addHyperText ($"Values [$count]");
[+] 		target.addHyperText($"Values [$count]");
[-] 		representModbusRegisterValues (target, p, count, baseOffset, mult);
[+] 		representModbusRegisterValues(target, p, count, baseOffset, mult);
[-] 			target.addHyperText ($"[\e^-1\e[34m-\e[m] Values [$count]");
[+] 			target.addHyperText($"[\e^-1\e[34m-\e[m] Values [$count]");
[-] 			representModbusRegisterValues (target, p, count, baseOffset, mult);
[+] 			representModbusRegisterValues(target, p, count, baseOffset, mult);
[-] 			target.addHyperText ($"[\e^+1\e[34m+\e[m] Values [$count]");
[+] 			target.addHyperText($"[\e^+1\e[34m+\e[m] Values [$count]");
[-] representModbusRegisterValues (
[+] representModbusRegisterValues(
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			baseOffset + i * sizeof (uint16_t) * mult,
[+] 			baseOffset + i * sizeof(uint16_t)* mult,
[-] 			sizeof (uint16_t) * mult,
[+] 			sizeof(uint16_t)* mult,
[-] 			p [i]
[+] 			p[i]
[-] representModbusPdu (
[+] representModbusPdu(
[-] 	target.addHyperText (
[+] 	target.addHyperText(
[-] 		baseOffset + offsetof (hdr.m_func) * mult,
[+] 		baseOffset + offsetof(hdr.m_func) * mult,
[-] 		sizeof (hdr.m_func) * mult,
[+] 		sizeof(hdr.m_func) * mult,
[-] 		io.getModbusFuncString (hdr.m_func)
[+] 		io.getModbusFuncString(hdr.m_func)
[-] 	switch (hdr.m_func)
[+] 	switch(hdr.m_func)
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * mult,
[+] 				baseOffset + offsetof(pdu.m_address) * mult,
[-] 				sizeof (pdu.m_address) * mult,
[+] 				sizeof(pdu.m_address) * mult,
[-] 				baseOffset + offsetof (pdu.m_count) * mult,
[+] 				baseOffset + offsetof(pdu.m_count) * mult,
[-] 				sizeof (pdu.m_count) * mult,
[+] 				sizeof(pdu.m_count) * mult,
[-] 				target.addHyperText (
[+] 				target.addHyperText(
[-] 					baseOffset + offsetof (pdu.m_size) * mult,
[+] 					baseOffset + offsetof(pdu.m_size) * mult,
[-] 					sizeof (pdu.m_size) * mult,
[+] 					sizeof(pdu.m_size) * mult,
[-] 				representModbusCoils (
[+] 				representModbusCoils(
[-] 					baseOffset + sizeof (io.ModbusReadReplyPdu) * mult,
[+] 					baseOffset + sizeof(io.ModbusReadReplyPdu) * mult,
[-] 				target.addHyperText (
[+] 				target.addHyperText(
[-] 					baseOffset + offsetof (pdu.m_size) * mult,
[+] 					baseOffset + offsetof(pdu.m_size) * mult,
[-] 					sizeof (pdu.m_size) * mult,
[+] 					sizeof(pdu.m_size) * mult,
[-] 				representModbusRegisters (
[+] 				representModbusRegisters(
[-] 					baseOffset + sizeof (io.ModbusReadReplyPdu) * mult,
[+] 					baseOffset + sizeof(io.ModbusReadReplyPdu) * mult,
[-] 		target.addHyperText (
[+] 		target.addHyperText(
[-] 			baseOffset + offsetof (pdu.m_address) * mult,
[+] 			baseOffset + offsetof(pdu.m_address) * mult,
[-] 			sizeof (pdu.m_address) * mult,
[+] 			sizeof(pdu.m_address) * mult,
[-] 			baseOffset + offsetof (pdu.m_value) * mult,
[+] 			baseOffset + offsetof(pdu.m_value) * mult,
[-] 			sizeof (pdu.m_value) * mult,
[+] 			sizeof(pdu.m_value) * mult,
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * mult,
[+] 				baseOffset + offsetof(pdu.m_address) * mult,
[-] 				sizeof (pdu.m_address) * mult,
[+] 				sizeof(pdu.m_address) * mult,
[-] 				baseOffset + offsetof (pdu.m_count) * mult,
[+] 				baseOffset + offsetof(pdu.m_count) * mult,
[-] 				sizeof (pdu.m_count) * mult,
[+] 				sizeof(pdu.m_count) * mult,
[-] 				baseOffset + offsetof (pdu.m_size) * mult,
[+] 				baseOffset + offsetof(pdu.m_size) * mult,
[-] 				sizeof (pdu.m_size) * mult,
[+] 				sizeof(pdu.m_size) * mult,
[-] 				representModbusCoils (
[+] 				representModbusCoils(
[-] 					baseOffset + sizeof (io.ModbusWriteMultiplePdu),
[+] 					baseOffset + sizeof(io.ModbusWriteMultiplePdu),
[-] 				representModbusRegisters (
[+] 				representModbusRegisters(
[-] 					baseOffset + sizeof (io.ModbusWriteMultiplePdu),
[+] 					baseOffset + sizeof(io.ModbusWriteMultiplePdu),
[-] 			target.addHyperText (
[+] 			target.addHyperText(
[-] 				baseOffset + offsetof (pdu.m_address) * mult,
[+] 				baseOffset + offsetof(pdu.m_address) * mult,
[-] 				sizeof (pdu.m_address) * mult,
[+] 				sizeof(pdu.m_address) * mult,
[-] 				baseOffset + offsetof (pdu.m_count) * mult,
[+] 				baseOffset + offsetof(pdu.m_count) * mult,
[-] 				sizeof (pdu.m_count) * mult,
[+] 				sizeof(pdu.m_count) * mult,
[-]             target.addHyperText (
[+]             target.addHyperText(
[-]                 baseOffset + offsetof (pdu.m_exception) * mult,
[+]                 baseOffset + offsetof(pdu.m_exception) * mult,
[-]                 sizeof (pdu.m_exception) * mult,
[+]                 sizeof(pdu.m_exception) * mult,
[-]                 io.getModbusExceptionString (pdu.m_exception)
[+]                 io.getModbusExceptionString(pdu.m_exception)
[-] representModbusMbap (
[+] representModbusMbap(
[-]     target.addHyperText (
[+]     target.addHyperText(
[-]         baseOffset + offsetof (hdr.m_transactId),
[+]         baseOffset + offsetof(hdr.m_transactId),
[-]         sizeof (hdr.m_transactId),
[+]         sizeof(hdr.m_transactId),
[-]         baseOffset + offsetof (hdr.m_protocolId),
[+]         baseOffset + offsetof(hdr.m_protocolId),
[-]         sizeof (hdr.m_protocolId),
[+]         sizeof(hdr.m_protocolId),
[-]         baseOffset + offsetof (hdr.m_sizePdu),
[+]         baseOffset + offsetof(hdr.m_sizePdu),
[-]         sizeof (hdr.m_sizePdu),
[+]         sizeof(hdr.m_sizePdu),
[-]         baseOffset + offsetof (hdr.m_unitId),
[+]         baseOffset + offsetof(hdr.m_unitId),
[-]         sizeof (hdr.m_unitId),
[+]         sizeof(hdr.m_unitId),
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TibboModbusGatewayMon\ModbusGatewayMonSession.jnc
----------------------
[-] 	static char const* m_stateStringTable [] =
[+] 	static char const* m_stateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	static uint8_t m_bufferIncoming [512];
[+] 	static uint8_t m_bufferIncoming[512];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode connect ();
[+] 	bool errorcode connect();
[-] 	bool errorcode connect (io.SocketAddress const* address);
[+] 	bool errorcode connect(io.SocketAddress const* address);
[-] 	disconnect ();
[+] 	disconnect();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	handleConnectError (std.Error const* error);
[+] 	handleConnectError(std.Error const* error);
[-] 	onConnect ();
[+] 	onConnect();
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onSocketEvent (
[+] 	onSocketEvent(
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] 	createUi ();
[+] 	createUi();
[-] ModbusGatewayMonSession.construct (doc.PluginHost* pluginHost)
[+] ModbusGatewayMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] ModbusGatewayMonSession.createUi ()
[+] ModbusGatewayMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Modbus Gateway Address:");
[+] 	m_pluginHost.m_toolBar.addLabel("Modbus Gateway Address:");
[-] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_addressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Connect] = new gui.Icon ("images/connect.png");
[+] 	m_iconTable[IconId.Connect] = new gui.Icon("images/connect.png");
[-] 	m_iconTable [IconId.Disconnect] = new gui.Icon ("images/disconnect.png");
[+] 	m_iconTable[IconId.Disconnect] = new gui.Icon("images/disconnect.png");
[-] 	m_actionTable [ActionId.Connect] = createAction ("Connect", m_iconTable [IconId.Connect]);
[+] 	m_actionTable[ActionId.Connect] = createAction("Connect", m_iconTable [IconId.Connect]);
[-] 	m_actionTable [ActionId.Connect].m_onTriggered += onConnect;
[+] 	m_actionTable[ActionId.Connect].m_onTriggered += onConnect;
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_color = gui.StdColor.Blue;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	m_statusPaneTable [StatusPaneId.Temp] = m_pluginHost.m_statusBar.addPane (, 100);
[+] 	m_statusPaneTable[StatusPaneId.Temp] = m_pluginHost.m_statusBar.addPane(, 100);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (m_pluginHost.m_propertyGrid, group); //,, mask);
[+] 	m_socketPropertySet.createProperties(m_pluginHost.m_propertyGrid, group); //,, mask);
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Modbus Gateway Connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Modbus Gateway Connection");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] ModbusGatewayMonSession.onConnect ()
[+] ModbusGatewayMonSession.onConnect()
[-] 		disconnect ();
[+] 		disconnect();
[-] 		try connect ();
[+] 		try connect();
[-] bool errorcode ModbusGatewayMonSession.connect ()
[+] bool errorcode ModbusGatewayMonSession.connect()
[-] 	disconnect ();
[+] 	disconnect();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_addressCombo.addEditTextToHistory ();
[+] 	m_addressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try address.parse (addressString);
[+] 	bool isDirectAddress = try address.parse(addressString);
[-] 		return try connect (&address);
[+] 		return try connect(&address);
[-] 	writeLog (
[+] 	writeLog(
[-] 		strlen (addressString)
[+] 		strlen(addressString)
[-] 	m_resolver.resolve (addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_resolver.resolve(addressString, addressFamily, onResolveCompleted ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] bool errorcode ModbusGatewayMonSession.connect (io.SocketAddress const* remoteAddress)
[+] bool errorcode ModbusGatewayMonSession.connect(io.SocketAddress const* remoteAddress)
[-] 	disconnect ();
[+] 	disconnect();
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 		m_socket.open (remoteAddress.m_family, io.Protocol.Tcp);
[+] 		m_socket.open(remoteAddress.m_family, io.Protocol.Tcp);
[-] 		localAddress.m_ip4.m_port = (uint16_t) m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[+] 		localAddress.m_ip4.m_port = (uint16_t)m_socketPropertySet.m_localPortProp.m_value; // same for IPv4/IPv6
[-] 		m_socket.open (io.Protocol.Tcp, &localAddress);
[+] 		m_socket.open(io.Protocol.Tcp, &localAddress);
[-] 	m_socket.connect (remoteAddress);
[+] 	m_socket.connect(remoteAddress);
[-] 	writeLog (SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof (p));
[+] 	writeLog(SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof(p));
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] 		writeLog (SocketLogRecordCode.Connecting, remoteAddress, sizeof (io.SocketAddress));
[+] 		writeLog(SocketLogRecordCode.Connecting, remoteAddress, sizeof(io.SocketAddress));
[-] 		writeLog (SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof (p));
[+] 		writeLog(SocketLogRecordCode.ConnectingFrom, p, dynamic sizeof(p));
[-] 	handleConnectError (std.getLastError ());
[+] 	handleConnectError(std.getLastError());
[-] ModbusGatewayMonSession.handleConnectError (std.Error const* error)
[+] ModbusGatewayMonSession.handleConnectError(std.Error const* error)
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] ModbusGatewayMonSession.disconnect ()
[+] ModbusGatewayMonSession.disconnect()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		writeLog (SocketLogRecordCode.ConnectCancelled);
[+] 		writeLog(SocketLogRecordCode.ConnectCancelled);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (params)
[+] 			sizeof(params)
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] void ModbusGatewayMonSession.load (doc.Storage* storage)
[+] void ModbusGatewayMonSession.load(doc.Storage* storage)
[-] 	m_addressCombo.loadHistory (storage, "addressHistory");
[+] 	m_addressCombo.loadHistory(storage, "addressHistory");
[-] 	m_addressCombo.m_editText = storage.readString ("address");
[+] 	m_addressCombo.m_editText = storage.readString("address");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] void ModbusGatewayMonSession.save (doc.Storage* storage)
[+] void ModbusGatewayMonSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_addressCombo.saveHistory (storage, "addressHistory");
[+] 	m_addressCombo.saveHistory(storage, "addressHistory");
[-] 	storage.writeString ("address", m_addressCombo.m_editText); // overwrite
[+] 	storage.writeString("address", m_addressCombo.m_editText); // overwrite
[-] void ModbusGatewayMonSession.updateProperties ()
[+] void ModbusGatewayMonSession.updateProperties()
[-] bool errorcode ModbusGatewayMonSession.applyProperties ()
[+] bool errorcode ModbusGatewayMonSession.applyProperties()
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] void ModbusGatewayMonSession.restoreDefaultProperties ()
[+] void ModbusGatewayMonSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] ModbusGatewayMonSession.waitSocketEvents ()
[+] ModbusGatewayMonSession.waitSocketEvents()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 	m_socket.wait (eventMask, onSocketEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_socket.wait(eventMask, onSocketEvent ~(++m_syncId) @ m_pluginHost.m_mainThreadScheduler);
[-] ModbusGatewayMonSession.onSocketEvent (
[+] ModbusGatewayMonSession.onSocketEvent(
[-] 		handleConnectError (m_socket.m_ioError);
[+] 		handleConnectError(m_socket.m_ioError);
[-] 		writeLog (SocketLogRecordCode.ConnectCompleted);
[+] 		writeLog(SocketLogRecordCode.ConnectCompleted);
[-] 		m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 		m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 		size_t sz = m_socket.write (m_telnetCommand, 4);
[+] 		size_t sz = m_socket.write(m_telnetCommand, 4);
[-] 			writeLog (ModbusGatewayMonLogRecordCode.CommandError);
[+] 			writeLog(ModbusGatewayMonLogRecordCode.CommandError);
[-] 			size_t result = m_socket.read (m_bufferIncoming, sizeof (m_bufferIncoming));
[+] 			size_t result = m_socket.read(m_bufferIncoming, sizeof(m_bufferIncoming));
[-] 			writeLog (log.StdRecordCode.Rx, m_bufferIncoming, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_bufferIncoming, result);
[-] 		writeLog (
[+] 		writeLog(
[-] 			sizeof (recordParams)
[+] 			sizeof(recordParams)
[-] 		m_socket.close ();
[+] 		m_socket.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 			result = try m_socket.read (&m_bufferIncoming + m_bufferIncomingLength, sizeof(m_bufferIncoming) - m_bufferIncomingLength);
[+] 			result = try m_socket.read(&m_bufferIncoming + m_bufferIncomingLength, sizeof(m_bufferIncoming) - m_bufferIncomingLength);
[-] 								writeLog (ModbusGatewayMonLogRecordCode.DumpPacket, &m_bufferIncoming[4], sizePacket - 2);
[+] 								writeLog(ModbusGatewayMonLogRecordCode.DumpPacket, &m_bufferIncoming[4], sizePacket - 2);
[-] 						writeLog (ModbusGatewayMonLogRecordCode.Log, str, dynamic sizeof(str));
[+] 						writeLog(ModbusGatewayMonLogRecordCode.Log, str, dynamic sizeof(str));
[-] 						writeLog (log.StdRecordCode.Rx, m_bufferIncoming, 128);
[+] 						writeLog(log.StdRecordCode.Rx, m_bufferIncoming, 128);
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] ModbusGatewayMonSession.onResolveCompleted (
[+] ModbusGatewayMonSession.onResolveCompleted(
[-] 		handleConnectError (error);
[+] 		handleConnectError(error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	io.SocketAddress address = addressTable [0];
[+] 	io.SocketAddress address = addressTable[0];
[-] 	connect (address);
[+] 	connect(address);
[-] 	m_actionTable [ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[+] 	m_actionTable[ActionId.Connect].m_text = m_state ? "Disconnect" : "Connect";
[-] 	m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? IconId.Disconnect : IconId.Connect];
[+] 	m_actionTable[ActionId.Connect].m_icon = m_iconTable[m_state ? IconId.Disconnect : IconId.Connect];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_stateStringTable[m_state];
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString () : "<peer-address>";
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_text = m_state > State.Resolving ? m_remoteAddress.getString() : "<peer-address>";
[-] 	m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
[+] 	m_statusPaneTable[StatusPaneId.RemoteAddress].m_isVisible = m_state > State.Resolving;
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TxModifier\TxModifierLayer.jnc
----------------------
[-] 	static char m_defaultPrefix [] = "\\x02";
[+] 	static char m_defaultPrefix[] = "\\x02";
[-] 	static char m_defaultSuffix [] = "\\r";
[+] 	static char m_defaultSuffix[] = "\\r";
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	size_t write (
[+] 	size_t write(
[-] 	flushDelayedWriteList ();
[+] 	flushDelayedWriteList();
[-] 	setDelayedWriteTimer ();
[+] 	setDelayedWriteTimer();
[-] 	onDelayedWriteTimer ();
[+] 	onDelayedWriteTimer();
[-] 	scheduleRetransmission (
[+] 	scheduleRetransmission(
[-] 	cancelRetransmission ();
[+] 	cancelRetransmission();
[-] 	onRetransmitTimer ();
[+] 	onRetransmitTimer();
[-] 	onTransmitEnabledChanged ();
[+] 	onTransmitEnabledChanged();
[-] 	createUi ();
[+] 	createUi();
[-] TxModifierLayer.construct (doc.PluginHost* pluginHost)
[+] TxModifierLayer.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] TxModifierLayer.createUi ()
[+] TxModifierLayer.createUi()
[-] 	m_isPrefixEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isPrefixEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_prefixProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_prefixProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_isSuffixEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isSuffixEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_suffixProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_suffixProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_isInterCharDelayEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isInterCharDelayEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_interCharDelayProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_interCharDelayProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_isRetransmitEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isRetransmitEnabledProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_retransmitCountProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_retransmitCountProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_retransmitDelayProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_retransmitDelayProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	bindingof (m_isTransmitEnabled) += onTransmitEnabledChanged;
[+] 	bindingof(m_isTransmitEnabled) += onTransmitEnabledChanged;
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] void TxModifierLayer.load (doc.Storage* storage)
[+] void TxModifierLayer.load(doc.Storage* storage)
[-] 	m_isPrefixEnabledProp.m_value = storage.readBool ("isPrefixEnabled", Defaults.IsPrefixEnabled);
[+] 	m_isPrefixEnabledProp.m_value = storage.readBool("isPrefixEnabled", Defaults.IsPrefixEnabled);
[-] 	m_prefixProp.m_value = storage.readString ("prefix", m_defaultPrefix);
[+] 	m_prefixProp.m_value = storage.readString("prefix", m_defaultPrefix);
[-] 	m_isSuffixEnabledProp.m_value = storage.readBool ("isSuffixEnabled", Defaults.IsSuffixEnabled);
[+] 	m_isSuffixEnabledProp.m_value = storage.readBool("isSuffixEnabled", Defaults.IsSuffixEnabled);
[-] 	m_suffixProp.m_value = storage.readString ("suffix", m_defaultSuffix);
[+] 	m_suffixProp.m_value = storage.readString("suffix", m_defaultSuffix);
[-] 	m_isInterCharDelayEnabledProp.m_value = storage.readBool ("isInterCharDelayEnabled", Defaults.IsInterCharDelayEnabled);
[+] 	m_isInterCharDelayEnabledProp.m_value = storage.readBool("isInterCharDelayEnabled", Defaults.IsInterCharDelayEnabled);
[-] 	m_interCharDelayProp.m_value = storage.readInt ("interCharDelay", Defaults.InterCharDelay);
[+] 	m_interCharDelayProp.m_value = storage.readInt("interCharDelay", Defaults.InterCharDelay);
[-] 	m_isRetransmitEnabledProp.m_value = storage.readBool ("isRetransmitEnabled", Defaults.IsRetansmitEnabled);
[+] 	m_isRetransmitEnabledProp.m_value = storage.readBool("isRetransmitEnabled", Defaults.IsRetansmitEnabled);
[-] 	m_retransmitCountProp.m_value = storage.readInt ("retransmitCount", Defaults.RetransmitCount);
[+] 	m_retransmitCountProp.m_value = storage.readInt("retransmitCount", Defaults.RetransmitCount);
[-] 	m_retransmitDelayProp.m_value = storage.readInt ("retransmitDelay", Defaults.RetransmitDelay);
[+] 	m_retransmitDelayProp.m_value = storage.readInt("retransmitDelay", Defaults.RetransmitDelay);
[-] void TxModifierLayer.save (doc.Storage* storage)
[+] void TxModifierLayer.save(doc.Storage* storage)
[-] 	storage.writeBool ("isPrefixEnabled", m_isPrefixEnabledProp.m_value);
[+] 	storage.writeBool("isPrefixEnabled", m_isPrefixEnabledProp.m_value);
[-] 	storage.writeString ("prefix", m_prefixProp.m_value);
[+] 	storage.writeString("prefix", m_prefixProp.m_value);
[-] 	storage.writeBool ("isSuffixEnabled", m_isSuffixEnabledProp.m_value);
[+] 	storage.writeBool("isSuffixEnabled", m_isSuffixEnabledProp.m_value);
[-] 	storage.writeString ("suffix", m_suffixProp.m_value);
[+] 	storage.writeString("suffix", m_suffixProp.m_value);
[-] 	storage.writeBool ("isInterCharDelayEnabled", m_isInterCharDelayEnabledProp.m_value);
[+] 	storage.writeBool("isInterCharDelayEnabled", m_isInterCharDelayEnabledProp.m_value);
[-] 	storage.writeInt ("interCharDelay", m_interCharDelayProp.m_value);
[+] 	storage.writeInt("interCharDelay", m_interCharDelayProp.m_value);
[-] 	storage.writeBool ("isRetransmitEnabled", m_isRetransmitEnabledProp.m_value);
[+] 	storage.writeBool("isRetransmitEnabled", m_isRetransmitEnabledProp.m_value);
[-] 	storage.writeInt ("retransmitCount", m_retransmitCountProp.m_value);
[+] 	storage.writeInt("retransmitCount", m_retransmitCountProp.m_value);
[-] 	storage.writeInt ("retransmitDelay", m_retransmitDelayProp.m_value);
[+] 	storage.writeInt("retransmitDelay", m_retransmitDelayProp.m_value);
[-] bool errorcode TxModifierLayer.applyProperties ()
[+] bool errorcode TxModifierLayer.applyProperties()
[-] 		flushDelayedWriteList ();
[+] 		flushDelayedWriteList();
[-] 		setDelayedWriteTimer ();
[+] 		setDelayedWriteTimer();
[-] void TxModifierLayer.restoreDefaultProperties ()
[+] void TxModifierLayer.restoreDefaultProperties()
[-] size_t errorcode TxModifierLayer.transmit (
[+] size_t errorcode TxModifierLayer.transmit(
[-] 			decodeEscapeString (&string, m_prefixProp.m_value);
[+] 			decodeEscapeString(&string, m_prefixProp.m_value);
[-] 			buffer.append (string.m_p, string.m_length);
[+] 			buffer.append(string.m_p, string.m_length);
[-] 		buffer.append (p, size);
[+] 		buffer.append(p, size);
[-] 			decodeEscapeString (&string, m_suffixProp.m_value);
[+] 			decodeEscapeString(&string, m_suffixProp.m_value);
[-] 			buffer.append (string.m_p, string.m_length);
[+] 			buffer.append(string.m_p, string.m_length);
[-] 	cancelRetransmission ();
[+] 	cancelRetransmission();
[-] 	return write (packet, packetSize);
[+] 	return write(packet, packetSize);
[-] size_t TxModifierLayer.write (
[+] size_t TxModifierLayer.write(
[-] 		size_t result = transmitNext (p, size);
[+] 		size_t result = transmitNext(p, size);
[-] 		m_lastWriteTimestamp = sys.getTimestamp ();
[+] 		m_lastWriteTimestamp = sys.getTimestamp();
[-] 		scheduleRetransmission (p, size);
[+] 		scheduleRetransmission(p, size);
[-] 	m_delayedWriteList.add (delayedWrite);
[+] 	m_delayedWriteList.add(delayedWrite);
[-] 	uint64_t timestamp = sys.getTimestamp ();
[+] 	uint64_t timestamp = sys.getTimestamp();
[-] 		onDelayedWriteTimer (); // send 1st char now
[+] 		onDelayedWriteTimer(); // send 1st char now
[-] 		setDelayedWriteTimer ();
[+] 		setDelayedWriteTimer();
[-] TxModifierLayer.flushDelayedWriteList ()
[+] TxModifierLayer.flushDelayedWriteList()
[-] 		DelayedWrite* delayedWrite = m_delayedWriteList.removeHead ();
[+] 		DelayedWrite* delayedWrite = m_delayedWriteList.removeHead();
[-] 		transmitNext (delayedWrite.m_p, size);
[+] 		transmitNext(delayedWrite.m_p, size);
[-] 			scheduleRetransmission (delayedWrite.m_start, delayedWrite.m_end - delayedWrite.m_start);
[+] 			scheduleRetransmission(delayedWrite.m_start, delayedWrite.m_end - delayedWrite.m_start);
[-] 	m_lastWriteTimestamp = sys.getTimestamp ();
[+] 	m_lastWriteTimestamp = sys.getTimestamp();
[-] TxModifierLayer.setDelayedWriteTimer ()
[+] TxModifierLayer.setDelayedWriteTimer()
[-] 	m_delayedWriteTimer.startPeriodicTimer (
[+] 	m_delayedWriteTimer.startPeriodicTimer(
[-] TxModifierLayer.onDelayedWriteTimer ()
[+] TxModifierLayer.onDelayedWriteTimer()
[-] 		uint64_t timestamp = sys.getTimestamp ();
[+] 		uint64_t timestamp = sys.getTimestamp();
[-] 			m_delayedWriteTimer.stop ();
[+] 			m_delayedWriteTimer.stop();
[-] 	transmitNext (delayedWrite.m_p, 1);
[+] 	transmitNext(delayedWrite.m_p, 1);
[-] 		m_delayedWriteList.removeHead ();
[+] 		m_delayedWriteList.removeHead();
[-] 			scheduleRetransmission (delayedWrite.m_start, delayedWrite.m_end - delayedWrite.m_start);
[+] 			scheduleRetransmission(delayedWrite.m_start, delayedWrite.m_end - delayedWrite.m_start);
[-] 	m_lastWriteTimestamp = sys.getTimestamp ();
[+] 	m_lastWriteTimestamp = sys.getTimestamp();
[-] TxModifierLayer.scheduleRetransmission (
[+] TxModifierLayer.scheduleRetransmission(
[-] 		m_retransmitTimer.stop ();
[+] 		m_retransmitTimer.stop();
[-] 	m_retransmitTimer.startSingleShotTimer (
[+] 	m_retransmitTimer.startSingleShotTimer(
[-] TxModifierLayer.cancelRetransmission ()
[+] TxModifierLayer.cancelRetransmission()
[-] 	m_retransmitTimer.stop ();
[+] 	m_retransmitTimer.stop();
[-] TxModifierLayer.onRetransmitTimer ()
[+] TxModifierLayer.onRetransmitTimer()
[-] 	write (m_retransmitPacket, m_retransmitPacketSize);
[+] 	write(m_retransmitPacket, m_retransmitPacketSize);
[-] TxModifierLayer.onTransmitEnabledChanged ()
[+] TxModifierLayer.onTransmitEnabledChanged()
[-] 	m_delayedWriteList.clear ();
[+] 	m_delayedWriteList.clear();
[-] 	m_delayedWriteTimer.stop ();
[+] 	m_delayedWriteTimer.stop();
[-] 	m_retransmitTimer.stop ();
[+] 	m_retransmitTimer.stop();
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\TxRxFilter\TxRxFilterLayer.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override bool filter (
[+] 	override bool filter(
[-] TxRxFilterLayer.construct (doc.PluginHost* pluginHost)
[+] TxRxFilterLayer.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_isTxVisibleProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isTxVisibleProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_isRxVisibleProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_isRxVisibleProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	pluginHost.m_log.addFilter (this);
[+] 	pluginHost.m_log.addFilter(this);
[-] void TxRxFilterLayer.load (doc.Storage* storage)
[+] void TxRxFilterLayer.load(doc.Storage* storage)
[-] 	m_isTxVisibleProp.m_value = storage.readBool ("isTxVisibleProp", true);
[+] 	m_isTxVisibleProp.m_value = storage.readBool("isTxVisibleProp", true);
[-] 	m_isRxVisibleProp.m_value = storage.readBool ("isRxVisibleProp", true);
[+] 	m_isRxVisibleProp.m_value = storage.readBool("isRxVisibleProp", true);
[-] void TxRxFilterLayer.save (doc.Storage* storage)
[+] void TxRxFilterLayer.save(doc.Storage* storage)
[-] 	storage.writeBool ("isTxVisibleProp", m_isTxVisibleProp.m_value);
[+] 	storage.writeBool("isTxVisibleProp", m_isTxVisibleProp.m_value);
[-] 	storage.writeBool ("isRxVisibleProp", m_isRxVisibleProp.m_value);
[+] 	storage.writeBool("isRxVisibleProp", m_isRxVisibleProp.m_value);
[-] void TxRxFilterLayer.restoreDefaultProperties ()
[+] void TxRxFilterLayer.restoreDefaultProperties()
[-] bool TxRxFilterLayer.filter (
[+] bool TxRxFilterLayer.filter(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Udp\UdpLogRepresenter.jnc
----------------------
[-] bool representUdpLog (
[+] bool representUdpLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		char const* remoteAddress = ((io.SocketAddress const*) p).getString ();
[+] 		char const* remoteAddress = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"To \e[34m$remoteAddress");
[+] 		target.addHyperText($"To \e[34m$remoteAddress");
[-] 		char const* remoteAddress = ((io.SocketAddress const*) p).getString ();
[+] 		char const* remoteAddress = ((io.SocketAddress const*) p).getString();
[-] 		target.addHyperText ($"From \e[34m$remoteAddress");
[+] 		target.addHyperText($"From \e[34m$remoteAddress");
----------------------
27/02/2019 18:02:27 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\Udp\UdpSession.jnc
----------------------
[-] 	static char DefaultRemoteAddress [] = "192.168.1.255";
[+] 	static char DefaultRemoteAddress[] = "192.168.1.255";
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	openSocket ();
[+] 	openSocket();
[-] 	closeSocket ();
[+] 	closeSocket();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	override size_t errorcode transmitTo (
[+] 	override size_t errorcode transmitTo(
[-] 	onRemoteAddressChanged ();
[+] 	onRemoteAddressChanged();
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onSocketEvent (
[+] 	onSocketEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] 	size_t writeDatagram (
[+] 	size_t writeDatagram(
[-] UdpSession.construct (doc.PluginHost* pluginHost)
[+] UdpSession.construct(doc.PluginHost* pluginHost)
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Compass] = new gui.Icon ("images/compass.png");
[+] 	m_iconTable[IconId.Compass] = new gui.Icon("images/compass.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Remote:");
[+] 	m_pluginHost.m_toolBar.addLabel("Remote:");
[-] 	m_remoteAddressCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_remoteAddressCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.AutoRemoteAddress] = createAction("Auto-switch remote address", m_iconTable [IconId.Compass]);
[+] 	m_actionTable[ActionId.AutoRemoteAddress] = createAction("Auto-switch remote address", m_iconTable [IconId.Compass]);
[-] 	m_actionTable [ActionId.AutoRemoteAddress].m_isCheckable = true;
[+] 	m_actionTable[ActionId.AutoRemoteAddress].m_isCheckable = true;
[-] 	m_pluginHost.m_toolBar.addLabel ("Adapter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Adapter:");
[-] 	m_adapterCombo = io.createNetworkAdapterComboBox (m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[+] 	m_adapterCombo = io.createNetworkAdapterComboBox(m_pluginHost.m_toolBar, io.NetworkAdapterUsage.Listener);
[-] 	m_pluginHost.m_toolBar.addLabel ("Port:");
[+] 	m_pluginHost.m_toolBar.addLabel("Port:");
[-] 	m_localPortCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_localPortCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_actionTable [ActionId.Open] = createAction("Open socket", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open socket", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpen;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpen;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_socketPropertySet.createProperties (
[+] 	m_socketPropertySet.createProperties(
[-] 	m_autoRemoteAddressProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_autoRemoteAddressProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (
[+] 	m_bufferPropertySet.createPropertiesGrouped(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("UDP socket");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("UDP socket");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 		closeSocket ();
[+] 		closeSocket();
[-] 		openSocket ();
[+] 		openSocket();
[-] UdpSession.openSocket ()
[+] UdpSession.openSocket()
[-] 	closeSocket ();
[+] 	closeSocket();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_localPortCombo.addEditTextToHistory ();
[+] 	m_localPortCombo.addEditTextToHistory();
[-] 	address.m_ip4.m_port = (uint16_t) atoi (portString); // same for IPv4/IPv6
[+] 	address.m_ip4.m_port = (uint16_t)atoi(portString); // same for IPv4/IPv6
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] 	m_socket.open (io.Protocol.Udp, &address);
[+] 	m_socket.open(io.Protocol.Udp, &address);
[-] 	writeLog (SocketLogRecordCode.Open, &address, sizeof (address));
[+] 	writeLog(SocketLogRecordCode.Open, &address, sizeof(address));
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	void const* p = memcat (&address, sizeof (address), error, error.m_size);
[+] 	void const* p = memcat(&address, sizeof(address), error, error.m_size);
[-] 	writeLog (SocketLogRecordCode.OpenError, p, dynamic sizeof (p));
[+] 	writeLog(SocketLogRecordCode.OpenError, p, dynamic sizeof(p));
[-] UdpSession.closeSocket ()
[+] UdpSession.closeSocket()
[-] 	m_socket.close ();
[+] 	m_socket.close();
[-] 	writeLog (SocketLogRecordCode.Close, &address, sizeof (address));
[+] 	writeLog(SocketLogRecordCode.Close, &address, sizeof(address));
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] UdpSession.waitSocketEvents ()
[+] UdpSession.waitSocketEvents()
[-] 	m_socket.wait (eventMask, onSocketEvent ~(++m_socketSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_socket.wait(eventMask, onSocketEvent ~(++m_socketSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] UdpSession.load (doc.Storage* storage)
[+] UdpSession.load(doc.Storage* storage)
[-] 	m_remoteAddressCombo.loadHistory (storage, "remoteAddressHistory");
[+] 	m_remoteAddressCombo.loadHistory(storage, "remoteAddressHistory");
[-] 	m_localPortCombo.loadHistory (storage, "localPortHistory");
[+] 	m_localPortCombo.loadHistory(storage, "localPortHistory");
[-] 	m_remoteAddressCombo.m_editText = storage.readString ("remoteAddress", DefaultRemoteAddress);
[+] 	m_remoteAddressCombo.m_editText = storage.readString("remoteAddress", DefaultRemoteAddress);
[-] 	m_actionTable [ActionId.AutoRemoteAddress].m_isChecked = storage.readInt ("autoRemoteAddress");
[+] 	m_actionTable[ActionId.AutoRemoteAddress].m_isChecked = storage.readInt("autoRemoteAddress");
[-] 	m_adapterCombo.m_currentIndex = storage.readInt ("adapterIdx");
[+] 	m_adapterCombo.m_currentIndex = storage.readInt("adapterIdx");
[-] 	m_localPortCombo.m_editText = storage.readString ("localPort");
[+] 	m_localPortCombo.m_editText = storage.readString("localPort");
[-] 	m_socketPropertySet.load (storage);
[+] 	m_socketPropertySet.load(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] UdpSession.save (doc.Storage* storage)
[+] UdpSession.save(doc.Storage* storage)
[-] 	m_socketPropertySet.save (storage);
[+] 	m_socketPropertySet.save(storage);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_remoteAddressCombo.saveHistory (storage, "remoteAddressHistory");
[+] 	m_remoteAddressCombo.saveHistory(storage, "remoteAddressHistory");
[-] 	m_localPortCombo.saveHistory (storage, "localPortHistory");
[+] 	m_localPortCombo.saveHistory(storage, "localPortHistory");
[-] 	storage.writeString ("remoteAddress", m_remoteAddressCombo.m_editText);
[+] 	storage.writeString("remoteAddress", m_remoteAddressCombo.m_editText);
[-] 	storage.writeInt ("autoRemoteAddress", m_actionTable [ActionId.AutoRemoteAddress].m_isChecked);
[+] 	storage.writeInt("autoRemoteAddress", m_actionTable [ActionId.AutoRemoteAddress].m_isChecked);
[-] 	storage.writeInt ("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[+] 	storage.writeInt("adapterIdx", (int) m_adapterCombo.m_currentIndex);
[-] 	storage.writeString ("localPort", m_localPortCombo.m_editText);
[+] 	storage.writeString("localPort", m_localPortCombo.m_editText);
[-] UdpSession.updateProperties ()
[+] UdpSession.updateProperties()
[-] 	m_autoRemoteAddressProp.m_value = m_actionTable [ActionId.AutoRemoteAddress].m_isChecked;
[+] 	m_autoRemoteAddressProp.m_value = m_actionTable[ActionId.AutoRemoteAddress].m_isChecked;
[-] 	m_socketPropertySet.m_localPortProp.m_value = atoi (m_localPortCombo.m_editText);
[+] 	m_socketPropertySet.m_localPortProp.m_value = atoi(m_localPortCombo.m_editText);
[-] bool errorcode UdpSession.applyProperties ()
[+] bool errorcode UdpSession.applyProperties()
[-] 	m_actionTable [ActionId.AutoRemoteAddress].m_isChecked = m_autoRemoteAddressProp.m_value;
[+] 	m_actionTable[ActionId.AutoRemoteAddress].m_isChecked = m_autoRemoteAddressProp.m_value;
[-] 	m_socket.m_options = io.getSocketOptions (m_socketPropertySet, m_bufferPropertySet);
[+] 	m_socket.m_options = io.getSocketOptions(m_socketPropertySet, m_bufferPropertySet);
[-] UdpSession.restoreDefaultProperties ()
[+] UdpSession.restoreDefaultProperties()
[-] 	m_socketPropertySet.restoreDefaults ();
[+] 	m_socketPropertySet.restoreDefaults();
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode UdpSession.transmit (
[+] size_t errorcode UdpSession.transmit(
[-] 	m_remoteAddressCombo.addEditTextToHistory ();
[+] 	m_remoteAddressCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try remoteAddress.parse (addressString);
[+] 	bool isDirectAddress = try remoteAddress.parse(addressString);
[-] 		size = writeDatagram (p, size, &remoteAddress);
[+] 		size = writeDatagram(p, size, &remoteAddress);
[-] 		m_pendingDatagram.copy (p, size);
[+] 		m_pendingDatagram.copy(p, size);
[-] 			writeLog (
[+] 			writeLog(
[-] 				strlen (addressString)
[+] 				strlen(addressString)
[-] 			m_resolver.resolve (addressString, addressFamily, onResolveCompleted ~(++m_resolverSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 			m_resolver.resolve(addressString, addressFamily, onResolveCompleted ~(++m_resolverSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] size_t errorcode UdpSession.transmitTo (
[+] size_t errorcode UdpSession.transmitTo(
[-] 	if (m_state == State.Closed || addressSize < sizeof (io.SocketAddress))
[+] 	if (m_state == State.Closed || addressSize < sizeof(io.SocketAddress))
[-] 	return writeDatagram (p, size, (io.SocketAddress const*) address);
[+] 	return writeDatagram(p, size, (io.SocketAddress const*) address);
[-] size_t UdpSession.writeDatagram (
[+] size_t UdpSession.writeDatagram(
[-] 	size_t result = m_socket.writeDatagram (p, size, address);
[+] 	size_t result = m_socket.writeDatagram(p, size, address);
[-] 	m_pluginHost.m_log.m_writer.write (UdpLogRecordCode.TxPacket, address, sizeof (io.SocketAddress));
[+] 	m_pluginHost.m_log.m_writer.write(UdpLogRecordCode.TxPacket, address, sizeof(io.SocketAddress));
[-] 		m_pluginHost.m_log.m_writer.write (log.StdRecordCode.Tx, p, result);
[+] 		m_pluginHost.m_log.m_writer.write(log.StdRecordCode.Tx, p, result);
[-] UdpSession.onRemoteAddressChanged ()
[+] UdpSession.onRemoteAddressChanged()
[-] UdpSession.onSocketEvent (
[+] UdpSession.onSocketEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_socket.m_ioError, m_socket.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_socket.m_ioError, m_socket.m_ioError.m_size);
[-] 		m_socket.close ();
[+] 		m_socket.close();
[-] 		m_stdSessionInfoSet.endSession ();
[+] 		m_stdSessionInfoSet.endSession();
[-] 		writeLog (log.StdRecordCode.RxBufferFullLossy);
[+] 		writeLog(log.StdRecordCode.RxBufferFullLossy);
[-] 		size_t result = m_socket.readDatagram (m_readBuffer.m_p, m_readBuffer.m_size, &remoteAddress);
[+] 		size_t result = m_socket.readDatagram(m_readBuffer.m_p, m_readBuffer.m_size, &remoteAddress);
[-] 		if (m_actionTable [ActionId.AutoRemoteAddress].m_isChecked)
[+] 		if (m_actionTable[ActionId.AutoRemoteAddress].m_isChecked)
[-] 			m_remoteAddressCombo.m_editText = remoteAddress.getString ();
[+] 			m_remoteAddressCombo.m_editText = remoteAddress.getString();
[-] 		writeLog (UdpLogRecordCode.RxPacket, &remoteAddress, sizeof (io.SocketAddress));
[+] 		writeLog(UdpLogRecordCode.RxPacket, &remoteAddress, sizeof(io.SocketAddress));
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitSocketEvents ();
[+] 	waitSocketEvents();
[-] UdpSession.onResolveCompleted (
[+] UdpSession.onResolveCompleted(
[-] 		writeLog (SocketLogRecordCode.ResolveError, error, error.m_size);
[+] 		writeLog(SocketLogRecordCode.ResolveError, error, error.m_size);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 	m_remoteAddress = addressTable [0];
[+] 	m_remoteAddress = addressTable[0];
[-] 	writeDatagram (m_pendingDatagram.m_p, m_pendingDatagram.m_size, &m_remoteAddress);
[+] 	writeDatagram(m_pendingDatagram.m_p, m_pendingDatagram.m_size, &m_remoteAddress);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (log.StdRecordCode.Error, error, error.m_size);
[+] 	writeLog(log.StdRecordCode.Error, error, error.m_size);
[-] 	m_remoteAddressCombo.m_isEnabled = !m_actionTable [ActionId.AutoRemoteAddress].m_isChecked;
[+] 	m_remoteAddressCombo.m_isEnabled = !m_actionTable[ActionId.AutoRemoteAddress].m_isChecked;
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close Socket" : "Open Socket";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close Socket" : "Open Socket";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\UdpFlowMon\UdpFlowMonLogRepresenter.jnc
----------------------
[-] bool representUdpFlowMonLog (
[+] bool representUdpFlowMonLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 			params.m_srcAddress.getString (),
[+] 			params.m_srcAddress.getString(),
[-] 			params.m_dstAddress.getString (),
[+] 			params.m_dstAddress.getString(),
[-] 		target.addHyperText (text);
[+] 		target.addHyperText(text);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\UdpFlowMon\UdpFlowMonSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	bool errorcode capture (
[+] 	bool errorcode capture(
[-] 	bool errorcode openCapFile (
[+] 	bool errorcode openCapFile(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		try (m_state ? stopCapture () : capture ());
[+] 		try(m_state ? stopCapture() : capture());
[-] 	onSetFilter ()
[+] 	onSetFilter()
[-] 		try (m_state ? applyFilter () : capture ());
[+] 		try(m_state ? applyFilter() : capture());
[-] 	onDeviceComboEnter ()
[+] 	onDeviceComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onFileDlgCompleted (gui.StdDlgButton button);
[+] 	onFileDlgCompleted(gui.StdDlgButton button);
[-] 	onResolveCompleted (
[+] 	onResolveCompleted(
[-] 	onPcapEvent (
[+] 	onPcapEvent(
[-] 	char const* createFilterString (io.SocketAddress const* filterAddress);
[+] 	char const* createFilterString(io.SocketAddress const* filterAddress);
[-] 	bool errorcode resolve (char const* addressString);
[+] 	bool errorcode resolve(char const* addressString);
[-] 	bool errorcode applyFilter ();
[+] 	bool errorcode applyFilter();
[-] 	bool errorcode setFilter (io.SocketAddress const* filterAddress);
[+] 	bool errorcode setFilter(io.SocketAddress const* filterAddress);
[-] 	bool decodePacket (
[+] 	bool decodePacket(
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	createUi ();
[+] 	createUi();
[-] UdpFlowMonSession.construct (doc.PluginHost* pluginHost)
[+] UdpFlowMonSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] UdpFlowMonSession.createUi ()
[+] UdpFlowMonSession.createUi()
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = io.createPcapDeviceComboBox (m_pluginHost.m_toolBar);
[+] 	m_deviceCombo = io.createPcapDeviceComboBox(m_pluginHost.m_toolBar);
[-] 	m_pluginHost.m_toolBar.addLabel ("Filter:");
[+] 	m_pluginHost.m_toolBar.addLabel("Filter:");
[-] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_filterCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = io.createPcapDeviceProperty (
[+] 	m_deviceProp = io.createPcapDeviceProperty(
[-] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_promisciousProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_filterProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentLimitProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_ipFragmentTimeoutProp  = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_snapshotSizeProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group,, mask);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group,, mask);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("UDP monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("UDP monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] UdpFlowMonSession.onFileDlgCompleted (gui.StdDlgButton button)
[+] UdpFlowMonSession.onFileDlgCompleted(gui.StdDlgButton button)
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (addressString);
[+] 	bool isDirectAddress = try filterAddress.parse(addressString);
[-] 		try openCapFile (fileName, &filterAddress);
[+] 		try openCapFile(fileName, &filterAddress);
[-] 		try resolve (addressString);
[+] 		try resolve(addressString);
[-] bool errorcode UdpFlowMonSession.capture ()
[+] bool errorcode UdpFlowMonSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 		m_fileDlg.show ();
[+] 		m_fileDlg.show();
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (addressString);
[+] 	bool isDirectAddress = try filterAddress.parse(addressString);
[-] 		return try capture (device, &filterAddress);
[+] 		return try capture(device, &filterAddress);
[-] 	return try resolve (addressString);
[+] 	return try resolve(addressString);
[-] bool errorcode UdpFlowMonSession.capture (
[+] bool errorcode UdpFlowMonSession.capture(
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openDevice (
[+] 	bool result = try m_pcap.openDevice(
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] bool errorcode UdpFlowMonSession.openCapFile (
[+] bool errorcode UdpFlowMonSession.openCapFile(
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.StartingCapture, filterString);
[+] 	writeLogString(PcapLogRecordCode.StartingCapture, filterString);
[-] 	bool result = try m_pcap.openFile (fileName, filterString);
[+] 	bool result = try m_pcap.openFile(fileName, filterString);
[-] 		writeLogLastError (PcapLogRecordCode.CaptureError);
[+] 		writeLogLastError(PcapLogRecordCode.CaptureError);
[-] 	writeLog (PcapLogRecordCode.CaptureStarted);
[+] 	writeLog(PcapLogRecordCode.CaptureStarted);
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] UdpFlowMonSession.stopCapture ()
[+] UdpFlowMonSession.stopCapture()
[-] 		writeLog (SocketLogRecordCode.ResolveCancelled);
[+] 		writeLog(SocketLogRecordCode.ResolveCancelled);
[-] 		writeLog (PcapLogRecordCode.CaptureStopped);
[+] 		writeLog(PcapLogRecordCode.CaptureStopped);
[-] 	m_pcap.close ();
[+] 	m_pcap.close();
[-] 	m_ipDefragmenter.reset ();
[+] 	m_ipDefragmenter.reset();
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] bool errorcode UdpFlowMonSession.resolve (char const* addressString)
[+] bool errorcode UdpFlowMonSession.resolve(char const* addressString)
[-] 	writeLogString (SocketLogRecordCode.Resolving, addressString);
[+] 	writeLogString(SocketLogRecordCode.Resolving, addressString);
[-] 	bool result = try m_resolver.resolve (
[+] 	bool result = try m_resolver.resolve(
[-] 		writeLogLastError (SocketLogRecordCode.ResolveError);
[+] 		writeLogLastError(SocketLogRecordCode.ResolveError);
[-] bool errorcode UdpFlowMonSession.applyFilter ()
[+] bool errorcode UdpFlowMonSession.applyFilter()
[-] 	m_filterCombo.addEditTextToHistory ();
[+] 	m_filterCombo.addEditTextToHistory();
[-] 	bool isDirectAddress = try filterAddress.parse (filterString);
[+] 	bool isDirectAddress = try filterAddress.parse(filterString);
[-] 		return try setFilter (&filterAddress);
[+] 		return try setFilter(&filterAddress);
[-] 	writeLogString (SocketLogRecordCode.Resolving, filterString);
[+] 	writeLogString(SocketLogRecordCode.Resolving, filterString);
[-] 	bool result = try m_resolver.resolve (
[+] 	bool result = try m_resolver.resolve(
[-] 		writeLogLastError (SocketLogRecordCode.ResolveError);
[+] 		writeLogLastError(SocketLogRecordCode.ResolveError);
[-] bool errorcode UdpFlowMonSession.setFilter (io.SocketAddress const* filterAddress)
[+] bool errorcode UdpFlowMonSession.setFilter(io.SocketAddress const* filterAddress)
[-] 	char const* filterString = createFilterString (filterAddress);
[+] 	char const* filterString = createFilterString(filterAddress);
[-] 	writeLogString (PcapLogRecordCode.ChangingFilter, filterString);
[+] 	writeLogString(PcapLogRecordCode.ChangingFilter, filterString);
[-] 	bool result = try m_pcap.setFilter (filterString);
[+] 	bool result = try m_pcap.setFilter(filterString);
[-] 		writeLogLastError (PcapLogRecordCode.FilterError);
[+] 		writeLogLastError(PcapLogRecordCode.FilterError);
[-] 	writeLog (PcapLogRecordCode.FilterChanged);
[+] 	writeLog(PcapLogRecordCode.FilterChanged);
[-] char const* UdpFlowMonSession.createFilterString (io.SocketAddress const* filterAddress)
[+] char const* UdpFlowMonSession.createFilterString(io.SocketAddress const* filterAddress)
[-] UdpFlowMonSession.waitPcapEvents ()
[+] UdpFlowMonSession.waitPcapEvents()
[-] 	m_pcap.wait (eventMask, onPcapEvent ~(++m_pcapSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_pcap.wait(eventMask, onPcapEvent ~(++m_pcapSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] void UdpFlowMonSession.load (doc.Storage* storage)
[+] void UdpFlowMonSession.load(doc.Storage* storage)
[-] 	m_filterCombo.loadHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.loadHistory(storage, "captureFilterHistory");
[-] 	m_deviceCombo.m_currentIndex = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex = storage.readInt("deviceIdx");
[-] 	m_promisciousProp.m_value = storage.readBool ("promiscious");
[+] 	m_promisciousProp.m_value = storage.readBool("promiscious");
[-] 	m_filterCombo.m_editText = storage.readString ("captureFilter");
[+] 	m_filterCombo.m_editText = storage.readString("captureFilter");
[-] 	m_ipFragmentLimitProp.m_value = storage.readInt ("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[+] 	m_ipFragmentLimitProp.m_value = storage.readInt("ipFragmentLimit", io.IpDefragmenter.DefIpFragmentLimit);
[-] 	m_ipFragmentTimeoutProp.m_value = storage.readInt ("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[+] 	m_ipFragmentTimeoutProp.m_value = storage.readInt("ipFragmentTimeout", io.IpDefragmenter.DefIpFragmentTimeout);
[-] 	m_snapshotSizeProp.m_value = storage.readInt ("snapshotSize", Defaults.SnapshotSize);
[+] 	m_snapshotSizeProp.m_value = storage.readInt("snapshotSize", Defaults.SnapshotSize);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void UdpFlowMonSession.save (doc.Storage* storage)
[+] void UdpFlowMonSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	m_filterCombo.saveHistory (storage, "captureFilterHistory");
[+] 	m_filterCombo.saveHistory(storage, "captureFilterHistory");
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("promiscious", m_promisciousProp.m_value);
[+] 	storage.writeBool("promiscious", m_promisciousProp.m_value);
[-] 	storage.writeString ("captureFilter", m_filterCombo.m_editText);
[+] 	storage.writeString("captureFilter", m_filterCombo.m_editText);
[-] 	storage.writeInt ("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[+] 	storage.writeInt("ipFragmentLimit", m_ipFragmentLimitProp.m_value);
[-] 	storage.writeInt ("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[+] 	storage.writeInt("ipFragmentTimeout", m_ipFragmentTimeoutProp.m_value);
[-] 	storage.writeInt ("snapshotSize", m_snapshotSizeProp.m_value);
[+] 	storage.writeInt("snapshotSize", m_snapshotSizeProp.m_value);
[-] void UdpFlowMonSession.updateProperties ()
[+] void UdpFlowMonSession.updateProperties()
[-] bool errorcode UdpFlowMonSession.applyProperties ()
[+] bool errorcode UdpFlowMonSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	applyFilter ();
[+] 	applyFilter();
[-] void UdpFlowMonSession.restoreDefaultProperties ()
[+] void UdpFlowMonSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] UdpFlowMonSession.onResolveCompleted (
[+] UdpFlowMonSession.onResolveCompleted(
[-] 		writeLogError (SocketLogRecordCode.ResolveError, error);
[+] 		writeLogError(SocketLogRecordCode.ResolveError, error);
[-] 	writeLog (
[+] 	writeLog(
[-] 		sizeof (io.SocketAddress)
[+] 		sizeof(io.SocketAddress)
[-] 		try setFilter (addressTable);
[+] 		try setFilter(addressTable);
[-] 		try capture (m_pendingDevice, addressTable);
[+] 		try capture(m_pendingDevice, addressTable);
[-] 		try openCapFile (m_pendingFileName, addressTable);
[+] 		try openCapFile(m_pendingFileName, addressTable);
[-] UdpFlowMonSession.onPcapEvent (
[+] UdpFlowMonSession.onPcapEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_pcap.m_ioError, m_pcap.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_pcap.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_pcap.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			decodePacket (m_readBuffer.m_p, result);
[+] 			decodePacket(m_readBuffer.m_p, result);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 	waitPcapEvents ();
[+] 	waitPcapEvents();
[-] bool UdpFlowMonSession.decodePacket (
[+] bool UdpFlowMonSession.decodePacket(
[-] 	if (size < sizeof (io.EthernetHdr))
[+] 	if (size < sizeof(io.EthernetHdr))
[-] 	p += sizeof (io.EthernetHdr);
[+] 	p += sizeof(io.EthernetHdr);
[-] 	size -= sizeof (io.EthernetHdr);
[+] 	size -= sizeof(io.EthernetHdr);
[-] 	switch (ethernetHdr.m_type)
[+] 	switch(ethernetHdr.m_type)
[-] 		if (size < sizeof (io.IpHdr))
[+] 		if (size < sizeof(io.IpHdr))
[-] 			ipHdrSize < sizeof (io.IpHdr) ||
[+] 			ipHdrSize < sizeof(io.IpHdr) ||
[-] 			ipHdr = m_ipDefragmenter.defragment (ipHdr, size);
[+] 			ipHdr = m_ipDefragmenter.defragment(ipHdr, size);
[-] 			size = dynamic sizeof (p);
[+] 			size = dynamic sizeof(p);
[-] 		if (size < sizeof (io.Ip6Hdr))
[+] 		if (size < sizeof(io.Ip6Hdr))
[-] 			ip6Hdr.m_payloadLength + sizeof (io.Ip6Hdr) > size)
[+] 			ip6Hdr.m_payloadLength + sizeof(io.Ip6Hdr) > size)
[-] 		p += sizeof (io.Ip6Hdr);
[+] 		p += sizeof(io.Ip6Hdr);
[-] 	if (size < sizeof (io.UdpHdr))
[+] 	if (size < sizeof(io.UdpHdr))
[-] 	if (udpHdr.m_length < sizeof (io.UdpHdr) || udpHdr.m_length > size)
[+] 	if (udpHdr.m_length < sizeof(io.UdpHdr) || udpHdr.m_length > size)
[-] 	p += sizeof (io.UdpHdr);
[+] 	p += sizeof(io.UdpHdr);
[-] 	size = udpHdr.m_length - sizeof (io.UdpHdr);
[+] 	size = udpHdr.m_length - sizeof(io.UdpHdr);
[-] 	if (params.m_srcAddress.isMatch (m_filterAddress))
[+] 	if (params.m_srcAddress.isMatch(m_filterAddress))
[-] 		writeLog (UdpFlowMonLogRecordCode.RxPacket, &params, sizeof (params));
[+] 		writeLog(UdpFlowMonLogRecordCode.RxPacket, &params, sizeof(params));
[-] 		writeLog (log.StdRecordCode.Rx, p, size);
[+] 		writeLog(log.StdRecordCode.Rx, p, size);
[-] 	else if (params.m_dstAddress.isMatch (m_filterAddress))
[+] 	else if (params.m_dstAddress.isMatch(m_filterAddress))
[-] 		writeLog (UdpFlowMonLogRecordCode.TxPacket, &params, sizeof (params));
[+] 		writeLog(UdpFlowMonLogRecordCode.TxPacket, &params, sizeof(params));
[-] 		writeLog (log.StdRecordCode.Tx, p, size);
[+] 		writeLog(log.StdRecordCode.Tx, p, size);
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text =
[+] 	m_statusPaneTable[StatusPaneId.State].m_text =
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\UsbControlEndpoint\UsbControlEndpointSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool openDevice ();
[+] 	bool openDevice();
[-] 	void closeDevice ();
[+] 	void closeDevice();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onOpenDevice ();
[+] 	onOpenDevice();
[-] 	onTransferCompleted (
[+] 	onTransferCompleted(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] UsbControlEndpointSession.construct (doc.PluginHost* pluginHost)
[+] UsbControlEndpointSession.construct(doc.PluginHost* pluginHost)
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] UsbControlEndpointSession.createUi ()
[+] UsbControlEndpointSession.createUi()
[-] 	static gui.EnumPropertyOption reqDirectionTable [] =
[+] 	static gui.EnumPropertyOption reqDirectionTable[] =
[-] 	static gui.EnumPropertyOption reqTypeTable [] =
[+] 	static gui.EnumPropertyOption reqTypeTable[] =
[-] 	static gui.EnumPropertyOption reqRecipientTable [] =
[+] 	static gui.EnumPropertyOption reqRecipientTable[] =
[-] 	static gui.EnumPropertyOption reqIdTable [] =
[+] 	static gui.EnumPropertyOption reqIdTable[] =
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh]  = createAction ("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh]  = createAction("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpenDevice;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpenDevice;
[-] 	m_reqDirectionCombo = m_pluginHost.m_toolBar.addComboBox (
[+] 	m_reqDirectionCombo = m_pluginHost.m_toolBar.addComboBox(
[-] 		countof (reqDirectionTable)
[+] 		countof(reqDirectionTable)
[-] 	m_reqRecipientCombo = m_pluginHost.m_toolBar.addComboBox (
[+] 	m_reqRecipientCombo = m_pluginHost.m_toolBar.addComboBox(
[-] 		countof (reqRecipientTable)
[+] 		countof(reqRecipientTable)
[-] 	m_reqTypeCombo = m_pluginHost.m_toolBar.addComboBox (
[+] 	m_reqTypeCombo = m_pluginHost.m_toolBar.addComboBox(
[-] 		countof (reqTypeTable)
[+] 		countof(reqTypeTable)
[-] 	m_reqCodeCombo = m_pluginHost.m_toolBar.addComboBox (
[+] 	m_reqCodeCombo = m_pluginHost.m_toolBar.addComboBox(
[-] 		countof (reqIdTable)
[+] 		countof(reqIdTable)
[-] 	m_pluginHost.m_toolBar.addLabel ("Value:");
[+] 	m_pluginHost.m_toolBar.addLabel("Value:");
[-] 	m_reqValueCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_reqValueCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_pluginHost.m_toolBar.addLabel ("Index:");
[+] 	m_pluginHost.m_toolBar.addLabel("Index:");
[-] 	m_reqIndexCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_reqIndexCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_reqDirectionProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_reqDirectionProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (reqDirectionTable)
[+] 		countof(reqDirectionTable)
[-] 	m_reqRecipientProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_reqRecipientProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (reqRecipientTable)
[+] 		countof(reqRecipientTable)
[-] 	m_reqTypeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_reqTypeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (reqTypeTable)
[+] 		countof(reqTypeTable)
[-] 	m_reqCodeProp = m_pluginHost.m_propertyGrid.createComboProperty (
[+] 	m_reqCodeProp = m_pluginHost.m_propertyGrid.createComboProperty(
[-] 		countof (reqIdTable)
[+] 		countof(reqIdTable)
[-] 	m_reqValueProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_reqValueProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	m_reqIndexProp = m_pluginHost.m_propertyGrid.createStringProperty (
[+] 	m_reqIndexProp = m_pluginHost.m_propertyGrid.createStringProperty(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("USB connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("USB connection");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] UsbControlEndpointSession.onOpenDevice ()
[+] UsbControlEndpointSession.onOpenDevice()
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 		openDevice ();
[+] 		openDevice();
[-] UsbControlEndpointSession.enumerateDevices ()
[+] UsbControlEndpointSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 	io.UsbDb* usbDb = io.getStdUsbDb ();
[+] 	io.UsbDb* usbDb = io.getStdUsbDb();
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		io.UsbVendor const* vendor = usbDb.findVendor (deviceDesc.m_vendorId);
[+] 		io.UsbVendor const* vendor = usbDb.findVendor(deviceDesc.m_vendorId);
[-] 		io.UsbProduct const* product = vendor ? vendor.findProduct (deviceDesc.m_productId) : null;
[+] 		io.UsbProduct const* product = vendor ? vendor.findProduct(deviceDesc.m_productId) : null;
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [i].m_text = text;
[+] 		optionTable[i].m_text = text;
[-] 		optionTable [i].m_value = device;
[+] 		optionTable[i].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, count);
[+] 	m_deviceProp.setOptions(optionTable, count);
[-] bool UsbControlEndpointSession.openDevice ()
[+] bool UsbControlEndpointSession.openDevice()
[-] 	closeDevice ();
[+] 	closeDevice();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	writeLog (UsbLogRecordCode.DeviceOpened, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.DeviceOpened, &params, sizeof(params));
[-] 	writeLogLastError (UsbLogRecordCode.DeviceOpenError);
[+] 	writeLogLastError(UsbLogRecordCode.DeviceOpenError);
[-] UsbControlEndpointSession.closeDevice ()
[+] UsbControlEndpointSession.closeDevice()
[-] 	m_device.close ();
[+] 	m_device.close();
[-] 	writeLog (UsbLogRecordCode.DeviceClosed);
[+] 	writeLog(UsbLogRecordCode.DeviceClosed);
[-] UsbControlEndpointSession.load (doc.Storage* storage)
[+] UsbControlEndpointSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_autoDetachKernelDriverProp.m_value = storage.readBool ("autoDetachKernelDriver");
[+] 	m_autoDetachKernelDriverProp.m_value = storage.readBool("autoDetachKernelDriver");
[-] 	m_reqDirectionCombo.m_currentIndex = storage.readInt ("reqDirection");
[+] 	m_reqDirectionCombo.m_currentIndex = storage.readInt("reqDirection");
[-] 	m_reqRecipientCombo.m_currentIndex = storage.readInt ("reqRecipient");
[+] 	m_reqRecipientCombo.m_currentIndex = storage.readInt("reqRecipient");
[-] 	m_reqTypeCombo.m_currentIndex = storage.readInt ("reqType");
[+] 	m_reqTypeCombo.m_currentIndex = storage.readInt("reqType");
[-] 	m_reqCodeCombo.m_editText = storage.readString ("reqCode", "0x00");
[+] 	m_reqCodeCombo.m_editText = storage.readString("reqCode", "0x00");
[-] 	m_reqValueCombo.m_editText = storage.readString ("reqValue", "0x0000");
[+] 	m_reqValueCombo.m_editText = storage.readString("reqValue", "0x0000");
[-] 	m_reqIndexCombo.m_editText = storage.readString ("reqIndex", "0x0000");
[+] 	m_reqIndexCombo.m_editText = storage.readString("reqIndex", "0x0000");
[-] UsbControlEndpointSession.save (doc.Storage* storage)
[+] UsbControlEndpointSession.save(doc.Storage* storage)
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[+] 	storage.writeBool("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[-] 	storage.writeInt ("reqDirection", m_reqDirectionCombo.m_currentIndex);
[+] 	storage.writeInt("reqDirection", m_reqDirectionCombo.m_currentIndex);
[-] 	storage.writeInt ("reqRecipient", m_reqRecipientCombo.m_currentIndex);
[+] 	storage.writeInt("reqRecipient", m_reqRecipientCombo.m_currentIndex);
[-] 	storage.writeInt ("reqType", m_reqTypeCombo.m_currentIndex);
[+] 	storage.writeInt("reqType", m_reqTypeCombo.m_currentIndex);
[-] 	storage.writeString ("reqCode", m_reqCodeCombo.m_editText);
[+] 	storage.writeString("reqCode", m_reqCodeCombo.m_editText);
[-] 	storage.writeString ("reqValue", m_reqValueCombo.m_editText);
[+] 	storage.writeString("reqValue", m_reqValueCombo.m_editText);
[-] 	storage.writeString ("reqIndex", m_reqIndexCombo.m_editText);
[+] 	storage.writeString("reqIndex", m_reqIndexCombo.m_editText);
[-] UsbControlEndpointSession.updateProperties ()
[+] UsbControlEndpointSession.updateProperties()
[-] bool errorcode UsbControlEndpointSession.applyProperties ()
[+] bool errorcode UsbControlEndpointSession.applyProperties()
[-] UsbControlEndpointSession.restoreDefaultProperties ()
[+] UsbControlEndpointSession.restoreDefaultProperties()
[-] size_t errorcode UsbControlEndpointSession.transmit (
[+] size_t errorcode UsbControlEndpointSession.transmit(
[-] 	uint_t code = parseInteger (m_reqCodeCombo.m_editText);;
[+] 	uint_t code = parseInteger(m_reqCodeCombo.m_editText);;
[-] 	uint_t value = parseInteger (m_reqValueCombo.m_editText);
[+] 	uint_t value = parseInteger(m_reqValueCombo.m_editText);
[-] 	uint_t index = parseInteger (m_reqIndexCombo.m_editText);
[+] 	uint_t index = parseInteger(m_reqIndexCombo.m_editText);
[-] 	char* buffer = new char [size];
[+] 	char* buffer = new char[size];
[-] 		memcpy (buffer, p, size);
[+] 		memcpy(buffer, p, size);
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] UsbControlEndpointSession.onTransferCompleted (
[+] UsbControlEndpointSession.onTransferCompleted(
[-] 	writeLog (UsbLogRecordCode.ControlTransfer, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.ControlTransfer, &params, sizeof(params));
[-] 		writeLogError (log.StdRecordCode.Error, error);
[+] 		writeLogError(log.StdRecordCode.Error, error);
[-] 		writeLog ((type & 0x80) ? log.StdRecordCode.Rx : log.StdRecordCode.Tx, p, size);
[+] 		writeLog((type & 0x80) ? log.StdRecordCode.Rx : log.StdRecordCode.Tx, p, size);
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close Device" : "Open Device";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close Device" : "Open Device";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state];
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_state ? "Opened" : "Closed";
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\UsbDataEndpoint\UsbDataEndpointSession.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool openDevice ();
[+] 	bool openDevice();
[-] 	void closeDevice ();
[+] 	void closeDevice();
[-] 	bool claimInterface ();
[+] 	bool claimInterface();
[-] 	void releaseInterface ();
[+] 	void releaseInterface();
[-] 	bool startReading ();
[+] 	bool startReading();
[-] 	void stopReading ();
[+] 	void stopReading();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	override size_t errorcode transmit (
[+] 	override size_t errorcode transmit(
[-] 	onOpenDevice ();
[+] 	onOpenDevice();
[-] 	onClaimInterface ();
[+] 	onClaimInterface();
[-] 	onReadEndpoint ();
[+] 	onReadEndpoint();
[-] 	onOutEndpointEvent (
[+] 	onOutEndpointEvent(
[-] 	onInEndpointEvent (
[+] 	onInEndpointEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	waitOutEndpointEvents ();
[+] 	waitOutEndpointEvents();
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] UsbDataEndpointSession.construct (doc.PluginHost* pluginHost)
[+] UsbDataEndpointSession.construct(doc.PluginHost* pluginHost)
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] UsbDataEndpointSession.createUi ()
[+] UsbDataEndpointSession.createUi()
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh]  = createAction ("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh]  = createAction("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpenDevice;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpenDevice;
[-] 	m_pluginHost.m_toolBar.addLabel ("Iface:");
[+] 	m_pluginHost.m_toolBar.addLabel("Iface:");
[-] 	m_interfaceCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_interfaceCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_actionTable [ActionId.Claim] = createAction("Claim interface", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Claim] = createAction("Claim interface", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Claim].m_onTriggered += onClaimInterface;
[+] 	m_actionTable[ActionId.Claim].m_onTriggered += onClaimInterface;
[-] 	m_pluginHost.m_toolBar.addLabel ("Out:");
[+] 	m_pluginHost.m_toolBar.addLabel("Out:");
[-] 	m_outEndpointCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_outEndpointCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_pluginHost.m_toolBar.addLabel ("In:");
[+] 	m_pluginHost.m_toolBar.addLabel("In:");
[-] 	m_inEndpointCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_inEndpointCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	m_actionTable [ActionId.Read] = createAction("Start reading from IN endpoint", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Read] = createAction("Start reading from IN endpoint", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Read].m_onTriggered += onReadEndpoint;
[+] 	m_actionTable[ActionId.Read].m_onTriggered += onReadEndpoint;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_interfaceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_interfaceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_outEndpointProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_outEndpointProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_inEndpointProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_inEndpointProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("USB connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("USB connection");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] UsbDataEndpointSession.onOpenDevice ()
[+] UsbDataEndpointSession.onOpenDevice()
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 		openDevice ();
[+] 		openDevice();
[-] UsbDataEndpointSession.onClaimInterface ()
[+] UsbDataEndpointSession.onClaimInterface()
[-] 		releaseInterface ();
[+] 		releaseInterface();
[-] 		claimInterface ();
[+] 		claimInterface();
[-] UsbDataEndpointSession.onReadEndpoint ()
[+] UsbDataEndpointSession.onReadEndpoint()
[-] 		stopReading ();
[+] 		stopReading();
[-] 		startReading ();
[+] 		startReading();
[-] UsbDataEndpointSession.enumerateDevices ()
[+] UsbDataEndpointSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 	io.UsbDb* usbDb = io.getStdUsbDb ();
[+] 	io.UsbDb* usbDb = io.getStdUsbDb();
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		io.UsbVendor const* vendor = usbDb.findVendor (deviceDesc.m_vendorId);
[+] 		io.UsbVendor const* vendor = usbDb.findVendor(deviceDesc.m_vendorId);
[-] 		io.UsbProduct const* product = vendor ? vendor.findProduct (deviceDesc.m_productId) : null;
[+] 		io.UsbProduct const* product = vendor ? vendor.findProduct(deviceDesc.m_productId) : null;
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [i].m_text = text;
[+] 		optionTable[i].m_text = text;
[-] 		optionTable [i].m_value = device;
[+] 		optionTable[i].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, count);
[+] 	m_deviceProp.setOptions(optionTable, count);
[-] bool UsbDataEndpointSession.openDevice ()
[+] bool UsbDataEndpointSession.openDevice()
[-] 	closeDevice ();
[+] 	closeDevice();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	m_interfaceCombo.clear ();
[+] 	m_interfaceCombo.clear();
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [confDesc.m_interfaceCount];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[confDesc.m_interfaceCount];
[-] 		io.UsbInterfaceDesc const* ifaceDesc = &confDesc.m_interfaceTable [i];
[+] 		io.UsbInterfaceDesc const* ifaceDesc = &confDesc.m_interfaceTable[i];
[-] 		optionTable [i].m_text = name;
[+] 		optionTable[i].m_text = name;
[-] 		optionTable [i].m_value = ifaceDesc;
[+] 		optionTable[i].m_value = ifaceDesc;
[-] 		m_interfaceCombo.addItem (name, ifaceDesc);
[+] 		m_interfaceCombo.addItem(name, ifaceDesc);
[-] 			m_interfaceCombo.addItem (
[+] 			m_interfaceCombo.addItem(
[-] 	m_interfaceProp.setOptions (optionTable, confDesc.m_interfaceCount);
[+] 	m_interfaceProp.setOptions(optionTable, confDesc.m_interfaceCount);
[-] 	writeLog (UsbLogRecordCode.DeviceOpened, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.DeviceOpened, &params, sizeof(params));
[-] 	writeLogLastError (UsbLogRecordCode.DeviceOpenError);
[+] 	writeLogLastError(UsbLogRecordCode.DeviceOpenError);
[-] UsbDataEndpointSession.closeDevice ()
[+] UsbDataEndpointSession.closeDevice()
[-] 	releaseInterface ();
[+] 	releaseInterface();
[-] 	m_device.close ();
[+] 	m_device.close();
[-] 	writeLog (UsbLogRecordCode.DeviceClosed);
[+] 	writeLog(UsbLogRecordCode.DeviceClosed);
[-] bool UsbDataEndpointSession.claimInterface ()
[+] bool UsbDataEndpointSession.claimInterface()
[-] 	releaseInterface ();
[+] 	releaseInterface();
[-] 	if (m_device.m_isKernelDriverActive [ifaceDesc.m_interfaceId] &&
[+] 	if (m_device.m_isKernelDriverActive[ifaceDesc.m_interfaceId] &&
[-] 		m_device.detachKernelDriver (ifaceDesc.m_interfaceId);
[+] 		m_device.detachKernelDriver(ifaceDesc.m_interfaceId);
[-] 		writeLog (UsbLogRecordCode.KernelDriverDetached, &ifaceDesc.m_interfaceId, sizeof (ifaceDesc.m_interfaceId));
[+] 		writeLog(UsbLogRecordCode.KernelDriverDetached, &ifaceDesc.m_interfaceId, sizeof(ifaceDesc.m_interfaceId));
[-] 	m_interface = m_device.claimInterface (ifaceDesc.m_interfaceId, ifaceDesc.m_altSettingId);
[+] 	m_interface = m_device.claimInterface(ifaceDesc.m_interfaceId, ifaceDesc.m_altSettingId);
[-] 	m_outEndpointCombo.clear ();
[+] 	m_outEndpointCombo.clear();
[-] 	m_inEndpointCombo.clear ();
[+] 	m_inEndpointCombo.clear();
[-] 	gui.EnumPropertyOption* outEnpointOptionTable = new gui.EnumPropertyOption [ifaceDesc.m_endpointCount];
[+] 	gui.EnumPropertyOption* outEnpointOptionTable = new gui.EnumPropertyOption[ifaceDesc.m_endpointCount];
[-] 	gui.EnumPropertyOption* inEnpointOptionTable = new gui.EnumPropertyOption [ifaceDesc.m_endpointCount];
[+] 	gui.EnumPropertyOption* inEnpointOptionTable = new gui.EnumPropertyOption[ifaceDesc.m_endpointCount];
[-] 		io.UsbEndpointDesc const* endpointDesc = &ifaceDesc.m_endpointTable [i];
[+] 		io.UsbEndpointDesc const* endpointDesc = &ifaceDesc.m_endpointTable[i];
[-] 			m_inEndpointCombo.addItem (name, endpointDesc);
[+] 			m_inEndpointCombo.addItem(name, endpointDesc);
[-] 			inEnpointOptionTable [inEndpointCount].m_text = name;
[+] 			inEnpointOptionTable[inEndpointCount].m_text = name;
[-] 			inEnpointOptionTable [inEndpointCount].m_value = endpointDesc;
[+] 			inEnpointOptionTable[inEndpointCount].m_value = endpointDesc;
[-] 			m_outEndpointCombo.addItem (name, endpointDesc);
[+] 			m_outEndpointCombo.addItem(name, endpointDesc);
[-] 			outEnpointOptionTable [outEndpointCount].m_text = name;
[+] 			outEnpointOptionTable[outEndpointCount].m_text = name;
[-] 			outEnpointOptionTable [outEndpointCount].m_value = endpointDesc;
[+] 			outEnpointOptionTable[outEndpointCount].m_value = endpointDesc;
[-] 	m_outEndpointProp.setOptions (outEnpointOptionTable, outEndpointCount);
[+] 	m_outEndpointProp.setOptions(outEnpointOptionTable, outEndpointCount);
[-] 	m_inEndpointProp.setOptions (inEnpointOptionTable, inEndpointCount);
[+] 	m_inEndpointProp.setOptions(inEnpointOptionTable, inEndpointCount);
[-] 	writeLog (UsbLogRecordCode.InterfaceClaimed, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.InterfaceClaimed, &params, sizeof(params));
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	writeLogLastError (UsbLogRecordCode.InterfaceClaimError);
[+] 	writeLogLastError(UsbLogRecordCode.InterfaceClaimError);
[-] UsbDataEndpointSession.releaseInterface ()
[+] UsbDataEndpointSession.releaseInterface()
[-] 	stopReading ();
[+] 	stopReading();
[-] 	m_interface.release ();
[+] 	m_interface.release();
[-] 	writeLogLastError (UsbLogRecordCode.InterfaceReleased);
[+] 	writeLogLastError(UsbLogRecordCode.InterfaceReleased);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] bool UsbDataEndpointSession.startReading ()
[+] bool UsbDataEndpointSession.startReading()
[-] 	stopReading ();
[+] 	stopReading();
[-] 	m_inEndpoint = m_interface.openEndpoint (endpointDesc.m_endpointId);
[+] 	m_inEndpoint = m_interface.openEndpoint(endpointDesc.m_endpointId);
[-] 	writeLog (UsbLogRecordCode.ReadingStarted, &endpointDesc.m_endpointId, sizeof (endpointDesc.m_endpointId));
[+] 	writeLog(UsbLogRecordCode.ReadingStarted, &endpointDesc.m_endpointId, sizeof(endpointDesc.m_endpointId));
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	writeLogLastError (UsbLogRecordCode.EndpointOpenError);
[+] 	writeLogLastError(UsbLogRecordCode.EndpointOpenError);
[-] UsbDataEndpointSession.stopReading ()
[+] UsbDataEndpointSession.stopReading()
[-] 	m_inEndpoint.close ();
[+] 	m_inEndpoint.close();
[-] 	writeLogLastError (UsbLogRecordCode.ReadingStopped);
[+] 	writeLogLastError(UsbLogRecordCode.ReadingStopped);
[-] 	m_outEndpoint.wait (eventMask, onOutEndpointEvent ~(++m_outSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_outEndpoint.wait(eventMask, onOutEndpointEvent ~(++m_outSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] 	m_inEndpoint.wait (eventMask, onInEndpointEvent ~(++m_inSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_inEndpoint.wait(eventMask, onInEndpointEvent ~(++m_inSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] UsbDataEndpointSession.load (doc.Storage* storage)
[+] UsbDataEndpointSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_autoDetachKernelDriverProp.m_value = storage.readBool ("autoDetachKernelDriver");
[+] 	m_autoDetachKernelDriverProp.m_value = storage.readBool("autoDetachKernelDriver");
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] UsbDataEndpointSession.save (doc.Storage* storage)
[+] UsbDataEndpointSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[+] 	storage.writeBool("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[-] UsbDataEndpointSession.updateProperties ()
[+] UsbDataEndpointSession.updateProperties()
[-] bool errorcode UsbDataEndpointSession.applyProperties ()
[+] bool errorcode UsbDataEndpointSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] UsbDataEndpointSession.restoreDefaultProperties ()
[+] UsbDataEndpointSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] size_t errorcode UsbDataEndpointSession.transmit (
[+] size_t errorcode UsbDataEndpointSession.transmit(
[-] 		m_outEndpoint = m_interface.openEndpoint (endpointDesc.m_endpointId);
[+] 		m_outEndpoint = m_interface.openEndpoint(endpointDesc.m_endpointId);
[-] 	size = m_outEndpoint.write (p, size);
[+] 	size = m_outEndpoint.write(p, size);
[-] 	writeLog (log.StdRecordCode.Tx, p, size);
[+] 	writeLog(log.StdRecordCode.Tx, p, size);
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] UsbDataEndpointSession.onOutEndpointEvent (
[+] UsbDataEndpointSession.onOutEndpointEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_inEndpoint.m_ioError, m_inEndpoint.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_inEndpoint.m_ioError, m_inEndpoint.m_ioError.m_size);
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 	waitOutEndpointEvents ();
[+] 	waitOutEndpointEvents();
[-] UsbDataEndpointSession.onInEndpointEvent (
[+] UsbDataEndpointSession.onInEndpointEvent(
[-] 		writeLog (log.StdRecordCode.Error, m_inEndpoint.m_ioError, m_inEndpoint.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, m_inEndpoint.m_ioError, m_inEndpoint.m_ioError.m_size);
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = m_inEndpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = m_inEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 			writeLog (log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[+] 			writeLog(log.StdRecordCode.Rx, m_readBuffer.m_p, result);
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	m_actionTable [ActionId.Open].m_text = isOpened ? "Close Device" : "Open Device";
[+] 	m_actionTable[ActionId.Open].m_text = isOpened ? "Close Device" : "Open Device";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [isOpened];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[isOpened];
[-] 	m_actionTable [ActionId.Claim].m_text = isClaimed ? "Release Interface" : "Claim Interface";
[+] 	m_actionTable[ActionId.Claim].m_text = isClaimed ? "Release Interface" : "Claim Interface";
[-] 	m_actionTable [ActionId.Claim].m_icon = m_iconTable [isClaimed];
[+] 	m_actionTable[ActionId.Claim].m_icon = m_iconTable[isClaimed];
[-] 	m_actionTable [ActionId.Claim].m_isEnabled = isOpened;
[+] 	m_actionTable[ActionId.Claim].m_isEnabled = isOpened;
[-] 	m_actionTable [ActionId.Read].m_text = isReading ? "Stop reading" : "Start reading";
[+] 	m_actionTable[ActionId.Read].m_text = isReading ? "Stop reading" : "Start reading";
[-] 	m_actionTable [ActionId.Read].m_icon = m_iconTable [isReading];
[+] 	m_actionTable[ActionId.Read].m_icon = m_iconTable[isReading];
[-] 	m_actionTable [ActionId.Read].m_isEnabled = isClaimed;
[+] 	m_actionTable[ActionId.Read].m_isEnabled = isClaimed;
[-] 	m_statusPaneTable [StatusPaneId.State].m_text =
[+] 	m_statusPaneTable[StatusPaneId.State].m_text =
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\UsbLog\UsbLogRepresenter.jnc
----------------------
[-] char const* formatDeviceString (DeviceParams const* params)
[+] char const* formatDeviceString(DeviceParams const* params)
[-] 	io.UsbDb* db = io.getStdUsbDb ();
[+] 	io.UsbDb* db = io.getStdUsbDb();
[-] 	io.UsbVendor const* vendor = db.findVendor (params.m_vendorId);
[+] 	io.UsbVendor const* vendor = db.findVendor(params.m_vendorId);
[-] 	io.UsbProduct const* product = vendor ? vendor.findProduct (params.m_productId) : null;
[+] 	io.UsbProduct const* product = vendor ? vendor.findProduct(params.m_productId) : null;
[-] bool representUsbLog (
[+] bool representUsbLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\XModem\XModem.jnc
----------------------
[-] 	uchar_t m_data [XModemBlockSize];
[+] 	uchar_t m_data[XModemBlockSize];
[-] uchar_t calcXModemChecksum (void const* p)
[+] uchar_t calcXModemChecksum(void const* p)
[-] 	return (uchar_t) checksum;
[+] 	return (uchar_t)checksum;
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\XModem\XModemLayer.jnc
----------------------
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	transmitFile ();
[+] 	transmitFile();
[-] 	receiveFile ();
[+] 	receiveFile();
[-] 	createUi ();
[+] 	createUi();
[-] 	onLogRecord (
[+] 	onLogRecord(
[-] 	onFileDlgCompleted (gui.StdDlgButton button);
[+] 	onFileDlgCompleted(gui.StdDlgButton button);
[-] 	onProgressDlgButtonClicked (gui.StdDlgButton button);
[+] 	onProgressDlgButtonClicked(gui.StdDlgButton button);
[-] XModemLayer.construct (doc.PluginHost* pluginHost)
[+] XModemLayer.construct(doc.PluginHost* pluginHost)
[-] 	basetype1.construct (pluginHost);
[+] 	basetype1.construct(pluginHost);
[-] 	m_transmitter.construct (this);
[+] 	m_transmitter.construct(this);
[-] 	m_receiver.construct (this);
[+] 	m_receiver.construct(this);
[-] 	pluginHost.m_log.addListener (onLogRecord @ pluginHost.m_mainThreadScheduler);
[+] 	pluginHost.m_log.addListener(onLogRecord @ pluginHost.m_mainThreadScheduler);
[-] 	createUi ();
[+] 	createUi();
[-] XModemLayer.createUi ()
[+] XModemLayer.createUi()
[-] 	m_pluginHost.m_toolBar.addSeparator ();
[+] 	m_pluginHost.m_toolBar.addSeparator();
[-] 	m_actionTable [ActionId.Transmit]  = createAction ("Transmit File with XModem", "images/transmit.png");
[+] 	m_actionTable[ActionId.Transmit]  = createAction("Transmit File with XModem", "images/transmit.png");
[-] 	m_actionTable [ActionId.Transmit].m_onTriggered += transmitFile;
[+] 	m_actionTable[ActionId.Transmit].m_onTriggered += transmitFile;
[-] 	m_actionTable [ActionId.Receive] = createAction ("Receive File with XModem", "images/receive.png");
[+] 	m_actionTable[ActionId.Receive] = createAction("Receive File with XModem", "images/receive.png");
[-] 	m_actionTable [ActionId.Receive].m_onTriggered += receiveFile;
[+] 	m_actionTable[ActionId.Receive].m_onTriggered += receiveFile;
[-] XModemLayer.transmitFile ()
[+] XModemLayer.transmitFile()
[-] 	cancelFileTranfer ();
[+] 	cancelFileTranfer();
[-] 	m_fileDlg.show ();
[+] 	m_fileDlg.show();
[-] XModemLayer.receiveFile ()
[+] XModemLayer.receiveFile()
[-] 	cancelFileTranfer ();
[+] 	cancelFileTranfer();
[-] 	m_fileDlg.show ();
[+] 	m_fileDlg.show();
[-] XModemLayer.cancelFileTranfer ()
[+] XModemLayer.cancelFileTranfer()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		m_transmitter.cancel ();
[+] 		m_transmitter.cancel();
[-] 		m_receiver.cancel ();
[+] 		m_receiver.cancel();
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	m_progressDlg.hide ();
[+] 	m_progressDlg.hide();
[-] XModemLayer.onFileDlgCompleted (gui.StdDlgButton button)
[+] XModemLayer.onFileDlgCompleted(gui.StdDlgButton button)
[-] 	m_progressDlg.show ();
[+] 	m_progressDlg.show();
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		m_file.open (
[+] 		m_file.open(
[-] 		m_transmitter.start ();
[+] 		m_transmitter.start();
[-] 		m_file.open (m_fileDlg.m_filePath);
[+] 		m_file.open(m_fileDlg.m_filePath);
[-] 		m_receiver.start ();
[+] 		m_receiver.start();
[-] 	m_progressDlg.m_status = std.getLastError ().m_description;
[+] 	m_progressDlg.m_status = std.getLastError().m_description;
[-] XModemLayer.onProgressDlgButtonClicked (gui.StdDlgButton button)
[+] XModemLayer.onProgressDlgButtonClicked(gui.StdDlgButton button)
[-] 	switch (button)
[+] 	switch(button)
[-] 		cancelFileTranfer ();
[+] 		cancelFileTranfer();
[-] 		m_progressDlg.hide ();
[+] 		m_progressDlg.hide();
[-] XModemLayer.onLogRecord (
[+] XModemLayer.onLogRecord(
[-] 		switch (m_state)
[+] 		switch(m_state)
[-] 			m_transmitter.onRx (p, size);
[+] 			m_transmitter.onRx(p, size);
[-] 			m_receiver.onRx (p, size);
[+] 			m_receiver.onRx(p, size);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\XModem\XModemReceiver.jnc
----------------------
[-] 	construct (XModemLayer* parent);
[+] 	construct(XModemLayer* parent);
[-] 	cancel ();
[+] 	cancel();
[-] 	onRx (
[+] 	onRx(
[-] 	onRx_Data (XModemBlock const* block);
[+] 	onRx_Data(XModemBlock const* block);
[-] 	complete ();
[+] 	complete();
[-] 	sendNextDataBlock ();
[+] 	sendNextDataBlock();
[-] XModemReceiver.construct (XModemLayer* parent)
[+] XModemReceiver.construct(XModemLayer* parent)
[-] XModemReceiver.start ()
[+] XModemReceiver.start()
[-] 	cancel ();
[+] 	cancel();
[-] 	try m_parent.transmit (&c, sizeof (c));
[+] 	try m_parent.transmit(&c, sizeof(c));
[-] 	m_parent.m_file.setSize (0);
[+] 	m_parent.m_file.setSize(0);
[-] XModemReceiver.cancel ()
[+] XModemReceiver.cancel()
[-] 		try m_parent.transmit (&c, sizeof(c));
[+] 		try m_parent.transmit(&c, sizeof(c));
[-] 	complete ();
[+] 	complete();
[-] XModemReceiver.complete ()
[+] XModemReceiver.complete()
[-] 	m_parent.m_file.unmapAllViews ();
[+] 	m_parent.m_file.unmapAllViews();
[-] 	m_parent.m_file.setSize (m_offset);
[+] 	m_parent.m_file.setSize(m_offset);
[-] 	m_parent.m_file.close ();
[+] 	m_parent.m_file.close();
[-] XModemReceiver.onRx (
[+] XModemReceiver.onRx(
[-] 	switch (c)
[+] 	switch(c)
[-] 		if (m_state == State.Data && size == sizeof (XModemBlock))
[+] 		if (m_state == State.Data && size == sizeof(XModemBlock))
[-] 			onRx_Data ((XModemBlock const*) p);
[+] 			onRx_Data((XModemBlock const*) p);
[-] 		complete ();
[+] 		complete();
[-] 		try m_parent.transmit (&c, sizeof (c));
[+] 		try m_parent.transmit(&c, sizeof(c));
[-] 		complete ();
[+] 		complete();
[-] XModemReceiver.onRx_Data (XModemBlock const* block)
[+] XModemReceiver.onRx_Data(XModemBlock const* block)
[-] 	uchar_t blockNumber = (uchar_t) (m_offset / XModemBlockSize + 1);
[+] 	uchar_t blockNumber = (uchar_t)(m_offset / XModemBlockSize + 1);
[-] 		m_parent.transmit (&nak, sizeof (nak));
[+] 		m_parent.transmit(&nak, sizeof(nak));
[-] 	uchar_t checksum = calcXModemChecksum (block.m_data);
[+] 	uchar_t checksum = calcXModemChecksum(block.m_data);
[-] 		m_parent.transmit (&nak, sizeof (nak));
[+] 		m_parent.transmit(&nak, sizeof(nak));
[-] 	m_parent.transmit (&ack, sizeof (ack));
[+] 	m_parent.transmit(&ack, sizeof(ack));
[-] 	void* p = m_parent.m_file.view (m_offset, XModemBlockSize);
[+] 	void* p = m_parent.m_file.view(m_offset, XModemBlockSize);
[-] 	memcpy (p, block.m_data, XModemBlockSize);
[+] 	memcpy(p, block.m_data, XModemBlockSize);
[-] 	m_parent.m_progressDlg.m_status = std.getLastError ().m_description;
[+] 	m_parent.m_progressDlg.m_status = std.getLastError().m_description;
[-] 	complete ();
[+] 	complete();
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\plugins\XModem\XModemTransmitter.jnc
----------------------
[-] 	construct (XModemLayer* parent);
[+] 	construct(XModemLayer* parent);
[-] 	cancel ();
[+] 	cancel();
[-] 	onRx (
[+] 	onRx(
[-] 	onRx_WaitNak (char c);
[+] 	onRx_WaitNak(char c);
[-] 	onRx_Data (char c);
[+] 	onRx_Data(char c);
[-] 	onRx_Eot (char c);
[+] 	onRx_Eot(char c);
[-] 	complete ();
[+] 	complete();
[-] 	sendNextDataBlock ();
[+] 	sendNextDataBlock();
[-] XModemTransmitter.construct (XModemLayer* parent)
[+] XModemTransmitter.construct(XModemLayer* parent)
[-] 	cancel ();
[+] 	cancel();
[-] XModemTransmitter.cancel ()
[+] XModemTransmitter.cancel()
[-] 		try m_parent.transmit (&c, sizeof (c));
[+] 		try m_parent.transmit(&c, sizeof(c));
[-] 	complete ();
[+] 	complete();
[-] XModemTransmitter.complete ()
[+] XModemTransmitter.complete()
[-] 	m_parent.m_file.close ();
[+] 	m_parent.m_file.close();
[-] XModemTransmitter.sendNextDataBlock ()
[+] XModemTransmitter.sendNextDataBlock()
[-] 	size_t size = (size_t) (m_parent.m_file.m_size - m_offset);
[+] 	size_t size = (size_t)(m_parent.m_file.m_size - m_offset);
[-] 	void const* p = m_parent.m_file.view (m_offset, size);
[+] 	void const* p = m_parent.m_file.view(m_offset, size);
[-] 	block.m_blockNumber = (uchar_t) (m_offset / XModemBlockSize + 1);
[+] 	block.m_blockNumber = (uchar_t)(m_offset / XModemBlockSize + 1);
[-] 	block.m_complement = (uchar_t) (block.m_blockNumber ^ 0xff);
[+] 	block.m_complement = (uchar_t)(block.m_blockNumber ^ 0xff);
[-] 	memcpy (block.m_data, p, size);
[+] 	memcpy(block.m_data, p, size);
[-] 	block.m_checksum = calcXModemChecksum (block.m_data);
[+] 	block.m_checksum = calcXModemChecksum(block.m_data);
[-] 	m_parent.transmit (&block, sizeof (block));
[+] 	m_parent.transmit(&block, sizeof(block));
[-] 	m_parent.m_progressDlg.m_progress = (int) ((m_offset + size / 2) * 100 / m_parent.m_file.m_size);
[+] 	m_parent.m_progressDlg.m_progress = (int)((m_offset + size / 2) * 100 / m_parent.m_file.m_size);
[-] 	m_parent.m_progressDlg.m_status = std.getLastError ().m_description;
[+] 	m_parent.m_progressDlg.m_status = std.getLastError().m_description;
[-] 	complete ();
[+] 	complete();
[-] XModemTransmitter.onRx (
[+] XModemTransmitter.onRx(
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		onRx_WaitNak (*(char const*) p);
[+] 		onRx_WaitNak(*(char const*) p);
[-] 		onRx_Data (*(char const*) p);
[+] 		onRx_Data(*(char const*) p);
[-] 		onRx_Eot (*(char const*) p);
[+] 		onRx_Eot(*(char const*) p);
[-] XModemTransmitter.onRx_WaitNak (char c)
[+] XModemTransmitter.onRx_WaitNak(char c)
[-] 	switch (c)
[+] 	switch(c)
[-] 		sendNextDataBlock ();
[+] 		sendNextDataBlock();
[-]  XModemTransmitter.onRx_Data (char c)
[+]  XModemTransmitter.onRx_Data(char c)
[-] 	switch (c)
[+] 	switch(c)
[-] 		m_parent.m_progressDlg.m_progress = (int) (m_offset * 100 / m_parent.m_file.m_size);
[+] 		m_parent.m_progressDlg.m_progress = (int)(m_offset * 100 / m_parent.m_file.m_size);
[-] 			sendNextDataBlock ();
[+] 			sendNextDataBlock();
[-] 		try m_parent.transmit (&c, sizeof (c));
[+] 		try m_parent.transmit(&c, sizeof(c));
[-] 		complete ();
[+] 		complete();
[-] 		complete ();
[+] 		complete();
[-] XModemTransmitter.onRx_Eot (char c)
[+] XModemTransmitter.onRx_Eot(char c)
[-] 	switch (c)
[+] 	switch(c)
[-] 		complete ();
[+] 		complete();
[-] 		try m_parent.transmit (&c, sizeof (c));
[+] 		try m_parent.transmit(&c, sizeof(c));
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\CypressUploader\CypressUploaderSession.jnc
----------------------
[-] 	char const* m_statusText [] =
[+] 	char const* m_statusText[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool openDevice ();
[+] 	bool openDevice();
[-] 	void closeDevice ();
[+] 	void closeDevice();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onOpenDevice ();
[+] 	onOpenDevice();
[-] 	onDownloadFile ();
[+] 	onDownloadFile();
[-] 	onUploadFile ();
[+] 	onUploadFile();
[-] 	onFileDlgCompleted (gui.StdDlgButton button);
[+] 	onFileDlgCompleted(gui.StdDlgButton button);
[-] 	onProgressDlgButtonClicked (gui.StdDlgButton button);
[+] 	onProgressDlgButtonClicked(gui.StdDlgButton button);
[-] 	onStatusCheckTimer ();
[+] 	onStatusCheckTimer();
[-] 	onFpgaCheckTimer ();
[+] 	onFpgaCheckTimer();
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] 	setStatusCheckTimer ();
[+] 	setStatusCheckTimer();
[-] 	enableFpga ();
[+] 	enableFpga();
[-] 	bool errorcode nextBlock ();
[+] 	bool errorcode nextBlock();
[-] 	bool checkStatus (ReqCode code);
[+] 	bool checkStatus(ReqCode code);
[-] 	bool errorcode syncControlTransfer (
[+] 	bool errorcode syncControlTransfer(
[-] 	onTransferCompleted (
[+] 	onTransferCompleted(
[-] CypressUploaderSession.construct (doc.PluginHost* pluginHost)
[+] CypressUploaderSession.construct(doc.PluginHost* pluginHost)
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] CypressUploaderSession.createUi ()
[+] CypressUploaderSession.createUi()
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_iconTable [IconId.Download] = new gui.Icon ("images/receive.png");
[+] 	m_iconTable[IconId.Download] = new gui.Icon("images/receive.png");
[-] 	m_iconTable [IconId.Upload] = new gui.Icon ("images/transmit.png");
[+] 	m_iconTable[IconId.Upload] = new gui.Icon("images/transmit.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Device:");
[+] 	m_pluginHost.m_toolBar.addLabel("Device:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh]  = createAction ("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh]  = createAction("Re-enumerate devices", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open device", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpenDevice;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpenDevice;
[-] 	m_pluginHost.m_menu.addSeparator ();
[+] 	m_pluginHost.m_menu.addSeparator();
[-] 	m_pluginHost.m_toolBar.addSeparator ();
[+] 	m_pluginHost.m_toolBar.addSeparator();
[-] 	m_actionTable [ActionId.Download] = createAction("Download file", m_iconTable [IconId.Download]);
[+] 	m_actionTable[ActionId.Download] = createAction("Download file", m_iconTable [IconId.Download]);
[-] 	m_actionTable [ActionId.Download].m_onTriggered += onDownloadFile;
[+] 	m_actionTable[ActionId.Download].m_onTriggered += onDownloadFile;
[-] 	m_actionTable [ActionId.Upload] = createAction("Upload file", m_iconTable [IconId.Upload]);
[+] 	m_actionTable[ActionId.Upload] = createAction("Upload file", m_iconTable [IconId.Upload]);
[-] 	m_actionTable [ActionId.Upload].m_onTriggered += onUploadFile;
[+] 	m_actionTable[ActionId.Upload].m_onTriggered += onUploadFile;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_autoDetachKernelDriverProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_statusCheckIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_statusCheckIntervalProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_fpgaCheckRetryCountProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_fpgaCheckRetryCountProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_blockSizeProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_blockSizeProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_maxDownloadSizeProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_maxDownloadSizeProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_eraseBeforeUploadProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_eraseBeforeUploadProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_extraStatusCheckProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_extraStatusCheckProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("USB connection");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("USB connection");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] CypressUploaderSession.onOpenDevice ()
[+] CypressUploaderSession.onOpenDevice()
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 		openDevice ();
[+] 		openDevice();
[-] CypressUploaderSession.enumerateDevices ()
[+] CypressUploaderSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 	io.UsbDb* usbDb = io.getStdUsbDb ();
[+] 	io.UsbDb* usbDb = io.getStdUsbDb();
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		io.UsbVendor const* vendor = usbDb.findVendor (deviceDesc.m_vendorId);
[+] 		io.UsbVendor const* vendor = usbDb.findVendor(deviceDesc.m_vendorId);
[-] 		io.UsbProduct const* product = vendor ? vendor.findProduct (deviceDesc.m_productId) : null;
[+] 		io.UsbProduct const* product = vendor ? vendor.findProduct(deviceDesc.m_productId) : null;
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [i].m_text = text;
[+] 		optionTable[i].m_text = text;
[-] 		optionTable [i].m_value = device;
[+] 		optionTable[i].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, count);
[+] 	m_deviceProp.setOptions(optionTable, count);
[-] bool CypressUploaderSession.openDevice ()
[+] bool CypressUploaderSession.openDevice()
[-] 	closeDevice ();
[+] 	closeDevice();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	writeLog (UsbLogRecordCode.DeviceOpened, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.DeviceOpened, &params, sizeof(params));
[-] 	writeLogLastError (UsbLogRecordCode.DeviceOpenError);
[+] 	writeLogLastError(UsbLogRecordCode.DeviceOpenError);
[-] CypressUploaderSession.closeDevice ()
[+] CypressUploaderSession.closeDevice()
[-] 	m_device.close ();
[+] 	m_device.close();
[-] 	writeLog (UsbLogRecordCode.DeviceClosed);
[+] 	writeLog(UsbLogRecordCode.DeviceClosed);
[-] CypressUploaderSession.load (doc.Storage* storage)
[+] CypressUploaderSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_autoDetachKernelDriverProp.m_value = storage.readBool ("autoDetachKernelDriver");
[+] 	m_autoDetachKernelDriverProp.m_value = storage.readBool("autoDetachKernelDriver");
[-] 	m_statusCheckIntervalProp.m_value = storage.readInt ("statusCheckInterval", Defaults.StatusCheckInterval);
[+] 	m_statusCheckIntervalProp.m_value = storage.readInt("statusCheckInterval", Defaults.StatusCheckInterval);
[-] 	m_fpgaCheckRetryCountProp.m_value = storage.readInt ("fpgaCheckRetryCount", Defaults.FpgaCheckRetryCount);
[+] 	m_fpgaCheckRetryCountProp.m_value = storage.readInt("fpgaCheckRetryCount", Defaults.FpgaCheckRetryCount);
[-] 	m_blockSizeProp.m_value = storage.readInt ("blockSize", Defaults.BlockSize);
[+] 	m_blockSizeProp.m_value = storage.readInt("blockSize", Defaults.BlockSize);
[-] 	m_maxDownloadSizeProp.m_value = storage.readInt ("maxDownloadSize", Defaults.MaxDownloadSize);
[+] 	m_maxDownloadSizeProp.m_value = storage.readInt("maxDownloadSize", Defaults.MaxDownloadSize);
[-] 	m_eraseBeforeUploadProp.m_value = storage.readBool ("eraseBeforeUpload", Defaults.EraseBeforUpload);
[+] 	m_eraseBeforeUploadProp.m_value = storage.readBool("eraseBeforeUpload", Defaults.EraseBeforUpload);
[-] 	m_extraStatusCheckProp.m_value = storage.readBool ("extraStatusChecks", Defaults.ExtraStatusChecks);
[+] 	m_extraStatusCheckProp.m_value = storage.readBool("extraStatusChecks", Defaults.ExtraStatusChecks);
[-] CypressUploaderSession.save (doc.Storage* storage)
[+] CypressUploaderSession.save(doc.Storage* storage)
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[+] 	storage.writeBool("autoDetachKernelDriver", m_autoDetachKernelDriverProp.m_value);
[-] 	storage.writeInt ("statusCheckInterval", m_statusCheckIntervalProp.m_value);
[+] 	storage.writeInt("statusCheckInterval", m_statusCheckIntervalProp.m_value);
[-] 	storage.writeInt ("fpgaCheckRetryCount", m_fpgaCheckRetryCountProp.m_value);
[+] 	storage.writeInt("fpgaCheckRetryCount", m_fpgaCheckRetryCountProp.m_value);
[-] 	storage.writeInt ("blockSize", m_blockSizeProp.m_value);
[+] 	storage.writeInt("blockSize", m_blockSizeProp.m_value);
[-] 	storage.writeInt ("maxDownloadSize", m_maxDownloadSizeProp.m_value);
[+] 	storage.writeInt("maxDownloadSize", m_maxDownloadSizeProp.m_value);
[-] 	storage.writeBool ("eraseBeforeUpload", m_eraseBeforeUploadProp.m_value);
[+] 	storage.writeBool("eraseBeforeUpload", m_eraseBeforeUploadProp.m_value);
[-] 	storage.writeBool ("extraStatusChecks", m_extraStatusCheckProp.m_value);
[+] 	storage.writeBool("extraStatusChecks", m_extraStatusCheckProp.m_value);
[-] CypressUploaderSession.updateProperties ()
[+] CypressUploaderSession.updateProperties()
[-] bool errorcode CypressUploaderSession.applyProperties ()
[+] bool errorcode CypressUploaderSession.applyProperties()
[-] CypressUploaderSession.restoreDefaultProperties ()
[+] CypressUploaderSession.restoreDefaultProperties()
[-] CypressUploaderSession.cancelFileTransfer ()
[+] CypressUploaderSession.cancelFileTransfer()
[-] 	m_timer.stop ();
[+] 	m_timer.stop();
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	m_progressDlg.hide ();
[+] 	m_progressDlg.hide();
[-] CypressUploaderSession.setStatusCheckTimer ()
[+] CypressUploaderSession.setStatusCheckTimer()
[-] 	m_timer.startPeriodicTimer (
[+] 	m_timer.startPeriodicTimer(
[-] bool CypressUploaderSession.checkStatus (ReqCode code)
[+] bool CypressUploaderSession.checkStatus(ReqCode code)
[-] 	syncControlTransfer (ReqType.VendorIn, code,,, &status, sizeof (status));
[+] 	syncControlTransfer(ReqType.VendorIn, code,,, &status, sizeof(status));
[-] CypressUploaderSession.onDownloadFile ()
[+] CypressUploaderSession.onDownloadFile()
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] 	writeLogString (log.StdRecordCode.PlainText, "Disabling FPGA...");
[+] 	writeLogString(log.StdRecordCode.PlainText, "Disabling FPGA...");
[-] 	syncControlTransfer (ReqType.VendorOut, ReqCode.DisableFpga);
[+] 	syncControlTransfer(ReqType.VendorOut, ReqCode.DisableFpga);
[-] 	writeLogString (log.StdRecordCode.PlainText, "Downloading file...");
[+] 	writeLogString(log.StdRecordCode.PlainText, "Downloading file...");
[-] 	nextBlock ();
[+] 	nextBlock();
[-] CypressUploaderSession.onUploadFile ()
[+] CypressUploaderSession.onUploadFile()
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] 	m_fileDlg.show ();
[+] 	m_fileDlg.show();
[-] CypressUploaderSession.onFileDlgCompleted (gui.StdDlgButton button)
[+] CypressUploaderSession.onFileDlgCompleted(gui.StdDlgButton button)
[-] 	m_progressDlg.show ();
[+] 	m_progressDlg.show();
[-] 	m_file.open (
[+] 	m_file.open(
[-] 	writeLogString (log.StdRecordCode.PlainText, "Disabling FPGA...");
[+] 	writeLogString(log.StdRecordCode.PlainText, "Disabling FPGA...");
[-] 	syncControlTransfer (ReqType.VendorOut, ReqCode.DisableFpga);
[+] 	syncControlTransfer(ReqType.VendorOut, ReqCode.DisableFpga);
[-] 	writeLogString (log.StdRecordCode.PlainText, $"Uploading file: $(m_fileDlg.m_filePath) ($(m_file.m_size) bytes)...");
[+] 	writeLogString(log.StdRecordCode.PlainText, $"Uploading file: $(m_fileDlg.m_filePath) ($(m_file.m_size) bytes)...");
[-] 		writeLogString (log.StdRecordCode.PlainText, "Erasing flash...");
[+] 		writeLogString(log.StdRecordCode.PlainText, "Erasing flash...");
[-] 		syncControlTransfer (ReqType.VendorOut, ReqCode.EraseFlash);
[+] 		syncControlTransfer(ReqType.VendorOut, ReqCode.EraseFlash);
[-] 		setStatusCheckTimer ();
[+] 		setStatusCheckTimer();
[-] 			checkStatus (ReqCode.GetFlashStatus);
[+] 			checkStatus(ReqCode.GetFlashStatus);
[-] 			nextBlock ();
[+] 			nextBlock();
[-] 			setStatusCheckTimer ();
[+] 			setStatusCheckTimer();
[-] 	m_progressDlg.m_status = std.getLastError ().m_description;
[+] 	m_progressDlg.m_status = std.getLastError().m_description;
[-] CypressUploaderSession.onStatusCheckTimer ()
[+] CypressUploaderSession.onStatusCheckTimer()
[-] 	bool isReady = checkStatus (ReqCode.GetFlashStatus);
[+] 	bool isReady = checkStatus(ReqCode.GetFlashStatus);
[-] 	m_timer.stop ();
[+] 	m_timer.stop();
[-] 	writeLogString (log.StdRecordCode.PlainText, $"Device ready, resuming upload...");
[+] 	writeLogString(log.StdRecordCode.PlainText, $"Device ready, resuming upload...");
[-] 	nextBlock ();
[+] 	nextBlock();
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] CypressUploaderSession.onFpgaCheckTimer ()
[+] CypressUploaderSession.onFpgaCheckTimer()
[-] 	bool isReady = checkStatus (ReqCode.GetFpgaStatus);
[+] 	bool isReady = checkStatus(ReqCode.GetFpgaStatus);
[-] 		writeLogString (log.StdRecordCode.PlainText, $"FPGA is functional");
[+] 		writeLogString(log.StdRecordCode.PlainText, $"FPGA is functional");
[-] 		cancelFileTransfer ();
[+] 		cancelFileTransfer();
[-] 	std.setError ("Can't load FPGA");
[+] 	std.setError("Can't load FPGA");
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] CypressUploaderSession.enableFpga ()
[+] CypressUploaderSession.enableFpga()
[-] 	writeLogString (log.StdRecordCode.PlainText, $"Enabling FPGA...");
[+] 	writeLogString(log.StdRecordCode.PlainText, $"Enabling FPGA...");
[-] 	syncControlTransfer (ReqType.VendorOut, ReqCode.EnableFpga);
[+] 	syncControlTransfer(ReqType.VendorOut, ReqCode.EnableFpga);
[-] 	m_timer.startPeriodicTimer (
[+] 	m_timer.startPeriodicTimer(
[-] bool errorcode CypressUploaderSession.nextBlock ()
[+] bool errorcode CypressUploaderSession.nextBlock()
[-] 	switch (m_state)
[+] 	switch(m_state)
[-] 		m_block.setSize (size);
[+] 		m_block.setSize(size);
[-] 		void const* p = m_file.view (m_offset, size);
[+] 		void const* p = m_file.view(m_offset, size);
[-] 		m_block.setSize (size);
[+] 		m_block.setSize(size);
[-] 		memcpy (m_block.m_p, p, size);
[+] 		memcpy(m_block.m_p, p, size);
[-] 		assert (false);
[+] 		assert(false);
[-] 		writeLogString (log.StdRecordCode.PlainText, $"File transfer completed ($m_offset bytes).");
[+] 		writeLogString(log.StdRecordCode.PlainText, $"File transfer completed ($m_offset bytes).");
[-] 		writeLog (log.StdRecordCode.Break); // separate from the next message
[+] 		writeLog(log.StdRecordCode.Break); // separate from the next message
[-] 		enableFpga ();
[+] 		enableFpga();
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 	writeLogError (log.StdRecordCode.Error, std.getLastError ());
[+] 	writeLogError(log.StdRecordCode.Error, std.getLastError());
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] bool errorcode CypressUploaderSession.syncControlTransfer (
[+] bool errorcode CypressUploaderSession.syncControlTransfer(
[-] 	writeLog (UsbLogRecordCode.ControlTransfer, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.ControlTransfer, &params, sizeof(params));
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 		writeLog ((type & ReqType.VendorIn) ? log.StdRecordCode.Rx : log.StdRecordCode.Tx, p, size);
[+] 		writeLog((type & ReqType.VendorIn) ? log.StdRecordCode.Rx : log.StdRecordCode.Tx, p, size);
[-] 	writeLogError (log.StdRecordCode.Error, std.getLastError ());
[+] 	writeLogError(log.StdRecordCode.Error, std.getLastError());
[-] 	cancelFileTransfer ();
[+] 	cancelFileTransfer();
[-] CypressUploaderSession.onTransferCompleted (
[+] CypressUploaderSession.onTransferCompleted(
[-] 	writeLog (UsbLogRecordCode.ControlTransfer, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.ControlTransfer, &params, sizeof(params));
[-] 		writeLogError (log.StdRecordCode.Error, error);
[+] 		writeLogError(log.StdRecordCode.Error, error);
[-] 		cancelFileTransfer ();
[+] 		cancelFileTransfer();
[-] 	writeLog (logRecordCode, p, size);
[+] 	writeLog(logRecordCode, p, size);
[-] 		nextBlock ();
[+] 		nextBlock();
[-] 		bool canSendNextBlock = !m_extraStatusCheckProp.m_value || checkStatus (ReqCode.GetFlashStatus);
[+] 		bool canSendNextBlock = !m_extraStatusCheckProp.m_value || checkStatus(ReqCode.GetFlashStatus);
[-] 			nextBlock ();
[+] 			nextBlock();
[-] 			setStatusCheckTimer ();
[+] 			setStatusCheckTimer();
[-] CypressUploaderSession.onProgressDlgButtonClicked (gui.StdDlgButton button)
[+] CypressUploaderSession.onProgressDlgButtonClicked(gui.StdDlgButton button)
[-] 	switch (button)
[+] 	switch(button)
[-] 		cancelFileTransfer ();
[+] 		cancelFileTransfer();
[-] 		m_progressDlg.hide ();
[+] 		m_progressDlg.hide();
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close Device" : "Open Device";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close Device" : "Open Device";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_actionTable [ActionId.Download].m_isEnabled = m_state;
[+] 	m_actionTable[ActionId.Download].m_isEnabled = m_state;
[-] 	m_actionTable [ActionId.Upload].m_isEnabled = m_state;
[+] 	m_actionTable[ActionId.Upload].m_isEnabled = m_state;
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_statusText [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_statusText[m_state];
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\HwSerialMonLogRepresenter.jnc
----------------------
[-] char const* getLineString (uint_t line)
[+] char const* getLineString(uint_t line)
[-] bool representHwSerialMonLog (
[+] bool representHwSerialMonLog(
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 		target.addBin (p, size);
[+] 		target.addBin(p, size);
[-] 		char const* rtsString = getLineString (rts);
[+] 		char const* rtsString = getLineString(rts);
[-] 		target.addHyperText ($"RTS changed: $rtsString");
[+] 		target.addHyperText($"RTS changed: $rtsString");
[-] 		char const* ctsString = getLineString (dtr);
[+] 		char const* ctsString = getLineString(dtr);
[-] 		target.addHyperText ($"CTS changed: $ctsString");
[+] 		target.addHyperText($"CTS changed: $ctsString");
[-] 		target.addHyperText ("UART framing error");
[+] 		target.addHyperText("UART framing error");
[-] 		target.addHyperText ("UART parity error");
[+] 		target.addHyperText("UART parity error");
[-] 		target.addHyperText ("I\u00b2C empty message");
[+] 		target.addHyperText("I\u00b2C empty message");
[-] 		target.addHyperText ("I\u00b2C preemptive start bit");
[+] 		target.addHyperText("I\u00b2C preemptive start bit");
[-] 		target.addHyperText ("I\u00b2C preemptive stop bit");
[+] 		target.addHyperText("I\u00b2C preemptive stop bit");
[-] 		target.addBin (log.StdRecordCode.Rx, p, size);
[+] 		target.addBin(log.StdRecordCode.Rx, p, size);
[-] 		target.addHyperText ("SPI empty message");
[+] 		target.addHyperText("SPI empty message");
[-] 		target.addHyperText ("SPI framing error");
[+] 		target.addHyperText("SPI framing error");
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\HwSerialMonSession.jnc
----------------------
[-] 	static char const* m_stateStringTable [] =
[+] 	static char const* m_stateStringTable[] =
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	gui.StatusPane* m_statusPaneTable [StatusPaneId._Count];
[+] 	gui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode openDevice ();
[+] 	bool errorcode openDevice();
[-] 	void closeDevice ();
[+] 	void closeDevice();
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	bool errorcode stopCapture ();
[+] 	bool errorcode stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override errorcode bool applyProperties ();
[+] 	override errorcode bool applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onOpenDevice ();
[+] 	onOpenDevice();
[-] 	onCapture ();
[+] 	onCapture();
[-] 	onUsbThroughputTimer (uint_t syncId);
[+] 	onUsbThroughputTimer(uint_t syncId);
[-] 	onInEndpointEvent (
[+] 	onInEndpointEvent(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	size_t errorcode writeOutEndpoint (
[+] 	size_t errorcode writeOutEndpoint(
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	updateUsbThroughput (uint64_t timestamp = sys.getTimestamp ());
[+] 	updateUsbThroughput(uint64_t timestamp = sys.getTimestamp());
[-] HwSerialMonSession.construct (doc.PluginHost* pluginHost)
[+] HwSerialMonSession.construct(doc.PluginHost* pluginHost)
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] HwSerialMonSession.createUi ()
[+] HwSerialMonSession.createUi()
[-] 	m_iconTable [IconId.Refresh] = new gui.Icon ("images/refresh.png");
[+] 	m_iconTable[IconId.Refresh] = new gui.Icon("images/refresh.png");
[-] 	m_iconTable [IconId.Open] = new gui.Icon ("images/open.png");
[+] 	m_iconTable[IconId.Open] = new gui.Icon("images/open.png");
[-] 	m_iconTable [IconId.Close] = new gui.Icon ("images/close.png");
[+] 	m_iconTable[IconId.Close] = new gui.Icon("images/close.png");
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Sniffer:");
[+] 	m_pluginHost.m_toolBar.addLabel("Sniffer:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Re-enumerate Devices", m_iconTable [IconId.Refresh]);
[+] 	m_actionTable[ActionId.Refresh] = createAction("Re-enumerate Devices", m_iconTable [IconId.Refresh]);
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Open] = createAction ("Open Sniffer Device", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Open] = createAction("Open Sniffer Device", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Open].m_onTriggered += onOpenDevice;
[+] 	m_actionTable[ActionId.Open].m_onTriggered += onOpenDevice;
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Open]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Open]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPaneTable [StatusPaneId.State] = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_showRawDataProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_showRawDataProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	gui.EnumPropertyOption serialIfaceTable [] =
[+] 	gui.EnumPropertyOption serialIfaceTable[] =
[-] 	m_serialIfaceProp  = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_serialIfaceProp  = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (serialIfaceTable)
[+] 		countof(serialIfaceTable)
[-] 	m_uart.createProperties (group);
[+] 	m_uart.createProperties(group);
[-] 	m_spi.createProperties (group);
[+] 	m_spi.createProperties(group);
[-] 	m_i2c.createProperties (group);
[+] 	m_i2c.createProperties(group);
[-] 	m_bufferPropertySet.createPropertiesGrouped (m_pluginHost.m_propertyGrid,,, ids);
[+] 	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid,,, ids);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("Serial monitor");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial monitor");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_usbTotalSizeInfo = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "USB total bytes");
[+] 	m_usbTotalSizeInfo = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "USB total bytes");
[-] 	m_usbThroughputInfo = m_pluginHost.m_informationGrid.createValue (infoGroup,,, "USB throughput");
[+] 	m_usbThroughputInfo = m_pluginHost.m_informationGrid.createValue(infoGroup,,, "USB throughput");
[-] 	m_usbThroughputTimestamp = sys.getTimestamp ();
[+] 	m_usbThroughputTimestamp = sys.getTimestamp();
[-] 	updateUsbThroughput (m_usbThroughputTimestamp);
[+] 	updateUsbThroughput(m_usbThroughputTimestamp);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] HwSerialMonSession.onOpenDevice ()
[+] HwSerialMonSession.onOpenDevice()
[-] 		closeDevice ();
[+] 		closeDevice();
[-] 		try openDevice ();
[+] 		try openDevice();
[-] HwSerialMonSession.onCapture ()
[+] HwSerialMonSession.onCapture()
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		try capture ();
[+] 		try capture();
[-] HwSerialMonSession.enumerateDevices ()
[+] HwSerialMonSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		io.UsbProduct const* product = g_usbDb.findProduct (deviceDesc.m_vendorId, deviceDesc.m_productId);
[+] 		io.UsbProduct const* product = g_usbDb.findProduct(deviceDesc.m_vendorId, deviceDesc.m_productId);
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [ftdiCount].m_text = text;
[+] 		optionTable[ftdiCount].m_text = text;
[-] 		optionTable [ftdiCount].m_value = device;
[+] 		optionTable[ftdiCount].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, ftdiCount);
[+] 	m_deviceProp.setOptions(optionTable, ftdiCount);
[-] bool errorcode HwSerialMonSession.openDevice ()
[+] bool errorcode HwSerialMonSession.openDevice()
[-] 	closeDevice ();
[+] 	closeDevice();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	m_iface = m_device.claimInterface (0);
[+] 	m_iface = m_device.claimInterface(0);
[-] 	m_outEndpoint = m_iface.openEndpoint (0x01);
[+] 	m_outEndpoint = m_iface.openEndpoint(0x01);
[-] 	m_inEndpoint = m_iface.openEndpoint (0x81);
[+] 	m_inEndpoint = m_iface.openEndpoint(0x81);
[-] 	writeLog (UsbLogRecordCode.DeviceOpened, &params, sizeof (params));
[+] 	writeLog(UsbLogRecordCode.DeviceOpened, &params, sizeof(params));
[-] 	return capture ();
[+] 	return capture();
[-] 	writeLogLastError (UsbLogRecordCode.DeviceOpenError);
[+] 	writeLogLastError(UsbLogRecordCode.DeviceOpenError);
[-] 	closeDevice ();
[+] 	closeDevice();
[-] HwSerialMonSession.closeDevice ()
[+] HwSerialMonSession.closeDevice()
[-] 		m_outEndpoint.close ();
[+] 		m_outEndpoint.close();
[-] 		m_inEndpoint.close ();
[+] 		m_inEndpoint.close();
[-] 		m_iface.release ();
[+] 		m_iface.release();
[-] 		m_device.close ();
[+] 		m_device.close();
[-] 		writeLog (UsbLogRecordCode.DeviceClosed);
[+] 		writeLog(UsbLogRecordCode.DeviceClosed);
[-] bool errorcode HwSerialMonSession.capture ()
[+] bool errorcode HwSerialMonSession.capture()
[-] 	static char packet [] = 0x"55 55 55 55";
[+] 	static char packet[] = 0x"55 55 55 55";
[-] 	writeOutEndpoint (packet, sizeof (packet));
[+] 	writeOutEndpoint(packet, sizeof(packet));
[-] 	m_captureBaseTime = sys.getTimestamp ();
[+] 	m_captureBaseTime = sys.getTimestamp();
[-] 	m_capturingSerialIface.start ();
[+] 	m_capturingSerialIface.start();
[-] 	writeLogString (HwSerialMonRecordCode.CaptureStarted, m_capturingSerialIface.m_name);
[+] 	writeLogString(HwSerialMonRecordCode.CaptureStarted, m_capturingSerialIface.m_name);
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	m_usbThroughputTimer.startPeriodicTimer (onUsbThroughputTimer ~(++m_usbThroughputTimerSyncId) @ m_pluginHost.m_mainThreadScheduler, 1000);
[+] 	m_usbThroughputTimer.startPeriodicTimer(onUsbThroughputTimer ~(++m_usbThroughputTimerSyncId) @ m_pluginHost.m_mainThreadScheduler, 1000);
[-] 	m_usbThroughputTimestamp = sys.getTimestamp ();
[+] 	m_usbThroughputTimestamp = sys.getTimestamp();
[-] 	updateUsbThroughput (m_usbThroughputTimestamp);
[+] 	updateUsbThroughput(m_usbThroughputTimestamp);
[-] bool errorcode HwSerialMonSession.stopCapture ()
[+] bool errorcode HwSerialMonSession.stopCapture()
[-] 	static char packet [] = 0x"aa aa aa aa";
[+] 	static char packet[] = 0x"aa aa aa aa";
[-] 	writeOutEndpoint (packet, sizeof (packet));
[+] 	writeOutEndpoint(packet, sizeof(packet));
[-] 	m_capturingSerialIface.stop ();
[+] 	m_capturingSerialIface.stop();
[-] 	writeLog (HwSerialMonRecordCode.CaptureStopped);
[+] 	writeLog(HwSerialMonRecordCode.CaptureStopped);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] 	m_usbThroughputTimer.stop ();
[+] 	m_usbThroughputTimer.stop();
[-] 	m_inEndpoint.wait (eventMask, onInEndpointEvent ~(++m_inEndpointSyncId) @ m_pluginHost.m_mainThreadScheduler);
[+] 	m_inEndpoint.wait(eventMask, onInEndpointEvent ~(++m_inEndpointSyncId) @ m_pluginHost.m_mainThreadScheduler);
[-] HwSerialMonSession.load (doc.Storage* storage)
[+] HwSerialMonSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_showRawDataProp.m_value = storage.readBool ("showRawData");
[+] 	m_showRawDataProp.m_value = storage.readBool("showRawData");
[-] 	m_serialIfaceProp.m_currentIndex  = storage.readInt ("serialInterface");
[+] 	m_serialIfaceProp.m_currentIndex  = storage.readInt("serialInterface");
[-] 	m_uart.loadProperties (storage);
[+] 	m_uart.loadProperties(storage);
[-] 	m_spi.loadProperties (storage);
[+] 	m_spi.loadProperties(storage);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] HwSerialMonSession.save (doc.Storage* storage)
[+] HwSerialMonSession.save(doc.Storage* storage)
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] 	storage.writeInt ("deviceIdx", m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", m_deviceCombo.m_currentIndex);
[-] 	storage.writeBool ("showRawData", m_showRawDataProp.m_value);
[+] 	storage.writeBool("showRawData", m_showRawDataProp.m_value);
[-] 	storage.writeInt ("serialInterface", m_serialIfaceProp.m_currentIndex);
[+] 	storage.writeInt("serialInterface", m_serialIfaceProp.m_currentIndex);
[-] 	m_uart.saveProperties (storage);
[+] 	m_uart.saveProperties(storage);
[-] 	m_spi.saveProperties (storage);
[+] 	m_spi.saveProperties(storage);
[-] HwSerialMonSession.updateProperties ()
[+] HwSerialMonSession.updateProperties()
[-] bool errorcode HwSerialMonSession.applyProperties ()
[+] bool errorcode HwSerialMonSession.applyProperties()
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 	m_capturingSerialIface.start (); // restart capturing with the new parameters
[+] 	m_capturingSerialIface.start(); // restart capturing with the new parameters
[-] HwSerialMonSession.restoreDefaultProperties ()
[+] HwSerialMonSession.restoreDefaultProperties()
[-] 	m_uart.restoreDefaultProperties ();
[+] 	m_uart.restoreDefaultProperties();
[-] 	m_spi.restoreDefaultProperties ();
[+] 	m_spi.restoreDefaultProperties();
[-] size_t errorcode HwSerialMonSession.writeOutEndpoint (
[+] size_t errorcode HwSerialMonSession.writeOutEndpoint(
[-] 	size_t result = try m_outEndpoint.write (p, size);
[+] 	size_t result = try m_outEndpoint.write(p, size);
[-] 		writeLogLastError (log.StdRecordCode.Error);
[+] 		writeLogLastError(log.StdRecordCode.Error);
[-] HwSerialMonSession.onUsbThroughputTimer (uint_t syncId)
[+] HwSerialMonSession.onUsbThroughputTimer(uint_t syncId)
[-] 		updateUsbThroughput ();
[+] 		updateUsbThroughput();
[-] HwSerialMonSession.updateUsbThroughput (uint64_t timestamp)
[+] HwSerialMonSession.updateUsbThroughput(uint64_t timestamp)
[-] HwSerialMonSession.onInEndpointEvent (
[+] HwSerialMonSession.onInEndpointEvent(
[-] 		writeLogError (log.StdRecordCode.Error, m_inEndpoint.m_ioError);
[+] 		writeLogError(log.StdRecordCode.Error, m_inEndpoint.m_ioError);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		size_t size = m_inEndpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t size = m_inEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 		uint64_t const* end = p + size / sizeof (uint64_t);
[+] 		uint64_t const* end = p + size / sizeof(uint64_t);
[-] 				m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.RawPacket, p, sizeof (uint64_t));
[+] 				m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.RawPacket, p, sizeof(uint64_t));
[-] 			m_capturingSerialIface.processSignal (timestamp, frame);
[+] 			m_capturingSerialIface.processSignal(timestamp, frame);
[-] 	waitInEndpointEvents ();
[+] 	waitInEndpointEvents();
[-] 	m_actionTable [ActionId.Open].m_text = m_state ? "Close Sniffer Device" : "Open Sniffer Device";
[+] 	m_actionTable[ActionId.Open].m_text = m_state ? "Close Sniffer Device" : "Open Sniffer Device";
[-] 	m_actionTable [ActionId.Open].m_icon = m_iconTable [m_state ? IconId.Close : IconId.Open];
[+] 	m_actionTable[ActionId.Open].m_icon = m_iconTable[m_state ? IconId.Close : IconId.Open];
[-] 	m_actionTable [ActionId.Capture].m_text = m_state == State.Capturing ? "Stop Capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state == State.Capturing ? "Stop Capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state == State.Capturing ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state == State.Capturing ? IconId.StopCapture : IconId.Capture];
[-] 	m_actionTable [ActionId.Capture].m_isEnabled = m_state;
[+] 	m_actionTable[ActionId.Capture].m_isEnabled = m_state;
[-] 	m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state];
[+] 	m_statusPaneTable[StatusPaneId.State].m_text = m_stateStringTable[m_state];
[-] construct ()
[+] construct()
[-] 	try g_usbDb.load ("sniffers.ids");
[+] 	try g_usbDb.load("sniffers.ids");
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\I2c.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 		basetype.construct (pluginHost);
[+] 		basetype.construct(pluginHost);
[-] 	override start ()
[+] 	override start()
[-] 		m_decoder.start ();
[+] 		m_decoder.start();
[-] 	override processSignal (
[+] 	override processSignal(
[-] override I2c.processSignal (
[+] override I2c.processSignal(
[-] 	io.I2cDecodeResult result = m_decoder.add (
[+] 	io.I2cDecodeResult result = m_decoder.add(
[-] 	switch (result)
[+] 	switch(result)
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, log.StdRecordCode.Break);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, log.StdRecordCode.Break);
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.I2cPreemptiveStart);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.I2cPreemptiveStart);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.I2cPreemptiveStop);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.I2cPreemptiveStop);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.I2cEmptyMessage);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.I2cEmptyMessage);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\SerialIface.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 	virtual createProperties (
[+] 	virtual createProperties(
[-] 	virtual loadProperties (doc.Storage* storage)
[+] 	virtual loadProperties(doc.Storage* storage)
[-] 	virtual saveProperties (doc.Storage* storage)
[+] 	virtual saveProperties(doc.Storage* storage)
[-] 	virtual restoreDefaultProperties ()
[+] 	virtual restoreDefaultProperties()
[-] 	abstract start ();
[+] 	abstract start();
[-] 	virtual stop ()
[+] 	virtual stop()
[-] 	abstract processSignal (
[+] 	abstract processSignal(
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\Spi.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 		basetype.construct (pluginHost);
[+] 		basetype.construct(pluginHost);
[-] 	override createProperties (
[+] 	override createProperties(
[-] 	override loadProperties (doc.Storage* storage);
[+] 	override loadProperties(doc.Storage* storage);
[-] 	override saveProperties (doc.Storage* storage);
[+] 	override saveProperties(doc.Storage* storage);
[-] 	override restoreDefaultProperties ();
[+] 	override restoreDefaultProperties();
[-] 	override start ()
[+] 	override start()
[-] 		m_decoder.start (m_modeProp.m_value, m_endiannessProp.m_value);
[+] 		m_decoder.start(m_modeProp.m_value, m_endiannessProp.m_value);
[-] 	override processSignal (
[+] 	override processSignal(
[-] Spi.createProperties (
[+] Spi.createProperties(
[-] 	static gui.EnumPropertyOption modeTable [] =
[+] 	static gui.EnumPropertyOption modeTable[] =
[-] 	static gui.EnumPropertyOption endiannessTable [] =
[+] 	static gui.EnumPropertyOption endiannessTable[] =
[-] 	m_groupProp = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	m_groupProp = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_modeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_modeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (modeTable)
[+] 		countof(modeTable)
[-] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (endiannessTable)
[+] 		countof(endiannessTable)
[-] Spi.loadProperties (doc.Storage* storage)
[+] Spi.loadProperties(doc.Storage* storage)
[-] 	m_modeProp.m_currentIndex = storage.readInt ("spiMode");
[+] 	m_modeProp.m_currentIndex = storage.readInt("spiMode");
[-] 	m_endiannessProp.m_currentIndex = storage.readInt ("spiEndianness");
[+] 	m_endiannessProp.m_currentIndex = storage.readInt("spiEndianness");
[-] Spi.saveProperties (doc.Storage* storage)
[+] Spi.saveProperties(doc.Storage* storage)
[-] 	storage.writeInt ("spiMode", m_modeProp.m_currentIndex);
[+] 	storage.writeInt("spiMode", m_modeProp.m_currentIndex);
[-] 	storage.writeInt ("spiEndianness", m_endiannessProp.m_currentIndex);
[+] 	storage.writeInt("spiEndianness", m_endiannessProp.m_currentIndex);
[-] Spi.restoreDefaultProperties ()
[+] Spi.restoreDefaultProperties()
[-] Spi.processSignal (
[+] Spi.processSignal(
[-] 	io.SpiDecodeResult result = m_decoder.add (
[+] 	io.SpiDecodeResult result = m_decoder.add(
[-] 	switch (result)
[+] 	switch(result)
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, log.StdRecordCode.Break);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, log.StdRecordCode.Break);
[-] 		char buffer [2] = { m_decoder.m_mosiChar, m_decoder.m_misoChar }
[+] 		char buffer[2] = { m_decoder.m_mosiChar, m_decoder.m_misoChar }
[-] 		m_pluginHost.m_log.m_writer.write (
[+] 		m_pluginHost.m_log.m_writer.write(
[-] 			sizeof (buffer)
[+] 			sizeof(buffer)
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.SpiFramingError);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.SpiFramingError);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.SpiEmptyMessage);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.SpiEmptyMessage);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\HwSerialMon\Uart.jnc
----------------------
[-] 	construct (doc.PluginHost* pluginHost)
[+] 	construct(doc.PluginHost* pluginHost)
[-] 		basetype.construct (pluginHost);
[+] 		basetype.construct(pluginHost);
[-] 	override createProperties (
[+] 	override createProperties(
[-] 	override loadProperties (doc.Storage* storage);
[+] 	override loadProperties(doc.Storage* storage);
[-] 	override saveProperties (doc.Storage* storage);
[+] 	override saveProperties(doc.Storage* storage);
[-] 	override restoreDefaultProperties ();
[+] 	override restoreDefaultProperties();
[-] 	override start ();
[+] 	override start();
[-] 	override stop ()
[+] 	override stop()
[-] 		m_timer.stop ();
[+] 		m_timer.stop();
[-] 	override processSignal (
[+] 	override processSignal(
[-] 	finalizeFrame (
[+] 	finalizeFrame(
[-] 	onTimer ();
[+] 	onTimer();
[-] Uart.createProperties (
[+] Uart.createProperties(
[-] 	static gui.EnumPropertyOption baudRateTable [] =
[+] 	static gui.EnumPropertyOption baudRateTable[] =
[-] 	static gui.EnumPropertyOption dataBitsTable [] =
[+] 	static gui.EnumPropertyOption dataBitsTable[] =
[-] 	static gui.EnumPropertyOption stopBitsTable [] =
[+] 	static gui.EnumPropertyOption stopBitsTable[] =
[-] 	static gui.EnumPropertyOption parityTable [] =
[+] 	static gui.EnumPropertyOption parityTable[] =
[-] 	m_groupProp = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	m_groupProp = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_baudRateProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_baudRateProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (baudRateTable)
[+] 		countof(baudRateTable)
[-] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (dataBitsTable)
[+] 		countof(dataBitsTable)
[-] 	m_stopBitsProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_stopBitsProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (stopBitsTable)
[+] 		countof(stopBitsTable)
[-] 	m_parityProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_parityProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (parityTable)
[+] 		countof(parityTable)
[-] Uart.loadProperties (doc.Storage* storage)
[+] Uart.loadProperties(doc.Storage* storage)
[-] 	m_baudRateProp.m_currentIndex = storage.readInt ("baudRate");
[+] 	m_baudRateProp.m_currentIndex = storage.readInt("baudRate");
[-] 	m_dataBitsProp.m_currentIndex = storage.readInt ("dataBits");
[+] 	m_dataBitsProp.m_currentIndex = storage.readInt("dataBits");
[-] 	m_stopBitsProp.m_currentIndex = storage.readInt ("stopBits");
[+] 	m_stopBitsProp.m_currentIndex = storage.readInt("stopBits");
[-] 	m_parityProp.m_currentIndex = storage.readInt ("parity");
[+] 	m_parityProp.m_currentIndex = storage.readInt("parity");
[-] Uart.saveProperties (doc.Storage* storage)
[+] Uart.saveProperties(doc.Storage* storage)
[-] 	storage.writeInt ("baudRate", m_baudRateProp.m_currentIndex);
[+] 	storage.writeInt("baudRate", m_baudRateProp.m_currentIndex);
[-] 	storage.writeInt ("dataBits", m_dataBitsProp.m_currentIndex);
[+] 	storage.writeInt("dataBits", m_dataBitsProp.m_currentIndex);
[-] 	storage.writeInt ("stopBits", m_stopBitsProp.m_currentIndex);
[+] 	storage.writeInt("stopBits", m_stopBitsProp.m_currentIndex);
[-] 	storage.writeInt ("parity", m_parityProp.m_currentIndex);
[+] 	storage.writeInt("parity", m_parityProp.m_currentIndex);
[-] Uart.restoreDefaultProperties ()
[+] Uart.restoreDefaultProperties()
[-] Uart.start ()
[+] Uart.start()
[-] 	m_txDecoder.start (
[+] 	m_txDecoder.start(
[-] 	m_rxDecoder.start (
[+] 	m_rxDecoder.start(
[-] 	m_timer.startPeriodicTimer (onTimer @ m_pluginHost.m_mainThreadScheduler, 200);
[+] 	m_timer.startPeriodicTimer(onTimer @ m_pluginHost.m_mainThreadScheduler, 200);
[-] Uart.processSignal (
[+] Uart.processSignal(
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.UartRtsChanged, &state, sizeof (state));
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.UartRtsChanged, &state, sizeof(state));
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.UartCtsChanged, &state, sizeof (state));
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.UartCtsChanged, &state, sizeof(state));
[-] 		io.UartDecodeResult result = m_txDecoder.add (timestamp, lines & Lines.Tx);
[+] 		io.UartDecodeResult result = m_txDecoder.add(timestamp, lines & Lines.Tx);
[-] 			finalizeFrame (
[+] 			finalizeFrame(
[-] 		io.UartDecodeResult result = m_rxDecoder.add (timestamp, lines & Lines.Rx);
[+] 		io.UartDecodeResult result = m_rxDecoder.add(timestamp, lines & Lines.Rx);
[-] 			finalizeFrame (
[+] 			finalizeFrame(
[-] Uart.finalizeFrame (
[+] Uart.finalizeFrame(
[-] 	m_pluginHost.m_log.m_writer.write (timestamp, recordCode, &data, 1);
[+] 	m_pluginHost.m_log.m_writer.write(timestamp, recordCode, &data, 1);
[-] 	switch (result)
[+] 	switch(result)
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.UartFramingError);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.UartFramingError);
[-] 		m_pluginHost.m_log.m_writer.write (timestamp, HwSerialMonRecordCode.UartParityError);
[+] 		m_pluginHost.m_log.m_writer.write(timestamp, HwSerialMonRecordCode.UartParityError);
[-] Uart.onTimer ()
[+] Uart.onTimer()
[-] 	result = m_txDecoder.onTimer ();
[+] 	result = m_txDecoder.onTimer();
[-] 		finalizeFrame (
[+] 		finalizeFrame(
[-] 			sys.getTimestamp (),
[+] 			sys.getTimestamp(),
[-] 	result = m_rxDecoder.onTimer ();
[+] 	result = m_rxDecoder.onTimer();
[-] 		finalizeFrame (
[+] 		finalizeFrame(
[-] 			sys.getTimestamp (),
[+] 			sys.getTimestamp(),
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\SpiTap\SpiTapLogRepresenter.jnc
----------------------
[-] char const* getTableString (
[+] char const* getTableString(
[-] 	return value < dynamic countof (table) ? table [value] : "\e[31mundefined\e[m";
[+] 	return value < dynamic countof(table) ? table[value] : "\e[31mundefined\e[m";
[-] bool representSpiTapLog (
[+] bool representSpiTapLog(
[-] 	static char const* endiannessStringTable [] =
[+] 	static char const* endiannessStringTable[] =
[-] 	switch (recordCode)
[+] 	switch(recordCode)
[-] 			char const* endiannessString = getTableString (params.m_endianness, endiannessStringTable);
[+] 			char const* endiannessString = getTableString(params.m_endianness, endiannessStringTable);
[-] 		target.addHyperText (string);
[+] 		target.addHyperText(string);
[-] 		target.addHyperText ($"Port \e[34m$name\e[m closed");
[+] 		target.addHyperText($"Port \e[34m$name\e[m closed");
[-] 		target.addHyperText ($"Cannot open port: $(error.m_description)");
[+] 		target.addHyperText($"Cannot open port: $(error.m_description)");
[-] 		target.addHyperText ($"Set clock frequency: \e[34m$frequency\e[m Hz");
[+] 		target.addHyperText($"Set clock frequency: \e[34m$frequency\e[m Hz");
[-] 		target.addHyperText ($"Set SPI mode: \e[34m$mode");
[+] 		target.addHyperText($"Set SPI mode: \e[34m$mode");
[-] 		target.addHyperText ($"Set data bits: \e[34m$dataBits\e[m bits");
[+] 		target.addHyperText($"Set data bits: \e[34m$dataBits\e[m bits");
[-] 		char const* endiannessString = getTableString (isMsbFirst, endiannessStringTable);
[+] 		char const* endiannessString = getTableString(isMsbFirst, endiannessStringTable);
[-] 		target.addHyperText ($"Set endianness: $endiannessString");
[+] 		target.addHyperText($"Set endianness: $endiannessString");
[-] 		target.addHyperText ($"SPI MOSI and MISO out-of-sync");
[+] 		target.addHyperText($"SPI MOSI and MISO out-of-sync");
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\ioninja\samples\SpiTap\SpiTapSession.jnc
----------------------
[-] 	bool errorcode claim (
[+] 	bool errorcode claim(
[-] 	release ();
[+] 	release();
[-] 	bool errorcode setBufferProperties (io.BufferPropertySet* bufferPropertySet);
[+] 	bool errorcode setBufferProperties(io.BufferPropertySet* bufferPropertySet);
[-] bool errorcode SpiIface.claim (
[+] bool errorcode SpiIface.claim(
[-] 	m_interface = device.claimInterface (ifaceId);
[+] 	m_interface = device.claimInterface(ifaceId);
[-] 	m_endpoint = m_interface.openEndpoint (ifaceId ? 0x85 : 0x82);
[+] 	m_endpoint = m_interface.openEndpoint(ifaceId ? 0x85 : 0x82);
[-] SpiIface.release ()
[+] SpiIface.release()
[-] 		m_endpoint.close ();
[+] 		m_endpoint.close();
[-] 		m_interface.release ();
[+] 		m_interface.release();
[-] bool errorcode SpiIface.setBufferProperties (io.BufferPropertySet* bufferPropertySet)
[+] bool errorcode SpiIface.setBufferProperties(io.BufferPropertySet* bufferPropertySet)
[-] 	gui.Action* m_actionTable [ActionId._Count];
[+] 	gui.Action* m_actionTable[ActionId._Count];
[-] 	gui.Icon* m_iconTable [IconId._Count];
[+] 	gui.Icon* m_iconTable[IconId._Count];
[-] 	construct (doc.PluginHost* pluginHost);
[+] 	construct(doc.PluginHost* pluginHost);
[-] 	bool errorcode capture ();
[+] 	bool errorcode capture();
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	override void load (doc.Storage* storage);
[+] 	override void load(doc.Storage* storage);
[-] 	override void save (doc.Storage* storage);
[+] 	override void save(doc.Storage* storage);
[-] 	override void updateProperties ();
[+] 	override void updateProperties();
[-] 	override bool errorcode applyProperties ();
[+] 	override bool errorcode applyProperties();
[-] 	override void restoreDefaultProperties ();
[+] 	override void restoreDefaultProperties();
[-] 	onCapture ()
[+] 	onCapture()
[-] 		m_state ? stopCapture () : try capture ();
[+] 		m_state ? stopCapture() : try capture();
[-] 	onDeviceComboEnter ()
[+] 	onDeviceComboEnter()
[-] 		try capture ();
[+] 		try capture();
[-] 	onModeChanged ();
[+] 	onModeChanged();
[-] 	onEndpointEvent (
[+] 	onEndpointEvent(
[-] 	onFlushTimer (uint_t syncId);
[+] 	onFlushTimer(uint_t syncId);
[-] 	bool flush (bool isForced);
[+] 	bool flush(bool isForced);
[-] 	void writeLogTextOnly (
[+] 	void writeLogTextOnly(
[-] 	void writeLogTextOnly (
[+] 	void writeLogTextOnly(
[-] 	createUi ();
[+] 	createUi();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	flipAB ();
[+] 	flipAB();
[-] 	waitEndpointEvents (SpiIface* iface);
[+] 	waitEndpointEvents(SpiIface* iface);
[-] 	bool errorcode configureSpiIface (uint_t ifaceId);
[+] 	bool errorcode configureSpiIface(uint_t ifaceId);
[-] SpiTapSession.construct (doc.PluginHost* pluginHost)
[+] SpiTapSession.construct(doc.PluginHost* pluginHost)
[-] 	basetype.construct (pluginHost);
[+] 	basetype.construct(pluginHost);
[-] 	m_readBuffer.setSize (io.BufferPropertySet.Defaults.ReadBufferSize);
[+] 	m_readBuffer.setSize(io.BufferPropertySet.Defaults.ReadBufferSize);
[-] 	m_textDfa.compile (r"[^\r\n\t -~]*([\r\n\t -~]+)"); // extract ASCII printables
[+] 	m_textDfa.compile(r"[^\r\n\t -~]*([\r\n\t -~]+)"); // extract ASCII printables
[-] 	createUi ();
[+] 	createUi();
[-] 	pluginHost.m_log.addSelectionProcessor (log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory ~(m_throughputInfoSet));
[-] 	pluginHost.m_log.addSelectionProcessor (log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[+] 	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory ~(m_checksumInfoSet));
[-] 	m_stdSessionInfoSet.addLogListener (pluginHost.m_log);
[+] 	m_stdSessionInfoSet.addLogListener(pluginHost.m_log);
[-] SpiTapSession.createUi ()
[+] SpiTapSession.createUi()
[-] 	static gui.EnumPropertyOption modeTable [] =
[+] 	static gui.EnumPropertyOption modeTable[] =
[-] 	static gui.EnumPropertyOption endiannessTable [] =
[+] 	static gui.EnumPropertyOption endiannessTable[] =
[-] 	m_iconTable [IconId.Capture] = new gui.Icon ("images/capture.png");
[+] 	m_iconTable[IconId.Capture] = new gui.Icon("images/capture.png");
[-] 	m_iconTable [IconId.StopCapture] = new gui.Icon ("images/pause.png");
[+] 	m_iconTable[IconId.StopCapture] = new gui.Icon("images/pause.png");
[-] 	m_pluginHost.m_toolBar.addLabel ("Tap:");
[+] 	m_pluginHost.m_toolBar.addLabel("Tap:");
[-] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox (-1);
[+] 	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
[-] 	m_actionTable [ActionId.Refresh] = createAction ("Re-enumerate devices", "images/refresh.png");
[+] 	m_actionTable[ActionId.Refresh] = createAction("Re-enumerate devices", "images/refresh.png");
[-] 	m_actionTable [ActionId.Refresh].m_onTriggered += enumerateDevices;
[+] 	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;
[-] 	m_actionTable [ActionId.Flip] = createAction ("Flip Master/Slave roles", "images/flip.png");
[+] 	m_actionTable[ActionId.Flip] = createAction("Flip Master/Slave roles", "images/flip.png");
[-] 	m_actionTable [ActionId.Flip].m_isCheckable = true;
[+] 	m_actionTable[ActionId.Flip].m_isCheckable = true;
[-] 	m_actionTable [ActionId.Flip].m_onTriggered = flipAB;
[+] 	m_actionTable[ActionId.Flip].m_onTriggered = flipAB;
[-] 	m_pluginHost.m_toolBar.addLabel ("Mode:");
[+] 	m_pluginHost.m_toolBar.addLabel("Mode:");
[-] 	m_modeCombo = m_pluginHost.m_toolBar.addComboBox ();
[+] 	m_modeCombo = m_pluginHost.m_toolBar.addComboBox();
[-] 	for (size_t i = 0; i < countof (modeTable); i++)
[+] 	for (size_t i = 0; i < countof(modeTable); i++)
[-] 		m_modeCombo.addItem (modeTable [i].m_text, modeTable [i].m_value);
[+] 		m_modeCombo.addItem(modeTable[i].m_text, modeTable[i].m_value);
[-] 	m_modeCombo.adjustSizeToContents ();
[+] 	m_modeCombo.adjustSizeToContents();
[-] 	m_actionTable [ActionId.Capture] = createAction ("Capture", m_iconTable [IconId.Capture]);
[+] 	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable [IconId.Capture]);
[-] 	m_actionTable [ActionId.Capture].m_onTriggered += onCapture;
[+] 	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
[-] 	m_statusPane = m_pluginHost.m_statusBar.addPane (, 80);
[+] 	m_statusPane = m_pluginHost.m_statusBar.addPane(, 80);
[-] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	gui.GroupProperty* group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 	m_frequencyProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_frequencyProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_modeProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_modeProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (modeTable)
[+] 		countof(modeTable)
[-] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty (
[+] 	m_endiannessProp = m_pluginHost.m_propertyGrid.createEnumProperty(
[-] 		countof (endiannessTable)
[+] 		countof(endiannessTable)
[-] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_dataBitsProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_useDualHexViewProp = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_useDualHexViewProp = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_useTextFilter = m_pluginHost.m_propertyGrid.createBoolProperty (
[+] 	m_useTextFilter = m_pluginHost.m_propertyGrid.createBoolProperty(
[-] 	m_flushTimeoutProp = m_pluginHost.m_propertyGrid.createIntProperty (
[+] 	m_flushTimeoutProp = m_pluginHost.m_propertyGrid.createIntProperty(
[-] 	group = m_pluginHost.m_propertyGrid.createGroupProperty (
[+] 	group = m_pluginHost.m_propertyGrid.createGroupProperty(
[-] 	m_bufferPropertySet.createProperties (m_pluginHost.m_propertyGrid, group,, mask);
[+] 	m_bufferPropertySet.createProperties(m_pluginHost.m_propertyGrid, group,, mask);
[-] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup ("SPI tap");
[+] 	gui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("SPI tap");
[-] 	m_stdSessionInfoSet.createInformationValues (m_pluginHost.m_informationGrid, infoGroup);
[+] 	m_stdSessionInfoSet.createInformationValues(m_pluginHost.m_informationGrid, infoGroup);
[-] 	m_throughputInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_checksumInfoSet.createInformationValuesGrouped (m_pluginHost.m_informationGrid);
[+] 	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
[-] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents ();
[+] 	m_pluginHost.m_informationGrid.resizeNameColumnToContents();
[-] 	enumerateDevices ();
[+] 	enumerateDevices();
[-] 	m_uiReactor.start ();
[+] 	m_uiReactor.start();
[-] SpiTapSession.enumerateDevices ()
[+] SpiTapSession.enumerateDevices()
[-] 	m_deviceCombo.clear ();
[+] 	m_deviceCombo.clear();
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray ();
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray();
[-] 	size_t count = dynamic countof (deviceArray);
[+] 	size_t count = dynamic countof(deviceArray);
[-] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption [count];
[+] 	gui.EnumPropertyOption* optionTable = new gui.EnumPropertyOption[count];
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		m_deviceCombo.addItem (text, device);
[+] 		m_deviceCombo.addItem(text, device);
[-] 		optionTable [ftdiCount].m_text = text;
[+] 		optionTable[ftdiCount].m_text = text;
[-] 		optionTable [ftdiCount].m_value = device;
[+] 		optionTable[ftdiCount].m_value = device;
[-] 	m_deviceProp.setOptions (optionTable, ftdiCount);
[+] 	m_deviceProp.setOptions(optionTable, ftdiCount);
[-] SpiTapSession.flipAB ()
[+] SpiTapSession.flipAB()
[-] bool errorcode SpiTapSession.configureSpiIface (uint_t ifaceId)
[+] bool errorcode SpiTapSession.configureSpiIface(uint_t ifaceId)
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] 		sizeof (spiConfig)
[+] 		sizeof(spiConfig)
[-] 	m_device.controlTransfer (
[+] 	m_device.controlTransfer(
[-] bool errorcode SpiTapSession.capture ()
[+] bool errorcode SpiTapSession.capture()
[-] 	stopCapture ();
[+] 	stopCapture();
[-] 	startSession ();
[+] 	startSession();
[-] 	m_device.open ();
[+] 	m_device.open();
[-] 	configureSpiIface (0);
[+] 	configureSpiIface(0);
[-] 	configureSpiIface (1);
[+] 	configureSpiIface(1);
[-] 	if (m_actionTable [ActionId.Flip].m_isChecked)
[+] 	if (m_actionTable[ActionId.Flip].m_isChecked)
[-] 		m_ifaceB.claim (m_device, 0);
[+] 		m_ifaceB.claim(m_device, 0);
[-] 		m_ifaceA.claim (m_device, 1);
[+] 		m_ifaceA.claim(m_device, 1);
[-] 		m_ifaceA.claim (m_device, 0);
[+] 		m_ifaceA.claim(m_device, 0);
[-] 		m_ifaceB.claim (m_device, 1);
[+] 		m_ifaceB.claim(m_device, 1);
[-] 	m_ifaceA.setBufferProperties (m_bufferPropertySet);
[+] 	m_ifaceA.setBufferProperties(m_bufferPropertySet);
[-] 	m_ifaceB.setBufferProperties (m_bufferPropertySet);
[+] 	m_ifaceB.setBufferProperties(m_bufferPropertySet);
[-] 	writeLog (SpiTapLogRecordCode.TapOpened, p, dynamic sizeof (p));
[+] 	writeLog(SpiTapLogRecordCode.TapOpened, p, dynamic sizeof(p));
[-] 	waitEndpointEvents (m_ifaceA);
[+] 	waitEndpointEvents(m_ifaceA);
[-] 	waitEndpointEvents (m_ifaceB);
[+] 	waitEndpointEvents(m_ifaceB);
[-] 	m_stdSessionInfoSet.startSession (m_pluginHost.m_mainThreadScheduler);
[+] 	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	writeLog (
[+] 	writeLog(
[-] 	m_ifaceA.release ();
[+] 	m_ifaceA.release();
[-] 	m_ifaceB.release ();
[+] 	m_ifaceB.release();
[-] 		m_device.close ();
[+] 		m_device.close();
[-] SpiTapSession.stopCapture ()
[+] SpiTapSession.stopCapture()
[-] 	writeLog (SpiTapLogRecordCode.TapClosed);
[+] 	writeLog(SpiTapLogRecordCode.TapClosed);
[-] 	m_stdSessionInfoSet.endSession ();
[+] 	m_stdSessionInfoSet.endSession();
[-] 	m_ifaceA.release ();
[+] 	m_ifaceA.release();
[-] 	m_ifaceB.release ();
[+] 	m_ifaceB.release();
[-] 	m_flushTimer.stop ();
[+] 	m_flushTimer.stop();
[-] 	m_device.close ();
[+] 	m_device.close();
[-] SpiTapSession.waitEndpointEvents (SpiIface* iface)
[+] SpiTapSession.waitEndpointEvents(SpiIface* iface)
[-] 	iface.m_endpoint.wait (
[+] 	iface.m_endpoint.wait(
[-] bool SpiTapSession.flush (bool isForced)
[+] bool SpiTapSession.flush(bool isForced)
[-] 			writeLogTextOnly (m_ifaceA.m_buffer.m_p, m_ifaceB.m_buffer.m_p, commonSize);
[+] 			writeLogTextOnly(m_ifaceA.m_buffer.m_p, m_ifaceB.m_buffer.m_p, commonSize);
[-] 			char const* p = memcat (m_ifaceA.m_buffer.m_p, commonSize, m_ifaceB.m_buffer.m_p, commonSize);
[+] 			char const* p = memcat(m_ifaceA.m_buffer.m_p, commonSize, m_ifaceB.m_buffer.m_p, commonSize);
[-] 			writeLog (log.StdRecordCode.TxRx, p, commonSize * 2);
[+] 			writeLog(log.StdRecordCode.TxRx, p, commonSize * 2);
[-] 		m_ifaceA.m_buffer.remove (0, commonSize);
[+] 		m_ifaceA.m_buffer.remove(0, commonSize);
[-] 		m_ifaceB.m_buffer.remove (0, commonSize);
[+] 		m_ifaceB.m_buffer.remove(0, commonSize);
[-] 			m_flushTimer.startSingleShotTimer (onFlushTimer ~(++m_flushTimerSyncId), m_flushTimeoutProp.m_value);
[+] 			m_flushTimer.startSingleShotTimer(onFlushTimer ~(++m_flushTimerSyncId), m_flushTimeoutProp.m_value);
[-] 			m_flushTimer.stop ();
[+] 			m_flushTimer.stop();
[-] 		writeLog (SpiTapLogRecordCode.TxRxOutOfSync);
[+] 		writeLog(SpiTapLogRecordCode.TxRxOutOfSync);
[-] 		char* p = new char [deltaSize * 2];
[+] 		char* p = new char[deltaSize * 2];
[-] 		memset (p, 0xcc, deltaSize * 2);
[+] 		memset(p, 0xcc, deltaSize * 2);
[-] 			memcpy (p, m_ifaceA.m_buffer.m_p + commonSize, deltaSize);
[+] 			memcpy(p, m_ifaceA.m_buffer.m_p + commonSize, deltaSize);
[-] 			memcpy (p + deltaSize, m_ifaceB.m_buffer.m_p + commonSize, deltaSize);
[+] 			memcpy(p + deltaSize, m_ifaceB.m_buffer.m_p + commonSize, deltaSize);
[-] 		writeLog (log.StdRecordCode.TxRx, p, deltaSize * 2);
[+] 		writeLog(log.StdRecordCode.TxRx, p, deltaSize * 2);
[-] 	m_ifaceA.m_buffer.clear ();
[+] 	m_ifaceA.m_buffer.clear();
[-] 	m_ifaceB.m_buffer.clear ();
[+] 	m_ifaceB.m_buffer.clear();
[-] SpiTapSession.onFlushTimer (uint_t syncId)
[+] SpiTapSession.onFlushTimer(uint_t syncId)
[-] 	flush (true);
[+] 	flush(true);
[-] SpiTapSession.onEndpointEvent (
[+] SpiTapSession.onEndpointEvent(
[-] 		writeLog (log.StdRecordCode.Error, iface.m_endpoint.m_ioError, iface.m_endpoint.m_ioError.m_size);
[+] 		writeLog(log.StdRecordCode.Error, iface.m_endpoint.m_ioError, iface.m_endpoint.m_ioError.m_size);
[-] 		stopCapture ();
[+] 		stopCapture();
[-] 		writeLog (log.StdRecordCode.RxBufferFull);
[+] 		writeLog(log.StdRecordCode.RxBufferFull);
[-] 		size_t result = iface.m_endpoint.read (m_readBuffer.m_p, m_readBuffer.m_size);
[+] 		size_t result = iface.m_endpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
[-] 				iface.m_buffer.append (m_readBuffer.m_p, result);
[+] 				iface.m_buffer.append(m_readBuffer.m_p, result);
[-] 				flush (false);
[+] 				flush(false);
[-] 					writeLogTextOnly (code, m_readBuffer.m_p, result);
[+] 					writeLogTextOnly(code, m_readBuffer.m_p, result);
[-] 					writeLog (code, m_readBuffer.m_p, result);
[+] 					writeLog(code, m_readBuffer.m_p, result);
[-] 	waitEndpointEvents (iface);
[+] 	waitEndpointEvents(iface);
[-] void SpiTapSession.writeLogTextOnly (
[+] void SpiTapSession.writeLogTextOnly(
[-] 		size_t result = try m_textDfa.match (state, p, end - p);
[+] 		size_t result = try m_textDfa.match(state, p, end - p);
[-] 		writeLog (
[+] 		writeLog(
[-] 			state.m_subMatchArray [0].m_text,
[+] 			state.m_subMatchArray[0].m_text,
[-] 			state.m_subMatchArray [0].m_length
[+] 			state.m_subMatchArray[0].m_length
[-] void SpiTapSession.writeLogTextOnly (
[+] void SpiTapSession.writeLogTextOnly(
[-] 		size_t result = try m_textDfa.match (state, rx, end - rx);
[+] 		size_t result = try m_textDfa.match(state, rx, end - rx);
[-] 		char const* cut = memcat (
[+] 		char const* cut = memcat(
[-] 			tx + state.m_subMatchArray [0].m_offset,
[+] 			tx + state.m_subMatchArray[0].m_offset,
[-] 			state.m_subMatchArray [0].m_length,
[+] 			state.m_subMatchArray[0].m_length,
[-] 			state.m_subMatchArray [0].m_text,
[+] 			state.m_subMatchArray[0].m_text,
[-] 			state.m_subMatchArray [0].m_length
[+] 			state.m_subMatchArray[0].m_length
[-] 		writeLog (
[+] 		writeLog(
[-] 			state.m_subMatchArray [0].m_length * 2
[+] 			state.m_subMatchArray[0].m_length * 2
[-] void SpiTapSession.load (doc.Storage* storage)
[+] void SpiTapSession.load(doc.Storage* storage)
[-] 	m_deviceCombo.m_currentIndex  = storage.readInt ("deviceIdx");
[+] 	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
[-] 	m_frequencyProp.m_value = storage.readInt ("frequency", Defaults.Frequency);
[+] 	m_frequencyProp.m_value = storage.readInt("frequency", Defaults.Frequency);
[-] 	m_modeCombo.m_currentIndex = storage.readInt ("mode", Defaults.Mode);
[+] 	m_modeCombo.m_currentIndex = storage.readInt("mode", Defaults.Mode);
[-] 	m_dataBitsProp.m_value = storage.readInt ("dataBits", Defaults.DataBits);  // 8-bits by default
[+] 	m_dataBitsProp.m_value = storage.readInt("dataBits", Defaults.DataBits);  // 8-bits by default
[-] 	m_endiannessProp.m_value = storage.readInt ("endianness", Defaults.Enidanness);
[+] 	m_endiannessProp.m_value = storage.readInt("endianness", Defaults.Enidanness);
[-] 	m_useDualHexViewProp.m_value = storage.readInt ("useDualHexView", Defaults.UseDualHexView);
[+] 	m_useDualHexViewProp.m_value = storage.readInt("useDualHexView", Defaults.UseDualHexView);
[-] 	m_flushTimeoutProp.m_value = storage.readInt ("flushTimeout", Defaults.FlushTimeout);
[+] 	m_flushTimeoutProp.m_value = storage.readInt("flushTimeout", Defaults.FlushTimeout);
[-] 	m_actionTable [ActionId.Flip].m_isChecked = storage.readBool ("flipAB", false);
[+] 	m_actionTable[ActionId.Flip].m_isChecked = storage.readBool("flipAB", false);
[-] 	m_bufferPropertySet.load (storage);
[+] 	m_bufferPropertySet.load(storage);
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] void SpiTapSession.save (doc.Storage* storage)
[+] void SpiTapSession.save(doc.Storage* storage)
[-] 	storage.writeInt ("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[+] 	storage.writeInt("deviceIdx", (int) m_deviceCombo.m_currentIndex);
[-] 	storage.writeInt ("frequency", m_frequencyProp.m_value);
[+] 	storage.writeInt("frequency", m_frequencyProp.m_value);
[-] 	storage.writeInt ("mode", m_modeCombo.m_currentIndex);
[+] 	storage.writeInt("mode", m_modeCombo.m_currentIndex);
[-] 	storage.writeInt ("dataBits", m_dataBitsProp.m_value);
[+] 	storage.writeInt("dataBits", m_dataBitsProp.m_value);
[-] 	storage.writeInt ("endianness", m_endiannessProp.m_value);
[+] 	storage.writeInt("endianness", m_endiannessProp.m_value);
[-] 	storage.writeBool ("useDualHexView", m_useDualHexViewProp.m_value);
[+] 	storage.writeBool("useDualHexView", m_useDualHexViewProp.m_value);
[-] 	storage.writeInt ("flushTimeout", m_flushTimeoutProp.m_value);
[+] 	storage.writeInt("flushTimeout", m_flushTimeoutProp.m_value);
[-] 	storage.writeBool ("flipAB", m_actionTable [ActionId.Flip].m_isChecked);
[+] 	storage.writeBool("flipAB", m_actionTable [ActionId.Flip].m_isChecked);
[-] 	m_bufferPropertySet.save (storage);
[+] 	m_bufferPropertySet.save(storage);
[-] void SpiTapSession.updateProperties ()
[+] void SpiTapSession.updateProperties()
[-] 	m_flipProp.m_value = m_actionTable [ActionId.Flip].m_isChecked;
[+] 	m_flipProp.m_value = m_actionTable[ActionId.Flip].m_isChecked;
[-] bool errorcode SpiTapSession.applyProperties ()
[+] bool errorcode SpiTapSession.applyProperties()
[-] 	m_actionTable [ActionId.Flip].m_isChecked = m_flipProp.m_value;
[+] 	m_actionTable[ActionId.Flip].m_isChecked = m_flipProp.m_value;
[-] 	m_readBuffer.setSize (m_bufferPropertySet.m_readBufferSizeProp.m_value);
[+] 	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
[-] 		writeLog (SpiTapLogRecordCode.FrequencyChanged, &frequency, sizeof (frequency));
[+] 		writeLog(SpiTapLogRecordCode.FrequencyChanged, &frequency, sizeof(frequency));
[-] 		writeLog (SpiTapLogRecordCode.DataBitsChanged, &dataBits, sizeof (dataBits));
[+] 		writeLog(SpiTapLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
[-] 		writeLog (SpiTapLogRecordCode.EndiannessChanged, &endianness, sizeof (endianness));
[+] 		writeLog(SpiTapLogRecordCode.EndiannessChanged, &endianness, sizeof(endianness));
[-] 	m_ifaceA.setBufferProperties (m_bufferPropertySet);
[+] 	m_ifaceA.setBufferProperties(m_bufferPropertySet);
[-] 	m_ifaceB.setBufferProperties (m_bufferPropertySet);
[+] 	m_ifaceB.setBufferProperties(m_bufferPropertySet);
[-] 	configureSpiIface (0);
[+] 	configureSpiIface(0);
[-] 	configureSpiIface (1);
[+] 	configureSpiIface(1);
[-] 		flush (true);
[+] 		flush(true);
[-] 		m_flushTimer.stop ();
[+] 		m_flushTimer.stop();
[-] void SpiTapSession.restoreDefaultProperties ()
[+] void SpiTapSession.restoreDefaultProperties()
[-] 	m_bufferPropertySet.restoreDefaults ();
[+] 	m_bufferPropertySet.restoreDefaults();
[-] SpiTapSession.onModeChanged ()
[+] SpiTapSession.onModeChanged()
[-] 	configureSpiIface (0);
[+] 	configureSpiIface(0);
[-] 	configureSpiIface (1);
[+] 	configureSpiIface(1);
[-] 	writeLog (SpiTapLogRecordCode.ModeChanged, &value, sizeof (value));
[+] 	writeLog(SpiTapLogRecordCode.ModeChanged, &value, sizeof(value));
[-] 	writeLogLastError (log.StdRecordCode.Error);
[+] 	writeLogLastError(log.StdRecordCode.Error);
[-] 	m_actionTable [ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[+] 	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
[-] 	m_actionTable [ActionId.Capture].m_icon = m_iconTable [m_state ? IconId.StopCapture : IconId.Capture];
[+] 	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.StopCapture : IconId.Capture];
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test01.jnc
----------------------
[-] 	bool errorcode foo (Point const* point)
[+] 	bool errorcode foo(Point const* point)
[-] 		printf ("foo ()\n");
[+] 		printf("foo ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("hello world!\n");
[+] 	printf("hello world!\n");
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
[-] 	try c.foo (&point);
[+] 	try c.foo(&point);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test02.jnc
----------------------
[-] bool errorcode foo (int x)
[+] bool errorcode foo(int x)
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] int errorcode baz (int x)
[+] int errorcode baz(int x)
[-] 	printf ("baz ()\n");
[+] 	printf("baz ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo (10);
[+] 	foo(10);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test03.jnc
----------------------
[-] multicast g_onMouseMove (
[+] multicast g_onMouseMove(
[-] 	onevent (bindingof (g_a)) ()
[+] 	onevent(bindingof(g_a)) ()
[-] 		printf ("g_a changed to %d\n", g_a);
[+] 		printf("g_a changed to %d\n", g_a);
[-] 	onevent g_onMouseMove (
[+] 	onevent g_onMouseMove(
[-] 		printf ("g_reactor.g_onMouseMove (%d, %d)\n", x, y);
[+] 		printf("g_reactor.g_onMouseMove (%d, %d)\n", x, y);
[-] foo ()
[+] foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] int main ()
[+] int main()
[-] 	g_reactor.start ();
[+] 	g_reactor.start();
[-] 	g_onMouseMove (10, 20);
[+] 	g_onMouseMove(10, 20);
[-] 	printf ("g_c = %d\n", g_c);
[+] 	printf("g_c = %d\n", g_c);
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test04.jnc
----------------------
[-] char g_a [Color.Count];
[+] char g_a[Color.Count];
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test05.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		printf ("yuppie!\n");
[+] 		printf("yuppie!\n");
[-] 		printf ("oh-oh!\n");
[+] 		printf("oh-oh!\n");
----------------------
27/02/2019 18:02:28 - C:\Projects\repos\ioninja\jancy\test\jnc\test06.jnc
----------------------
[-] alignment (2);
[+] alignment(2);
[-] 		uint8_t m_ip8 [4];
[+] 		uint8_t m_ip8[4];
[-] 		bigendian uint16_t m_ip16 [8];
[+] 		bigendian uint16_t m_ip16[8];
[-] 		uint8_t m_ip8 [16];
[+] 		uint8_t m_ip8[16];
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf (
[+] 	printf(
[-] 		address.m_ip4.m_ip8 [0],
[+] 		address.m_ip4.m_ip8[0],
[-] 		address.m_ip4.m_ip8 [1],
[+] 		address.m_ip4.m_ip8[1],
[-] 		address.m_ip4.m_ip8 [2],
[+] 		address.m_ip4.m_ip8[2],
[-] 		address.m_ip4.m_ip8 [3],
[+] 		address.m_ip4.m_ip8[3],
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test07.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	char const* p = std.format ("offset = %d\n", offsetof (Line.m_b.m_y));
[+] 	char const* p = std.format("offset = %d\n", offsetof (Line.m_b.m_y));
[-] 	printf ("s = %s\n", p);
[+] 	printf("s = %s\n", p);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test08.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test09.jnc
----------------------
[-] bool foo ()
[+] bool foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] bool bar ()
[+] bool bar()
[-] 	printf ("bar ()\n");
[+] 	printf("bar ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	if (foo () && bar ())
[+] 	if (foo() && bar())
[-] 		printf ("&& true\n");
[+] 		printf("&& true\n");
[-] 		printf ("&& false\n");
[+] 		printf("&& false\n");
[-] 	if (foo () || bar ())
[+] 	if (foo() || bar())
[-] 		printf ("|| true\n");
[+] 		printf("|| true\n");
[-] 		printf ("|| false\n");
[+] 		printf("|| false\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test10.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	char a [] = "abc";
[+] 	char a[] = "abc";
[-] 	char b [] = "defghi";
[+] 	char b[] = "defghi";
[-] 	void* c = memcat (a, 3, b, 7);
[+] 	void* c = memcat(a, 3, b, 7);
[-] 	printf ("memcat = %s\n", c);
[+] 	printf("memcat = %s\n", c);
[-] 	char d [4];
[+] 	char d[4];
[-] 	memcpy (d, a, 4);
[+] 	memcpy(d, a, 4);
[-] 	printf ("memcpy = %s\n", d);
[+] 	printf("memcpy = %s\n", d);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test100.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("compiling\n");	
[+] 	printf("compiling\n");
[-] 	dfa.incrementalCompile (r"\x02[^\r]+\r");
[+] 	dfa.incrementalCompile(r"\x02[^\r]+\r");
[-] 	dfa.incrementalCompile (r"[a-z]+");
[+] 	dfa.incrementalCompile(r"[a-z]+");
[-] 	dfa.incrementalCompile (r"[0-9]+");
[+] 	dfa.incrementalCompile(r"[0-9]+");
[-] 	dfa.incrementalCompile (r".");
[+] 	dfa.incrementalCompile(r".");
[-] 	dfa.finalize ();
[+] 	dfa.finalize();
[-] 	printf ("matching\n");		
[+] 	printf("matching\n");
[-] 	result = try dfa.match (state, "\x02ab123cdef45678\xff");
[+] 	result = try dfa.match(state, "\x02ab123cdef45678\xff");
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	result = try dfa.match (state, null, 0);
[+] 	result = try dfa.match(state, null, 0);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	printf ($"error: $!\n");
[+] 	printf($"error: $!\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test101.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("compiling\n");	
[+] 	printf("compiling\n");
[-] 	dfa.incrementalCompile (r"[0-9]+");
[+] 	dfa.incrementalCompile(r"[0-9]+");
[-] 	dfa.incrementalCompile (r".");
[+] 	dfa.incrementalCompile(r".");
[-] 	dfa.finalize ();
[+] 	dfa.finalize();
[-] 	printf ("matching\n");		
[+] 	printf("matching\n");
[-] 	result = try dfa.match (state, "\x2e123456\x2e");
[+] 	result = try dfa.match(state, "\x2e123456\x2e");
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	assert (result == 1 && state.m_consumedLength == 1);
[+] 	assert(result == 1 && state.m_consumedLength == 1);
[-] 	result = try dfa.match (state, "123456\x2e");
[+] 	result = try dfa.match(state, "123456\x2e");
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	assert (result == 0 && state.m_consumedLength == 7);
[+] 	assert(result == 0 && state.m_consumedLength == 7);
[-] 	result = try dfa.match (state, null);
[+] 	result = try dfa.match(state, null);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	assert (result == 1 && state.m_consumedLength == 0);
[+] 	assert(result == 1 && state.m_consumedLength == 0);
[-] 	result = try dfa.match (state, null);
[+] 	result = try dfa.match(state, null);
[-] 	printf ("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[+] 	printf("regex result: %d, consumed length: %d, match offset: %d, match length: %d, match: %s\n", result, state.m_consumedLength, state.m_match.m_offset, state.m_match.m_length, state.m_match.m_text);
[-] 	assert (result == -1 && state.m_consumedLength == 0);
[+] 	assert(result == -1 && state.m_consumedLength == 0);
[-] 	printf ($"error: $!\n");
[+] 	printf($"error: $!\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test102.jnc
----------------------
[-] 	baz ();
[+] 	baz();
[-] C2.baz ()
[+] C2.baz()
[-] 	c.bar ();
[+] 	c.bar();
[-] int main ()
[+] int main()
[-] 	printf ("main\n");	
[+] 	printf("main\n");
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.bar ();
[+] 	c.bar();
[-] 	c2.baz ();
[+] 	c2.baz();
[-] 	bar ();
[+] 	bar();
[-] 	foo ()
[+] 	foo()
[-] 		printf ("C.foo (%p)\n", this);
[+] 		printf("C.foo (%p)\n", this);
[-] E.bar ()
[+] E.bar()
[-] 	printf ("E.bar (%p)\n", this);
[+] 	printf("E.bar (%p)\n", this);
[-] 	foo ();
[+] 	foo();
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test103.jnc
----------------------
[-] int main ()
[+] int main()
[-] 		a.append (s);
[+] 		a.append(s);
[-] 		S s = a [i];
[+] 		S s = a[i];
[-] 		printf ("s = { %lld, %lld, %lld }\n", s.m_a, s.m_b, s.m_c);
[+] 		printf("s = { %lld, %lld, %lld }\n", s.m_a, s.m_b, s.m_c);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test104.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test105.jnc
----------------------
[-] foo (io.Protocol proto, io.SocketAddress const* a)
[+] foo(io.Protocol proto, io.SocketAddress const* a)
[-] 	printf ("foo: address: %s\n", a.getString ());
[+] 	printf("foo: address: %s\n", a.getString ());
[-] 	std.setErrno (5);
[+] 	std.setErrno(5);
[-] openSocket ()
[+] openSocket()
[-] 	printf ("openSocket - pre foo: address: %s\n", address.getString ());
[+] 	printf("openSocket - pre foo: address: %s\n", address.getString ());
[-] 	foo (io.Protocol.Udp, &address);
[+] 	foo(io.Protocol.Udp, &address);
[-] /*	m_socket.open (io.Protocol.Udp, &address);
[+] /*	m_socket.open(io.Protocol.Udp, &address);
[-] /*	printf ("openSocket - 5\n");
[+] /*	printf("openSocket - 5\n");
[-] 	printf ("openSocket - 6\n");
[+] 	printf("openSocket - 6\n");
[-] 	writeLog (UdpRecordCode.Open, &address, sizeof (address));
[+] 	writeLog(UdpRecordCode.Open, &address, sizeof(address));
[-] 	printf ("openSocket - 7\n");
[+] 	printf("openSocket - 7\n");
[-] 	waitSocketEvents (); */
[+] 	waitSocketEvents(); */
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	printf ("openSocket - catch: address: %s, error: %s\n", address.getString (), error.m_description);
[+] 	printf("openSocket - catch: address: %s, error: %s\n", address.getString (), error.m_description);
[-] foo ()
[+] foo()
[-] int main ()
[+] int main()
[-] 	openSocket ();
[+] 	openSocket();
[-] 	foo ();
[+] 	foo();
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test106.jnc
----------------------
[-] foo ()
[+] foo()
[-] int main ()
[+] int main()
[-] 	printf ("f.m_value = %d\n", f.m_value);
[+] 	printf("f.m_value = %d\n", f.m_value);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test107.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf (
[+] 	printf(
[-] 		printf ("windows\n");
[+] 		printf("windows\n");
[-] 		printf ("non-windows\n");
[+] 		printf("non-windows\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test108.jnc
----------------------
[-] 	foo ()
[+] 	foo()
[-] 	bar ()
[+] 	bar()
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test109.jnc
----------------------
[-] 	uint8_t m_dstAddress [6];
[+] 	uint8_t m_dstAddress[6];
[-] 	uint8_t m_srcAddress [6];
[+] 	uint8_t m_srcAddress[6];
[-] int main ()
[+] int main()
[-] 	char buf [] = "123456123456" 0x"08 06";
[+] 	char buf[] = "123456123456" 0x"08 06";
[-] 	printf ("*** all should print 0x0806\n");
[+] 	printf("*** all should print 0x0806\n");
[-] 	printf ("hdr.m_type = %04x\n", hdr.m_type);
[+] 	printf("hdr.m_type = %04x\n", hdr.m_type);
[-] 	printf ("a = %04x\n", a);
[+] 	printf("a = %04x\n", a);
[-] 	printf ("b = %04x\n", b);
[+] 	printf("b = %04x\n", b);
[-] 	printf ("c = %04x\n", c);
[+] 	printf("c = %04x\n", c);
[-] 	printf ("d = %04x\n", d);
[+] 	printf("d = %04x\n", d);
[-] 	printf ("e = %04x\n", e);
[+] 	printf("e = %04x\n", e);
[-] 	printf ("f = %04x\n", f);
[+] 	printf("f = %04x\n", f);
[-] 	printf ("g = %04x\n", g);
[+] 	printf("g = %04x\n", g);
[-] 	printf ("h = %04x\n", h);
[+] 	printf("h = %04x\n", h);
[-] 		printf ("ARP\n");
[+] 		printf("ARP\n");
[-] 		printf ("NOT ARP\n");
[+] 		printf("NOT ARP\n");
[-] 		assert (false);
[+] 		assert(false);
[-] 		printf ("ARP\n");
[+] 		printf("ARP\n");
[-] 		printf ("NOT ARP\n");
[+] 		printf("NOT ARP\n");
[-] 		assert (false);
[+] 		assert(false);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test11.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	dynamic (XxxErrorEventParams const*) params;
[+] 	dynamic(XxxErrorEventParams const*) params;
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test110.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	static uchar_t ipTable [] [4] =
[+] 	static uchar_t ipTable[] [4] =
[-] 	for (size_t i = 0; i < countof (ipTable); i++)
[+] 	for (size_t i = 0; i < countof(ipTable); i++)
[-] 		const uchar_t* p = ipTable [i];
[+] 		const uchar_t* p = ipTable[i];
[-] 		printf (
[+] 		printf(
[-] 			p [0], p [1], p [2], p [3]
[+] 			p[0], p[1], p[2], p[3]
[-] 	static uchar_t macTable [] [6] =
[+] 	static uchar_t macTable[] [6] =
[-] 	for (size_t i = 0; i < countof (macTable); i++)
[+] 	for (size_t i = 0; i < countof(macTable); i++)
[-] 		const uchar_t* p = macTable [i];
[+] 		const uchar_t* p = macTable[i];
[-] 		printf (
[+] 		printf(
[-] 			p [0], p [1], p [2], p [3], p [4], p [5]
[+] 			p[0], p[1], p[2], p[3], p[4], p[5]
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test111.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	std.setErrno (2);
[+] 	std.setErrno(2);
[-] 	std.Error const* error = std.getLastError ();
[+] 	std.Error const* error = std.getLastError();
[-] 	printf ("error: %s\n", error.m_description);
[+] 	printf("error: %s\n", error.m_description);
[-] 		printf ("error.m_guid == std.g_errnoGuid\n");
[+] 		printf("error.m_guid == std.g_errnoGuid\n");
[-] 		printf ("error.m_guid != std.g_errnoGuid\n");
[+] 		printf("error.m_guid != std.g_errnoGuid\n");
[-] 		printf ("guid1 == std.g_errnoGuid\n");
[+] 		printf("guid1 == std.g_errnoGuid\n");
[-] 		printf ("guid1 != std.g_errnoGuid\n");
[+] 		printf("guid1 != std.g_errnoGuid\n");
[-] 		printf ("guid2 == std.g_winErrorGuid\n");
[+] 		printf("guid2 == std.g_winErrorGuid\n");
[-] 		printf ("guid3 != std.g_winErrorGuid\n");
[+] 		printf("guid3 != std.g_winErrorGuid\n");
[-] 		printf ("guid3 == std.g_ntStatusGuid\n");
[+] 		printf("guid3 == std.g_ntStatusGuid\n");
[-] 		printf ("guid3 != std.g_ntStatusGuid\n");
[+] 		printf("guid3 != std.g_ntStatusGuid\n");
[-] 		printf ("guid1 == std.g_winErrorGuid\n");
[+] 		printf("guid1 == std.g_winErrorGuid\n");
[-] 		printf ("guid1 != std.g_winErrorGuid\n");
[+] 		printf("guid1 != std.g_winErrorGuid\n");
[-] 		printf ("guid1 == std.g_ntStatusGuid\n");
[+] 		printf("guid1 == std.g_ntStatusGuid\n");
[-] 		printf ("guid1 != std.g_ntStatusGuid\n");
[+] 		printf("guid1 != std.g_ntStatusGuid\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test112.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	char a [] = 0x"""
[+] 	char a[] = 0x"""
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test113.jnc
----------------------
[-] g_a.set (int x)
[+] g_a.set(int x)
[-] 	printf ("g_a.set (%d)\n", x);
[+] 	printf("g_a.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] g_b.set (int x)
[+] g_b.set(int x)
[-] 	printf ("g_b.set (%d)\n", x);
[+] 	printf("g_b.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] event g_onClicked (
[+] event g_onClicked(
[-] 	onevent g_onClicked (
[+] 	onevent g_onClicked(
[-] 		printf ("g_onClicked (%d, %d)\n", x, y);
[+] 		printf("g_onClicked (%d, %d)\n", x, y);
[-] 	event m_onClicked (
[+] 	event m_onClicked(
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C.construct (this: %p)\n", this);
[+] 		printf("C.construct (this: %p)\n", this);
[-] 		printf ("C.m_reactor (this: %p)\n", this);
[+] 		printf("C.m_reactor (this: %p)\n", this);
[-] 		onevent m_onClicked (
[+] 		onevent m_onClicked(
[-] 			printf ("m_onClicked (%d, %d)\n", x, y);
[+] 			printf("m_onClicked (%d, %d)\n", x, y);
[-] 	fireOnClickedEvent (
[+] 	fireOnClickedEvent(
[-] 		m_onClicked (x, y);
[+] 		m_onClicked(x, y);
[-] C.m_a.set (int x)
[+] C.m_a.set(int x)
[-] 	printf ("C.m_a.set (%d)\n", x);
[+] 	printf("C.m_a.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] C.m_b.set (int x)
[+] C.m_b.set(int x)
[-] 	printf ("C.m_b.set (%d)\n", x);
[+] 	printf("C.m_b.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	g_reactor.start ();
[+] 	g_reactor.start();
[-] 	g_onClicked (100, 200);
[+] 	g_onClicked(100, 200);
[-] 	g_reactor.stop ();
[+] 	g_reactor.stop();
[-] 	c.m_reactor.start ();
[+] 	c.m_reactor.start();
[-] 	c.fireOnClickedEvent (1000, 2000);
[+] 	c.fireOnClickedEvent(1000, 2000);
[-] 	c.m_reactor.stop ();
[+] 	c.m_reactor.stop();
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test114.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test115.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	std.Guid guid ("{d74419a1-789c-4d9a-8d92-bd44ee19c971}");
[+] 	std.Guid guid("{d74419a1-789c-4d9a-8d92-bd44ee19c971}");
[-] 	printf ("guid: %s\n", guid.getString ());
[+] 	printf("guid: %s\n", guid.getString ());
[-] 	printf ("guid: %s\n", guid2.getString ());
[+] 	printf("guid: %s\n", guid2.getString ());
[-] 	printf ("guid: %s\n", guid.getString (std.GuidStringFlags.CurlyBraces | std.GuidStringFlags.UpperCase));
[+] 	printf("guid: %s\n", guid.getString (std.GuidStringFlags.CurlyBraces | std.GuidStringFlags.UpperCase));
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test116.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("A.construct (%p)\n", this);
[+] 		printf("A.construct (%p)\n", this);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("A.destruct (%p)\n", this);
[+] 		printf("A.destruct (%p)\n", this);
[-] 	construct ()
[+] 	construct()
[-] 		printf ("B.construct (%p)\n", this);
[+] 		printf("B.construct (%p)\n", this);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("B.destruct (%p)\n", this);
[+] 		printf("B.destruct (%p)\n", this);
[-] int main ()
[+] int main()
[-] 	printf ("file: " __FILE__ "\n");
[+] 	printf("file: " __FILE__ "\n");
[-] 	printf ("dir: " __DIR__ "\n");
[+] 	printf("dir: " __DIR__ "\n");
[-] 	printf ("static B b\n");
[+] 	printf("static B b\n");
[-] 	printf ("B b\n");
[+] 	printf("B b\n");
[-] destruct ()
[+] destruct()
[-] 	printf ("module.destruct: g_counter: %d\n", g_objectCount);
[+] 	printf("module.destruct: g_counter: %d\n", g_objectCount);
[-] 	assert (g_objectCount == 0);
[+] 	assert(g_objectCount == 0);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test117.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C.construct (%p)\n", this);
[+] 		printf("C.construct (%p)\n", this);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C.destruct (%p)\n", this);
[+] 		printf("C.destruct (%p)\n", this);
[-] foo ()
[+] foo()
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo ();
[+] 	foo();
[-] construct ()
[+] construct()
[-] 	printf ("module.construct ()\n");
[+] 	printf("module.construct ()\n");
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test118.jnc
----------------------
[-] scanStream (
[+] scanStream(
[-] 		reswitch (state, p, end - p)
[+] 		reswitch(state, p, end - p)
[-] 			printf (
[+] 			printf(
[-] 			printf (
[+] 			printf(
[-] 	printf ("final: offset: %d state.m_currentOffset: %d state.m_consumedLength: %d\n", p - p0, state.m_currentOffset, state.m_consumedLength);
[+] 	printf("final: offset: %d state.m_currentOffset: %d state.m_consumedLength: %d\n", p - p0, state.m_currentOffset, state.m_consumedLength);
[-] int main ()
[+] int main()
[-] 	jnc.RegexState state (true);
[+] 	jnc.RegexState state(true);
[-] 	scanStream (state, "abc123d", 7);
[+] 	scanStream(state, "abc123d", 7);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test119.jnc
----------------------
[-] event g_event ();
[+] event g_event();
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C.construct: this: %p\n", this);
[+] 		printf("C.construct: this: %p\n", this);
[-] 	int foo ()
[+] 	int foo()
[-] 		printf ("C.foo: this: %p\n", this);
[+] 		printf("C.foo: this: %p\n", this);
[-] 		assert (this == g_c);
[+] 		assert(this == g_c);
[-] 	m_x = foo ();
[+] 	m_x = foo();
[-] 	onevent g_event ()
[+] 	onevent g_event()
[-] 		printf ("C.m_reactor.onevent: this: %p\n", this);
[+] 		printf("C.m_reactor.onevent: this: %p\n", this);
[-] 		assert (this == g_c);
[+] 		assert(this == g_c);
[-] int main ()
[+] int main()
[-] 	c.m_reactor.start ();
[+] 	c.m_reactor.start();
[-] 	g_event ();
[+] 	g_event();
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test12.jnc
----------------------
[-] typedef char EthernetAddress [6];
[+] typedef char EthernetAddress[6];
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	assert (x == 6);
[+] 	assert(x == 6);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test120.jnc
----------------------
[-] int async asyncBar (int x, int y)
[+] int async asyncBar(int x, int y)
[-] 	printf ("+bar (%d, %d): tid: %p\n", x, y, sys.getCurrentThreadId ());
[+] 	printf("+bar (%d, %d): tid: %p\n", x, y, sys.getCurrentThreadId ());
[-] 	printf ("s: %s\n", s);
[+] 	printf("s: %s\n", s);
[-] 	timer.startSingleShotTimer (promise.complete, 1000);
[+] 	timer.startSingleShotTimer(promise.complete, 1000);
[-] 	await promise.asyncWait ();
[+] 	await promise.asyncWait();
[-] 	printf ("-bar (%d, %d): tid: %p, s: %s\n", x, y, sys.getCurrentThreadId (), s);
[+] 	printf("-bar (%d, %d): tid: %p, s: %s\n", x, y, sys.getCurrentThreadId (), s);
[-] int async asyncFoo (int x, int y) 
[+] int async asyncFoo(int x, int y)
[-] 	printf ("+foo (%d, %d): tid: %p\n", x, y, sys.getCurrentThreadId ());
[+] 	printf("+foo (%d, %d): tid: %p\n", x, y, sys.getCurrentThreadId ());
[-] 	printf ("s: %s\n", s);
[+] 	printf("s: %s\n", s);
[-] 	int result1 = await asyncBar (3, 4);
[+] 	int result1 = await asyncBar(3, 4);
[-] 	printf ("~foo (%d, %d): tid: %p, result: %d, s: %s\n", x, y, sys.getCurrentThreadId (), result1, s);
[+] 	printf("~foo (%d, %d): tid: %p, result: %d, s: %s\n", x, y, sys.getCurrentThreadId (), result1, s);
[-] 	int result2 = await asyncBar (5, 6);
[+] 	int result2 = await asyncBar(5, 6);
[-] 	printf ("-foo (%d, %d): tid: %p, result: %d, prev: %d, s: %s\n", x, y, sys.getCurrentThreadId (), result2, result1, s);
[+] 	printf("-foo (%d, %d): tid: %p, result: %d, prev: %d, s: %s\n", x, y, sys.getCurrentThreadId (), result2, result1, s);
[-] int main ()
[+] int main()
[-] 	printf ("+main: tid: %p\n", sys.getCurrentThreadId ());
[+] 	printf("+main: tid: %p\n", sys.getCurrentThreadId ());
[-] 	jnc.Promise* promise = asyncFoo (1, 2);
[+] 	jnc.Promise* promise = asyncFoo(1, 2);
[-] 	int result = promise.blockingWait ();
[+] 	int result = promise.blockingWait();
[-] 	assert (result == 21);
[+] 	assert(result == 21);
[-] 	printf ("-main: tid: %p, result: %d\n", sys.getCurrentThreadId (), result);
[+] 	printf("-main: tid: %p, result: %d\n", sys.getCurrentThreadId (), result);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test13.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test14.jnc
----------------------
[-] 	foo (
[+] 	foo(
[-] 		int y = bar ()
[+] 		int y = bar()
[-] 		printf ("C1.foo (%d, %d)\n", x, y);
[+] 		printf("C1.foo (%d, %d)\n", x, y);
[-] 	int bar ()
[+] 	int bar()
[-] 	event m_classOnChanged ();
[+] 	event m_classOnChanged();
[-] 		int get ()
[+] 		int get()
[-] 		set (int x)
[+] 		set(int x)
[-] 			m_classOnChanged ();
[+] 			m_classOnChanged();
[-] 		event* getbinding () ()
[+] 		event* getbinding() ()
[-] foo ()
[+] foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] int main ()
[+] int main()
[-] 	c1.foo (1);
[+] 	c1.foo(1);
[-] 	printf ("m_classValue = %d\n", c2.m_classValue);
[+] 	printf("m_classValue = %d\n", c2.m_classValue);
----------------------
27/02/2019 18:02:29 - C:\Projects\repos\ioninja\jancy\test\jnc\test15.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("allocating...\n");
[+] 	printf("allocating...\n");
[-] 	int* x = new int [count];
[+] 	int* x = new int[count];
[-] 	printf ("assigning [0]...\n");
[+] 	printf("assigning [0]...\n");
[-] 	printf ("assigning [1]...\n");
[+] 	printf("assigning [1]...\n");
[-] 	printf ("done\n");
[+] 	printf("done\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test16.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test17.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("s = 0x%02x\n", *(unsigned char*) &s);
[+] 	printf("s = 0x%02x\n", *(unsigned char*) &s);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test18.jnc
----------------------
[-] 	virtual foo ()
[+] 	virtual foo()
[-] 		printf ("C1.foo ()\n");
[+] 		printf("C1.foo ()\n");
[-] 	override foo ()
[+] 	override foo()
[-] 		basetype1.foo ();
[+] 		basetype1.foo();
[-] 		printf ("C2.foo ()\n");
[+] 		printf("C2.foo ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	c.foo ();
[+] 	c.foo();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test19.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test20.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("x = %d\n", x);
[+] 	printf("x = %d\n", x);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test21.jnc
----------------------
[-] 	override schedule (function* f ())
[+] 	override schedule(function* f())
[-] 		printf ("MyScheduler.schedule ()\n");
[+] 		printf("MyScheduler.schedule ()\n");
[-] 		f ();
[+] 		f();
[-] foo (int x)
[+] foo(int x)
[-] 	printf ("foo (%d)\n", x);
[+] 	printf("foo (%d)\n", x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test22.jnc
----------------------
[-] write (
[+] write(
[-] 	printf ("write (%d, %d)\n", recordCode, foldFlags);
[+] 	printf("write (%d, %d)\n", recordCode, foldFlags);
[-] write (
[+] write(
[-] 	printf ("write (%d, %d, %d, %d)\n", recordCode, p, size, foldFlags);
[+] 	printf("write (%d, %d, %d, %d)\n", recordCode, p, size, foldFlags);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	write (10);
[+] 	write(10);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test23.jnc
----------------------
[-] main ()
[+] main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	c.m_MyAutoEv.start ();
[+] 	c.m_MyAutoEv.start();
[-] 	printf ("c.m_Int = %d\n", c.m_Int);
[+] 	printf("c.m_Int = %d\n", c.m_Int);
[-] foo ()
[+] foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] bar ()
[+] bar()
[-] 	printf ("bar ()\n");
[+] 	printf("bar ()\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test24.jnc
----------------------
[-] Hui* foo ()
[+] Hui* foo()
[-] Hui* bar ()
[+] Hui* bar()
[-] 	return foo ();
[+] 	return foo();
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test25.jnc
----------------------
[-] 	construct (
[+] 	construct(
[-] 		printf ("OpaqueTest.construct (%d, %d)\n", x, y);
[+] 		printf("OpaqueTest.construct (%d, %d)\n", x, y);
[-] 	void foo ()
[+] 	void foo()
[-] 		printf ("OpaqueTest.foo ()\n");
[+] 		printf("OpaqueTest.foo ()\n");
[-] 	void bar ()
[+] 	void bar()
[-] 		printf ("OpaqueTest.bar ()\n");
[+] 		printf("OpaqueTest.bar ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	OpaqueTest* p = new OpaqueTest (100, 200);
[+] 	OpaqueTest* p = new OpaqueTest(100, 200);
[-] 	p.foo ();
[+] 	p.foo();
[-] 	p.bar ();
[+] 	p.bar();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test26.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test27.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("p = %s\n", p);
[+] 	printf("p = %s\n", p);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test28.jnc
----------------------
[-] unsigned int errorcode foo (int x)
[+] unsigned int errorcode foo(int x)
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo (-1);
[+] 	foo(-1);
[-] 	printf ("exception!\n");
[+] 	printf("exception!\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test29.jnc
----------------------
[-] 	static int m_table [] =
[+] 	static int m_table[] =
[-] 	static construct ()
[+] 	static construct()
[-] 		printf ("C1.static construct ()\n");
[+] 		printf("C1.static construct ()\n");
[-] 	preconstruct ()
[+] 	preconstruct()
[-] 		printf ("C1.preconstruct ()\n");
[+] 		printf("C1.preconstruct ()\n");
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	foo ()
[+] 	foo()
[-] 		printf ("m_table [0] = %d\n", m_table [0]);
[+] 		printf("m_table [0] = %d\n", m_table [0]);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	c.foo ();
[+] 	c.foo();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test30.jnc
----------------------
[-] /*	OpaqueTest* operator new (
[+] /*	OpaqueTest* operator new(
[-] 	construct (int x, int y)
[+] 	construct(int x, int y)
[-] 	foo ()
[+] 	foo()
[-] 		printf ("C1.foo () { m_x = %d, m_y = %d }\n", m_x, m_y);
[+] 		printf("C1.foo () { m_x = %d, m_y = %d }\n", m_x, m_y);
[-] 	Point thiscall bar (
[+] 	Point thiscall bar(
[-] 		printf ("C1.bar (%d, %d) { m_x = %d, m_y = %d }\n", x, y, m_x, m_y);
[+] 		printf("C1.bar (%d, %d) { m_x = %d, m_y = %d }\n", x, y, m_x, m_y);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	OpaqueTest* a = new OpaqueTest (1, 2);
[+] 	OpaqueTest* a = new OpaqueTest(1, 2);
[-] 	a.foo ();
[+] 	a.foo();
[-] 	Point point = a.bar (10, 20);
[+] 	Point point = a.bar(10, 20);
[-] 	printf (
[+] 	printf(
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test31.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test32.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 	construct (int x)
[+] 	construct(int x)
[-] 	construct (double y)
[+] 	construct(double y)
[-] 	foo ()
[+] 	foo()
[-] 	foo (int x)
[+] 	foo(int x)
[-] 	foo (double y)
[+] 	foo(double y)
[-] 	construct ()
[+] 	construct()
[-] 	construct (int x)
[+] 	construct(int x)
[-] 	construct (double y)
[+] 	construct(double y)
[-] 	foo ()
[+] 	foo()
[-] 	foo (int x)
[+] 	foo(int x)
[-] 	foo (double y)
[+] 	foo(double y)
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	TestClass t2 construct (5);
[+] 	TestClass t2 construct(5);
[-] 	TestClass t3 construct (2.71828);
[+] 	TestClass t3 construct(2.71828);
[-] 	t1.foo ();
[+] 	t1.foo();
[-] 	t1.foo (10);
[+] 	t1.foo(10);
[-] 	t1.foo (3.14);
[+] 	t1.foo(3.14);
[-] 	TestStruct s2 construct (5);
[+] 	TestStruct s2 construct(5);
[-] 	TestStruct s3 construct (2.71828);
[+] 	TestStruct s3 construct(2.71828);
[-] 	s1.foo ();
[+] 	s1.foo();
[-] 	s1.foo (10);
[+] 	s1.foo(10);
[-] 	s1.foo (3.14);
[+] 	s1.foo(3.14);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test33.jnc
----------------------
[-] 	construct (int x)
[+] 	construct(int x)
[-] 		printf ("A.construct (%d)\n", x);
[+] 		printf("A.construct (%d)\n", x);
[-] foo (A a)
[+] foo(A a)
[-] 	printf ("foo (A {%d})\n", a.m_x);
[+] 	printf("foo (A {%d})\n", a.m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test34.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	printf ("s = '%s'\n", s);
[+] 	printf("s = '%s'\n", s);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test35.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	char const* string = stringBuilder.detachString ();
[+] 	char const* string = stringBuilder.detachString();
[-] 	printf ("string = '%s'\n", string);
[+] 	printf("string = '%s'\n", string);
[-] 	assert (streq (string, "hui govno i muravei!"));
[+] 	assert(streq(string, "hui govno i muravei!"));
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test37.jnc
----------------------
[-] foo (Point* point)
[+] foo(Point* point)
[-] 	printf ("foo ({%d, %d})\n", point.m_x, point.m_y);
[+] 	printf("foo ({%d, %d})\n", point.m_x, point.m_y);
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	foo (point);
[+] 	foo(point);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test38.jnc
----------------------
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test39.jnc
----------------------
[-] foo (void const* p)
[+] foo(void const* p)
[-] 	B const* b = dynamic (B const*) p;
[+] 	B const* b = dynamic(B const*) p;
[-] 		printf ("p is NOT B\n");
[+] 		printf("p is NOT B\n");
[-] 	size_t size = dynamic sizeof (b);
[+] 	size_t size = dynamic sizeof(b);
[-] 	size_t count = dynamic countof (b);
[+] 	size_t count = dynamic countof(b);
[-] 	printf ("p is B: sizeof = %d, countof = %d\n", size, count);
[+] 	printf("p is B: sizeof = %d, countof = %d\n", size, count);
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	B b [5];
[+] 	B b[5];
[-] 	foo (a);
[+] 	foo(a);
[-] 	foo (&b [3]);
[+] 	foo(&b[3]);
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test40.jnc
----------------------
[-] bool errorcode bar ()
[+] bool errorcode bar()
[-] 	printf ("bar ()\n");
[+] 	printf("bar ()\n");
[-] foo ()
[+] foo()
[-] 		bar ();
[+] 		bar();
[-] 		bar ();
[+] 		bar();
[-] 		bar ();
[+] 		bar();
[-] 		printf ("finally\n");
[+] 		printf("finally\n");
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	foo ();
[+] 	foo();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test41.jnc
----------------------
[-] foo ()
[+] foo()
[-] 	printf ("ns1.foo ()\n");
[+] 	printf("ns1.foo ()\n");
[-] foo ()
[+] foo()
[-] 	printf ("ns2.foo ()\n");
[+] 	printf("ns2.foo ()\n");
[-] bar ()
[+] bar()
[-] 	foo ();
[+] 	foo();
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	foo ();
[+] 	foo();
[-] 	bar ();
[+] 	bar();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test42.jnc
----------------------
[-] 	foo ()
[+] 	foo()
[-] 		printf ("C1.foo () { m_x = %d }\n", m_x);
[+] 		printf("C1.foo () { m_x = %d }\n", m_x);
[-] 	bar ()
[+] 	bar()
[-] 		printf ("C1Ext.bar () { m_x = %d }\n", m_x);
[+] 		printf("C1Ext.bar () { m_x = %d }\n", m_x);
[-] 	int m_prop.get ()
[+] 	int m_prop.get()
[-] 		printf ("C1Ext.m_prop.get () { m_x = %d }\n", m_x);
[+] 		printf("C1Ext.m_prop.get () { m_x = %d }\n", m_x);
[-] 	m_prop.set (int x)
[+] 	m_prop.set(int x)
[-] 		printf ("C1Ext.set (%d) { m_x = %d }\n", x, m_x);
[+] 		printf("C1Ext.set (%d) { m_x = %d }\n", x, m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	c.foo ();
[+] 	c.foo();
[-] 	c.bar ();
[+] 	c.bar();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test43.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	printf ($"point = { %1, %2 }\n" (point.m_x, point.m_y));
[+] 	printf($"point = { %1, %2 }\n" (point.m_x, point.m_y));
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test44.jnc
----------------------
[-] g_a.set (int x)
[+] g_a.set(int x)
[-] 	printf ("g_a.set (%d)\n", x);
[+] 	printf("g_a.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] g_b.set (int x)
[+] g_b.set(int x)
[-] 	printf ("g_b.set (%d)\n", x);
[+] 	printf("g_b.set (%d)\n", x);
[-] 	m_onChanged ();
[+] 	m_onChanged();
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	g_myReactor.start ();
[+] 	g_myReactor.start();
----------------------
27/02/2019 18:02:30 - C:\Projects\repos\ioninja\jancy\test\jnc\test45.jnc
----------------------
[-] 		static construct ()
[+] 		static construct()
[-] 			printf ("C1.m_prop.static construct () { m_x = %d, m_px = %d }\n", m_x, m_px);
[+] 			printf("C1.m_prop.static construct () { m_x = %d, m_px = %d }\n", m_x, m_px);
[-] 		construct ()
[+] 		construct()
[-] 			printf ("C1.m_prop.construct () { m_x = %d, m_y = %d, m_px = %d, m_py = %d  }\n", m_x, m_y, m_px, m_py);
[+] 			printf("C1.m_prop.construct () { m_x = %d, m_y = %d, m_px = %d, m_py = %d  }\n", m_x, m_y, m_px, m_py);
[-] 		destruct ()
[+] 		destruct()
[-] 			printf ("C1.m_prop.destruct () { m_x = %d, m_y = %d, m_px = %d, m_py = %d  }\n", m_x, m_y, m_px, m_py);
[+] 			printf("C1.m_prop.destruct () { m_x = %d, m_y = %d, m_px = %d, m_py = %d  }\n", m_x, m_y, m_px, m_py);
[-] 		static destruct ()
[+] 		static destruct()
[-] 			printf ("C1.m_prop.static destruct () { m_x = %d, m_px = %d }\n", m_x, m_px);
[+] 			printf("C1.m_prop.static destruct () { m_x = %d, m_px = %d }\n", m_x, m_px);
[-] 		int get ()
[+] 		int get()
[-] 	static construct ()
[+] 	static construct()
[-] 		printf ("C1.static construct () { m_x = %d }\n", m_x);
[+] 		printf("C1.static construct () { m_x = %d }\n", m_x);
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct () { m_x = %d, m_y = %d }\n", m_x, m_y);
[+] 		printf("C1.construct () { m_x = %d, m_y = %d }\n", m_x, m_y);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct () { m_x = %d, m_y = %d }\n", m_x, m_y);
[+] 		printf("C1.destruct () { m_x = %d, m_y = %d }\n", m_x, m_y);
[-] 	static destruct ()
[+] 	static destruct()
[-] 		printf ("C1.static destruct () { m_x = %d }\n", m_x);
[+] 		printf("C1.static destruct () { m_x = %d }\n", m_x);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test46.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C1.construct ()\n");
[+] 		printf("C1.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C1.destruct ()\n");
[+] 		printf("C1.destruct ()\n");
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C2.construct ()\n");
[+] 		printf("C2.construct ()\n");
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C2.destruct ()\n");
[+] 		printf("C2.destruct ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	utilsFoo ();
[+] 	utilsFoo();
[-] 	printf ("running GC...\n");
[+] 	printf("running GC...\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test47.jnc
----------------------
[-] bool errorcode scanPacket (
[+] bool errorcode scanPacket(
[-] 		length = strlen (p);
[+] 		length = strlen(p);
[-] 		reswitch (state, p, end - p)
[+] 		reswitch(state, p, end - p)
[-] 			printf ("command = open\n%s\n", state.m_match.m_text);
[+] 			printf("command = open\n%s\n", state.m_match.m_text);
[-] 			printf ("command = close\n%s\n", state.m_match.m_text);
[+] 			printf("command = close\n%s\n", state.m_match.m_text);
[-] 			printf ("command = connect\n%s\n", state.m_match.m_text);
[+] 			printf("command = connect\n%s\n", state.m_match.m_text);
[-] 			assert (state.m_consumedLength == end - p);
[+] 			assert(state.m_consumedLength == end - p);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	jnc.RegexState state (true); // incremental recognizer
[+] 	jnc.RegexState state(true); // incremental recognizer
[-] 		scanPacket (state, "op");
[+] 		scanPacket(state, "op");
[-] 		scanPacket (state, "en 12\ncon");
[+] 		scanPacket(state, "en 12\ncon");
[-] 		scanPacket (state, "nect5\r cl");
[+] 		scanPacket(state, "nect5\r cl");
[-] 		scanPacket (state, "ose\t7777");
[+] 		scanPacket(state, "ose\t7777");
[-] 		printf ("the following will fail ('close' has no [\\r\\n]\n");
[+] 		printf("the following will fail ('close' has no [\\r\\n]\n");
[-] 		scanPacket (state, null);
[+] 		scanPacket(state, null);
[-] 		printf ("recognition error\n");
[+] 		printf("recognition error\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test48.jnc
----------------------
[-] bool errorcode scanCommand (
[+] bool errorcode scanCommand(
[-] 		length = strlen (p);
[+] 		length = strlen(p);
[-] 		reswitch (state, p, end - p)
[+] 		reswitch(state, p, end - p)
[-] 			char const* chunk = strdup (g_data, length);
[+] 			char const* chunk = strdup(g_data, length);
[-] 			printf ("%s\n", chunk);
[+] 			printf("%s\n", chunk);
[-] 			printf ("inband '%s'\n", state.m_match.m_text);
[+] 			printf("inband '%s'\n", state.m_match.m_text);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	jnc.RegexState state (true);
[+] 	jnc.RegexState state(true);
[-] 		scanCommand (state, g_data, strlen (g_data));
[+] 		scanCommand(state, g_data, strlen(g_data));
[-] 		char const* chunk = strdup (g_data, length);
[+] 		char const* chunk = strdup(g_data, length);
[-] 		printf ("%s", chunk);
[+] 		printf("%s", chunk);
[-] 		scanCommand (state, g_data, strlen (g_data));
[+] 		scanCommand(state, g_data, strlen(g_data));
[-] 		chunk = strdup (g_data, length);
[+] 		chunk = strdup(g_data, length);
[-] 		printf ("%s", chunk);
[+] 		printf("%s", chunk);
[-] 		scanCommand (state, g_data, strlen (g_data));
[+] 		scanCommand(state, g_data, strlen(g_data));
[-] 		chunk = strdup (g_data, length);
[+] 		chunk = strdup(g_data, length);
[-] 		printf ("%s", chunk);
[+] 		printf("%s", chunk);
[-] 		scanCommand (state, g_data, strlen (g_data));
[+] 		scanCommand(state, g_data, strlen(g_data));
[-] 		chunk = strdup (g_data, length);
[+] 		chunk = strdup(g_data, length);
[-] 		printf ("%s", chunk);
[+] 		printf("%s", chunk);
[-] 		printf ("recognition error\n");
[+] 		printf("recognition error\n");
[-] 	printf ("\n");
[+] 	printf("\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test49.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ($"v1 = $v1; v2 = $v2; v3 = $v3; v4 = $v4\n");
[+] 	printf($"v1 = $v1; v2 = $v2; v3 = $v3; v4 = $v4\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test50.jnc
----------------------
[-] typedef int stdcall SndPlaySound (
[+] typedef int stdcall SndPlaySound(
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	lib.open ("winmm.dll");
[+] 	lib.open("winmm.dll");
[-] 		sndPlaySound = (SndPlaySound thin*) lib.getFunction ("sndPlaySoundA");
[+] 		sndPlaySound = (SndPlaySound thin*) lib.getFunction("sndPlaySoundA");
[-] 	sndPlaySound ("c:/windows/media/tada.wav", 0);
[+] 	sndPlaySound("c:/windows/media/tada.wav", 0);
[-] 	printf ("error caught: %s\n", std.getLastError ().m_description);
[+] 	printf("error caught: %s\n", std.getLastError ().m_description);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test51.jnc
----------------------
[-] 	int stdcall MessageBoxA (
[+] 	int stdcall MessageBoxA(
[-] 	int stdcall MessageBeep (int type);
[+] 	int stdcall MessageBeep(int type);
[-] 	int cdecl printf (
[+] 	int cdecl printf(
[-] foo (Msvcrt* msvcrt)
[+] foo(Msvcrt* msvcrt)
[-] 	msvcrt.lib.printf ("hui govno i muravei!\n");
[+] 	msvcrt.lib.printf("hui govno i muravei!\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	user32.open ("user32.dll");
[+] 	user32.open("user32.dll");
[-] 	user32.lib.MessageBeep (0x00000030); // MB_ICONEXCLAMATION
[+] 	user32.lib.MessageBeep(0x00000030); // MB_ICONEXCLAMATION
[-] 	msvcrt.open ("msvcrt.dll");
[+] 	msvcrt.open("msvcrt.dll");
[-] 	foo (msvcrt);
[+] 	foo(msvcrt);
[-] 	printf ("error caught: %s\n", std.getLastError ().m_description);
[+] 	printf("error caught: %s\n", std.getLastError ().m_description);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test52.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test53.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	reswitch (state, packet)
[+] 	reswitch(state, packet)
[-] 		printf ("echo\n");
[+] 		printf("echo\n");
[-] 		printf ("MAC: %s\n", state.m_match.m_text);
[+] 		printf("MAC: %s\n", state.m_match.m_text);
[-] 		reswitch (state, packet + state.m_consumedLength)
[+] 		reswitch(state, packet + state.m_consumedLength)
[-] 			printf ("<IONJ-3.4.0>/ec8ec901-bb4b-4468-bfb9-bf482589cc17/test!\n");
[+] 			printf("<IONJ-3.4.0>/ec8ec901-bb4b-4468-bfb9-bf482589cc17/test!\n");
[-] 			printf ("A*R*/00/&h A:0000,B:0000,PC:00000000,SP:00,FL:Z**/65535\n");
[+] 			printf("A*R*/00/&h A:0000,B:0000,PC:00000000,SP:00,FL:Z**/65535\n");
[-] 	printf ("recognition error\n");
[+] 	printf("recognition error\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test54.jnc
----------------------
[-] 	construct (
[+] 	construct(
[-] 		printf ("Foo.construct (this = %x) { m_tid =  %d; m_oid = %d; } \n", this, m_tid, m_oid);
[+] 		printf("Foo.construct (this = %x) { m_tid =  %d; m_oid = %d; } \n", this, m_tid, m_oid);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("Foo.destruct (this = %x) { m_tid =  %d; m_oid = %d; } \n", this, m_tid, m_oid);
[+] 		printf("Foo.destruct (this = %x) { m_tid =  %d; m_oid = %d; } \n", this, m_tid, m_oid);
[-] threadProc ()
[+] threadProc()
[-] 	intptr_t tid = sys.getCurrentThreadId ();
[+] 	intptr_t tid = sys.getCurrentThreadId();
[-] 	printf ("+threadProc %d\n", tid);
[+] 	printf("+threadProc %d\n", tid);
[-] 		new Foo (tid, i);
[+] 		new Foo(tid, i);
[-] 	printf ("-threadProc %d\n", tid);
[+] 	printf("-threadProc %d\n", tid);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	sys.Thread* threadTable [10];
[+] 	sys.Thread* threadTable[10];
[-] 	for (size_t i = 0; i < countof (threadTable); i++)
[+] 	for (size_t i = 0; i < countof(threadTable); i++)
[-] 		threadTable [i] = new sys.Thread;
[+] 		threadTable[i] = new sys.Thread;
[-] 		threadTable [i].start (threadProc);
[+] 		threadTable[i].start(threadProc);
[-] 	printf ("waiting for threads...\n");
[+] 	printf("waiting for threads...\n");
[-] 	for (size_t i = 0; i < countof (threadTable); i++)
[+] 	for (size_t i = 0; i < countof(threadTable); i++)
[-] 		threadTable [i].waitAndClose ();
[+] 		threadTable[i].waitAndClose();
[-] 	printf ("exiting main...\n");
[+] 	printf("exiting main...\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test55.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		printf ("read-only is true\n");
[+] 		printf("read-only is true\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test56.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("State.Bridged = %d\n", State.Bridged);
[+] 	printf("State.Bridged = %d\n", State.Bridged);
[-] 	printf ("Flags.All = 0x%x\n", Flags.All);
[+] 	printf("Flags.All = 0x%x\n", Flags.All);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test57.jnc
----------------------
[-] foo (char const* const* table)
[+] foo(char const* const* table)
[-] 	printf ("dynamic countof = %d\n", dynamic countof (table));
[+] 	printf("dynamic countof = %d\n", dynamic countof (table));
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	char const* a [] =
[+] 	char const* a[] =
[-] 	foo (a);
[+] 	foo(a);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test58.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	char buffer [] = 0x"03 9d";
[+] 	char buffer[] = 0x"03 9d";
[-] 	Test* test = (Test*) buffer;
[+] 	Test* test = (Test*)buffer;
[-] 	printf ("flags = %d; offset = %d\n", test.m_flags, test.m_offset * 8);
[+] 	printf("flags = %d; offset = %d\n", test.m_flags, test.m_offset * 8);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test59.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	hashTable.add ("first-name", "Vladimir");
[+] 	hashTable.add("first-name", "Vladimir");
[-] 	hashTable ["last-name"] = "Gladkov";
[+] 	hashTable["last-name"] = "Gladkov";
[-] 	printf (
[+] 	printf(
[-] 			hashTable.findValue ("FIRST-NAME"),
[+] 			hashTable.findValue("FIRST-NAME"),
[-] 			hashTable ["LAST-NAME"],
[+] 			hashTable["LAST-NAME"],
[-] 			(bool) hashTable.find ("MIDDLE-NAME")
[+] 			(bool)hashTable.find("MIDDLE-NAME")
[-] 	hashTable2.add (1, "Vladimir");
[+] 	hashTable2.add(1, "Vladimir");
[-] 	hashTable2 [2] = "Gladkov";
[+] 	hashTable2[2] = "Gladkov";
[-] 	printf (
[+] 	printf(
[-] 			hashTable2.findValue (1),
[+] 			hashTable2.findValue(1),
[-] 			hashTable2 [2],
[+] 			hashTable2[2],
[-] 			(bool) hashTable2.find (3)
[+] 			(bool)hashTable2.find(3)
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test60.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	Pod* p3 = dynamic (Pod*) p2;
[+] 	Pod* p3 = dynamic(Pod*)p2;
[-] 	NonPod* p4 = dynamic (NonPod*) p2;
[+] 	NonPod* p4 = dynamic(NonPod*)p2;
[-] 	printf ("p0 = %p, p2 = %p, p3 = %p, p4 = %p\n", p0, p2, p3, p4);
[+] 	printf("p0 = %p, p2 = %p, p3 = %p, p4 = %p\n", p0, p2, p3, p4);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test61.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("Resource.construct (%p)\n", this);
[+] 		printf("Resource.construct (%p)\n", this);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("Resource.destruct (%p)\n", this);
[+] 		printf("Resource.destruct (%p)\n", this);
[-] 	close ()
[+] 	close()
[-] 		printf ("Resource.close (%p)\n", this);
[+] 		printf("Resource.close (%p)\n", this);
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 		printf ("catch 1\n");
[+] 		printf("catch 1\n");
[-] 		printf ("finally 1\n");
[+] 		printf("finally 1\n");
[-] 	printf ("hmmm\n");
[+] 	printf("hmmm\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test62.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test63.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("C.construct (%p)\n", this);
[+] 		printf("C.construct (%p)\n", this);
[-] 	destruct ()
[+] 	destruct()
[-] 		printf ("C.destruct (%p)\n", this);
[+] 		printf("C.destruct (%p)\n", this);
[-] 	dispose ()
[+] 	dispose()
[-] 		printf ("C.dispose (%p)\n", this);
[+] 		printf("C.dispose (%p)\n", this);
[-] foo ()
[+] foo()
[-] 	printf ("foo () is about to throw...\n");
[+] 	printf("foo () is about to throw...\n");
[-] 	std.setError ("foo error");
[+] 	std.setError("foo error");
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
[-] 	foo ();
[+] 	foo();
[-] 	printf ("main catch\n");
[+] 	printf("main catch\n");
[-] 	printf ("main finally\n");
[+] 	printf("main finally\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test64.jnc
----------------------
[-] bar (
[+] bar(
[-] 	printf ("a = %s; b = %s\n", a, b);
[+] 	printf("a = %s; b = %s\n", a, b);
[-] baz ()
[+] baz()
[-] 	bar (
[+] 	bar(
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	baz ();
[+] 	baz();
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test65.jnc
----------------------
[-] foo (bool isError)
[+] foo(bool isError)
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] 		printf ("foo is about to throw...\n");
[+] 		printf("foo is about to throw...\n");
[-] 		std.setError ("foo-error");
[+] 		std.setError("foo-error");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	bool result = try foo (true);
[+] 	bool result = try foo(true);
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 		printf ("before calling foo...\n");
[+] 		printf("before calling foo...\n");
[-] 		foo (false);
[+] 		foo(false);
[-] 		foo (false);
[+] 		foo(false);
[-] 		foo (true);
[+] 		foo(true);
[-] 		printf ("try-finally\n", result);
[+] 		printf("try-finally\n", result);
[-] 		foo (true);
[+] 		foo(true);
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 	printf ("main-catch: %s\n", std.getLastErrorDescription ());
[+] 	printf("main-catch: %s\n", std.getLastErrorDescription ());
[-] 	printf ("main-finally\n");
[+] 	printf("main-finally\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test66.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		char a [128];
[+] 		char a[128];
[-] 	printf ($"v0 = $v0\n");
[+] 	printf($"v0 = $v0\n");
[-] 	printf ($"v1 = $v1\n");
[+] 	printf($"v1 = $v1\n");
[-] 	char a [] = "hui govno i muravei, muravei govno i hui";
[+] 	char a[] = "hui govno i muravei, muravei govno i hui";
[-] 	printf ($"v2 = $v2\n");
[+] 	printf($"v2 = $v2\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test67.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf (
[+] 	printf(
[-] 		dynamic sizeof (&p.m_a),
[+] 		dynamic sizeof(&p.m_a),
[-] 		dynamic sizeof (&p.m_b)
[+] 		dynamic sizeof(&p.m_b)
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test68.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	switch (x)
[+] 	switch(x)
[-] 		printf ("x -- case 0\n");
[+] 		printf("x -- case 0\n");
[-] 		printf ("collect garbage #1\n");
[+] 		printf("collect garbage #1\n");
[-] 		sys.collectGarbage ();
[+] 		sys.collectGarbage();
[-] 		printf ("x -- case 1\n");
[+] 		printf("x -- case 1\n");
[-] 		printf ("x -- default\n");
[+] 		printf("x -- default\n");
[-] 	printf ("collect garbage #2\n");
[+] 	printf("collect garbage #2\n");
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test69.jnc
----------------------
[-] bigendian uint16_t foo ()
[+] bigendian uint16_t foo()
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("MinInterFrameDelay   = %llx\n", MinInterFrameDelay);
[+] 	printf("MinInterFrameDelay   = %llx\n", MinInterFrameDelay);
[-] 	printf ("MinInterFrameDelay32 = %x\n", MinInterFrameDelay32);
[+] 	printf("MinInterFrameDelay32 = %x\n", MinInterFrameDelay32);
[-] 	printf ("foo -> %x\n", foo ());
[+] 	printf("foo -> %x\n", foo ());
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test70.jnc
----------------------
[-] 	char m_name [32];
[+] 	char m_name[32];
[-] encodeNetBiosName (
[+] encodeNetBiosName(
[-] 		uchar_t c = name [i];
[+] 		uchar_t c = name[i];
[-] 		buffer [j++] = 'A' + (c >> 4);
[+] 		buffer[j++] = 'A' + (c >> 4);
[-] 		buffer [j++] = 'A' + (c & 0x0f);
[+] 		buffer[j++] = 'A' + (c & 0x0f);
[-] 		buffer [j++] = 'A' + (' ' >> 4);
[+] 		buffer[j++] = 'A' + (' ' >> 4);
[-] 		buffer [j++] = 'A' + (' ' & 0x0f);
[+] 		buffer[j++] = 'A' + (' ' & 0x0f);
[-] 	void initialize (char const* name)
[+] 	void initialize(char const* name)
[-] 		encodeNetBiosName (m_question.m_name, name);
[+] 		encodeNetBiosName(m_question.m_name, name);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test71.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	int x = rand () % 3;
[+] 	int x = rand() % 3;
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test72.jnc
----------------------
[-] foo ()
[+] foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] 	g_event.signal ();
[+] 	g_event.signal();
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	timer.startSingleShotTimer (foo, 3000);
[+] 	timer.startSingleShotTimer(foo, 3000);
[-] 	printf ("waiting...\n");
[+] 	printf("waiting...\n");
[-] 	g_event.wait ();
[+] 	g_event.wait();
[-] 	printf ("done\n");
[+] 	printf("done\n");
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test73.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		printf ("i = %d\n", i);
[+] 		printf("i = %d\n", i);
----------------------
27/02/2019 18:02:31 - C:\Projects\repos\ioninja\jancy\test\jnc\test74.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ($"v = $v\n");
[+] 	printf($"v = $v\n");
[-] 		printf ("if (v)\n");
[+] 		printf("if (v)\n");
[-] 		printf ("else (v)\n");
[+] 		printf("else (v)\n");
[-] 		printf ("if (!v)\n");
[+] 		printf("if (!v)\n");
[-] 		printf ("else (!v)\n");
[+] 		printf("else (!v)\n");
[-] 	printf ($"v = $v\n");
[+] 	printf($"v = $v\n");
[-] 		printf ("if (v)\n");
[+] 		printf("if (v)\n");
[-] 		printf ("else (v)\n");
[+] 		printf("else (v)\n");
[-] 		printf ("if (!v)\n");
[+] 		printf("if (!v)\n");
[-] 		printf ("else (!v)\n");
[+] 		printf("else (!v)\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test75.jnc
----------------------
[-] 	char const* foo ()
[+] 	char const* foo()
[-] 		printf ("+Foo.m_foo = %d\n", m_foo);
[+] 		printf("+Foo.m_foo = %d\n", m_foo);
[-] 		sys.collectGarbage (); // <-- Foo was collected due to incorrect gc grame map
[+] 		sys.collectGarbage(); // <-- Foo was collected due to incorrect gc grame map
[-] 		printf ("-Foo.m_foo = %d\n", m_foo);
[+] 		printf("-Foo.m_foo = %d\n", m_foo);
[-] foo ()
[+] foo()
[-] 		foo.foo ();
[+] 		foo.foo();
[-] bar ()
[+] bar()
[-] 		address.m_ip4.m_address.m_i8 [3] = i;
[+] 		address.m_ip4.m_address.m_i8[3] = i;
[-] 		printf ($"probing $(address.getString ())...\n");
[+] 		printf($"probing $(address.getString ())...\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	foo ();
[+] 	foo();
[-] 	bar ();
[+] 	bar();
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test76.jnc
----------------------
[-] 	int m_a [10];
[+] 	int m_a[10];
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("sizeof (Foo) = %d\n", sizeof (Foo));
[+] 	printf("sizeof (Foo) = %d\n", sizeof (Foo));
[-] 	printf ("sizeof (Foo.m_c) = %d\n", sizeof (Foo.m_c));
[+] 	printf("sizeof (Foo.m_c) = %d\n", sizeof (Foo.m_c));
[-] 	printf ("sizeof (Foo.m_a) = %d\n", sizeof (Foo.m_a));
[+] 	printf("sizeof (Foo.m_a) = %d\n", sizeof (Foo.m_a));
[-] 	printf ("countof (Foo.m_a) = %d\n", countof (Foo.m_a));
[+] 	printf("countof (Foo.m_a) = %d\n", countof (Foo.m_a));
[-] 	printf ("offsetof (Foo.m_a) = %d\n", offsetof (Foo.m_a));
[+] 	printf("offsetof (Foo.m_a) = %d\n", offsetof (Foo.m_a));
[-] 	printf ("sizeof (foo) = %d\n", sizeof (foo));
[+] 	printf("sizeof (foo) = %d\n", sizeof (foo));
[-] 	printf ("sizeof (foo.m_c) = %d\n", sizeof (foo.m_c));
[+] 	printf("sizeof (foo.m_c) = %d\n", sizeof (foo.m_c));
[-] 	printf ("sizeof (foo.m_a) = %d\n", sizeof (foo.m_a));
[+] 	printf("sizeof (foo.m_a) = %d\n", sizeof (foo.m_a));
[-] 	printf ("countof (foo.m_a) = %d\n", countof (foo.m_a));
[+] 	printf("countof (foo.m_a) = %d\n", countof (foo.m_a));
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test77.jnc
----------------------
[-] 	void foo (io.SocketAddress const* remoteAddress);
[+] 	void foo(io.SocketAddress const* remoteAddress);
[-] void TcpConnectionSession.foo (io.SocketAddress const* remoteAddress)
[+] void TcpConnectionSession.foo(io.SocketAddress const* remoteAddress)
[-] 	printf ("foo - 1\n");
[+] 	printf("foo - 1\n");
[-] 		printf ("foo - 2\n");
[+] 		printf("foo - 2\n");
[-] 		m_socket.open (io.Protocol.Tcp, &localAddress);
[+] 		m_socket.open(io.Protocol.Tcp, &localAddress);
[-] 		printf ("foo - 3\n");
[+] 		printf("foo - 3\n");
[-] 	printf ("foo - 4\n");
[+] 	printf("foo - 4\n");
[-] 	char const* xxx = m_remoteAddress.getString ();
[+] 	char const* xxx = m_remoteAddress.getString();
[-] 	printf ("foo - 5\n");
[+] 	printf("foo - 5\n");
[-] 	printf ("foo - 6\n");
[+] 	printf("foo - 6\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	session.foo (&remoteAddress);
[+] 	session.foo(&remoteAddress);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test78.jnc
----------------------
[-] 	close ()
[+] 	close()
[-] 		printf ("Foo.close ()\n");
[+] 		printf("Foo.close ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test79.jnc
----------------------
[-] char const* g_testProp.get ()
[+] char const* g_testProp.get()
[-] 	return strdup ("hui-govno-i-muravei");
[+] 	return strdup("hui-govno-i-muravei");
[-] char const* foo ()
[+] char const* foo()
[-] 	return strdup ("hui-govno-i-muravei");
[+] 	return strdup("hui-govno-i-muravei");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 		printf ($" %1 %2 %3 %4\n" (foo (), foo (), foo (), foo ()));
[+] 		printf($" %1 %2 %3 %4\n" (foo (), foo (), foo (), foo ()));
[-] 		printf ($" %1 %2 %3 %4\n" (g_testProp, g_testProp, g_testProp, g_testProp));
[+] 		printf($" %1 %2 %3 %4\n" (g_testProp, g_testProp, g_testProp, g_testProp));
[-] 		printf (" %s %s %s %s\n", g_testProp, g_testProp, g_testProp, g_testProp);
[+] 		printf(" %s %s %s %s\n", g_testProp, g_testProp, g_testProp, g_testProp);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test80.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	std.setError ("something bad happened");
[+] 	std.setError("something bad happened");
[-] 	printf ($"last error (method 1): $(std.getLastError ().m_description)\n");
[+] 	printf($"last error (method 1): $(std.getLastError ().m_description)\n");
[-] 	printf ($"last error (method 2): $(std.getLastErrorDescription ())\n");
[+] 	printf($"last error (method 2): $(std.getLastErrorDescription ())\n");
[-] 	printf ($"last error (method 2): $!\n");
[+] 	printf($"last error (method 2): $!\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test82.jnc
----------------------
[-] printUsbEndpointDesc (io.UsbEndpointDesc const* endpointDesc)
[+] printUsbEndpointDesc(io.UsbEndpointDesc const* endpointDesc)
[-] 	printf ("      Endpoint:   0x%02x\n", endpointDesc.m_endpointId);
[+] 	printf("      Endpoint:   0x%02x\n", endpointDesc.m_endpointId);
[-] 	printf ("      Direction:  %s\n", (endpointDesc.m_endpointId & 0x80) ? "IN" : "OUT");
[+] 	printf("      Direction:  %s\n", (endpointDesc.m_endpointId & 0x80) ? "IN" : "OUT");
[-] 	printf ("      Type:       %s\n", io.getUsbTransferTypeString (endpointDesc.m_transferType));
[+] 	printf("      Type:       %s\n", io.getUsbTransferTypeString (endpointDesc.m_transferType));
[-] 	printf ("      Max packet: %d\n", endpointDesc.m_maxPacketSize);
[+] 	printf("      Max packet: %d\n", endpointDesc.m_maxPacketSize);
[-] printUsbIfaceDesc (io.UsbInterfaceDesc const* ifaceDesc)
[+] printUsbIfaceDesc(io.UsbInterfaceDesc const* ifaceDesc)
[-] 	printf ("    Interface:   %d\n", ifaceDesc.m_interfaceId);
[+] 	printf("    Interface:   %d\n", ifaceDesc.m_interfaceId);
[-] 	printf ("    Alt setting: %d\n", ifaceDesc.m_altSettingId);
[+] 	printf("    Alt setting: %d\n", ifaceDesc.m_altSettingId);
[-] 	printf ("    Class:       %02x/%02x (%s)\n", ifaceDesc.m_class, ifaceDesc.m_subClass, io.getUsbClassString (ifaceDesc.m_class));
[+] 	printf("    Class:       %02x/%02x (%s)\n", ifaceDesc.m_class, ifaceDesc.m_subClass, io.getUsbClassString (ifaceDesc.m_class));
[-] 	printf ("    Protocol:    %d\n", ifaceDesc.m_protocol);
[+] 	printf("    Protocol:    %d\n", ifaceDesc.m_protocol);
[-] 	printf ("    Endpoints:   %d\n", ifaceDesc.m_endpointCount);
[+] 	printf("    Endpoints:   %d\n", ifaceDesc.m_endpointCount);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 		printUsbEndpointDesc (&ifaceDesc.m_endpointTable [i]);
[+] 		printUsbEndpointDesc(&ifaceDesc.m_endpointTable[i]);
[-] printUsbConfigurationDesc (io.UsbConfigurationDesc const* configDesc)
[+] printUsbConfigurationDesc(io.UsbConfigurationDesc const* configDesc)
[-] 	printf ("  Configuration: %d\n", configDesc.m_configurationId);
[+] 	printf("  Configuration: %d\n", configDesc.m_configurationId);
[-] 	printf ("  Max power:     %d x(2|8) mA\n", configDesc.m_maxPower);
[+] 	printf("  Max power:     %d x(2|8) mA\n", configDesc.m_maxPower);
[-] 	printf ("  Interfaces:    %d\n", configDesc.m_interfaceCount);
[+] 	printf("  Interfaces:    %d\n", configDesc.m_interfaceCount);
[-] 		io.UsbInterfaceDesc const* ifaceDesc = &configDesc.m_interfaceTable [i];
[+] 		io.UsbInterfaceDesc const* ifaceDesc = &configDesc.m_interfaceTable[i];
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 			printUsbIfaceDesc (ifaceDesc);
[+] 			printUsbIfaceDesc(ifaceDesc);
[-] printUsbDevice (io.UsbDevice* device)
[+] printUsbDevice(io.UsbDevice* device)
[-] 	printf ("Vendor:  %04x %s\n", deviceDesc.m_vendorId, try device.getStringDesc (deviceDesc.m_vendorStringId));
[+] 	printf("Vendor:  %04x %s\n", deviceDesc.m_vendorId, try device.getStringDesc (deviceDesc.m_vendorStringId));
[-] 	printf ("Product: %04x %s\n", deviceDesc.m_productId, try device.getStringDesc (deviceDesc.m_productStringId));
[+] 	printf("Product: %04x %s\n", deviceDesc.m_productId, try device.getStringDesc (deviceDesc.m_productStringId));
[-] 	printf ("Class:   %02x/%02x (%s)\n", deviceDesc.m_class, deviceDesc.m_subClass, io.getUsbClassString (deviceDesc.m_class));
[+] 	printf("Class:   %02x/%02x (%s)\n", deviceDesc.m_class, deviceDesc.m_subClass, io.getUsbClassString (deviceDesc.m_class));
[-] 	printf ("Serial:  %s\n", try device.getStringDesc (deviceDesc.m_serialStringId));
[+] 	printf("Serial:  %s\n", try device.getStringDesc (deviceDesc.m_serialStringId));
[-] 	printf ("Bus:     %d\n", device.m_bus);
[+] 	printf("Bus:     %d\n", device.m_bus);
[-] 	printf ("Address: %d\n", device.m_address);
[+] 	printf("Address: %d\n", device.m_address);
[-] 	printf ("Speed:   %s\n", io.getUsbSpeedString (device.m_speed));
[+] 	printf("Speed:   %s\n", io.getUsbSpeedString (device.m_speed));
[-] 	printf ("Configs: %d\n", deviceDesc.m_configurationCount);
[+] 	printf("Configs: %d\n", deviceDesc.m_configurationCount);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 		printUsbConfigurationDesc (&deviceDesc.m_configurationTable [i]);
[+] 		printUsbConfigurationDesc(&deviceDesc.m_configurationTable[i]);
[-] int main ()
[+] int main()
[-] 	printf ("Enumerating USB devices...\n");
[+] 	printf("Enumerating USB devices...\n");
[-] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray (&count);
[+] 	io.UsbDevice* const* deviceArray = io.createUsbDeviceArray(&count);
[-] 		io.UsbDevice* device = deviceArray [i];
[+] 		io.UsbDevice* device = deviceArray[i];
[-] 		try device.open ();
[+] 		try device.open();
[-] 		printUsbDevice (device);
[+] 		printUsbDevice(device);
[-] 		printf ("\n");
[+] 		printf("\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test83.jnc
----------------------
[-] onUsbEndpointEvent (
[+] onUsbEndpointEvent(
[-] 		static char buffer [1024];
[+] 		static char buffer[1024];
[-] 		size_t size = endpoint.read (buffer, sizeof (buffer));
[+] 		size_t size = endpoint.read(buffer, sizeof(buffer));
[-] 		printf ("  %d bytes read from the endpoint\n", size);
[+] 		printf("  %d bytes read from the endpoint\n", size);
[-] 	endpoint.wait (io.UsbEndpointEvents.IncomingData, onUsbEndpointEvent ~(endpoint));
[+] 	endpoint.wait(io.UsbEndpointEvents.IncomingData, onUsbEndpointEvent ~(endpoint));
[-] int main ()
[+] int main()
[-] 	printf ("Opening USB mouse...\n");
[+] 	printf("Opening USB mouse...\n");
[-] 	io.UsbDevice* device = io.openUsbDevice (0x046d, 0xc246);
[+] 	io.UsbDevice* device = io.openUsbDevice(0x046d, 0xc246);
[-] 	printf ("Claiming interface #0...\n");
[+] 	printf("Claiming interface #0...\n");
[-] 	io.UsbInterface* iface = device.claimInterface (0);
[+] 	io.UsbInterface* iface = device.claimInterface(0);
[-] 	printf ("Opening IN endpoint #81...\n");
[+] 	printf("Opening IN endpoint #81...\n");
[-] 	io.UsbEndpoint* endpoint = iface.openEndpoint (0x81);
[+] 	io.UsbEndpoint* endpoint = iface.openEndpoint(0x81);
[-] 	endpoint.wait (io.UsbEndpointEvents.IncomingData, onUsbEndpointEvent ~(endpoint));
[+] 	endpoint.wait(io.UsbEndpointEvents.IncomingData, onUsbEndpointEvent ~(endpoint));
[-] 	printf ("Closing endpoint...\n");
[+] 	printf("Closing endpoint...\n");
[-] 	endpoint.close ();
[+] 	endpoint.close();
[-] 	printf ("Done.\n");
[+] 	printf("Done.\n");
[-] 	printf ($"Error: $!\n");
[+] 	printf($"Error: $!\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test84.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	reswitch (state, packet)
[+] 	reswitch(state, packet)
[-] 		printf ("detected foobar: '%s'\n", state.m_match.m_text);
[+] 		printf("detected foobar: '%s'\n", state.m_match.m_text);
[-] 		printf ("foo: '%s'\n", state.m_subMatchArray [0].m_text);
[+] 		printf("foo: '%s'\n", state.m_subMatchArray [0].m_text);
[-] 		printf ("bar: '%s'\n", state.m_subMatchArray [1].m_text);
[+] 		printf("bar: '%s'\n", state.m_subMatchArray [1].m_text);
[-] 		printf ("offset: %d\n", state.m_currentOffset);
[+] 		printf("offset: %d\n", state.m_currentOffset);
[-] 		printf ("recognition error\n");
[+] 		printf("recognition error\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test85.jnc
----------------------
[-] construct ()
[+] construct()
[-] 	printf ("module.construct ()\n");
[+] 	printf("module.construct ()\n");
[-] destruct ()
[+] destruct()
[-] 	printf ("module.destruct ()\n");
[+] 	printf("module.destruct ()\n");
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	printf ("triggers: %d, %d\n", triggers.m_allocSizeTrigger, triggers.m_periodSizeTrigger);
[+] 	printf("triggers: %d, %d\n", triggers.m_allocSizeTrigger, triggers.m_periodSizeTrigger);
[-] 	sys.collectGarbage ();
[+] 	sys.collectGarbage();
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test86.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	c.m_testReactor.start ();
[+] 	c.m_testReactor.start();
[-] 	printf ("g_out = %d\n", g_all);
[+] 	printf("g_out = %d\n", g_all);
[-] 	printf ("g_out = %d\n", g_all);
[+] 	printf("g_out = %d\n", g_all);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test87.jnc
----------------------
[-] 	construct ()
[+] 	construct()
[-] 		printf ("Foo.construct (%p)\n", this);
[+] 		printf("Foo.construct (%p)\n", this);
[-] 	close ()
[+] 	close()
[-] 		printf ("Foo.close (%p)\n", this);
[+] 		printf("Foo.close (%p)\n", this);
[-] 	construct ()
[+] 	construct()
[-] 		printf ("Bar.construct (%p)\n", this);
[+] 		printf("Bar.construct (%p)\n", this);
[-] 	close ()
[+] 	close()
[-] 		printf ("Bar.close (%p)\n", this);
[+] 		printf("Bar.close (%p)\n", this);
[-] int main ()
[+] int main()
[-] 	printf ("before\n");
[+] 	printf("before\n");
[-] 	printf ("after\n");
[+] 	printf("after\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test88.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	int a [4] = { 10, 20, 30, 40 }
[+] 	int a[4] = { 10, 20, 30, 40 }
[-] 	variant v1 = &a [0];
[+] 	variant v1 = &a[0];
[-] 	variant v2 = &a [2];
[+] 	variant v2 = &a[2];
[-] 	printf ($"v1 = $v1; v2 = $v2; v3 = $v3; v4 = $v4\n");
[+] 	printf($"v1 = $v1; v2 = $v2; v3 = $v3; v4 = $v4\n");
[-] 	printf ($"v.m_x = %1, v.m_y = %2\n" (v.m_x, v.m_y));
[+] 	printf($"v.m_x = %1, v.m_y = %2\n" (v.m_x, v.m_y));
[-] 	printf ($"v.m_x = %1, v.m_y = %2\n" (v.m_x, v.m_y));
[+] 	printf($"v.m_x = %1, v.m_y = %2\n" (v.m_x, v.m_y));
[-] 	printf ("point.m_x = %d, point.m_y = %d\n", point.m_x, point.m_y);
[+] 	printf("point.m_x = %d, point.m_y = %d\n", point.m_x, point.m_y);
[-] 	v [0] = 100;
[+] 	v[0] = 100;
[-] 	v [1] = 200;
[+] 	v[1] = 200;
[-] 	v [2] = 300;
[+] 	v[2] = 300;
[-] 	v [3] = 400;
[+] 	v[3] = 400;
[-] 	printf ($"v = { %1, %2, %3, %4 }\n" (v [0], v [1], v [2], v [3]));
[+] 	printf($"v = { %1, %2, %3, %4 }\n" (v [0], v [1], v [2], v [3]));
[-] 	printf ($"v = { %1, %2, %3, %4 }\n" (v [0], v [1], v [2], v [3]));
[+] 	printf($"v = { %1, %2, %3, %4 }\n" (v [0], v [1], v [2], v [3]));
[-] 	printf ($"a = { %1, %2, %3, %4 }\n" (a [0], a [1], a [2], a [3]));
[+] 	printf($"a = { %1, %2, %3, %4 }\n" (a [0], a [1], a [2], a [3]));
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test89.jnc
----------------------
[-] 		set (int x)
[+] 		set(int x)
[-] 			m_onChanged ();
[+] 			m_onChanged();
[-] 	event m_classOnChanged ();
[+] 	event m_classOnChanged();
[-] foo ()
[+] foo()
[-] 	printf ("foo ()\n");
[+] 	printf("foo ()\n");
[-] int foo (int x)
[+] int foo(int x)
[-] 	printf ("foo (%d)\n", x);
[+] 	printf("foo (%d)\n", x);
[-] int baz (int) = foo;
[+] int baz(int) = foo;
[-] baz ()
[+] baz()
[-] 	printf ("baz ()\n");
[+] 	printf("baz ()\n");
[-] int main ()
[+] int main()
[-] 	bar ();
[+] 	bar();
[-] 	bar (100);
[+] 	bar(100);
[-] 	bindingof (c2.m_prop) += foo;
[+] 	bindingof(c2.m_prop) += foo;
[-] 	printf ("m_classValue = %d\n", c2.m_classValue);
[+] 	printf("m_classValue = %d\n", c2.m_classValue);
[-] 	baz ();
[+] 	baz();
[-] 	baz (255);
[+] 	baz(255);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test90.jnc
----------------------
[-] 	int get (int i)
[+] 	int get(int i)
[-] 		printf ("C2.get (%d)\n", i);
[+] 		printf("C2.get (%d)\n", i);
[-] 	set (
[+] 	set(
[-] 		printf ("C2.get (%d, %d)\n", i, value);
[+] 		printf("C2.get (%d, %d)\n", i, value);
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	c [10] = 100;
[+] 	c[10] = 100;
[-] 	int x = c [20];
[+] 	int x = c[20];
[-] 	printf ("x = %d\n", x);
[+] 	printf("x = %d\n", x);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test91.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	a.setCount (100);
[+] 	a.setCount(100);
[-] 	print ("filling array\n");
[+] 	print("filling array\n");
[-] 		a [i] = i * 10;
[+] 		a[i] = i * 10;
[-] 	print ("printing array\n");
[+] 	print("printing array\n");
[-] 		print ($"a [$i] = $(a [i])\n");
[+] 		print($"a [$i] = $(a [i])\n");
[-] 	printf ("error caught: %s\n", std.getLastErrorDescription ());
[+] 	printf("error caught: %s\n", std.getLastErrorDescription ());
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test92.jnc
----------------------
[-] size_t hashString_i (variant v)
[+] size_t hashString_i(variant v)
[-] 	char const* end = p + strlen (p);
[+] 	char const* end = p + strlen(p);
[-] 		hash = ((hash << 5) + hash) + tolower (*p); // hash * 33 + c
[+] 		hash = ((hash << 5) + hash) + tolower(*p); // hash * 33 + c
[-] bool isEqualString_i (
[+] bool isEqualString_i(
[-] 	return stricmp (v1, v2) == 0;
[+] 	return stricmp(v1, v2) == 0;
[-] int main ()
[+] int main()
[-] 	hashTable [1] = 100;
[+] 	hashTable[1] = 100;
[-] 	hashTable [2] = 200;
[+] 	hashTable[2] = 200;
[-] 	print ($"1 => %1 2 => %2\n" (hashTable [1], hashTable [2]));
[+] 	print($"1 => %1 2 => %2\n" (hashTable [1], hashTable [2]));
[-] 	std.HashTable hashTable2 (hashString_i, isEqualString_i);
[+] 	std.HashTable hashTable2(hashString_i, isEqualString_i);
[-] 	hashTable2 ["user"] = "John Doe";
[+] 	hashTable2["user"] = "John Doe";
[-] 	hashTable2 ["pass"] = "qwerty";
[+] 	hashTable2["pass"] = "qwerty";
[-] 	print ($"user: %1 password: %2\n" (hashTable2 ["USER"], hashTable2 ["PASS"]));
[+] 	print($"user: %1 password: %2\n" (hashTable2 ["USER"], hashTable2 ["PASS"]));
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test93.jnc
----------------------
[-] int cmpVariant (
[+] int cmpVariant(
[-] int main ()
[+] int main()
[-] 	std.RbTree rbTree (cmpVariant);
[+] 	std.RbTree rbTree(cmpVariant);
[-] 	int a [10];
[+] 	int a[10];
[-] 	for (int i = 0; i < countof (a); i++)
[+] 	for (int i = 0; i < countof(a); i++)
[-] 		int n = rand () % 100;
[+] 		int n = rand() % 100;
[-] 		a [i] = n;
[+] 		a[i] = n;
[-] 		print ($"adding $n...\n");
[+] 		print($"adding $n...\n");
[-] 		rbTree.add (n, n);
[+] 		rbTree.add(n, n);
[-] 	printf ("ascending order:\n");
[+] 	printf("ascending order:\n");
[-] 		print ($"key: $(entry.m_key) value: $(entry.m_value)\n");
[+] 		print($"key: $(entry.m_key) value: $(entry.m_value)\n");
[-] 	printf ("descending order:\n");
[+] 	printf("descending order:\n");
[-] 		print ($"key: $(entry.m_key) value: $(entry.m_value)\n");
[+] 		print($"key: $(entry.m_key) value: $(entry.m_value)\n");
[-] 	printf ("validating...\n");
[+] 	printf("validating...\n");
[-] 	for (int i = 0; i < countof (a); i++)
[+] 	for (int i = 0; i < countof(a); i++)
[-] 		int n = a [i];
[+] 		int n = a[i];
[-] 		std.MapEntry* entry = rbTree.find (n);
[+] 		std.MapEntry* entry = rbTree.find(n);
[-] 		assert (entry && entry.m_key == n && entry.m_value == n);
[+] 		assert(entry && entry.m_key == n && entry.m_value == n);
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test94.jnc
----------------------
[-] variant findValue (
[+] variant findValue(
[-] int main ()
[+] int main()
[-] 	findValue (100);
[+] 	findValue(100);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test95.jnc
----------------------
[-] foo ()
[+] foo()
[-] 	print ("foo\n");
[+] 	print("foo\n");
[-] int bar ()
[+] int bar()
[-] 	print ("bar\n");
[+] 	print("bar\n");
[-] int main ()
[+] int main()
[-] 	print ($"$(x; 02llx)\n");
[+] 	print($"$(x; 02llx)\n");
[-] 	print ("I\u00b2C\n");
[+] 	print("I\u00b2C\n");
[-] 	i ? foo () : bar ();
[+] 	i ? foo() : bar();
[-] 	i ? foo () : bar ();
[+] 	i ? foo() : bar();
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test96.jnc
----------------------
[-] int main ()
[+] int main()
[-] 	printf (
[+] 	printf(
[-] 	assert (a == c && b != c && d == null);
[+] 	assert(a == c && b != c && d == null);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test97.jnc
----------------------
[-] 	S1 foo ();
[+] 	S1 foo();
[-] 	bar (S1 a);
[+] 	bar(S1 a);
[-] 	S1 baz (S1 a, S2 b);
[+] 	S1 baz(S1 a, S2 b);
[-] C.bar (S1 a)
[+] C.bar(S1 a)
[-] S1 C.foo ()
[+] S1 C.foo()
[-] S1 C.baz (S1 a, S2 b)
[+] S1 C.baz(S1 a, S2 b)
[-] int main ()
[+] int main()
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test98.jnc
----------------------
[-] size_t getSzSize1 (char const* s)
[+] size_t getSzSize1(char const* s)
[-] 	printf ("getSzSize1 (%s)\n", s);
[+] 	printf("getSzSize1 (%s)\n", s);
[-] 	return strlen (s) + 1;
[+] 	return strlen(s) + 1;
[-] size_t getSzSize2 (char const* s)
[+] size_t getSzSize2(char const* s)
[-] 	printf ("getSzSize2 (%s)\n", s);
[+] 	printf("getSzSize2 (%s)\n", s);
[-] 	return strlen (s) + 1;
[+] 	return strlen(s) + 1;
[-] 	char m_s1 [getSzSize1 (m_s1)];
[+] 	char m_s1[getSzSize1(m_s1)];
[-] 	char m_s2 [getSzSize2 (m_s2)];
[+] 	char m_s2[getSzSize2(m_s2)];
[-] void printS (S const* s)
[+] void printS(S const* s)
[-] 	printf ("s.m_hdr.m_a = %d\n", s.m_hdr.m_a);
[+] 	printf("s.m_hdr.m_a = %d\n", s.m_hdr.m_a);
[-] 	printf ("s.m_hdr.m_b = %d\n", s.m_hdr.m_b);
[+] 	printf("s.m_hdr.m_b = %d\n", s.m_hdr.m_b);
[-] 	printf ("s.m_c = %d\n", s.m_c);
[+] 	printf("s.m_c = %d\n", s.m_c);
[-] 	printf ("s.m_d = %d\n", s.m_d);
[+] 	printf("s.m_d = %d\n", s.m_d);
[-] 	printf ("s.m_e = %d\n", s.m_e);
[+] 	printf("s.m_e = %d\n", s.m_e);
[-] 	printf ("sizeof (*s)            = %d\n", dynamic sizeof (*s));
[+] 	printf("sizeof (*s)            = %d\n", dynamic sizeof (*s));
[-] 	printf ("sizeof (s.m_hdr)       = %d\n", dynamic sizeof (s.m_hdr));
[+] 	printf("sizeof (s.m_hdr)       = %d\n", dynamic sizeof (s.m_hdr));
[-] 	printf ("sizeof (s.m_hdr.m_s1)  = %d\n", dynamic sizeof (s.m_hdr.m_s1));
[+] 	printf("sizeof (s.m_hdr.m_s1)  = %d\n", dynamic sizeof (s.m_hdr.m_s1));
[-] 	printf ("countof (s.m_hdr.m_s1) = %d\n", dynamic countof (s.m_hdr.m_s1));
[+] 	printf("countof (s.m_hdr.m_s1) = %d\n", dynamic countof (s.m_hdr.m_s1));
[-] 	printf ("sizeof (s.m_s2)        = %d\n", dynamic sizeof (s.m_s2));
[+] 	printf("sizeof (s.m_s2)        = %d\n", dynamic sizeof (s.m_s2));
[-] 	printf ("countof (s.m_s2)       = %d\n", dynamic countof (s.m_s2));
[+] 	printf("countof (s.m_s2)       = %d\n", dynamic countof (s.m_s2));
[-] int main ()
[+] int main()
[-] 	char buffer [] = 
[+] 	char buffer[] =
[-] 	S* s = (S*) buffer;
[+] 	S* s = (S*)buffer;
[-] 	printS (s);
[+] 	printS(s);
[-] 	printf ("s     = %p\n", s);
[+] 	printf("s     = %p\n", s);
[-] 	printf ("s + 1 = %p\n", s);
[+] 	printf("s + 1 = %p\n", s);
[-] 	printS (s);
[+] 	printS(s);
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\test99.jnc
----------------------
[-] g_p.set (bool)
[+] g_p.set(bool)
[-] int main ()
[+] int main()
[-] 	printf ("main\n");
[+] 	printf("main\n");
----------------------
27/02/2019 18:02:32 - C:\Projects\repos\ioninja\jancy\test\jnc\utils.jnc
----------------------
[-] construct ()
[+] construct()
[-] 	printf ("utils.jnc.construct ()\n");
[+] 	printf("utils.jnc.construct ()\n");
[-] destruct ()
[+] destruct()
[-] 	printf ("utils.jnc.destruct ()\n");
[+] 	printf("utils.jnc.destruct ()\n");
[-] utilsFoo ()
[+] utilsFoo()
[-] 	printf ("utilsFoo ()\n");
[+] 	printf("utilsFoo ()\n");
----------------------
27/02/2019 18:02:33 - C:\Projects\repos\ioninja\jancy\test\jnc_test_abi\main.jnc
----------------------
[-] funcInt32 (
[+] funcInt32(
[-] 	assert (a1 == -1);
[+] 	assert(a1 == -1);
[-] 	assert (a2 == -2);
[+] 	assert(a2 == -2);
[-] 	assert (a3 == -3);
[+] 	assert(a3 == -3);
[-] 	assert (a4 == -4);
[+] 	assert(a4 == -4);
[-] 	assert (a5 == -5);
[+] 	assert(a5 == -5);
[-] 	assert (a6 == -6);
[+] 	assert(a6 == -6);
[-] 	assert (a7 == -7);
[+] 	assert(a7 == -7);
[-] 	assert (a8 == -8);
[+] 	assert(a8 == -8);
[-] funcInt64 (
[+] funcInt64(
[-] 	assert (a1 == -1);
[+] 	assert(a1 == -1);
[-] 	assert (a2 == -2);
[+] 	assert(a2 == -2);
[-] 	assert (a3 == -3);
[+] 	assert(a3 == -3);
[-] 	assert (a4 == -4);
[+] 	assert(a4 == -4);
[-] 	assert (a5 == -5);
[+] 	assert(a5 == -5);
[-] 	assert (a6 == -6);
[+] 	assert(a6 == -6);
[-] 	assert (a7 == -7);
[+] 	assert(a7 == -7);
[-] 	assert (a8 == -8);
[+] 	assert(a8 == -8);
[-] funcStruct32 (
[+] funcStruct32(
[-] 	assert (s1.m_a == -1);
[+] 	assert(s1.m_a == -1);
[-] 	assert (s2.m_a == -2);
[+] 	assert(s2.m_a == -2);
[-] 	assert (s3.m_a == -3);
[+] 	assert(s3.m_a == -3);
[-] 	assert (s4.m_a == -4);
[+] 	assert(s4.m_a == -4);
[-] 	assert (s5.m_a == -5);
[+] 	assert(s5.m_a == -5);
[-] 	assert (s6.m_a == -6);
[+] 	assert(s6.m_a == -6);
[-] 	assert (s7.m_a == -7);
[+] 	assert(s7.m_a == -7);
[-] 	assert (s8.m_a == -8);
[+] 	assert(s8.m_a == -8);
[-] funcStruct64 (
[+] funcStruct64(
[-] 	assert (s1.m_a == -1);
[+] 	assert(s1.m_a == -1);
[-] 	assert (s2.m_a == -2);
[+] 	assert(s2.m_a == -2);
[-] 	assert (s3.m_a == -3);
[+] 	assert(s3.m_a == -3);
[-] 	assert (s4.m_a == -4);
[+] 	assert(s4.m_a == -4);
[-] 	assert (s5.m_a == -5);
[+] 	assert(s5.m_a == -5);
[-] 	assert (s6.m_a == -6);
[+] 	assert(s6.m_a == -6);
[-] 	assert (s7.m_a == -7);
[+] 	assert(s7.m_a == -7);
[-] 	assert (s8.m_a == -8);
[+] 	assert(s8.m_a == -8);
[-] funcStruct128 (
[+] funcStruct128(
[-] 	assert (s1.m_a == -1);
[+] 	assert(s1.m_a == -1);
[-] 	assert (s1.m_b == -2);
[+] 	assert(s1.m_b == -2);
[-] 	assert (s2.m_a == -3);
[+] 	assert(s2.m_a == -3);
[-] 	assert (s2.m_b == -4);
[+] 	assert(s2.m_b == -4);
[-] 	assert (s3.m_a == -5);
[+] 	assert(s3.m_a == -5);
[-] 	assert (s3.m_b == -6);
[+] 	assert(s3.m_b == -6);
[-] 	assert (s4.m_a == -7);
[+] 	assert(s4.m_a == -7);
[-] 	assert (s4.m_b == -8);
[+] 	assert(s4.m_b == -8);
[-] funcVariant (
[+] funcVariant(
[-] 	assert (v1 == -1);
[+] 	assert(v1 == -1);
[-] 	assert (v2 == -2);
[+] 	assert(v2 == -2);
[-] 	assert (v3 == -3);
[+] 	assert(v3 == -3);
[-] 	assert (v4 == -4);
[+] 	assert(v4 == -4);
[-] funcFloat (
[+] funcFloat(
[-] 	assert (x > (float) 3.1414 && x < (float) 3.1416);
[+] 	assert(x > (float) 3.1414 && x < (float) 3.1416);
[-] 	assert (y > (float) 2.7181 && y < (float) 2.7183);
[+] 	assert(y > (float) 2.7181 && y < (float) 2.7183);
[-] funcDouble (
[+] funcDouble(
[-] 	assert (x > 3.1414 && x < 3.1416);
[+] 	assert(x > 3.1414 && x < 3.1416);
[-] 	assert (y > 2.7181 && y < 2.7183);
[+] 	assert(y > 2.7181 && y < 2.7183);
[-] funcInt32 (
[+] funcInt32(
[-] funcInt64 (
[+] funcInt64(
[-] funcStruct32 (
[+] funcStruct32(
[-] funcStruct64 (
[+] funcStruct64(
[-] funcStruct128 (
[+] funcStruct128(
[-] funcVariant (
[+] funcVariant(
[-] funcPtr (
[+] funcPtr(
[-] funcFloat (
[+] funcFloat(
[-] funcDouble (
[+] funcDouble(
[-] testInt32 ()
[+] testInt32()
[-] 	int32_t retval = funcInt32 (-1, -2, -3, -4, -5, -6, -7, -8);
[+] 	int32_t retval = funcInt32(-1, -2, -3, -4, -5, -6, -7, -8);
[-] 	assert (retval == -36);
[+] 	assert(retval == -36);
[-] testInt64 ()
[+] testInt64()
[-] 	int64_t retval = funcInt64 (-1, -2, -3, -4, -5, -6, -7, -8);
[+] 	int64_t retval = funcInt64(-1, -2, -3, -4, -5, -6, -7, -8);
[-] 	assert (retval == -36);
[+] 	assert(retval == -36);
[-] testStruct32 ()
[+] testStruct32()
[-] 	struct32 retval = funcStruct32 (s1, s2, s3, s4, s5, s6, s7, s8);
[+] 	struct32 retval = funcStruct32(s1, s2, s3, s4, s5, s6, s7, s8);
[-] 	assert (retval.m_a == -36);
[+] 	assert(retval.m_a == -36);
[-] testStruct64 ()
[+] testStruct64()
[-] 	struct64 retval = funcStruct64 (s1, s2, s3, s4, s5, s6, s7, s8);
[+] 	struct64 retval = funcStruct64(s1, s2, s3, s4, s5, s6, s7, s8);
[-] 	assert (retval.m_a == -36);
[+] 	assert(retval.m_a == -36);
[-] testStruct128 ()
[+] testStruct128()
[-] 	struct128 retval = funcStruct128 (s1, s2, s3, s4);
[+] 	struct128 retval = funcStruct128(s1, s2, s3, s4);
[-] 	assert (retval.m_a == -16 && retval.m_b == -20);
[+] 	assert(retval.m_a == -16 && retval.m_b == -20);
[-] testVariant ()
[+] testVariant()
[-] 	variant retval = funcVariant (v1, v2, v3, v4);
[+] 	variant retval = funcVariant(v1, v2, v3, v4);
[-] 	assert (retval == -10);
[+] 	assert(retval == -10);
[-] testPtr ()
[+] testPtr()
[-] 	char* retval = funcPtr ("abc", "def");
[+] 	char* retval = funcPtr("abc", "def");
[-] 	assert (strcmp (retval, "abc") == 0);
[+] 	assert(strcmp(retval, "abc") == 0);
[-] testFloat ()
[+] testFloat()
[-] 	float retval = funcFloat ((float) 3.1415, (float) 2.7182);
[+] 	float retval = funcFloat((float) 3.1415, (float) 2.7182);
[-] 	assert (retval > (float) 2.7182 && retval < (float) 3.1415)
[+] 	assert(retval > (float) 2.7182 && retval < (float) 3.1415)
[-] testDouble ()
[+] testDouble()
[-] 	double retval = funcDouble (3.1415, 2.7182);
[+] 	double retval = funcDouble(3.1415, 2.7182);
[-] 	assert (retval > 2.7182 && retval < 3.1415)
[+] 	assert(retval > 2.7182 && retval < 3.1415)
