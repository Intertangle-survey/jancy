//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace io {

//! \addtogroup usb
//! @{

//..............................................................................

enum UsbTransferType: uint8_t
{
	Control     = 0,
	Isochronous = 1,
	Bulk        = 2,
	Interrupt   = 3,
	BulkStream  = 4,
};

enum UsbIsoSyncType: uint8_t
{
	None     = 0,
	Async    = 1,
	Adaptive = 2,
	Sync     = 3,
}

enum UsbIsoUsage: uint8_t
{
	Data     = 0,
	Feedback = 1,
	Implicit = 2,
}

enum UsbClass: uint8_t
{
	PerInterface       = 0,
	Audio              = 1,
	Comm               = 2,
	Hid                = 3,
	Physical           = 5,
	Ptp                = 6,
	Printer            = 7,
	MassStorage        = 8,
	Hub                = 9,
	Data               = 10,
	SmartCard          = 0x0b,
	ContentSecurity    = 0x0d,
	Video              = 0x0e,
	PersonalHealthcare = 0x0f,
	DiagnosticDevice   = 0xdc,
	Wireless           = 0xe0,
	Application        = 0xfe,
	VendorSpec         = 0xff
};

enum UsbSpeed: uint8_t
{
	Unknown = 0,
	Low     = 1,
	Full    = 2,
	High    = 3,
	Super   = 4,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

char const*
getUsbClassString (UsbClass cls);

char const*
getUsbSpeedString (UsbSpeed speed);

char const*
getUsbTransferTypeString (UsbTransferType type);

//..............................................................................

struct UsbEndpointDesc
{
	uint8_t m_endpointId;
	UsbTransferType m_transferType;
	UsbIsoSyncType m_isoSyncType;
	UsbIsoUsage m_isoUsage;
	uint16_t m_maxPacketSize;
	uint8_t m_interval;
	uint8_t m_refresh;
	uint8_t m_synchAddress;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct UsbInterfaceDesc
{
	UsbInterfaceDesc const* m_nextAltSettingInterface;
	UsbEndpointDesc const* m_endpointTable;
	size_t m_endpointCount;

	uint8_t m_interfaceId;
	uint8_t m_altSettingId;
	uint8_t m_descriptionStringId;
	UsbClass m_class;
	UsbSpeed m_subClass;
	uint8_t m_protocol;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct UsbConfigurationDesc
{
	UsbInterfaceDesc const* m_interfaceTable;
	size_t m_interfaceCount;

	uint8_t m_configurationId;
	uint8_t m_descriptionStringId;
	uint8_t m_attributes;
	uint8_t  m_maxPower;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct UsbDeviceDesc
{
	UsbConfigurationDesc const* m_configurationTable;
	size_t m_configurationCount;

	uint16_t m_usbVersion;
	uint16_t m_deviceVersion;
	uint16_t m_vendorId;
	uint16_t m_productId;
	uint8_t m_vendorStringId;
	uint8_t m_productStringId;
	uint8_t m_serialStringId;
	UsbClass m_class;
	uint8_t m_subClass;
	uint8_t m_protocol;
}

//..............................................................................

enum UsbEndpointEventCode
{
	ReadyRead,
	IoError,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct UsbEndpointEventParams
{
	UsbEndpointEventCode m_eventCode;
	uint_t m_syncId;
	std.Error const* m_error;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class UsbEndpoint
{
	UsbInterface* const m_parentInterface;
	UsbEndpointDesc const* const m_endpointDesc;
	size_t m_incomingQueueLimit;
	bool readonly m_isOpen;
	uint_t m_syncId;

	construct ();
	destruct ();

	void close ();
	alias void dispose = close;

	size_t errorcode read (
		void* p,
		size_t size
		);

	size_t errorcode write (
		void const* p,
		size_t size,
		uint_t timeout = -1
		);

	event m_onEndpointEvent (UsbEndpointEventParams const* params);
	bool property m_isEndpointEventEnabled;
};

//..............................................................................

opaque class UsbInterface
{
	UsbDevice* const m_parentDevice;
	UsbInterfaceDesc const* const m_interfaceDesc;

	bool readonly m_isClaimed;
	uint_t m_syncId;

	construct ();
	destruct ();

	void release ();
	alias void dispose = release;

	UsbEndpoint* errorcode openEndpoint (uint8_t endpointId);
};

//..............................................................................

opaque class UsbDevice
{
	UsbDeviceDesc const* const property m_deviceDesc;
	UsbConfigurationDesc const* const property m_activeConfigurationDesc;
	uint8_t property m_configurationId;
	uint8_t const property m_bus;
	uint8_t const property m_address;
	UsbSpeed const property m_speed;

	bool readonly m_isOpen;

	construct ();
	destruct ();

	void close ();
	alias void dispose = close;

	bool errorcode open ();

	bool autoget property m_isAutoDetachKernelDriverEnabled;
	bool const indexed property m_isKernelDriverActive (uint_t interfaceId);
	bool errorcode attachKernelDriver (uint_t interfaceId);
	bool errorcode detachKernelDriver (uint_t interfaceId);

	UsbInterface* errorcode claimInterface (
		uint8_t interfaceId,
		uint8_t altSettingId = 0
		);

	char const* errorcode getStringDesc (uint8_t stringId);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

UsbDevice* const* errorcode createUsbDeviceArray (size_t* count = null);

UsbDevice* errorcode openUsbDevice (
	uint_t vendorId,
	uint_t productId
	);

//..............................................................................

//! @}

} // namespace io
