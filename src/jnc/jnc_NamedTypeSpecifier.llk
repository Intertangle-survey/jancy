//.............................................................................

// root

class
{
	Type* m_type;
}
named_type_specifier
	:	enum_specifier
			{
				$.m_type = $1.m_type;
			}
	|	struct_specifier
			{
				$.m_type = $1.m_type;
			}
	|	union_specifier
			{
				$.m_type = $1.m_type;
			}
	|	class_specifier
			{
				$.m_type = $1.m_type;
			}
	;

//.............................................................................

// enum

class
{
	EnumType* m_type;
}
enum_specifier
	leave
	{
		if ($.m_type->getName ().isEmpty () || ($.m_type->getFlags () & EnumTypeFlagKind_Exposed))
			return m_module->m_namespaceMgr.getCurrentNamespace ()->exposeEnumConsts ($.m_type);
	}
	:	enum_type_kind $k
		TokenKind_Identifier $n?
		(':' type_name $b)?
			{
				$.m_type = createEnumType (
					$k.m_enumTypeKind,
					isValidLocator ($n) ? $n.m_data.m_string : rtl::String (),
					isValidLocator ($b) ? $b.m_type : NULL,
					$k.m_flags
					);

				if (!$.m_type)
					return false;
			}
		enum_block <$.m_type>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	EnumTypeKind m_enumTypeKind;
	uint_t m_flags;
}
enum_type_kind
	:	TokenKind_Enum
			{
				$.m_enumTypeKind = EnumTypeKind_Normal;
				$.m_flags = 0;
			}
	|	TokenKind_FEnum
			{
				$.m_enumTypeKind = EnumTypeKind_Flag;
				$.m_flags = 0;
			}
	|	TokenKind_CEnum
			{
				$.m_enumTypeKind = EnumTypeKind_Normal;
				$.m_flags = EnumTypeFlagKind_Exposed;
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum_block <EnumType* $type>
	:	'{'
			{
				m_module->m_namespaceMgr.openNamespace ($type);
			}
		enum_member_list <$type>
		'}'
			{
				m_module->m_namespaceMgr.closeNamespace ();
			}
	;

nullable
enum_member_list <EnumType* $type>
	:	enum_member <$type> (',' enum_member <$type>)*
	;

nullable
enum_member <EnumType* $type>
	:	TokenKind_Identifier ('=' expression_pass1 $i)?
			{
				EnumConst* member = $type->createConst (
					$1.m_data.m_string,
					isValidLocator ($i) ? &$i.m_tokenList : NULL
					);

				if (!member)
					return false;

				member->m_pos = $1.m_pos;
			}
	|	epsilon
	;

//.............................................................................

// struct

class
{
	StructType* m_type;
}
struct_specifier
	leave
	{
		if ($.m_type->getName ().isEmpty ())
			return declareUnnamedStructOrUnion ($.m_type);
	}
	:	TokenKind_Struct
		struct_pack_factor $p?
		TokenKind_Identifier $n?
		(':' type_name_list $b)?
			{
				$.m_type = createStructType (
					isValidLocator ($n) ? $n.m_data.m_string : rtl::String (),
					isValidLocator ($b) ? &$b.m_typeList : NULL,
					isValidLocator ($p) ? $p.m_packFactor : m_structPackFactor
					);

				if (!$.m_type)
					return false;
			}
		named_type_block <$.m_type>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	size_t m_packFactor;
}
struct_pack_factor
	:	TokenKind_Pack '(' struct_pack_factor_value $v ')'
			{
				$.m_packFactor = $v.m_value;
			}
	;

class
{
	size_t m_value;
}
struct_pack_factor_value
	:	TokenKind_Integer
			{
				$.m_value = $1.m_data.m_integer;
			}
	|	TokenKind_Default
			{
				$.m_value = m_defaultStructPackFactor;
			}
	;

//.............................................................................

// union

class
{
	UnionType* m_type;
}
union_specifier
	leave
	{
		if ($.m_type->getName ().isEmpty ())
			return declareUnnamedStructOrUnion ($.m_type);
	}
	:	TokenKind_Union
		struct_pack_factor $p?
		TokenKind_Identifier $n?
			{
				$.m_type = createUnionType (
					isValidLocator ($n) ? $n.m_data.m_string : rtl::String (),
					isValidLocator ($p) ? $p.m_packFactor : m_structPackFactor
					);

				if (!$.m_type)
					return false;
			}
		named_type_block <$.m_type>
	;

//.............................................................................

// class

// TODO: redesign class attributes (abstract, sealed, pack)

class
{
	ClassType* m_type;
}
class_specifier
	:	TokenKind_Opaque $o?
		TokenKind_Class
		struct_pack_factor $p?
		TokenKind_Identifier $n
		(':' type_name_list $b)?
			{
				$.m_type = createClassType (
					$n.m_data.m_string,
					isValidLocator ($b) ? &$b.m_typeList : NULL,
					isValidLocator ($p) ? $p.m_packFactor : m_structPackFactor,
					isValidLocator ($o) ? ClassTypeFlagKind_Opaque : 0
					);

				if (!$.m_type)
					return false;
			}
		named_type_block <$.m_type>
	;

//.............................................................................

// struct, union, class, property

named_type_block <Namespace* $nspace>
	enter
	{
		m_module->m_namespaceMgr.openNamespace ($nspace);
	}
	leave
	{
		m_module->m_namespaceMgr.closeNamespace ();
	}
	:	named_type_block_impl
	;

start
named_type_block_impl
	:	'{' named_type_block_declaration* '}'
	;

//.............................................................................
