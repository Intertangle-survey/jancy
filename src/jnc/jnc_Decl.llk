//.............................................................................

pragma
pragma_pack
	:	'#' TokenKind_Pack '(' struct_pack_factor_value $v ')'
		{
			m_structPackFactor = $v.m_value;
		}
	;

//.............................................................................

// root declaration productions

global_declaration
	:	namespace_declaration
	|	extend_declaration
	|	using_declaration
	|	friend_declaration
	|	access_declaration
	|	named_type_specifier
	|	item_declaration_w_specifier
	|	resolver (item_declaration_wo_specifier_rslv) priority (2) // set higher priority than type_specifier::qualified_name
		item_declaration_wo_specifier
	|	';'
	;

named_type_block_declaration
	:	friend_declaration
	|	access_declaration
	|	named_type_specifier
	|	item_declaration_w_specifier
	|	resolver (item_declaration_wo_specifier_rslv) priority (2) // set higher priority than type_specifier::qualified_name
		item_declaration_wo_specifier
	|	';'
	;

local_declaration
	enter
	{
		m_module->m_controlFlowMgr.resetJumpFlag (); // 'stack new' is currently illegal in conditional expression
		m_module->m_namespaceMgr.setSourcePos (m_currentToken.m_pos);
	}
	:	statement
	|	using_declaration
	|	named_type_specifier
	|	item_declaration_w_specifier
	|	resolver ({ return false; }) priority (2) // set higher priority than type_specifier::qualified_name
		item_declaration_wo_specifier
	|	catch_label
	|	finally_label
	;

//.............................................................................

// namespace & using declarations

namespace_declaration
	:	TokenKind_Namespace qualified_name
			{
				return openGlobalNamespace ($2.m_name, $2.m_firstToken.m_pos) != NULL;
			}
		'{' global_declaration* '}'
			{
				m_module->m_namespaceMgr.closeNamespace ();
			}
	;

extend_declaration
	:	TokenKind_Extend qualified_name
			{
				return openTypeExtension ($2.m_name, $2.m_firstToken.m_pos);
			}
		'{' named_type_block_declaration* '}'
			{
				m_module->m_namespaceMgr.closeNamespace ();
			}
	;

using_declaration
	:	TokenKind_Using qualified_name (',' qualified_name)* ';'
	;

friend_declaration
	:	TokenKind_Friend qualified_name (',' qualified_name)* ';'
	;

access_declaration
	:	access_specifier ':'
			{
				m_module->m_namespaceMgr.m_currentAccessKind = $1.m_accessKind;
			}
	;

//.............................................................................

class
{
	QualifiedName m_name
}
qualified_name
	:	qualified_name_impl <&$.m_name>
	;

qualified_name_impl <QualifiedName* $name>
	:	TokenKind_Identifier
			{
				$name->addName ($1.m_data.m_string);
			}
		('.' TokenKind_Identifier $n2
			{
				$name->addName ($n2.m_data.m_string);
			}
		)*
	;

//.............................................................................

// item declarations

item_declaration_w_specifier
	enter
	{
		m_storageKind = StorageKind_Undefined;
		m_accessKind = AccessKind_Undefined;
	}
	:	declaration_specifier_list $s
		declarator_list <&$s.m_typeSpecifier>?
		declaration_terminator <&$s.m_typeSpecifier>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

item_declaration_wo_specifier
	local
	{
		Declarator $declarator;
	}
	enter
	{
		m_storageKind = StorageKind_Undefined;
		m_accessKind = AccessKind_Undefined;
		$declarator.setTypeSpecifier (NULL);
	}
	:	declarator_prefix <&$declarator>*
		declarator_name <&$declarator>
		function_suffix <&$declarator> declarator_suffix <&$declarator>*
		post_declarator_modifier <&$declarator>*
			{
				return declare (&$declarator);
			}
		declaration_terminator <NULL>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// conflict at EToken_Identifier in global scope and in named type block
// between qualified_type_name and declarator_name
// prefer declarator_name if and only if this is a function

item_declaration_wo_specifier_rslv
	local
	{
		Declarator $declarator;
	}
	:	declarator_name <&$declarator> '(' // must be a function
	;

//.............................................................................

declaration_terminator <TypeSpecifier* $typeSpecifier>
	leave
	{
		if (m_attributeBlock)
		{
			err::setFormatStringError ("unused attribute block in declaration");
			return false;
		}

		m_lastDeclaredItem = NULL;
	}
	:	';'
			{
				return isEmptyDeclarationTerminatorAllowed ($typeSpecifier);
			}
	|	declaration_body_pass1
			{
				return setDeclarationBody (&$1.m_tokenList);
			}
	;

class
{
	rtl::BoxList <Token> m_tokenList;
}
declaration_body_pass1
	:	compound_stmt_pass1 <&$.m_tokenList>
	;

class
{
	Token* m_anchorToken;
}
compound_stmt_pass1 <rtl::BoxList <Token>* $tokenList>
	:	'{' $l
			{
				$.m_anchorToken = &*$tokenList->insertTail ($l);
				$.m_anchorToken->m_data.m_integer = 0; // tokens can be reused, ensure cleanup
			}
		statement_pass1 <$tokenList, $.m_anchorToken>*
		'}' $r
			{
				$tokenList->insertTail ($r);
			}
	;

noast
statement_pass1 <rtl::BoxList <Token>* $tokenList, Token* $anchorToken>
	:	compound_stmt_pass1 <$tokenList>
	|	TokenKind_Catch
			{
				$tokenList->insertTail ($1);
				$anchorToken->m_data.m_integer |= LandingPadFlag_Catch;
			}
	|	TokenKind_Finally
			{
				$tokenList->insertTail ($1);
				$anchorToken->m_data.m_integer |= LandingPadFlag_Finally;
			}
	|	any
			{
				$tokenList->insertTail ($1);
			}
	;

//.............................................................................

// type names

type_name_impl <Type** $type, Value* $countValue>
	local
	{
		Declarator $declarator;
	}
	:	type_specifier_modifier_list
			{
				$declarator.setTypeSpecifier (&$1.m_typeSpecifier);
			}
		declarator_prefix <&$declarator>*
		declarator_suffix <&$declarator>*
			{
				Type* type = $declarator.calcType ($countValue);
				if (!type)
					return false;

				*$type = type;
			}
	;

class
{
	Type* m_type;
}
type_name
	: type_name_impl <&$.m_type, NULL>
	;

class
{
	rtl::BoxList <Type*> m_typeList;
}
type_name_list
	:	type_name
			{
				$.m_typeList.insertTail ($1.m_type);
			}
		(',' type_name $t2
			{
				$.m_typeList.insertTail ($t2.m_type);
			}
		)*
	;

class
{
	Type* m_type;
}
type_name_or_expr
	:	type_name
			{
				$.m_type = $1.m_type;
			}
	|	expression_0
			{
				$.m_type = $1.m_value.getType ();
			}
	;

//.............................................................................

// attributes

attribute_block
	:	'['
			{
				m_attributeBlock = m_module->m_attributeMgr.createAttributeBlock ();
			}
		attribute_declarator_list
		']'
	;

nullable
attribute_declarator_list
	:	attribute_declarator (',' attribute_declarator)*
	;

nullable
attribute_declarator
	:	TokenKind_Identifier ('=' expression_pass1)?
			{
				Attribute* attribute = m_attributeBlock->createAttribute ($1.m_data.m_string, NULL);
				if (!attribute)
					return false;

				attribute->m_pos = $1.m_pos;
			}
	|	epsilon
	;

//.............................................................................
